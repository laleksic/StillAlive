using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using System.Threading;
using System.Windows.Forms;
using System.IO;
using System.Linq;

using djack.RogueSurvivor.Data;
using djack.RogueSurvivor.Engine.Actions;
using djack.RogueSurvivor.Engine.Items;
using djack.RogueSurvivor.Engine.MapObjects;
using djack.RogueSurvivor.Gameplay;
using djack.RogueSurvivor.Gameplay.AI;
using djack.RogueSurvivor.Gameplay.Generators;

using Message = djack.RogueSurvivor.Data.Message;
using djack.RogueSurvivor.Engine.Tasks;
using ItemRating = djack.RogueSurvivor.Gameplay.AI.BaseAI.ItemRating;
using TradeRating = djack.RogueSurvivor.Gameplay.AI.BaseAI.TradeRating;

namespace djack.RogueSurvivor.Engine
{
    class RogueGame
    {
        #region CONSTANTS
        public const int MAP_MAX_HEIGHT = 100;
        public const int MAP_MAX_WIDTH = 100;

        public const int TILE_SIZE = 32;
        public const int ACTOR_SIZE = 32;
        public const int ACTOR_OFFSET = (TILE_SIZE - ACTOR_SIZE) / 2;
        public const int TILE_VIEW_WIDTH = 21;
        public const int TILE_VIEW_HEIGHT = 21;
        const int HALF_VIEW_WIDTH = 10;
        const int HALF_VIEW_HEIGHT = 10;

        public const int CANVAS_WIDTH = 1024;
        public const int CANVAS_HEIGHT = 768;

        const int DAMAGE_DX = 10;
        const int DAMAGE_DY = 10;

        #region -UI elements
        const int RIGHTPANEL_X = TILE_SIZE * TILE_VIEW_WIDTH + 4; //=676 total
        const int RIGHTPANEL_Y = 0;
        const int RIGHTPANEL_TEXT_X = RIGHTPANEL_X + 4; //=680 total
        const int RIGHTPANEL_TEXT_Y = RIGHTPANEL_Y + 4; //=4 total

        const int INVENTORYPANEL_X = RIGHTPANEL_TEXT_X; //=680 total
        const int INVENTORYPANEL_Y = RIGHTPANEL_TEXT_Y + 156; //=160 total     //@MP - looks like RJ might have had it at 142 prior to implementing sanity
        const int GROUNDINVENTORYPANEL_Y = INVENTORYPANEL_Y + 64; //=224 total
        const int CORPSESPANEL_Y = GROUNDINVENTORYPANEL_Y + 64; //=288 total
        const int INVENTORY_SLOTS_PER_LINE = 10;
        const int BACKPACKPANEL_Y = GROUNDINVENTORYPANEL_Y; //+124 to have it above the Inventory             //@MP (Release 8-2)

        const int SKILLTABLE_Y = CORPSESPANEL_Y + 64; //=352 total
        const int SKILLTABLE_LINES = 10;

        const int LOCATIONPANEL_X = RIGHTPANEL_X;
        const int LOCATIONPANEL_Y = MESSAGES_Y;
        const int LOCATIONPANEL_TEXT_X = LOCATIONPANEL_X + 4;
        const int LOCATIONPANEL_TEXT_Y = LOCATIONPANEL_Y + 4;

        const int MESSAGES_X = 4;
        const int MESSAGES_Y = TILE_VIEW_HEIGHT * TILE_SIZE + 4;
        const int MESSAGES_SPACING = 12;
        const int MESSAGES_FADEOUT = 25;
        const int MAX_MESSAGES = 7;
        const int MESSAGES_HISTORY = 59;

        public const int MINITILE_SIZE = 2;
        const int MINIMAP_X = RIGHTPANEL_X + (CANVAS_WIDTH - RIGHTPANEL_X - MAP_MAX_WIDTH * MINITILE_SIZE) / 2;
        const int MINIMAP_Y = MESSAGES_Y - MINITILE_SIZE * MAP_MAX_HEIGHT - 1;
        const int MINI_TRACKER_OFFSET = 1;

        const int DELAY_SHORT = 250;
        const int DELAY_NORMAL = 500;
        const int DELAY_LONG = 1000;

        readonly Color POPUP_FILLCOLOR = Color.FromArgb(192, Color.CornflowerBlue);

        readonly string[] CLOSE_DOOR_MODE_TEXT = new string[] { "CLOSE MODE - directions to close, ESC cancels" };
        readonly string[] BARRICADE_MODE_TEXT = new string[] { "BARRICADE/REPAIR MODE - directions to barricade/repair, ESC cancels" };
        readonly string[] BREAK_MODE_TEXT = new string[] { "BREAK MODE - directions/wait to break an object, ESC cancels" };
        readonly string[] BUILD_LARGE_FORT_MODE_TEXT = new string[] { "BUILD LARGE FORTIFICATION MODE - directions to build, ESC cancels" };
        readonly string[] BUILD_SMALL_FORT_MODE_TEXT = new string[] { "BUILD SMALL FORTIFICATION MODE - directions to build, ESC cancels" };
        readonly string[] TRADE_MODE_TEXT = new string[] { "TRADE MODE - Y to accept the deal, N to refuse" };
        readonly string[] NEGOTIATE_TRADE_MODE_TEXT = new string[] { "NEGOTIATE TRADE MODE - directions to negotiate a trade, ESC cancels" };
        readonly string[] UPGRADE_MODE_TEXT = new string[] { "UPGRADE MODE - follow instructions in the message panel" };
        readonly string[] FIRE_MODE_TEXT = new string[] { "FIRE MODE - F to fire, T next target, M toggle mode, ESC cancels" };
        readonly string[] SWITCH_PLACE_MODE_TEXT = new string[] { "SWITCH PLACE MODE - directions to switch place with a follower, ESC cancels" };
        readonly string[] TAKE_LEAD_MODE_TEXT = new string[] { "TAKE LEAD MODE - directions to recruit a follower, ESC cancels" };
        readonly string[] PULL_MODE_TEXT = new string[] { "PULL MODE - directions to select object, ESC cancels" }; // alpha10
        readonly string[] PUSH_MODE_TEXT = new string[] { "PUSH/SHOVE MODE - directions to push/shove, ESC cancels" };
        readonly string[] TAG_MODE_TEXT = new string[] { "TAG MODE - directions to tag a wall or on the floor, ESC cancels" };
        readonly string[] PAINT_THINNER_MODE_TEXT = new string[] { "CLEAN MODE - directions to clean a wall or on the floor, ESC cancels" }; //@@MP (Release 7-6)
        readonly string[] FIRE_EXTINGUISHER_MODE_TEXT = new string[] { "EXTINGUISH MODE - directions to clean a tile or object, ESC cancels" }; //@@MP (Release 7-6)
        readonly string[] START_FIRE_MODE_TEXT = new string[] { "MATCHES MODE - directions to start a fire for cooking/light, ESC cancels" }; //@@MP (Release 7-6)
        readonly string[] SPRAY_MODE_TEXT = new string[] { "SPRAY MODE - directions to spray or wait key to spray on yourself, ESC cancels" };
        readonly string PULL_OBJECT_MODE_TEXT = "PULLING {0} - directions to walk to, ESC cancels";  // alpha10
        readonly string PULL_ACTOR_MODE_TEXT = "PULLING {0} - directions to walk to, ESC cancels";  // alpha10
        readonly string PUSH_OBJECT_MODE_TEXT = "PUSHING {0} - directions to push, ESC cancels";
        readonly string SHOVE_ACTOR_MODE_TEXT = "SHOVING {0} - directions to shove, ESC cancels";
        readonly string[] ORDER_MODE_TEXT = new string[] { "ORDER MODE - follow instructions in the message panel, ESC cancels" };
        readonly string[] GIVE_MODE_TEXT = new string[] { "GIVE MODE - directions to give item to someone, ESC cancels" };
        readonly string[] THROW_MODE_TEXT = new string[] { "THROW MODE - directions to select, F to throw,  ESC cancels" };
        readonly string[] MARK_ENEMIES_MODE = new string[] { "MARK ENEMIES MODE - E to make enemy, T next actor, ESC cancels" };
        readonly string[] BUILD_FORT_MODE = new string[] { "BUILD FORTIFICATIONS MODE - build a (L)arge or (S)mall fortification? ESC cancels" }; //@@MP (Release 6-6)
        readonly string[] BUILD_MODE = new string[] { "BUILD MODE - (R)epair door, build a (B)arricade or (F)ortification? ESC cancels" }; //@@MP (Release 6-6)(Release 8-1)
        readonly string[] TRADING_DIALOG_MODE_TEXT = new string[] { "TRADING MODE - TAB switch mode, 0..9 select, ESC cancels" }; // alpha10
        readonly string[] DROP_FUEL_TEXT = new string[] { "DROPPING FUEL CANS - place (O)ne or drop (A)ll cans? ESC cancels" }; //@@MP (Release 7-1)
        readonly string[] DROP_CANDLES_TEXT = new string[] { "DROPPING CANDLES - place (O)ne lit candle or drop (A)ll candles? ESC cancels" }; //@@MP (Release 7-1)
        readonly string[] THROWABLE_LIGHT_TEXT = new string[] { "USING THROWABLE LIGHTS - (C)arry or (T)hrow a lit one? ESC cancels" }; //@@MP (Release 7-1)
        readonly string[] INSPECTION_MODE_TEXT = new string[] { "USING INSPECTION MODE - directions to move highlighted cell, ESC cancels" }; //@@MP (Release 7-1)
        readonly string[] REPAIR_DOOR_MODE_TEXT = new string[] { "REPAIR DOOR MODE - directions to repair, ESC cancels" }; //@@MP (Release 8-1)
        readonly string[] SWAP_ITEM_INVENTORY_MODE_TEXT = new string[] { "SWAP INVENTORY MODE - key for Inventory slot number, ESC cancels" }; //@@MP (Release 8-2)
        readonly string[] SWAP_ITEM_BACKPACK_MODE_TEXT = new string[] { "SWAP INVENTORY MODE - key for Backpack slot number, ESC cancels" }; //@@MP (Release 8-2)
        readonly Color MODE_TEXTCOLOR = Color.Yellow;
        readonly Color MODE_BORDERCOLOR = Color.Yellow;
        readonly Color MODE_FILLCOLOR = Color.FromArgb(192, Color.Gray);

        // alpha10
        readonly Color TRADE_COLOR_SELECTED_ITEM = Color.LightBlue;
        readonly Color TRADE_COLOR_ACCEPT = Color.LightGreen;
        readonly Color TRADE_COLOR_REFUSE = Color.DarkRed;
        readonly Color TRADE_COLOR_MAYBE_SUCCESS = Color.Green;
        readonly Color TRADE_COLOR_MAYBE_FAILED = Color.Red;

        readonly Color PLAYER_ACTION_COLOR = Color.White;
        readonly Color OTHER_ACTION_COLOR = Color.Gray;
        readonly Color SAYOREMOTE_DANGER_COLOR = Color.Brown; // alpha10
        readonly Color SAYOREMOTE_NORMAL_COLOR = Color.DarkCyan; // alpha10
        readonly Color PLAYER_AUDIO_COLOR = Color.Green;

        const int LINE_SPACING = 12;
        const int BOLD_LINE_SPACING = 14;
        const int CREDIT_CHAR_SPACING = 8;
        const int CREDIT_LINE_SPACING = LINE_SPACING;

        readonly Color NIGHT_COLOR = Color.Cyan;
        readonly Color DAY_COLOR = Color.Gold;

        const int TEXTFILE_CHARS_PER_LINE = 120;
        const int TEXTFILE_LINES_PER_PAGE = 50;
        #endregion

        #region -Notable Zone names
        public const string NAME_SUBWAY_STATION = "Subway Station";
        public const string NAME_SEWERS_MAINTENANCE = "Sewers Maintenance";
        public const string NAME_SUBWAY_RAILS = "rails";
        public const string NAME_POLICE_STATION_JAILS_CELL = "cell"; //@@MP - was "jail" (Release 8-1)
        #endregion

        #region -EVENTS
        const int SPAWN_DISTANCE_TO_PLAYER = 12; //@@MP - upped because of max FoV (Release 7-3)

        #region Zombie invasion

        #endregion

        #region Sewers invasion
        const int SEWERS_INVASION_CHANCE = 1;
        public const float SEWERS_UNDEADS_FACTOR = 0.50f;  // 1.0 for as much as surface undead spawning.
        #endregion

        #region DISABLED Subway invasion 
#if false 
        const int SUBWAY_INVASION_CHANCE = 1;
        public const float SUBWAY_UNDEADS_FACTOR = 0.25f;  // 1.0 for as much as surface undead spawning.
#endif
        #endregion

        #region Refugees
        /// <summary>
        /// How many refugees in each wave, as ratio of max civilians.
        /// </summary>
        const float REFUGEES_WAVE_SIZE = 0.20f;

        /// <summary>
        /// How many random items each new refugee will carry.
        /// </summary>
        const int REFUGEES_WAVE_ITEMS = 6; //@@MP - upped items to 6. left one spot for a mandatory flashlight (Release 7-6)

        /// <summary>
        /// Chance to spawn on the surface vs sewers/subway.
        /// </summary>
        const int REFUGEE_SURFACE_SPAWN_CHANCE = 80;
        #endregion

        #region Unique NPC refugees
        //const int UNIQUE_REFUGEE_CHECK_CHANCE = 10;    //@@MP - unique NPCs removed (Release 8-1)
        #endregion

        #region National Guard Squad
        /// <summary>
        /// Date at which natguard can intervene.
        /// </summary>
        public const int NATGUARD_DAY = 3;

        /// <summary>
        /// Date at which natguard will stop coming.
        /// </summary>
        const int NATGUARD_END_DAY = 10;

        /// <summary>
        /// Date at which the natguard leader will bring Z-Trackers.
        /// </summary>
        const int NATGUARD_ZTRACKER_DAY = NATGUARD_DAY + 3;

        /// <summary>
        /// How many soldiers in each national guard squad.
        /// </summary>
        const int NATGUARD_SQUAD_SIZE = 5;

        /// <summary>
        /// By how many times the undeads must outnumber the livings for the nat guard to intervene.
        /// Factored by option.
        /// </summary>
        const float NATGUARD_INTERVENTION_FACTOR = 5;

        /// <summary>
        /// How many chance per turn the nat guard intervene (if other conditions are met).
        /// </summary>
        const int NATGUARD_INTERVENTION_CHANCE = 1;
        #endregion

        #region Army drop supplies
        /// <summary>
        /// Date at which army can drop supplies.
        /// </summary>
        const int ARMY_SUPPLIES_DAY = 4;

        /// <summary>
        /// Ratio total map food items nutrition / livings below which the army drop supplies event can fire.
        /// Factored by option.
        /// </summary>
        const float ARMY_SUPPLIES_FACTOR = 0.40f * Rules.FOOD_BASE_POINTS; //@@MP - upped from 0.20f (release 5-5)

        /// <summary>
        /// Chances per turn the army will drop supply (if other conditions are met).
        /// </summary>
        const int ARMY_SUPPLIES_CHANCE = 2;

        /// <summary>
        /// Radius in which supplies items are dropped.
        /// One item is dropped per suitable tile in radius.
        /// </summary>
        const int ARMY_SUPPLIES_SCATTER = 1;

        #endregion

        #region Bikers raid
        /// <summary>
        /// Date at which bikers will start to raid.
        /// </summary>
        public const int BIKERS_RAID_DAY = 2;

        /// <summary>
        /// Date at which bikers will stop coming.
        /// </summary>
        const int BIKERS_END_DAY = 14;

        /// <summary>
        /// Number of bikers in the raid.
        /// </summary>
        const int BIKERS_RAID_SIZE = 6;

        /// <summary>
        /// Raid chance per turn (if others conditions are met).
        /// </summary>
        const int BIKERS_RAID_CHANCE_PER_TURN = 1;

        /// <summary>
        /// Number of days between each bikers raid.
        /// </summary>
        const int BIKERS_RAID_DAYS_GAP = 2;
        #endregion

        #region Gangstas raid
        /// <summary>
        /// Date at which gangsta will start to raid.
        /// </summary>
        public const int GANGSTAS_RAID_DAY = 7;

        /// <summary>
        /// Date at which gangstas will stop coming.
        /// </summary>
        const int GANGSTAS_END_DAY = 21;

        /// <summary>
        /// Number of gangstas in the raid.
        /// </summary>
        const int GANGSTAS_RAID_SIZE = 6;

        /// <summary>
        /// Raid chance per turn (if others conditions are met).
        /// </summary>
        const int GANGSTAS_RAID_CHANCE_PER_TURN = 1;

        /// <summary>
        /// Number of days between each gangsta raid.
        /// </summary>
        const int GANGSTAS_RAID_DAYS_GAP = 3;
        #endregion

        #region BlackOps raid
        /// <summary>
        /// Date at which blackops will start to raid.
        /// </summary>
        const int BLACKOPS_RAID_DAY = 14;

        /// <summary>
        /// Number of blackops in the raid.
        /// </summary>
        const int BLACKOPS_RAID_SIZE = 3;

        /// <summary>
        /// Raid chances per turn (if others conditions are met).
        /// </summary>
        const int BLACKOPS_RAID_CHANCE_PER_TURN = 1;

        /// <summary>
        /// Delay between each raid.
        /// </summary>
        const int BLACKOPS_RAID_DAY_GAP = 5;
        #endregion

        #region Band of Survivors 
        const int SURVIVORS_BAND_DAY = 21;
        const int SURVIVORS_BAND_SIZE = 5;
        const int SURVIVORS_BAND_CHANCE_PER_TURN = 1;
        const int SURVIVORS_BAND_DAY_GAP = 5;
        #endregion

        #region CHAR scientists research team
        //@@MP - added (Release 8-1)
        const int SCIENTISTS_TEAM_DAY = 21;
        const int SCIENTISTS_TEAM_SCIENTISTS = 4;
        const int SCIENTISTS_TEAM_GUARDS = 3;
        const int SCIENTISTS_TEAM_CHANCE_PER_TURN = 1;
        const int SCIENTISTS_TEAM_DAY_GAP = 5;
        #endregion

        #endregion

        #region Undeads evolution
        //@@MP - apply evolution minimum timeframes to all undead types (Release 5-6), revied down a bit to keep it challenging (Release 5-7)
        const int UNDEAD_STAGE2_SLOW_EVOLUTION_MIN_DAY = 3;
        const int UNDEAD_STAGE3_SLOW_EVOLUTION_MIN_DAY = 7;
        const int UNDEAD_STAGE2_FAST_EVOLUTION_MIN_DAY = 3;
        const int UNDEAD_STAGE3_FAST_EVOLUTION_MIN_DAY = 7;
        #endregion

        #region Map color tints for day phases
        //@@MP (Release 5-7)
        readonly Color TINT_DAY = Color.White;
        readonly Color TINT_SUNSET = Color.FromArgb(240, 220, 185);//235, 235, 235);
        readonly Color TINT_EVENING = Color.FromArgb(205, 230, 245);//215, 215, 215);
        readonly Color TINT_MIDNIGHT = Color.FromArgb(165, 165, 165);//195, 195, 195);
        readonly Color TINT_NIGHT = Color.FromArgb(165, 165, 165);//205, 205, 205);
        readonly Color TINT_SUNRISE = Color.FromArgb(240, 215, 215);//225, 225, 225);
        #endregion

        #region Hearing chances - avoid spamming messages.
        const int PLAYER_HEAR_FIGHT_CHANCE = 25;
        const int PLAYER_HEAR_SCREAMS_CHANCE = 10;
        const int PLAYER_HEAR_PUSHPULL_CHANCE = 25;  // alpha10 also for pulls
        const int PLAYER_HEAR_BASH_CHANCE = 25;
        const int PLAYER_HEAR_BREAK_CHANCE = 50;
        const int PLAYER_HEAR_EXPLOSION_CHANCE = 100;
        #endregion

        #region 'Still Alive' misc additions
        const int BLOOD_WALL_SPLAT_CHANCE = 20; //@@MP (Release 2)
        const int BASE_TILE_FIRE_DAMAGE = 1; //@@MP (Release 5-2)
        const int BASE_ISONFIRE_FIRE_DAMAGE = 2; //@@MP (Release 5-7)
        const int TILE_FIRE_SPREAD_CHANCE = 5; //@@MP - note: even tiny increases make fire spread significantly (Release 6-1), was 6 (Release 7-6)
        const int CATCH_ONFIRE_FROM_TILE_CHANCE = 25; //@@MP (Release 6-6)
        const int FLAME_WEAPON_SPLASHBACK_CHANCE = 20; //@@MP (Release 7-2)
        const int CATCH_ONFIRE_FROM_FLAMING_SHOT_CHANCE = 33; //@@MP (Release 7-2)
        const int CATCH_ONFIRE_FROM_FLAME_WEAPON_CHANCE = 50; //@@MP (Release 7-2)
        const int RANDOM_TILE_FIRE_FROM_FLAME_WEAPON_CHANCE = 33; //@@MP (Release 7-2)
        const int ON_WAIT_EXTINGUISH_FIRE_CHANCE = 50; //@@MP (Release 7-6)
        const int TILE_FIRE_DAMAGE_TO_CORPSE = 6; //@@MP (Release 7-6)
        const int CAUSE_GRUESOME_DEATH_SANITY_PENALTY = 50; //@@MP (Release 7-2)
        const int MAX_THROWABLE_DISTANCE = 5; //@@MP - for non-standard throwables eg flares (Release 7-1)
        public const int MAX_ITEMLIGHT_TINT_RANGE = 3; //@@MP - the distance that lights that tint the surroundings (eg flares) apply the colour (Release 7-1)
        const string BINOCULARS_DENIED_MESSAGE = "Can't do that with binoculars equipped."; //@@MP (Release 7-1)
        const int STUN_WEAPON_EFFECT_TURNS = 5; //@@MP - eg stun guns. actually makes 4 turns, because the first turn is when they get hit (Release 7-2)
        const int CATCHING_FISH_BASE_CHANCE = 2; //@@MP - percentage. can't be less than 2. is affected by s_Options.ResourcesAvailability (Release 7-6)
        const int FIRE_FUEL_PER_WOOD_PLANK = 90; //@@MP (Release 7-6)
        const string BACKPACK_DENIED_MESSAGE = "Can't do that with the backpack open (ie. unequipped)."; //@@MP (Release 8-2)
        #endregion

        #region NPC player sleeping snoring message chance
        public const int MESSAGE_NPC_SLEEP_SNORE_CHANCE = 10;
        #endregion

        #region Weather
        const int WEATHER_CHANGE_CHANCE = 50; //@@MP - was 33 (Release 6-1)
        //@@MP additions below (Release 6-1)
        const int HEAVY_RAIN_FIRE_EXTINGUISH_CHANCE = 80;
        const int LIGHT_RAIN_FIRE_EXTINGUISH_CHANCE = 70;
        const int CLEAR_WEATHER_FIRE_EXTINGUISH_CHANCE = 33; //only applies to livings, as undead aren't smart enough to extinguish themselves. //@@MP - was 40 (Release 7-6)
        #endregion

        #region Music
        const int BGMUSIC_UPDATE_TURNS = 4 * WorldTime.TURNS_PER_HOUR; // check bg music every Nth game hours  // alpha10
        #endregion

        #region World Gen
        const int DISTRICT_EXIT_CHANCE_PER_TILE = 15;
        #endregion

        #region Common verbs
        readonly Verb VERB_ACCEPT_THE_DEAL = new Verb("accept the deal", "accepts the deal");
        readonly Verb VERB_ACTIVATE = new Verb("activate");
        readonly Verb VERB_AVOID = new Verb("avoid");
        readonly Verb VERB_BARRICADE = new Verb("barricade");
        readonly Verb VERB_BASH = new Verb("bash", "bashes");
        readonly Verb VERB_BE = new Verb("are", "is");
        readonly Verb VERB_BLACK_OUT = new Verb("black out", "blacks out"); //@@MP (Release 7-1)
        readonly Verb VERB_BREAK = new Verb("break");
        readonly Verb VERB_BUILD = new Verb("build");
        readonly Verb VERB_BUTCHER = new Verb("butcher");
        readonly Verb VERB_CATCH = new Verb("catch", "catches");
        readonly Verb VERB_CHAT_WITH = new Verb("chat with", "chats with");
        readonly Verb VERB_CLOSE = new Verb("close");
        readonly Verb VERB_COLLAPSE = new Verb("collapse");
        readonly Verb VERB_CRUSH = new Verb("crush", "crushes");
        readonly Verb VERB_DEACTIVATE = new Verb("deactivate");
        readonly Verb VERB_DESTROY = new Verb("destroy");
        readonly Verb VERB_DIE = new Verb("die");
        readonly Verb VERB_DIE_FROM_STARVATION = new Verb("die from starvation", "dies from starvation");
        readonly Verb VERB_DISARM = new Verb("disarm");  // alpha10
        readonly Verb VERB_DISCARD = new Verb("discard");
        readonly Verb VERB_DRAG = new Verb("drag");
        readonly Verb VERB_DROP = new Verb("drop");
        readonly Verb VERB_EAT = new Verb("eat");
        readonly Verb VERB_ENJOY = new Verb("enjoy");
        readonly Verb VERB_ENTER = new Verb("enter");
        readonly Verb VERB_ESCAPE = new Verb("escape");
        readonly Verb VERB_FAIL = new Verb("fail");
        readonly Verb VERB_FEAST_ON = new Verb("feast on", "feasts on");
        readonly Verb VERB_FEEL = new Verb("feel");
        readonly Verb VERB_GET = new Verb("get"); // alpha10
        readonly Verb VERB_GET_DRUNK = new Verb("get drunk on", "gets drunk on"); //@@MP (Release 7-1)
        readonly Verb VERB_GIVE = new Verb("give");
        readonly Verb VERB_GRAB = new Verb("grab");
        readonly Verb VERB_EQUIP = new Verb("equip");
        readonly Verb VERB_HAVE = new Verb("have", "has");
        readonly Verb VERB_HELP = new Verb("help");
        readonly Verb VERB_HEAL_WITH = new Verb("heal with", "heals with");
        readonly Verb VERB_JUMP_ON = new Verb("jump on", "jumps on");
        readonly Verb VERB_KILL = new Verb("kill");
        readonly Verb VERB_LEAVE = new Verb("leave");
        readonly Verb VERB_MISS = new Verb("miss", "misses");
        readonly Verb VERB_MURDER = new Verb("murder");
        readonly Verb VERB_OFFER = new Verb("offer");
        readonly Verb VERB_OPEN = new Verb("open");
        readonly Verb VERB_ORDER = new Verb("order");
        readonly Verb VERB_PERSUADE = new Verb("persuade");
        readonly Verb VERB_PULL = new Verb("pull", "pulls");  // alpha10
        readonly Verb VERB_PUSH = new Verb("push", "pushes");
        readonly Verb VERB_RAISE_ALARM = new Verb("raise the alarm", "raises the alarm");
        readonly Verb VERB_REFUSE_THE_DEAL = new Verb("refuse the deal", "refuses the deal");
        readonly Verb VERB_RELOAD = new Verb("reload");
        readonly Verb VERB_RECHARGE = new Verb("recharge");
        readonly Verb VERB_REMOVE = new Verb("remove", "removes"); //@@MP (Release 7-6)
        readonly Verb VERB_REPAIR = new Verb("repair");
        readonly Verb VERB_REVIVE = new Verb("revive");
        readonly Verb VERB_SEE = new Verb("see");
        readonly Verb VERB_SHOUT = new Verb("shout");
        readonly Verb VERB_SHOVE = new Verb("shove");
        readonly Verb VERB_SNORE = new Verb("snore");
        readonly Verb VERB_SPRAY = new Verb("spray");
        readonly Verb VERB_START = new Verb("start");
        readonly Verb VERB_STOP = new Verb("stop");
        readonly Verb VERB_STUMBLE = new Verb("stumble");
        readonly Verb VERB_SWITCH = new Verb("switch", "switches");
        readonly Verb VERB_SWITCH_PLACE_WITH = new Verb("switch place with", "switches place with");
        readonly Verb VERB_TAKE = new Verb("take");
        readonly Verb VERB_THROW = new Verb("throw");
        readonly Verb VERB_TRADE = new Verb("trade");  // alpha10
        readonly Verb VERB_TRANSFORM_INTO = new Verb("transform into", "transforms into");
        readonly Verb VERB_UNEQUIP = new Verb("unequip");
        readonly Verb VERB_UNLOAD = new Verb("unload", "unloads"); //@@MP (Release 7-6)
        readonly Verb VERB_VOMIT = new Verb("vomit");
        readonly Verb VERB_WAIT = new Verb("wait");
        readonly Verb VERB_WAKE_UP = new Verb("wake up", "wakes up");
        #endregion

        #endregion

        #region TYPES
        #region Overlays
        abstract class Overlay
        {
            public abstract void Draw(IRogueUI ui);
        }

        class OverlayImage : Overlay
        {
            public Point ScreenPosition { get; set; } //@@MP - can't be made static
            public string ImageID { get; set; } //@@MP - can't be made static

            public OverlayImage(Point screenPosition, string imageID)
            {
                ScreenPosition = screenPosition;
                ImageID = imageID;
            }

            public override void Draw(IRogueUI ui)
            {
                ui.UI_DrawImage(ImageID, ScreenPosition.X, ScreenPosition.Y);
            }
        }

        class OverlayTransparentImage : Overlay
        {
            public float Alpha { get; set; } //@@MP - can't be made static
            public Point ScreenPosition { get; set; } //@@MP - can't be made static
            public string ImageID { get; set; } //@@MP - can't be made static

            public OverlayTransparentImage(float alpha, Point screenPosition, string imageID)
            {
                Alpha = alpha;
                ScreenPosition = screenPosition;
                ImageID = imageID;
            }

            public override void Draw(IRogueUI ui)
            {
                ui.UI_DrawTransparentImage(Alpha, ImageID, ScreenPosition.X, ScreenPosition.Y);
            }
        }

        class OverlayText : Overlay
        {
            public Point ScreenPosition { get; set; } //@@MP - can't be made static
            public string Text { get; set; } //@@MP - can't be made static
            public Color Color { get; set; } //@@MP - can't be made static
            public Color? ShadowColor { get; set; } //@@MP - can't be made static

            public OverlayText(Point screenPosition, Color color, string text)
                : this(screenPosition, color, text, null)
            {
            }

            public OverlayText(Point screenPosition, Color color, string text, Color? shadowColor)
            {
                ScreenPosition = screenPosition;
                Color = color;
                ShadowColor = shadowColor;
                Text = text;
            }

            public override void Draw(IRogueUI ui)
            {
                if (ShadowColor.HasValue)
                    ui.UI_DrawString(ShadowColor.Value, Text, ScreenPosition.X + 1, ScreenPosition.Y + 1);
                ui.UI_DrawString(Color, Text, ScreenPosition.X, ScreenPosition.Y);
            }
        }

        class OverlayLine : Overlay
        {
            public Point ScreenFrom { get; set; } //@@MP - can't be made static
            public Point ScreenTo { get; set; } //@@MP - can't be made static
            public Color Color { get; set; } //@@MP - can't be made static

            public OverlayLine(Point screenFrom, Color color, Point screenTo)
            {
                ScreenFrom = screenFrom;
                ScreenTo = screenTo;
                Color = color;
            }

            public override void Draw(IRogueUI ui)
            {
                ui.UI_DrawLine(Color, ScreenFrom.X, ScreenFrom.Y, ScreenTo.X, ScreenTo.Y);
            }
        }

        class OverlayRect : Overlay
        {
            public Rectangle Rectangle { get; set; } //@@MP - can't be made static
            public Color Color { get; set; } //@@MP - can't be made static

            public OverlayRect(Color color, Rectangle rect)
            {
                Rectangle = rect;
                Color = color;
            }

            public override void Draw(IRogueUI ui)
            {
                ui.UI_DrawRect(Color, Rectangle);
            }
        }

        class OverlayPopup : Overlay
        {
            public Point ScreenPosition { get; set; } //@@MP - can't be made static
            public Color TextColor { get; set; } //@@MP - can't be made static
            public Color BoxBorderColor { get; set; } //@@MP - can't be made static
            public Color BoxFillColor { get; set; } //@@MP - can't be made static
            public string[] Lines { get; set; } //@@MP - can't be made static

            /// <summary>
            /// 
            /// </summary>
            /// <param name="lines">can be null if want to set text property later</param>
            public OverlayPopup(string[] lines, Color textColor, Color boxBorderColor, Color boxFillColor, Point screenPos)
            {
                ScreenPosition = screenPos;
                TextColor = textColor;
                BoxBorderColor = boxBorderColor;
                BoxFillColor = boxFillColor;
                Lines = lines;
            }

            public override void Draw(IRogueUI ui)
            {
                ui.UI_DrawPopup(Lines, TextColor, BoxBorderColor, BoxFillColor, ScreenPosition.X, ScreenPosition.Y);
            }

        }

        class OverlayPopupTitle : Overlay // alpha10 added
        {
            public Point ScreenPosition { get; set; }
            public string Title { get; set; }
            public Color TitleColor { get; set; }
            public string[] Lines { get; set; }
            public Color TextColor { get; set; }
            public Color BoxBorderColor { get; set; }
            public Color BoxFillColor { get; set; }

            public OverlayPopupTitle(string title, Color titleColor, string[] lines, Color textColor, Color boxBorderColor, Color boxFillColor, Point screenPos)
            {
                this.ScreenPosition = screenPos;
                this.Title = title;
                this.TitleColor = titleColor;
                this.TextColor = textColor;
                this.BoxBorderColor = boxBorderColor;
                this.BoxFillColor = boxFillColor;
                this.Lines = lines;
            }

            public override void Draw(IRogueUI ui)
            {
                ui.UI_DrawPopupTitle(Title, TitleColor, Lines, TextColor, BoxBorderColor, BoxFillColor, ScreenPosition.X, ScreenPosition.Y);
            }
        }

        class OverlayPopupTitleColors : Overlay // alpha10 added
        {
            public Point ScreenPosition { get; set; }
            public string Title { get; set; }
            public Color TitleColor { get; set; }
            public string[] Lines { get; set; }
            public Color[] Colors { get; set; }
            public Color BoxBorderColor { get; set; }
            public Color BoxFillColor { get; set; }

            public OverlayPopupTitleColors(string title, Color titleColor, string[] lines, Color[] colors, Color boxBorderColor, Color boxFillColor, Point screenPos)
            {
                this.ScreenPosition = screenPos;
                this.Title = title;
                this.TitleColor = titleColor;
                this.Colors = colors;
                this.BoxBorderColor = boxBorderColor;
                this.BoxFillColor = boxFillColor;
                this.Lines = lines;
            }

            public override void Draw(IRogueUI ui)
            {
                ui.UI_DrawPopupTitleColors(Title, TitleColor, Lines, Colors, BoxBorderColor, BoxFillColor, ScreenPosition.X, ScreenPosition.Y);
            }
        }
        #endregion

        #region Character generation
        struct CharGen
        {
            public bool IsUndead { get; set; }
            public GameActors.IDs UndeadModel { get; set; }
            public bool IsMale { get; set; }
            public Skills.IDs StartingSkill { get; set; }
        }
        #endregion

        #region Simulation
        [Flags]
        enum SimFlags
        {
            NOT_SIMULATING = 0,
            HIDETAIL_TURN = (1 << 0),
            LODETAIL_TURN = (1 << 1)
        }
        #endregion
        #endregion

        #region FIELDS
        readonly IRogueUI m_UI;
        Rules m_Rules;
        Session m_Session;
        HiScoreTable m_HiScoreTable;
        MessageManager m_MessageManager;
        bool m_IsGameRunning = true;
        bool m_HasLoadedGame = false;
        bool m_PlayerWasRescued = false; //@@MP (Release 6-4)
        List<Overlay> m_Overlays = new List<Overlay>();
        Actor m_Player;
        HashSet<Point> m_PlayerFOV = new HashSet<Point>();
        Rectangle m_MapViewRect;
        Point m_PlayerInspectionModePt; //@@MP (Release 7-1)

        static GameOptions s_Options;
        static Keybindings s_KeyBindings;
        static GameHintsStatus s_Hints;
        OverlayPopup m_HintAvailableOverlay;  // alpha10

        BaseTownGenerator m_TownGenerator;

        bool m_PlayedIntro;
        List<string> m_bgMusicPlaylist = new List<string>(); //@@MP (Release 6-1)
        ISoundManager m_MusicManager;
        ISoundManager m_SFXManager; //@@MP (Release 2)
        ISoundManager m_AmbientSFXManager; //@@MP (Release 6-1)

        CharGen m_CharGen;

        TextFile m_Manual;
        int m_ManualLine;

        TextFile m_Credits;
        int m_CreditsLine;

        GameFactions m_GameFactions;
        GameActors m_GameActors;
        GameItems m_GameItems;
        GameTiles m_GameTiles;

        bool m_IsPlayerLongWait;
        bool m_IsPlayerLongWaitForcedStop;
        WorldTime m_PlayerLongWaitEnd;

        // alpha10 new sim thread management
        //Object m_SimMutex = new Object();  // alpha10 obsolete
        Thread m_SimThread;
        readonly Object m_SimStateLock = new Object(); // alpha10 lock when reading sim thread state flags
        bool m_SimThreadDoRun;  // alpha10 sim thread state: set by main thread to false to ask sim thread to stop.
        bool m_SimThreadIsWorking;  // alpha10 sim thread state: set by sim thread to false when has exited
        static Thread MainThread;  //@@MP (Release 7-1)
        #endregion

        #region PROPERTIES
        public Session Session
        {
            get { return m_Session; }
        }

        public Rules Rules
        {
            get { return m_Rules; }
        }

        public IRogueUI UI
        {
            get { return m_UI; }
        }

        public bool IsGameRunning
        {
            get { return m_IsGameRunning; }
            set { m_IsGameRunning = value; }
        }

        public static GameOptions Options
        {
            get { return s_Options; }
        }

        public static Keybindings KeyBindings
        {
            get { return s_KeyBindings; }
        }

        public GameFactions GameFactions
        {
            get { return m_GameFactions; }
        }

        public GameActors GameActors
        {
            get { return m_GameActors; }
        }

        public GameItems GameItems
        {
            get { return m_GameItems; }
        }

        public GameTiles GameTiles
        {
            get { return m_GameTiles; }
        }

        public Actor Player
        {
            get { return m_Player; }
        }
        #endregion

        //----------------

        #region INIT (INTERFACE)
        public RogueGame(IRogueUI UI)
        {
            Logger.WriteLine(Logger.Stage.INIT_MAIN, "Building RogueGame()");

            m_UI = UI;

            Logger.WriteLine(Logger.Stage.INIT_MAIN, "creating Music Manager"); //@@MP - now used for background music, rather than weather (Release 6-1)
            m_MusicManager = new SFMLMusicManager(); //@@MP (Release 5-3)

            Logger.WriteLine(Logger.Stage.INIT_MAIN, "creating Sound Manager"); //@@MP (Release 2)
            m_SFXManager = new SFMLSoundManager(); //sound manager is good for short tracks called frequently, as they are kept in memory

            Logger.WriteLine(Logger.Stage.INIT_MAIN, "creating Ambient Sound Manager"); //@@MP (Release 2)
            m_AmbientSFXManager = new SFMLMusicManager(); //music manager is good for long tracks, as they are streamed from disk rather than kept in memory

            Logger.WriteLine(Logger.Stage.INIT_MAIN, "creating MessageManager");
            m_MessageManager = new MessageManager(MESSAGES_SPACING, MESSAGES_FADEOUT, MESSAGES_HISTORY);

            m_Session = Session.Get;
            Logger.WriteLine(Logger.Stage.INIT_MAIN, "creating Rules");
            m_Rules = new Rules(new DiceRoller(m_Session.Seed));

            BaseTownGenerator.Parameters genParams = BaseTownGenerator.DEFAULT_PARAMS;
            genParams.MapWidth = genParams.MapHeight = 100;
            Logger.WriteLine(Logger.Stage.INIT_MAIN, "creating Town Generator");
            m_TownGenerator = new StdTownGenerator(this, genParams);

            Logger.WriteLine(Logger.Stage.INIT_MAIN, "creating options, keys, and hints");
            s_Options = new GameOptions();
            s_Options.ResetToDefaultValues(GameOptions.OptionsCategory.ALL);
            s_KeyBindings = new Keybindings();
            s_KeyBindings.ResetToDefaults();
            s_Hints = new GameHintsStatus();
            s_Hints.ResetAllHints();

            Logger.WriteLine(Logger.Stage.INIT_MAIN, "creating databases");
            m_GameFactions = new GameFactions();
            m_GameActors = new GameActors();
            m_GameItems = new GameItems();
            m_GameTiles = new GameTiles();

            Logger.WriteLine(Logger.Stage.INIT_MAIN, "RogueGame() done");
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="forced"></param>
        void AnimDelay(int msecs, bool forced)
        {
            if (s_Options.IsAnimDelayOn || forced) //@@MP - added forced for situations where the user must see the delay (Release 6-6)
                m_UI.UI_Wait(msecs);
        }
        #endregion

        #region MESSAGING & GRAMMAR HELPERS
        public void AddMessage(Message msg)
        {
            // ignore empty messages
            if (msg.Text.Length == 0)
                return;

            // Clear if too much messages.
            if (m_MessageManager.Count >= MAX_MESSAGES)
                m_MessageManager.Clear();

            // Format message: <turn> <Text>           
            msg.Text = String.Format("{0} {1}", m_Session.WorldTime.TurnCounter, Capitalize(msg.Text));

            // Add.
            m_MessageManager.Add(msg);
        }

        /// <summary>
        /// Adds the message if it is audible by the player and redraws the screen.
        /// </summary>
        public void AddMessageIfAudibleForPlayer(Location location, Message msg)
        {
            if (msg == null)
                throw new ArgumentNullException("msg");

            // 1. Audible to player?
            if (m_Player != null)
            {
                // if sleeping can't hear.
                if (m_Player.IsSleeping)
                    return;

                // can't hear if not same map.
                if (location.Map != m_Player.Location.Map)
                    return;

                // can hear if close enough.
                if (m_Rules.StdDistance(m_Player.Location.Position, location.Position) <= m_Player.AudioRange)
                {
                    // hear.
                    msg.Color = PLAYER_AUDIO_COLOR;
                    AddMessage(msg);

                    // if waiting, interupt.
                    if (m_IsPlayerLongWait)
                        m_IsPlayerLongWaitForcedStop = true;

                    // redraw.
                    RedrawPlayScreen();
                }
            }
        }

        /// <summary>
        /// Make a message with the text: [eventText] DISTANCE tiles to the DIRECTION.
        /// </summary>
        /// <param name="eventText"></param>
        /// <param name="position"></param>
        /// <returns></returns>
        Message MakePlayerCentricMessage(string eventText, Point position)
        {
            Point vDir = new Point(position.X - m_Player.Location.Position.X, position.Y - m_Player.Location.Position.Y);
            string text = String.Format("{0} {1} tiles to the {2}.", eventText, (int)m_Rules.StdDistance(vDir), Direction.ApproximateFromVector(vDir));
            return new Message(text, m_Session.WorldTime.TurnCounter);
        }

        Message MakeErrorMessage(string text)
        {
            return new Message(text, m_Session.WorldTime.TurnCounter, Color.Red);
        }

        Message MakeYesNoMessage(string question)
        {
            return new Message(String.Format("{0}? Y to confirm, N to cancel", question), m_Session.WorldTime.TurnCounter, Color.Yellow);
        }

        /// <summary>
        /// Checks if the player is in a position and state to hear a given sound
        /// </summary>
        /// <param name="location">The source Location of the noise</param>  
        /// <param name="audioRadius">Provide a number >0 or leave default to ignore</param>  
        public bool IsAudibleToPlayer(Location location, int audioRadius = 0) //@@MP - addded (Release 2), added optional radius (Release 5-3)
        {
            if (location == null)
                throw new ArgumentNullException("location");

            // Audible to player?
            if (m_Player != null) //unecessary check, but whatever
            {
                // can't hear if not same map.
                if (location.Map != m_Player.Location.Map)
                    return false;

                // if sleeping can't hear.
                if (m_Player.IsSleeping)
                    return false;

                // can hear if close enough.
                if (m_Rules.StdDistance(m_Player.Location.Position, location.Position) <= m_Player.AudioRange)
                {
                    if (audioRadius == 0)
                        return true; // heard. no specific radius given
                    else //it's within the standard audible range. now check if it's within the supplied radius
                    {
                        Point audioSourcePoint = new Point(location.Position.X, location.Position.Y);
                        int noiseDistance = m_Rules.GridDistance(Player.Location.Position, audioSourcePoint); //@@MP - added a distance check, because the default audible range is big (Release 5-3)
                        if (noiseDistance <= audioRadius)
                            return true;
                    }
                }
            }

            return false; //not heard
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="actor"></param>
        /// <returns>"someone" if not visible to the player; TheName if visible.</returns>
        string ActorVisibleIdentity(Actor actor)
        {
            return IsVisibleToPlayer(actor) ? actor.Name : "someone"; //@@MP - was .TheName but was grammatically incorrect (Release 6-4)
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="mapObj"></param>
        /// <returns>"something" if not visible to the player; TheName if visible.</returns>
        string ObjectVisibleIdentity(MapObject mapObj)
        {
            return IsVisibleToPlayer(mapObj) ? mapObj.TheName : "something";
        }

        Message MakeMessage(Actor actor, string doWhat)
        {
            return MakeMessage(actor, doWhat, OTHER_ACTION_COLOR);
        }

        Message MakeMessage(Actor actor, string doWhat, Color color) //@@MP - removed default rather than force a color if IsPlayer (Release 7-3)
        {
            StringBuilder sb = new StringBuilder();
            sb.Append(ActorVisibleIdentity(actor));
            sb.Append(" ");
            sb.Append(doWhat);

            Message msg = new Message(sb.ToString(), m_Session.WorldTime.TurnCounter);
            msg.Color = color;

            return msg;
        }

        Message MakeMessage(Actor actor, string doWhat, Actor target)
        {
            return MakeMessage(actor, doWhat, target, ".");
        }

        Message MakeMessage(Actor actor, string doWhat, Actor target, string phraseEnd)
        {
            StringBuilder sb = new StringBuilder();
            sb.Append(ActorVisibleIdentity(actor));
            sb.Append(" ");
            sb.Append(doWhat);
            sb.Append(" ");
            sb.Append(ActorVisibleIdentity(target));
            sb.Append(phraseEnd);

            Message msg = new Message(sb.ToString(), m_Session.WorldTime.TurnCounter);
            if (actor.IsPlayer || target.IsPlayer)
                msg.Color = PLAYER_ACTION_COLOR;
            else
                msg.Color = OTHER_ACTION_COLOR;

            return msg;
        }

        Message MakeMessage(Actor actor, string doWhat, MapObject target)
        {
            return MakeMessage(actor, doWhat, target, ".");
        }

        Message MakeMessage(Actor actor, string doWhat, MapObject target, string phraseEnd)
        {
            StringBuilder sb = new StringBuilder();
            sb.Append(ActorVisibleIdentity(actor));
            sb.Append(" ");
            sb.Append(doWhat);
            sb.Append(" ");
            sb.Append(ObjectVisibleIdentity(target));
            sb.Append(phraseEnd);

            Message msg = new Message(sb.ToString(), m_Session.WorldTime.TurnCounter);
            if (actor.IsPlayer)
                msg.Color = PLAYER_ACTION_COLOR;
            else
                msg.Color = OTHER_ACTION_COLOR;

            return msg;
        }

        Message MakeMessage(Actor actor, string doWhat, Item target)
        {
            return MakeMessage(actor, doWhat, target, ".");
        }

        Message MakeMessage(Actor actor, string doWhat, Item target, string phraseEnd)
        {
            StringBuilder sb = new StringBuilder();
            sb.Append(ActorVisibleIdentity(actor));
            sb.Append(" ");
            sb.Append(doWhat);
            sb.Append(" ");
            sb.Append(target.TheName);
            sb.Append(phraseEnd);

            Message msg = new Message(sb.ToString(), m_Session.WorldTime.TurnCounter);
            if (actor.IsPlayer)
                msg.Color = PLAYER_ACTION_COLOR;
            else
                msg.Color = OTHER_ACTION_COLOR;

            return msg;
        }

        void ClearMessages()
        {
            m_MessageManager.Clear();
        }

        void ClearMessagesHistory()
        {
            m_MessageManager.ClearHistory();
        }

        void RemoveLastMessage()
        {
            m_MessageManager.RemoveLastMessage();
        }

        void DrawMessages()
        {
            m_MessageManager.Draw(m_UI, m_Session.LastTurnPlayerActed, MESSAGES_X, MESSAGES_Y);
        }

        void AddMessagePressEnter() // alpha10.1 caller should handle Bot Mode: check for IsBotPlayer and dont call this
        {
            AddMessage(new Message("<press ENTER>", m_Session.WorldTime.TurnCounter, Color.Yellow));
            RedrawPlayScreen();
            WaitEnter();
            RemoveLastMessage();
            RedrawPlayScreen();
        }

        static string Conjugate(Actor actor, string verb) //@@MP - made static (Release 5-7)
        {
            return actor.IsProperName && !actor.IsPluralName ? verb + "s" : verb;
        }

        static string Conjugate(Actor actor, Verb verb) //@@MP - made static (Release 5-7)
        {
            return actor.IsProperName && !actor.IsPluralName ? verb.HeForm : verb.YouForm;
        }

        static string Capitalize(string text) //@@MP - made static (Release 5-7)
        {
            if (text == null)
                return "";
            if (text.Length == 1)
                return String.Format("{0}", Char.ToUpper(text[0]));

            return String.Format("{0}{1}", Char.ToUpper(text[0]), text.Substring(1));
        }

        static string HisOrHer(Actor actor) //@@MP - made static (Release 5-7)
        {
            return actor.Model.DollBody.IsMale ? "his" : "her";
        }

        static string HeOrShe(Actor actor) //@@MP - made static (Release 5-7)
        {
            return actor.Model.DollBody.IsMale ? "he" : "she";
        }

        static string HimOrHer(Actor actor) //@@MP - made static (Release 5-7)
        {
            return actor.Model.DollBody.IsMale ? "him" : "her";
        }

        static string HimselfOrHerself(Actor actor) // alpha10 //@@MP made static (Release 6-1)
        {
            return actor.Model.DollBody.IsMale ? "himself" : "herself";
        }

        /// <summary>
        /// </summary>
        /// <returns>"a/an name"</returns>
        static string AorAn(string name) //@@MP - made static (Release 5-7)
        {
            char c = name[0];
            return (c == 'a' || c == 'e' || c == 'i' || c == 'u' ? "an " : "a ") + name;
        }

        static string TruncateString(string s, int maxLength) //@@MP - made static (Release 5-7)
        {
            return s.Length <= maxLength ? s : s.Substring(0, maxLength);
        }

        #region -Text helpers
        static int FindLongestLine(string[] lines)
        {
            if (lines == null || lines.Length == 0)
                return 0;

            int max = Int32.MinValue;

            foreach (string s in lines)
            {
                if (s == null)  // sanity check.
                    continue;
                if (s.Length > max)
                    max = s.Length;
            }

            return max;
        }
        #endregion
        #endregion

        #region INPUT HELPERS
        void WaitKeyOrMouse(out KeyEventArgs key, out Point mousePos, out MouseButtons? mouseButtons)
        {
            // Peek keyboard & mouse until we got an event.
            m_UI.UI_PeekKey();  // consume keys to avoid repeats.
            KeyEventArgs inKey;
            Point prevMousePos = m_UI.UI_GetMousePosition();
            mousePos = new Point(-1, -1);
            mouseButtons = null;
            for (; ; )
            {
                inKey = m_UI.UI_PeekKey();
                if (inKey != null)
                {
                    key = inKey;
                    return;
                }
                else
                {
                    mousePos = m_UI.UI_GetMousePosition();
                    mouseButtons = m_UI.UI_PeekMouseButtons();
                    if (mousePos != prevMousePos || mouseButtons != null)
                    {
                        key = null;
                        return;
                    }
                }
            }
        }

        /// <summary>
        /// Loop input until Exit/Cancel or a direction command is issued.
        /// </summary>
        /// <returns>null if Exit/Cancel</returns>
        Direction WaitDirectionOrCancel()
        {
            for (; ; )
            {
                KeyEventArgs inKey = m_UI.UI_WaitKey();
                PlayerCommand command = InputTranslator.KeyToCommand(inKey);
                if (inKey.KeyCode == Keys.Escape)// command == PlayerCommand.EXIT_OR_CANCEL)
                    return null;
                Direction dir = CommandToDirection(command);
                if (dir != null)
                    return dir;
            }
        }

        void WaitEnter()
        {
            for (; ; )
            {
                KeyEventArgs inKey = m_UI.UI_WaitKey();
                if (inKey.KeyCode == Keys.Enter)
                    return;
            }
        }

        void WaitEscape()
        {
            for (; ; )
            {
                KeyEventArgs inKey = m_UI.UI_WaitKey();
                if (inKey.KeyCode == Keys.Escape)
                    return;
            }
        }

        /// <summary>
        /// -1 if no choice.
        /// </summary>
        /// <param name="key"></param>
        /// <returns></returns>
        static int KeyToChoiceNumber(Keys key) //@@MP - made static (Release 5-7)
        {
            switch (key)
            {
                case Keys.NumPad0:
                case Keys.D0:
                    return 0;

                case Keys.NumPad1:
                case Keys.D1:
                    return 1;

                case Keys.NumPad2:
                case Keys.D2:
                    return 2;

                case Keys.NumPad3:
                case Keys.D3:
                    return 3;

                case Keys.NumPad4:
                case Keys.D4:
                    return 4;

                case Keys.NumPad5:
                case Keys.D5:
                    return 5;

                case Keys.NumPad6:
                case Keys.D6:
                    return 6;

                case Keys.NumPad7:
                case Keys.D7:
                    return 7;

                case Keys.NumPad8:
                case Keys.D8:
                    return 8;

                case Keys.NumPad9:
                case Keys.D9:
                    return 9;

                default:
                    return -1;
            }
        }

        bool WaitYesOrNo()
        {
            for (; ; )
            {
                KeyEventArgs inKey = m_UI.UI_WaitKey();
                if (inKey.KeyCode == Keys.Y)
                    return true;
                else if (inKey.KeyCode == Keys.N || inKey.KeyCode == Keys.Escape)
                    return false;
            }
        }
        #endregion

        #region MENUS
        void HandleMainMenu()
        {
            bool loop = true;
            bool isLoadEnabled = File.Exists(GetUserSave());
            bool isBackupSave = File.Exists(String.Format("{0}backup.dat", GetUserSavesPath()));  //@@MP (Release 7-5)

            string[] menuEntries = new string[] {
                "New Game",                                     // 0 
                isLoadEnabled ?  "Load Saved Game" : "(no save found)",   // 1
                isBackupSave ?  "Load Backup Save" : "(no backup save found)",   // 2      //@@MP (Release 7-5)
                "Redefine keys",                                // 3
                "Options",                                      // 4
                "Game Manual",                                  // 5
                "Hints",                                        // 6
                "High Scores",                                  // 7
                "Credits",                                      // 8
                "About",                                        // 9      //@@MP (Release 7-6)
                "Quit Game" };                                  // 10
            int selected = 0;
            do
            {
                // music.
                if (!m_MusicManager.IsPlaying(GameMusics.INTRO) && !m_PlayedIntro)
                {
                    m_MusicManager.StopAll();
                    m_MusicManager.Play(GameMusics.INTRO, AudioPriority.PRIORITY_EVENT);
                    m_PlayedIntro = true;
                }

                // display.
                int gx, gy;
                gx = 0;
                gy = 70; //@@MP - made room for a banner (Release 7-6)
                m_UI.UI_Clear(Color.Black);
                m_UI.UI_DrawImage(GameImages.MENU_TITLE, gx, 5); //@@MP - added a banner (Release 7-6)
                DrawHeader(gy);
                gy += BOLD_LINE_SPACING;
                m_UI.UI_DrawStringBold(Color.Yellow, "Main Menu", 0, gy);
                gy += 2 * BOLD_LINE_SPACING;
                DrawMenuOrOptions(selected, Color.White, menuEntries, Color.White, null, gx, ref gy);
                gy += 3 * BOLD_LINE_SPACING;
                m_UI.UI_DrawStringBold(Color.LightSkyBlue, "Please note that Rogue Survivor: Still Alive is currently in alpha. There will be bugs.", 0, gy);
                gy += 2 * BOLD_LINE_SPACING;
                gy += 3 * BOLD_LINE_SPACING;
                DrawGameTips(gx, gy); //@@MP (Release 6-6)
                DrawFootnote(Color.White, "cursor to move, ENTER to select");

                // repaint.
                m_UI.UI_Repaint();

                // get menu action.
                KeyEventArgs key = m_UI.UI_WaitKey();
                switch (key.KeyCode)
                {
                    case Keys.Up:       // move up
                        if (selected > 0) --selected;
                        else selected = menuEntries.Length - 1;
                        break;
                    case Keys.Down:     // move down
                        selected = (selected + 1) % menuEntries.Length;
                        break;

                    case Keys.Enter:    // validate
                        {
                            switch (selected)
                            {
                                case 0:
                                    if (HandleNewCharacter(out string suppliedName)) //@@MP - added parameter for user to supply a name (Release 5-7)
                                    {
                                        StartNewGame(suppliedName); //@@MP - added parameter for user to supply a name (Release 5-7)
                                        loop = false;
                                    }
                                    break;

                                case 1:
                                    if (!isLoadEnabled)
                                        break;
                                    gy += 2 * BOLD_LINE_SPACING;
                                    m_UI.UI_DrawStringBold(Color.Yellow, "Loading game, please wait...", gx, gy);
                                    m_UI.UI_Repaint();
                                    LoadGame(GetUserSave());
                                    loop = false;
                                    if (s_Options.IsSimON && s_Options.SimThread) // alpha10
                                        StartSimThread();
                                    break;

                                case 2:  //@@MP (Relese 7-5)
                                    if (!isBackupSave)
                                        break;
                                    gy += 2 * BOLD_LINE_SPACING;
                                    m_UI.UI_DrawStringBold(Color.Yellow, "Loading game, please wait...", gx, gy);
                                    m_UI.UI_Repaint();
                                    LoadGame(GetUserSavesPath() + "backup.dat");
                                    loop = false;
                                    if (s_Options.IsSimON && s_Options.SimThread) // alpha10
                                        StartSimThread();
                                    break;

                                case 3:
                                    HandleRedefineKeys();
                                    break;

                                case 4:
                                    HandleOptions(); //@@MP - unused parameter (Release 5-7)
                                    ApplyOptions(); //@@MP - unused parameter (Release 5-7)
                                    break;

                                case 5:
                                    HandleHelpMode();
                                    break;

                                case 6:
                                    HandleHintsScreen();
                                    break;

                                case 7:
                                    HandleHiScores(true);
                                    break;

                                case 8:
                                    HandleCredits();
                                    break;

                                case 9:
                                    HandleAbout();
                                    break;

                                case 10:
                                    m_IsGameRunning = false;
                                    loop = false;
                                    break;

                                default:
                                    break;
                            } // switch selected
                            break;
                        }
                }
            }
            while (loop);
        }

        void HandleOptions() //@@MP - unused parameter (Release 5-7)
        {
            //GameOptions prevOptions = s_Options; //@@MP - obsolete (Release 6-1)

            #region Order
            GameOptions.IDs[] list = new GameOptions.IDs[]  //@@MP provides the order in which they appear in the menu
            {
                // config
                GameOptions.IDs.CONFIG_WINDOW,
                GameOptions.IDs.CONFIG_WRITE_LOG_TO_FILE,
                // helpers
                GameOptions.IDs.UI_AUTOSAVE, //@MP (Release 6-1)
                GameOptions.IDs.UI_ADVISOR,
                GameOptions.IDs.UI_COMBAT_ASSISTANT,
                GameOptions.IDs.UI_SHOW_PLAYER_TARGETS,
                GameOptions.IDs.UI_SHOW_TARGETS,
                GameOptions.IDs.UI_ANIM_DELAY,
                GameOptions.IDs.UI_SHOW_MINIMAP,
                // sim
                GameOptions.IDs.GAME_SIMULATE_DISTRICTS,
                GameOptions.IDs.GAME_TURNS_SIM_CAP, //@@MP (Release 7-3)
                GameOptions.IDs.GAME_SIM_THREAD,
                GameOptions.IDs.GAME_SIMULATE_SLEEP,
                // death
                GameOptions.IDs.GAME_DEATH_SCREENSHOT,
                GameOptions.IDs.GAME_PERMADEATH,
                // maps
                GameOptions.IDs.GAME_CITY_SIZE,
                GameOptions.IDs.GAME_DISTRICT_SIZE,
                GameOptions.IDs.GAME_MAX_ANIMALS, //@@MP (Release 7-3)
                GameOptions.IDs.GAME_DAYS_BEFORE_ITEM_DESPAWNS, //@@MP (Release 7-6)
                GameOptions.IDs.GAME_REDUCED_MAPOBJECT_LIGHTING, //@@MP (Release 7-6)
                GameOptions.IDs.GAME_WORLD_DECAY, //@@MP (Release 7-6)
                GameOptions.IDs.GAME_DAYS_BEFORE_WORLD_DECAYS, //@@MP (Release 7-6)
                //GameOptions.IDs.GAME_REVEAL_STARTING_DISTRICT, //@@MP (Release 6-1)
                // reinc
                //GameOptions.IDs.GAME_REINC_LIVING_RESTRICTED, //@@MP (Release 5-7)
                //GameOptions.IDs.GAME_REINCARNATE_AS_RAT, //@@MP (Release 5-7)
                //GameOptions.IDs.GAME_REINCARNATE_TO_SEWERS //@@MP (Release 5-7)
                // sounds
                GameOptions.IDs.UI_AI_VOCALISATION_CHANCE, //@@MP (Release 7-6)
                GameOptions.IDs.UI_MUSIC,
                GameOptions.IDs.UI_MUSIC_VOLUME,
                GameOptions.IDs.UI_SFXS, //@@MP (Release 2)
                GameOptions.IDs.UI_SFXS_VOLUME, //@@MP (Release 2)
                GameOptions.IDs.UI_AMBIENTSFXS, //@@MP (Release 6-1)
                GameOptions.IDs.UI_AMBIENTSFXS_VOLUME //@@MP (Release 6-1)

                #region //MOVED TO CHARACTER CREATION   //@@MP (Release 7-4)
                /*
                // living
                GameOptions.IDs.GAME_MAX_CIVILIANS,
                GameOptions.IDs.GAME_ZOMBIFICATION_CHANCE,
                GameOptions.IDs.GAME_AGGRESSIVE_HUNGRY_CIVILIANS,
                GameOptions.IDs.GAME_NPC_CAN_STARVE_TO_DEATH,
                GameOptions.IDs.GAME_STARVED_ZOMBIFICATION,
                GameOptions.IDs.GAME_SANITY, //@@MP (Release 1)
                GameOptions.IDs.GAME_VTG_ANTIVIRAL_PILLS, //@@MP (Release 5-2)
                GameOptions.IDs.GAME_RESOURCES_AVAILABILITY, //@@MP (Release 7-4)
                // undeads
                GameOptions.IDs.GAME_MAX_UNDEADS,
                GameOptions.IDs.GAME_ALLOW_UNDEADS_EVOLUTION,
                GameOptions.IDs.GAME_DAY_ZERO_UNDEADS_PERCENT,
                GameOptions.IDs.GAME_ZOMBIE_INVASION_DAILY_INCREASE,
                GameOptions.IDs.GAME_UNDEADS_UPGRADE_DAYS,
                GameOptions.IDs.GAME_SHAMBLERS_UPGRADE,
                GameOptions.IDs.GAME_SKELETONS_UPGRADE,
                //GameOptions.IDs.GAME_RATS_UPGRADE, //@@MP (Release 5-7)
                // events
                GameOptions.IDs.GAME_NATGUARD_FACTOR,
                GameOptions.IDs.GAME_SUPPLIESDROP_FACTOR,
                */
                #endregion
            };
            #endregion

            string[] menuEntries = new string[list.Length];
            string[] values = new string[list.Length];
            for (int i = 0; i < list.Length; i++)
            {
                menuEntries[i] = GameOptions.Name(list[i]);
            }

            bool loop = true;
            int selected = 0;
            char[] newlines = { '\n' };  // alpha10
            char[] spaces = { ' ' }; // alpha10
            do
            {
                for (int i = 0; i < list.Length; i++)
                    values[i] = s_Options.DescribeValue(list[i]); //@@MP - unused parameter (Release 5-7)

                int gx, gy;
                gx = gy = 0;
                m_UI.UI_Clear(Color.Black);
                DrawHeader(0);
                gy += BOLD_LINE_SPACING;
                m_UI.UI_DrawStringBold(Color.Yellow, "Options", 0, gy);  // alpha10 dont mention current mode
                gy += 2 * BOLD_LINE_SPACING;
                DrawMenuOrOptions(selected, Color.White, menuEntries, Color.LightGreen, values, gx, ref gy, false, 400);

                // describe current option.    // alpha10
                gy += BOLD_LINE_SPACING;
                m_UI.UI_DrawStringBold(Color.White, menuEntries[selected].TrimStart(spaces), gx, gy);
                gy += BOLD_LINE_SPACING;
                string desc = GameOptions.Describe(list[selected]);
                string[] descLines = desc.Split(newlines);
                foreach (string d in descLines)
                {
                    m_UI.UI_DrawString(Color.White, "  " + d, gx, gy);
                    gy += BOLD_LINE_SPACING;
                }

                // caution.
                gy += BOLD_LINE_SPACING;
                m_UI.UI_DrawStringBold(Color.Red, "* Caution : increasing these values can make the game run slower and saving/loading longer.", gx, gy);
                gy += BOLD_LINE_SPACING;
                m_UI.UI_DrawStringBold(Color.Red, "** Changing these options requires restarting the game to take effect.", gx, gy);
                gy += BOLD_LINE_SPACING;

                // footnote.
                DrawFootnote(Color.White, "Move cursor then left/right to change values, R to restore defaults, ESC to save and leave");
                m_UI.UI_Repaint();

                // handle
                // get menu action.
                KeyEventArgs key = m_UI.UI_WaitKey();
                switch (key.KeyCode)
                {
                    case Keys.Up:       // move up
                        if (selected > 0) --selected;
                        else selected = menuEntries.Length - 1;
                        OptionsMenuAudioAdjustment((GameOptions.IDs)list[selected]); //@@MP - preview volume on relevant options (Release 7-3)
                        break;
                    case Keys.Down:     // move down
                        selected = (selected + 1) % menuEntries.Length;
                        OptionsMenuAudioAdjustment((GameOptions.IDs)list[selected]); //@@MP - preview volume on relevant options (Release 7-3)
                        break;

                    case Keys.R:        // restore defaults.
                        s_Options.ResetToDefaultValues(GameOptions.OptionsCategory.GENERAL); //prevOptions; //@@MP - used to restore changes in this session, now resets defaults (Release 6-1)
                        SetupConfig.Window = SetupConfig.eWindow.WINDOW_FULLSCREEN;
                        SetupConfig.WriteLogToFile = false;
                        SetupConfig.Save();
                        ApplyOptions();
                        SaveOptions();
                        break;

                    case Keys.Escape:   // validate and leave
                        loop = false;
                        OptionsMenuAudioAdjustment(GameOptions.IDs.UI_ADVISOR); //@@MP - just use a dummy one to stop any playing volume preview audio (Release 7-3)
                        break;

                    case Keys.Left:
                        switch ((GameOptions.IDs)list[selected])
                        {
                            case GameOptions.IDs.CONFIG_WINDOW:
                                switch (SetupConfig.Window) {
                                    case SetupConfig.eWindow.WINDOW_FULLSCREEN: SetupConfig.Window = SetupConfig.eWindow.WINDOW_WINDOWED; break;
                                    case SetupConfig.eWindow.WINDOW_WINDOWED: SetupConfig.Window = SetupConfig.eWindow.WINDOW_FULLSCREEN; break;
                                }
                                break;
                            case GameOptions.IDs.CONFIG_WRITE_LOG_TO_FILE: SetupConfig.WriteLogToFile = !SetupConfig.WriteLogToFile; break;
                            case GameOptions.IDs.GAME_DISTRICT_SIZE: s_Options.DistrictSize -= 5; break;
                            case GameOptions.IDs.UI_MUSIC: s_Options.PlayMusic = !s_Options.PlayMusic; break;
                            case GameOptions.IDs.UI_MUSIC_VOLUME: s_Options.MusicVolume -= 5; break;
                            case GameOptions.IDs.UI_SFXS: s_Options.PlaySFXs = !s_Options.PlaySFXs; break; //@@MP (Release 2)
                            case GameOptions.IDs.UI_SFXS_VOLUME: s_Options.SFXVolume -= 5; OptionsMenuAudioAdjustment((GameOptions.IDs)list[selected]); break; //@@MP - added (Release 2), added preview of volume (Release 7-3)
                            case GameOptions.IDs.UI_AMBIENTSFXS: s_Options.PlayAmbientSFXs = !s_Options.PlayAmbientSFXs; break; //@@MP (Release 6-1)
                            case GameOptions.IDs.UI_AMBIENTSFXS_VOLUME: s_Options.AmbientSFXVolume -= 5; break; //@@MP (Release 6-1)
                            case GameOptions.IDs.UI_ANIM_DELAY: s_Options.IsAnimDelayOn = !s_Options.IsAnimDelayOn; break;
                            case GameOptions.IDs.UI_SHOW_MINIMAP: s_Options.IsMinimapOn = !s_Options.IsMinimapOn; break;
                            case GameOptions.IDs.UI_ADVISOR: s_Options.IsAdvisorEnabled = !s_Options.IsAdvisorEnabled; break;
                            case GameOptions.IDs.UI_COMBAT_ASSISTANT: s_Options.IsCombatAssistantOn = !s_Options.IsCombatAssistantOn; break;
                            case GameOptions.IDs.UI_SHOW_TARGETS: s_Options.ShowTargets = !s_Options.ShowTargets; break;
                            case GameOptions.IDs.UI_SHOW_PLAYER_TARGETS: s_Options.ShowPlayerTargets = !s_Options.ShowPlayerTargets; break;
                            case GameOptions.IDs.UI_AUTOSAVE: s_Options.Autosaving = !s_Options.Autosaving; break; //@@MP (Release 6-1)
                            case GameOptions.IDs.UI_AI_VOCALISATION_CHANCE: s_Options.AIVocalisationChance -= 5; break; //@@MP (Release 7-6)
                            case GameOptions.IDs.GAME_CITY_SIZE: s_Options.CitySize -= 1; break;
                            case GameOptions.IDs.GAME_MAX_ANIMALS: --s_Options.MaxAnimals; break; //@@MP (Release 7-3)
                            case GameOptions.IDs.GAME_SIMULATE_DISTRICTS:
                                if (s_Options.SimulateDistricts != GameOptions.SimRatio.OFF)
                                    s_Options.SimulateDistricts = (GameOptions.SimRatio)(s_Options.SimulateDistricts - 1);
                                break;
                            case GameOptions.IDs.GAME_TURNS_SIM_CAP: //@@MP (Release 7-3)
                                if (s_Options.SimTurnsCap != GameOptions.SimCap._FIRST)
                                    s_Options.SimTurnsCap = (GameOptions.SimCap)(s_Options.SimTurnsCap - 1);
                                break;
                            case GameOptions.IDs.GAME_SIMULATE_SLEEP: s_Options.SimulateWhenSleeping = !s_Options.SimulateWhenSleeping; break;
                            case GameOptions.IDs.GAME_SIM_THREAD: s_Options.SimThread = !s_Options.SimThread; break;
                            //case GameOptions.IDs.GAME_REINCARNATE_AS_RAT: s_Options.CanReincarnateAsRat = !s_Options.CanReincarnateAsRat; break; //@@MP (Release 5-7)
                            //case GameOptions.IDs.GAME_REINCARNATE_TO_SEWERS: s_Options.CanReincarnateToSewers = !s_Options.CanReincarnateToSewers; break; //@@MP (Release 5-7)
                            //case GameOptions.IDs.GAME_REINC_LIVING_RESTRICTED: s_Options.IsLivingReincRestricted = !s_Options.IsLivingReincRestricted; break; //@@MP (Release 5-7)
                            case GameOptions.IDs.GAME_PERMADEATH: s_Options.IsPermadeathOn = !s_Options.IsPermadeathOn; break;
                            case GameOptions.IDs.GAME_DEATH_SCREENSHOT: s_Options.IsDeathScreenshotOn = !s_Options.IsDeathScreenshotOn; break;
                            case GameOptions.IDs.GAME_DAYS_BEFORE_ITEM_DESPAWNS: --s_Options.DaysBeforeDiscardedItemDespawns; break; //@@MP (Release 7-6)
                            case GameOptions.IDs.GAME_REDUCED_MAPOBJECT_LIGHTING: s_Options.ReducedMapObjectLighting = !s_Options.ReducedMapObjectLighting; break; //@@MP (Release 7-6)
                            case GameOptions.IDs.GAME_WORLD_DECAY: s_Options.IsWorldDecayOn = !s_Options.IsWorldDecayOn; break; //@@MP (Release 7-6)
                            case GameOptions.IDs.GAME_DAYS_BEFORE_WORLD_DECAYS: --s_Options.DaysBeforeWorldDecays; break; //@@MP (Release 7-6)
                        }
                        break;
                    case Keys.Right:
                        switch ((GameOptions.IDs)list[selected])
                        {
                            case GameOptions.IDs.CONFIG_WINDOW:
                                switch (SetupConfig.Window) {
                                    case SetupConfig.eWindow.WINDOW_FULLSCREEN: SetupConfig.Window = SetupConfig.eWindow.WINDOW_WINDOWED; break;
                                    case SetupConfig.eWindow.WINDOW_WINDOWED: SetupConfig.Window = SetupConfig.eWindow.WINDOW_FULLSCREEN; break;
                                }
                                break;
                            case GameOptions.IDs.CONFIG_WRITE_LOG_TO_FILE: SetupConfig.WriteLogToFile = !SetupConfig.WriteLogToFile; break;                            
                            case GameOptions.IDs.GAME_DISTRICT_SIZE: s_Options.DistrictSize += 5; break;
                            case GameOptions.IDs.UI_MUSIC: s_Options.PlayMusic = !s_Options.PlayMusic; break;
                            case GameOptions.IDs.UI_MUSIC_VOLUME: s_Options.MusicVolume += 5; break;
                            case GameOptions.IDs.UI_SFXS: s_Options.PlaySFXs = !s_Options.PlaySFXs; break; //@@MP (Release 2)
                            case GameOptions.IDs.UI_SFXS_VOLUME: s_Options.SFXVolume += 5; OptionsMenuAudioAdjustment((GameOptions.IDs)list[selected]); break; //@@MP - added (Release 2), added preview of volume (Release 7-3)
                            case GameOptions.IDs.UI_AMBIENTSFXS: s_Options.PlayAmbientSFXs = !s_Options.PlayAmbientSFXs; break; //@@MP (Release 6-1)
                            case GameOptions.IDs.UI_AMBIENTSFXS_VOLUME: s_Options.AmbientSFXVolume += 5; break; //@@MP (Release 6-1)
                            case GameOptions.IDs.UI_ANIM_DELAY: s_Options.IsAnimDelayOn = !s_Options.IsAnimDelayOn; break;
                            case GameOptions.IDs.UI_SHOW_MINIMAP: s_Options.IsMinimapOn = !s_Options.IsMinimapOn; break;
                            case GameOptions.IDs.UI_ADVISOR: s_Options.IsAdvisorEnabled = !s_Options.IsAdvisorEnabled; break;
                            case GameOptions.IDs.UI_COMBAT_ASSISTANT: s_Options.IsCombatAssistantOn = !s_Options.IsCombatAssistantOn; break;
                            case GameOptions.IDs.UI_SHOW_TARGETS: s_Options.ShowTargets = !s_Options.ShowTargets; break;
                            case GameOptions.IDs.UI_SHOW_PLAYER_TARGETS: s_Options.ShowPlayerTargets = !s_Options.ShowPlayerTargets; break;
                            case GameOptions.IDs.UI_AUTOSAVE: s_Options.Autosaving = !s_Options.Autosaving; break; //@@MP (Release 6-1)
                            case GameOptions.IDs.UI_AI_VOCALISATION_CHANCE: s_Options.AIVocalisationChance += 5; break; //@@MP (Release 7-6)
                            case GameOptions.IDs.GAME_CITY_SIZE: s_Options.CitySize += 1; break;
                            case GameOptions.IDs.GAME_MAX_ANIMALS: ++s_Options.MaxAnimals; break; //@@MP (Release 7-3)
                            case GameOptions.IDs.GAME_SIMULATE_DISTRICTS:
                                if (s_Options.SimulateDistricts != GameOptions.SimRatio.FULL)
                                    s_Options.SimulateDistricts = (GameOptions.SimRatio)(s_Options.SimulateDistricts + 1);
                                break;
                            case GameOptions.IDs.GAME_TURNS_SIM_CAP: //@@MP (Release 7-3)
                                if (s_Options.SimTurnsCap != GameOptions.SimCap.MAX)
                                    s_Options.SimTurnsCap = (GameOptions.SimCap)(s_Options.SimTurnsCap + 1);
                                break;
                            case GameOptions.IDs.GAME_SIMULATE_SLEEP: s_Options.SimulateWhenSleeping = !s_Options.SimulateWhenSleeping; break;
                            case GameOptions.IDs.GAME_SIM_THREAD: s_Options.SimThread = !s_Options.SimThread; break;
                            //case GameOptions.IDs.GAME_REINCARNATE_AS_RAT: s_Options.CanReincarnateAsRat = !s_Options.CanReincarnateAsRat; break; //@@MP (Release 5-7)
                            //case GameOptions.IDs.GAME_REINCARNATE_TO_SEWERS: s_Options.CanReincarnateToSewers = !s_Options.CanReincarnateToSewers; break; //@@MP (Release 5-7)
                            //case GameOptions.IDs.GAME_REINC_LIVING_RESTRICTED: s_Options.IsLivingReincRestricted = !s_Options.IsLivingReincRestricted; break; //@@MP (Release 5-7)
                            case GameOptions.IDs.GAME_PERMADEATH: s_Options.IsPermadeathOn = !s_Options.IsPermadeathOn; break;
                            case GameOptions.IDs.GAME_DEATH_SCREENSHOT: s_Options.IsDeathScreenshotOn = !s_Options.IsDeathScreenshotOn; break;
                            case GameOptions.IDs.GAME_DAYS_BEFORE_ITEM_DESPAWNS: ++s_Options.DaysBeforeDiscardedItemDespawns; break; //@@MP (Release 7-6)
                            case GameOptions.IDs.GAME_REDUCED_MAPOBJECT_LIGHTING: s_Options.ReducedMapObjectLighting = !s_Options.ReducedMapObjectLighting; break; //@@MP (Release 7-6)
                            case GameOptions.IDs.GAME_WORLD_DECAY: s_Options.IsWorldDecayOn = !s_Options.IsWorldDecayOn; break; //@@MP (Release 7-6)
                            case GameOptions.IDs.GAME_DAYS_BEFORE_WORLD_DECAYS: ++s_Options.DaysBeforeWorldDecays; break; //@@MP (Release 7-6)
                        }
                        break;
                }

                // force some options combinations.
                if (s_Options.SimThread)
                    s_Options.SimulateWhenSleeping = false;
                // apply options.
                ApplyOptions(); //@@MP - unused parameter (Release 5-7)

            }
            while (loop);

            // save.
            SaveOptions();
            SetupConfig.Save();
        }

        void HandleRedefineKeys()
        {
            bool loop = true;
            int selected = 0;
            bool conflict = false;
            do
            {
                // check for conflict.
                conflict = s_KeyBindings.CheckForConflict();

                // draw
                string[] menuEntries = new string[]
                {
                    "Move N",
                    "Move NE",
                    "Move E",
                    "Move SE",
                    "Move S",
                    "Move SW",
                    "Move W",
                    "Move NW",
                    "Wait",
                    "Wait 1 hour",
                    "Break",
                    "Build Mode",
                    "Bury Corpse", //@MP (Release 7-6)
                    "City Info",
                    "Close",
                    "Cook Food", //@MP (Release 7-6)
                    "Make a fire", //@MP (Release 7-6)
                    "Destroy Item", //@MP (Release 7-6)
                    "Eat Corpse", //@MP - was missing from vanilla (Release 7-6)
                    "Fire",
                    "Give",
                    "Help",
                    "Negotiate Trade",
                    "Item 1 slot",
                    "Item 2 slot",
                    "Item 3 slot",
                    "Item 4 slot",
                    "Item 5 slot",
                    "Item 6 slot",
                    "Item 7 slot",
                    "Item 8 slot",
                    "Item 9 slot",
                    "Item 10 slot",
                    "Take Lead Of",
                    "Inspection Mode", //@MP - was missing from original R7-1 release (Release 7-6)
                    "Mark Enemies",
                    "Messages Log",
                    "Order",
                    "Pull",  // alpha10
                    "Push",
                    "Revive Corpse", //@MP - was missing from vanilla (Release 7-6)
                    "Run",
                    "Shout",
                    "Sleep",
                    "Swap inventory", //@@MP (Release 8-2)
                    "Switch Place",
                    "Unload Ammo", //@MP (Release 7-6)
                    "Use Exit",
                    "Use Spray",
                };
                const int O_MOVE_N = 0;
                const int O_MOVE_NE = 1;
                const int O_MOVE_E = 2;
                const int O_MOVE_SE = 3;
                const int O_MOVE_S = 4;
                const int O_MOVE_SW = 5;
                const int O_MOVE_W = 6;
                const int O_MOVE_NW = 7;
                const int O_WAIT = 8;
                const int O_WAIT_LONG = 9;
                const int O_BREAK = 10;
                const int O_BUILD_MODE = 11; //@MP - combined barricade, build small and build large fortications (Release 6-6)
                const int O_BURY_CORPSE = 12;
                const int O_CITYINFO = 13;
                const int O_CLOSE = 14;
                const int O_COOK_FOOD = 15;
                const int O_MAKE_A_FIRE = 16;
                const int O_DESTROY_ITEM = 17;
                const int O_EAT_CORPSE = 18;
                const int O_FIRE = 19;
                const int O_GIVE = 20;
                const int O_HELP = 21;
                const int O_INIT_TRADE = 22; //negotiate
                const int O_ITEM_1 = 23;
                const int O_ITEM_2 = 24;
                const int O_ITEM_3 = 25;
                const int O_ITEM_4 = 26;
                const int O_ITEM_5 = 27;
                const int O_ITEM_6 = 28;
                const int O_ITEM_7 = 29;
                const int O_ITEM_8 = 30;
                const int O_ITEM_9 = 31;
                const int O_ITEM_10 = 32;
                const int O_LEAD = 33;
                const int O_INSPECTION_MODE = 34; //@@MP (Release 7-1), shifted all down 1 below in alpha 10 (was 50)
                const int O_MARKENEMY = 35;
                const int O_LOG = 36;
                const int O_ORDER = 37;
                const int O_PULL = 38;  // alpha10 inserted and shifted all below
                const int O_PUSH = 39;
                const int O_REVIVE_CORPSE = 40;
                const int O_RUN = 41;
                const int O_SHOUT = 42;
                const int O_SLEEP = 43;
                const int o_SWAP_INVENTORY = 44;
                const int O_SWITCH = 45;
                const int O_UNLOAD_AMMO = 46;
                const int O_USE_EXIT = 47;
                const int O_USE_SPRAY = 48;
                //MP: 50 is the magic number. any more than that and the list doesn't fit in the Redefine Keys menu
                string[] values = new string[]
                {
                    s_KeyBindings.GetFriendlyFormat(PlayerCommand.MOVE_N).ToString(),
                    s_KeyBindings.GetFriendlyFormat(PlayerCommand.MOVE_NE).ToString(),
                    s_KeyBindings.GetFriendlyFormat(PlayerCommand.MOVE_E).ToString(),
                    s_KeyBindings.GetFriendlyFormat(PlayerCommand.MOVE_SE).ToString(),
                    s_KeyBindings.GetFriendlyFormat(PlayerCommand.MOVE_S).ToString(),
                    s_KeyBindings.GetFriendlyFormat(PlayerCommand.MOVE_SW).ToString(),
                    s_KeyBindings.GetFriendlyFormat(PlayerCommand.MOVE_W).ToString(),
                    s_KeyBindings.GetFriendlyFormat(PlayerCommand.MOVE_NW).ToString(),
                    s_KeyBindings.GetFriendlyFormat(PlayerCommand.WAIT_OR_SELF).ToString(),
                    s_KeyBindings.GetFriendlyFormat(PlayerCommand.WAIT_LONG).ToString(),
                    s_KeyBindings.GetFriendlyFormat(PlayerCommand.BREAK_MODE).ToString(),
                    s_KeyBindings.GetFriendlyFormat(PlayerCommand.BUILD_MODE).ToString(),
                    s_KeyBindings.GetFriendlyFormat(PlayerCommand.BURY_CORPSE).ToString(),
                    s_KeyBindings.GetFriendlyFormat(PlayerCommand.CITY_INFO).ToString(),
                    s_KeyBindings.GetFriendlyFormat(PlayerCommand.CLOSE_DOOR).ToString(),
                    s_KeyBindings.GetFriendlyFormat(PlayerCommand.COOK_FOOD).ToString(),
                    s_KeyBindings.GetFriendlyFormat(PlayerCommand.MAKE_COOKING_FIRE).ToString(),
                    s_KeyBindings.GetFriendlyFormat(PlayerCommand.DESTROY_ITEM).ToString(),
                    s_KeyBindings.GetFriendlyFormat(PlayerCommand.EAT_CORPSE).ToString(),
                    s_KeyBindings.GetFriendlyFormat(PlayerCommand.FIRE_MODE).ToString(),
                    s_KeyBindings.GetFriendlyFormat(PlayerCommand.GIVE_ITEM).ToString(),
                    s_KeyBindings.GetFriendlyFormat(PlayerCommand.HELP_MODE).ToString(),
                    s_KeyBindings.GetFriendlyFormat(PlayerCommand.NEGOTIATE_TRADE).ToString(),
                    s_KeyBindings.GetFriendlyFormat(PlayerCommand.ITEM_SLOT_0).ToString(),
                    s_KeyBindings.GetFriendlyFormat(PlayerCommand.ITEM_SLOT_1).ToString(),
                    s_KeyBindings.GetFriendlyFormat(PlayerCommand.ITEM_SLOT_2).ToString(),
                    s_KeyBindings.GetFriendlyFormat(PlayerCommand.ITEM_SLOT_3).ToString(),
                    s_KeyBindings.GetFriendlyFormat(PlayerCommand.ITEM_SLOT_4).ToString(),
                    s_KeyBindings.GetFriendlyFormat(PlayerCommand.ITEM_SLOT_5).ToString(),
                    s_KeyBindings.GetFriendlyFormat(PlayerCommand.ITEM_SLOT_6).ToString(),
                    s_KeyBindings.GetFriendlyFormat(PlayerCommand.ITEM_SLOT_7).ToString(),
                    s_KeyBindings.GetFriendlyFormat(PlayerCommand.ITEM_SLOT_8).ToString(),
                    s_KeyBindings.GetFriendlyFormat(PlayerCommand.ITEM_SLOT_9).ToString(),
                    s_KeyBindings.GetFriendlyFormat(PlayerCommand.LEAD_MODE).ToString(),
                    s_KeyBindings.GetFriendlyFormat(PlayerCommand.INSPECTION_MODE).ToString(),
                    s_KeyBindings.GetFriendlyFormat(PlayerCommand.MARK_ENEMIES_MODE).ToString(),
                    s_KeyBindings.GetFriendlyFormat(PlayerCommand.MESSAGE_LOG).ToString(),
                    s_KeyBindings.GetFriendlyFormat(PlayerCommand.ORDER_MODE).ToString(),
                    s_KeyBindings.GetFriendlyFormat(PlayerCommand.PULL_MODE).ToString(), // alpha10
                    s_KeyBindings.GetFriendlyFormat(PlayerCommand.PUSH_MODE).ToString(),
                    s_KeyBindings.GetFriendlyFormat(PlayerCommand.REVIVE_CORPSE).ToString(),
                    s_KeyBindings.GetFriendlyFormat(PlayerCommand.RUN_TOGGLE).ToString(),
                    s_KeyBindings.GetFriendlyFormat(PlayerCommand.SHOUT).ToString(),
                    s_KeyBindings.GetFriendlyFormat(PlayerCommand.SLEEP).ToString(),
                    s_KeyBindings.GetFriendlyFormat(PlayerCommand.SWAP_INVENTORY).ToString(),
                    s_KeyBindings.GetFriendlyFormat(PlayerCommand.SWITCH_PLACE).ToString(),
                    s_KeyBindings.GetFriendlyFormat(PlayerCommand.UNLOAD_AMMO).ToString(),
                    s_KeyBindings.GetFriendlyFormat(PlayerCommand.USE_EXIT).ToString(),
                    s_KeyBindings.GetFriendlyFormat(PlayerCommand.USE_SPRAY).ToString(),
                };

                int gx, gy;
                gx = gy = 0;
                m_UI.UI_Clear(Color.Black);
                DrawHeader(0);
                gy += BOLD_LINE_SPACING;
                m_UI.UI_DrawStringBold(Color.Yellow, "Redefine keys", 0, gy);
                gy += BOLD_LINE_SPACING;
                DrawMenuOrOptions(selected, Color.White, menuEntries, Color.LightGreen, values, gx, ref gy);
                if (conflict)
                {
                    m_UI.UI_DrawStringBold(Color.Red, "Conflicting keys. Please redefine the keys so the commands don't overlap.", gx, gy);
                    gy += BOLD_LINE_SPACING;
                }
                DrawFootnote(Color.White, "cursor to move, ENTER to rebind a key, ESC to save and leave");
                m_UI.UI_Repaint();

                // handle
                // get menu action.
                KeyEventArgs key = m_UI.UI_WaitKey();
                switch (key.KeyCode)
                {
                    case Keys.Up:       // move up
                        if (selected > 0) --selected;
                        else selected = menuEntries.Length - 1;
                        break;
                    case Keys.Down:     // move down
                        selected = (selected + 1) % menuEntries.Length;
                        break;

                    case Keys.Escape:   // leave.
                        if (!conflict)
                        {
                            loop = false;
                        }
                        break;

                    case Keys.Enter: // rebind
                        // say.
                        m_UI.UI_DrawStringBold(Color.Yellow, String.Format("rebinding {0}, press the new key.", menuEntries[selected]), gx, gy);
                        m_UI.UI_Repaint();

                        // read new key.
                        bool loopNewKey = true;
                        Keys newKeyData = Keys.None;
                        do
                        {
                            KeyEventArgs newKey = m_UI.UI_WaitKey();
                            // ignore Shift and Control alone.
                            if (newKey.KeyCode == Keys.ShiftKey || newKey.KeyCode == Keys.ControlKey)
                                continue;
                            // always ignore Alt.
                            if (newKey.Alt)
                                continue;
                            // done!
                            newKeyData = newKey.KeyData;
                            loopNewKey = false;
                        }
                        while (loopNewKey);

                        // get command.
                        PlayerCommand command;
                        switch (selected)
                        {
                            case O_MOVE_N: command = PlayerCommand.MOVE_N; break;
                            case O_MOVE_NE: command = PlayerCommand.MOVE_NE; break;
                            case O_MOVE_E: command = PlayerCommand.MOVE_E; break;
                            case O_MOVE_SE: command = PlayerCommand.MOVE_SE; break;
                            case O_MOVE_S: command = PlayerCommand.MOVE_S; break;
                            case O_MOVE_SW: command = PlayerCommand.MOVE_SW; break;
                            case O_MOVE_W: command = PlayerCommand.MOVE_W; break;
                            case O_MOVE_NW: command = PlayerCommand.MOVE_NW; break;
                            case O_WAIT: command = PlayerCommand.WAIT_OR_SELF; break;
                            case O_WAIT_LONG: command = PlayerCommand.WAIT_LONG; break;
                            case O_BREAK: command = PlayerCommand.BREAK_MODE; break;
                            case O_BUILD_MODE: command = PlayerCommand.BUILD_MODE; break;
                            case O_BURY_CORPSE: command = PlayerCommand.BURY_CORPSE; break;
                            case O_CITYINFO: command = PlayerCommand.CITY_INFO; break;
                            case O_CLOSE: command = PlayerCommand.CLOSE_DOOR; break;
                            case O_COOK_FOOD: command = PlayerCommand.COOK_FOOD; break;
                            case O_MAKE_A_FIRE: command = PlayerCommand.MAKE_COOKING_FIRE; break;
                            case O_DESTROY_ITEM: command = PlayerCommand.DESTROY_ITEM; break;
                            case O_EAT_CORPSE: command = PlayerCommand.EAT_CORPSE; break;
                            case O_FIRE: command = PlayerCommand.FIRE_MODE; break;
                            case O_GIVE: command = PlayerCommand.GIVE_ITEM; break;
                            case O_HELP: command = PlayerCommand.HELP_MODE; break;
                            case O_INIT_TRADE: command = PlayerCommand.NEGOTIATE_TRADE; break;
                            case O_ITEM_1: command = PlayerCommand.ITEM_SLOT_0; break;
                            case O_ITEM_2: command = PlayerCommand.ITEM_SLOT_1; break;
                            case O_ITEM_3: command = PlayerCommand.ITEM_SLOT_2; break;
                            case O_ITEM_4: command = PlayerCommand.ITEM_SLOT_3; break;
                            case O_ITEM_5: command = PlayerCommand.ITEM_SLOT_4; break;
                            case O_ITEM_6: command = PlayerCommand.ITEM_SLOT_5; break;
                            case O_ITEM_7: command = PlayerCommand.ITEM_SLOT_6; break;
                            case O_ITEM_8: command = PlayerCommand.ITEM_SLOT_7; break;
                            case O_ITEM_9: command = PlayerCommand.ITEM_SLOT_8; break;
                            case O_ITEM_10: command = PlayerCommand.ITEM_SLOT_9; break;
                            case O_LEAD: command = PlayerCommand.LEAD_MODE; break;
                            case O_INSPECTION_MODE: command = PlayerCommand.INSPECTION_MODE; break;
                            case O_MARKENEMY: command = PlayerCommand.MARK_ENEMIES_MODE; break;
                            case O_LOG: command = PlayerCommand.MESSAGE_LOG; break;
                            case O_ORDER: command = PlayerCommand.ORDER_MODE; break;
                            case O_PULL: command = PlayerCommand.PULL_MODE; break;  // alpha10
                            case O_PUSH: command = PlayerCommand.PUSH_MODE; break;
                            case O_REVIVE_CORPSE: command = PlayerCommand.REVIVE_CORPSE; break;
                            case O_RUN: command = PlayerCommand.RUN_TOGGLE; break;
                            case O_SHOUT: command = PlayerCommand.SHOUT; break;
                            case O_SLEEP: command = PlayerCommand.SLEEP; break;
                            case o_SWAP_INVENTORY: command = PlayerCommand.SWAP_INVENTORY; break;
                            case O_SWITCH: command = PlayerCommand.SWITCH_PLACE; break;
                            case O_UNLOAD_AMMO: command = PlayerCommand.UNLOAD_AMMO; break;
                            case O_USE_EXIT: command = PlayerCommand.USE_EXIT; break;
                            case O_USE_SPRAY: command = PlayerCommand.USE_SPRAY; break;
                            default:
                                throw new InvalidOperationException("unhandled selected");
                        }

                        // bind it.                      
                        s_KeyBindings.Set(command, newKeyData);

                        break;

                }
            }
            while (loop);

            // Save.
            SaveKeybindings();
        }

        void HandleAbout() //@@MP - was Credits (Release 7-6)
        {
            const int left = 0;
            const int right = 256;
            int gy = 0;

            // draw.
            m_UI.UI_Clear(Color.Black);
            DrawHeader(0);
            gy += BOLD_LINE_SPACING;
            m_UI.UI_DrawStringBold(Color.Yellow, "About the game", 0, gy);
            gy += 2 * BOLD_LINE_SPACING;
            m_UI.UI_DrawStringBold(Color.White, "Original programming, graphics & music by Jacques Ruiz (roguedjack)", 0, gy);
            gy += 2 * BOLD_LINE_SPACING;
            m_UI.UI_DrawStringBold(Color.White, "Programming", left, gy); m_UI.UI_DrawString(Color.White, "- C# NET 3.5, Microsoft Visual C# 2010 Express", right, gy);
            gy += BOLD_LINE_SPACING;
            m_UI.UI_DrawStringBold(Color.White, "Graphics softwares", left, gy); m_UI.UI_DrawString(Color.White, "- Inkscape, Paint.NET", right, gy);
            gy += BOLD_LINE_SPACING;
            m_UI.UI_DrawStringBold(Color.White, "Sound & Music softwares", left, gy); m_UI.UI_DrawString(Color.White, "- GuitarPro 6, Audacity", right, gy);
            gy += BOLD_LINE_SPACING;
            m_UI.UI_DrawStringBold(Color.White, "Sound samples", left, gy); m_UI.UI_DrawString(Color.White, @"- http://www.sound-fishing.net  http://www.soundsnap.com", right, gy);
            gy += BOLD_LINE_SPACING;
            m_UI.UI_DrawStringBold(Color.White, "Contact", 0, gy);
            /*gy += BOLD_LINE_SPACING;
            m_UI.UI_DrawString(Color.White, @"Email      : roguedjack@yahoo.fr", 0, gy);*/
            gy += BOLD_LINE_SPACING;
            m_UI.UI_DrawString(Color.White, @"Fans Forum : http://roguesurvivor.proboards.com", 0, gy);
            gy += BOLD_LINE_SPACING;
            m_UI.UI_DrawString(Color.White, @"Discord : discord.gg/PPGHpDr", 0, gy);
            gy += BOLD_LINE_SPACING;
            m_UI.UI_DrawString(Color.White, @"Original RS blog : http://roguesurvivor.blogspot.com", 0, gy);
            /*gy += BOLD_LINE_SPACING;
            m_UI.UI_DrawStringBold(Color.White, "Thanks to the players for their feedback and eagerness to die!", 0, gy);*/
            gy += 3 * BOLD_LINE_SPACING;
            m_UI.UI_DrawStringBold(Color.White, "'Still Alive' modifications", left, gy);
            gy += BOLD_LINE_SPACING;
            m_UI.UI_DrawString(Color.White, @"Programming", left, gy); m_UI.UI_DrawString(Color.White, @"- Mark Pryor (MP) (http://roguesurvivor.proboards.com/user/180)", right, gy);
            gy += BOLD_LINE_SPACING;
            m_UI.UI_DrawString(Color.White, @"Source", left, gy); m_UI.UI_DrawString(Color.White, @"- (https://gitlab.com/RogueSurvivor-StillAlive/)", right, gy);
            gy += 2 * BOLD_LINE_SPACING;
            m_UI.UI_DrawString(Color.White, @"Incorporates some of Deon's 'Deonapocalypse' tileset", 0, gy);
            gy += BOLD_LINE_SPACING;
            m_UI.UI_DrawString(Color.White, @"Grab the whole set for vanilla RS: http://roguesurvivor.proboards.com/thread/264/alpha-9-deonapocalypse", 0, gy);
            gy += 2 * BOLD_LINE_SPACING;
            m_UI.UI_DrawString(Color.White, @"Incorporates images from https://opengameart.org", 0, gy);
            gy += BOLD_LINE_SPACING;
            m_UI.UI_DrawString(Color.White, @"Incorporates sounds from https://freesound.org and https://pixabay.com", 0, gy);
            gy += BOLD_LINE_SPACING;
            m_UI.UI_DrawString(Color.White, @"For the full list of images and sounds please see the Credits menu or CREDITS.txt in the game directory", 0, gy);
            gy += 2 * BOLD_LINE_SPACING;
            m_UI.UI_DrawString(Color.White, @"Discuss the mod here: http://roguesurvivor.proboards.com/thread/377/", 0, gy);

            DrawFootnote(Color.White, "ESC to leave");
            m_UI.UI_Repaint();
            WaitEscape();
        }

        void HandleCredits() //@@MP - added (Release 7-6)
        {
            if (m_Credits == null)
            {
                m_UI.UI_Clear(Color.Black);
                int gy = 0;
                m_UI.UI_DrawStringBold(Color.Red, "Credits file not available (file missing?).", 0, gy);
                gy += BOLD_LINE_SPACING;
                DrawFootnote(Color.White, "press ENTER");
                m_UI.UI_Repaint();
                WaitEnter();
                return;
            }

            bool loop = true;
            List<string> lines = m_Credits.FormatedLines;
            do
            {
                // draw header.
                m_UI.UI_Clear(Color.Black);
                int gy = 0;
                DrawHeader(0);
                gy += BOLD_LINE_SPACING;
                m_UI.UI_DrawStringBold(Color.Yellow, "Credits", 0, gy);
                gy += BOLD_LINE_SPACING;
                m_UI.UI_DrawStringBold(Color.White, "---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+", 0, gy);
                gy += BOLD_LINE_SPACING;

                // draw credits.
                int iLine = m_CreditsLine;
                do
                {
                    // ignore commands
                    bool ignore = (lines[iLine] == "<SECTION>");

                    if (!ignore)
                    {
                        m_UI.UI_DrawStringBold(Color.LightGray, lines[iLine], 0, gy);
                        gy += BOLD_LINE_SPACING;
                    }
                    ++iLine;
                }
                while (iLine < lines.Count && gy < CANVAS_HEIGHT - 2 * BOLD_LINE_SPACING);

                // draw foot.
                m_UI.UI_DrawStringBold(Color.White, "---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+", 0, gy);
                gy += BOLD_LINE_SPACING;
                DrawFootnote(Color.White, "cursor and PgUp/PgDn to move, numbers to jump to section, ESC to leave");

                m_UI.UI_Repaint();

                // get command.
                KeyEventArgs key = m_UI.UI_WaitKey();
                int choice = KeyToChoiceNumber(key.KeyCode);

                if (choice >= 0)
                {
                    if (choice == 0)
                    {
                        m_CreditsLine = 0;
                    }
                    else
                    {
                        // jump to Nth section.
                        int prevLine = m_CreditsLine;
                        int sectionCount = 0;
                        m_CreditsLine = 0;
                        while (sectionCount < choice && m_CreditsLine < lines.Count)
                        {
                            if (lines[m_CreditsLine] == "<SECTION>")
                            {
                                ++sectionCount;
                            }
                            ++m_CreditsLine;
                        }

                        // if section not found, don't move.
                        if (m_CreditsLine >= lines.Count)
                        {
                            m_CreditsLine = prevLine;
                        }
                    }
                }
                else
                {
                    switch (key.KeyCode)
                    {
                        case Keys.Escape:
                            loop = false;
                            break;

                        case Keys.Up:
                            --m_CreditsLine;
                            break;
                        case Keys.Down:
                            ++m_CreditsLine;
                            break;
                        case Keys.PageUp:
                            m_CreditsLine -= TEXTFILE_LINES_PER_PAGE;
                            break;
                        case Keys.PageDown:
                            m_CreditsLine += TEXTFILE_LINES_PER_PAGE;
                            break;
                    }
                }

                if (m_CreditsLine < 0) m_CreditsLine = 0;
                if (m_CreditsLine + TEXTFILE_LINES_PER_PAGE >= lines.Count) m_CreditsLine = Math.Max(0, lines.Count - TEXTFILE_LINES_PER_PAGE);
            }
            while (loop);
        }

        /// <summary>
        /// Plays a track when cursor on one of the volume adjustment options. For choosing the level that suits you
        /// </summary>
        /// <param name="optionID">Only applies to long-running types ie music and ambients</param>
        void OptionsMenuAudioAdjustment(GameOptions.IDs optionID) //@@MP (Release 7-3)
        {
            switch ((GameOptions.IDs)optionID)
            {
                case GameOptions.IDs.UI_MUSIC_VOLUME:
                    m_AmbientSFXManager.Stop(GameAmbients.TEST_AMBIENT); //just in case
                    m_MusicManager.PauseAll(); //pause any music for the moment
                    m_AmbientSFXManager.PauseAll(); //pause any ambients for the moment
                    m_MusicManager.PlayIfNotAlreadyPlaying(GameMusics.TEST_MUSIC, AudioPriority.PRIORITY_EVENT, true);
                    break;
                case GameOptions.IDs.UI_AMBIENTSFXS_VOLUME:
                    m_MusicManager.Stop(GameMusics.TEST_MUSIC); //just in case
                    m_AmbientSFXManager.PauseAll(); //pause any ambients for the moment
                    m_MusicManager.PauseAll(); //pause any music for the moment
                    m_AmbientSFXManager.PlayIfNotAlreadyPlaying(GameAmbients.TEST_AMBIENT, AudioPriority.PRIORITY_EVENT, true);
                    break;
                case GameOptions.IDs.UI_SFXS_VOLUME:
                    m_AmbientSFXManager.Stop(GameAmbients.TEST_AMBIENT); //just in case
                    m_MusicManager.Stop(GameMusics.TEST_MUSIC); //just in case
                    m_AmbientSFXManager.PauseAll(); //pause any ambients for the moment
                    m_MusicManager.PauseAll(); //pause any music for the moment
                    m_SFXManager.Play(GameSounds.MELEE_ATTACK_MISS_PLAYER, AudioPriority.PRIORITY_EVENT);
                    break;
                case GameOptions.IDs.UI_MUSIC:
                case GameOptions.IDs.UI_AMBIENTSFXS:
                case GameOptions.IDs.UI_SFXS:
                    m_MusicManager.Stop(GameMusics.TEST_MUSIC); //just in case
                    m_AmbientSFXManager.Stop(GameAmbients.TEST_AMBIENT); //just in case
                    m_MusicManager.PauseAll(); //pause any music for the moment
                    m_AmbientSFXManager.PauseAll(); //pause any ambients for the moment
                    break;
                default:
                    m_MusicManager.Stop(GameMusics.TEST_MUSIC);
                    m_AmbientSFXManager.Stop(GameAmbients.TEST_AMBIENT);
                    m_MusicManager.ResumeAll();
                    m_AmbientSFXManager.ResumeAll();
                    break;
            }
        }

        #region -Drawing headers & footnotes
        void DrawHeader(int y)
        {
            m_UI.UI_DrawStringBold(Color.Red, "ROGUE SURVIVOR: " + SetupConfig.GAME_VERSION, 0, y, Color.DarkRed);
        }

        void DrawFootnote(Color color, string text)
        {
            Color shadowColor = Color.FromArgb(color.A, color.R / 2, color.G / 2, color.B / 2);
            m_UI.UI_DrawStringBold(color, String.Format("<{0}>", text), 0, CANVAS_HEIGHT - BOLD_LINE_SPACING, shadowColor);
        }
        #endregion

        /// <summary>
        /// Menu helpers
        /// </summary>
        /// <param name="entries">choices text</param>
        /// <param name="values">(options values) can be null, array must be same length as choices</param>
        /// <param name="gx"></param>
        /// <param name="gy"></param>
        /// /// <param name="valuesOnNewLine">false: draw values on same line as entries; true: draw values on new lines</param> //alpha10
        /// <param param name="rightPadding">x padding to add when displaying values</param> //alpha10
        void DrawMenuOrOptions(int currentChoice, Color entriesColor, string[] entries, Color valuesColor, string[] values, int gx, ref int gy, bool valuesOnNewLine = false, int rightPadding = 256) //alpha10 added valuesOnNewLine
        {
            int right = gx + rightPadding;

            if (values != null && entries.Length != values.Length)
                throw new ArgumentException("values length!= choices length");

            // display.
            Color entriesShadowColor = Color.FromArgb(entriesColor.A, entriesColor.R / 2, entriesColor.G / 2, entriesColor.B / 2);
            for (int i = 0; i < entries.Length; i++)
            {
                string choiceStr;
                if (i == currentChoice)
                    choiceStr = String.Format("---> {0}", entries[i]);
                else
                    choiceStr = String.Format("     {0}", entries[i]);
                m_UI.UI_DrawStringBold(entriesColor, choiceStr, gx, gy, entriesShadowColor);

                if (values != null)
                {
                    string valueStr;
                    if (i == currentChoice && !valuesOnNewLine)
                        valueStr = String.Format("{0} <---", values[i]);
                    else
                        valueStr = values[i];

                    if (valuesOnNewLine)
                    {
                        gy += BOLD_LINE_SPACING;
                        m_UI.UI_DrawStringBold(valuesColor, valueStr, gx + right, gy);
                    }
                    else
                        m_UI.UI_DrawStringBold(valuesColor, valueStr, right, gy);
                }

                gy += BOLD_LINE_SPACING;
            }
        }

        void DrawGameTips(int gx, int gy) //@@MP (Release 6-6)
        {
            int iTip = m_Rules.Roll(0, GameTips.TIPS.Length);
            m_UI.UI_DrawStringBold(Color.LightPink, " TIP: " + GameTips.TIPS[iTip], gx, gy);
        }
        #endregion

        #region 1. CONTENT LOADING AND SAVING
        #region -SAVE GAMES
        void DoSaveGame(string saveName, bool autosave) //@@MP - added parameter for autosaves (Release 6-1)
        {
            StopSimThread(false);  // alpha10.1
            ClearMessages();
            if (autosave)
                AddMessage(new Message("AUTO-SAVING GAME, PLEASE WAIT...", m_Session.WorldTime.TurnCounter, Color.Yellow));
            else
                AddMessage(new Message("SAVING GAME, PLEASE WAIT...", m_Session.WorldTime.TurnCounter, Color.Yellow));
            RedrawPlayScreen();
            m_UI.UI_Repaint();

            // save session object.
            Session.Save(m_Session, saveName, Session.SaveFormat.FORMAT_BIN);

            // backup. replace previous last known-good save file   //@@MP (Release 7-5)
            // first delete the older one
            Session.Delete(GetUserSavesPath() + "backup.dat");
            // now duplicate the current save as the new backup
            Session.Save(m_Session, GetUserSavesPath() + "backup.dat", Session.SaveFormat.FORMAT_BIN);

            AddMessage(new Message("SAVING DONE.", m_Session.WorldTime.TurnCounter, Color.Yellow));
            RedrawPlayScreen();
            m_UI.UI_Repaint();
            StartSimThread();  // alpha10.1
        }

        void DoLoadGame(string saveName)
        {
            StopSimThread(false); // alpha10.1
            ClearMessages();
            AddMessage(new Message("LOADING GAME, PLEASE WAIT...", m_Session.WorldTime.TurnCounter, Color.Yellow));
            RedrawPlayScreen();
            m_UI.UI_Repaint();

            if (!LoadGame(saveName))
            {
                AddMessage(new Message("LOADING FAILED, NO GAME SAVED OR VERSION NOT COMPATIBLE.", m_Session.WorldTime.TurnCounter, Color.Red));
            }
            StartSimThread();  // alpha10.1
        }

        void DeleteSavedGame(string saveName)
        {
            // do it.
            if (Session.Delete(saveName))
            {
                // tell.
                AddMessage(new Message("PERMADEATH IS ENABLED : SAVE GAME DELETED!", m_Session.WorldTime.TurnCounter, Color.Red));
            }
        }

        bool LoadGame(string saveName)
        {
            // load session object.
            m_MusicManager.StopAll(); //@@MP (Release 3)
            m_AmbientSFXManager.StopAll(); //@@MP (Release 6-1)
            bool loaded = Session.Load(saveName, Session.SaveFormat.FORMAT_BIN);
            if (!loaded)
                return false;
            m_Session = Session.Get;
            m_Rules = new Rules(new DiceRoller(m_Session.Seed));

            RefreshPlayer();

            AddMessage(new Message("LOADING DONE.", m_Session.WorldTime.TurnCounter, Color.Yellow));
            AddMessage(new Message("Welcome back to Rogue Survivor!", m_Session.WorldTime.TurnCounter, Color.LightGreen));
            RedrawPlayScreen();
            m_UI.UI_Repaint();

            // Log ;/
            m_Session.Scoring.AddEvent(m_Session.WorldTime.TurnCounter, "<Loaded game>");

            return true;
        }
        #endregion

        void LoadManual()
        {
            m_UI.UI_Clear(Color.Black);
            int gy = 0;
            m_UI.UI_DrawStringBold(Color.White, "Loading game manual...", 0, 0);
            gy += BOLD_LINE_SPACING;
            m_UI.UI_Repaint();

            m_Manual = new TextFile();
            m_ManualLine = 0;
            if (!m_Manual.Load(GetUserManualFilePath()))
            {
                // error.
                m_UI.UI_DrawStringBold(Color.Red, "Error while loading the manual.", 0, gy);
                gy += BOLD_LINE_SPACING;
                m_UI.UI_DrawStringBold(Color.Red, "The manual won't be available ingame.", 0, gy);
                gy += BOLD_LINE_SPACING;
                m_UI.UI_Repaint();
                DrawFootnote(Color.White, "press ENTER");
                WaitEnter();

                // delete manual.
                m_Manual = null;
                return;
            }

            m_UI.UI_DrawStringBold(Color.White, "Parsing game manual...", 0, gy);
            gy += BOLD_LINE_SPACING;
            m_UI.UI_Repaint();
            m_Manual.FormatLines(TEXTFILE_CHARS_PER_LINE);

            m_UI.UI_Clear(Color.Black);
            m_UI.UI_DrawStringBold(Color.White, "Game manual... done!", 0, gy);
            m_UI.UI_Repaint();
        }

        void LoadCredits() //@@MP (Release 7-6)
        {
            m_UI.UI_Clear(Color.Black);
            int gy = 0;
            m_UI.UI_DrawStringBold(Color.White, "Loading game credits...", 0, 0);
            gy += BOLD_LINE_SPACING;
            m_UI.UI_Repaint();

            m_Credits = new TextFile();
            m_CreditsLine = 0;
            if (!m_Credits.Load(GetCreditsFilePath()))
            {
                // error.
                m_UI.UI_DrawStringBold(Color.Red, "Error while loading the credits file.", 0, gy);
                gy += BOLD_LINE_SPACING;
                m_UI.UI_DrawStringBold(Color.Red, "The credits list won't be available ingame.", 0, gy);
                gy += BOLD_LINE_SPACING;
                m_UI.UI_Repaint();
                DrawFootnote(Color.White, "press ENTER");
                WaitEnter();

                // delete credits.
                m_Credits = null;
                return;
            }

            m_UI.UI_DrawStringBold(Color.White, "Parsing credits file...", 0, gy);
            gy += BOLD_LINE_SPACING;
            m_UI.UI_Repaint();
            m_Credits.FormatLines(TEXTFILE_CHARS_PER_LINE);

            m_UI.UI_Clear(Color.Black);
            m_UI.UI_DrawStringBold(Color.White, "Credits file... done!", 0, gy);
            m_UI.UI_Repaint();
        }

        #region -GAME USER DATA PATHS
        void InitDirectories()
        {
            int gy = 0;
            m_UI.UI_Clear(Color.Black);
            m_UI.UI_DrawStringBold(Color.Yellow, "Checking user game directories...", 0, gy);
            gy += BOLD_LINE_SPACING;
            m_UI.UI_Repaint();

            ///////////////////////////////////////////
            // Create directories & check for RS Manual
            ///////////////////////////////////////////
            bool created = false;
            created |= CheckDirectory(GetUserBasePath(), "base user", ref gy);
            created |= CheckDirectory(GetUserConfigPath(), "config", ref gy);
            //created |= CheckDirectory(GetUserDocsPath(), "docs", ref gy);  //@@MP - unused now that we don't copy the manual there (Release 1)
            created |= CheckDirectory(GetUserGraveyardPath(), "graveyard", ref gy);
            created |= CheckDirectory(GetUserSavesPath(), "saves", ref gy);
            created |= CheckDirectory(GetUserScreenshotsPath(), "screenshots", ref gy);
            CheckCopyOfManual(); //@@MP - just check, don't count it towards created (Release 5-7)

            if (created)
            {
                m_UI.UI_DrawStringBold(Color.Yellow, "Directories created.", 0, gy);
                gy += BOLD_LINE_SPACING;
                //m_UI.UI_DrawStringBold(Color.Yellow, "Your save, high scores, and screenshots are in the game's directory:", 0, gy); //@@MP - moved to user data (Release 5-1)
                m_UI.UI_DrawStringBold(Color.Yellow, "Your save, high scores, and screenshots are in your AppData directory:", 0, gy);
                gy += BOLD_LINE_SPACING;
                m_UI.UI_DrawString(Color.LightGreen, GetUserBasePath(), 0, gy);
                gy += BOLD_LINE_SPACING;
                /*m_UI.UI_DrawStringBold(Color.Yellow, "When you uninstall the game you can delete this directory.", 0, gy); //@@MP - this stopped being relevant when RJ gave up packaging as an installer (Release 1)
                gy += BOLD_LINE_SPACING;*/
                DrawFootnote(Color.White, "press ENTER");
                m_UI.UI_Repaint();
                WaitEnter();
            }
        }

        public static string GetUserBasePath()
        {
            return SetupConfig.DirPath;
            /*
            string myDocs = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);
            return myDocs + @"\Rogue Survivor\" + SetupConfig.GAME_VERSION + @"\";
             */
        }

        public static string GetUserSavesPath()
        {
            return GetUserBasePath() + @"Saves\";
        }

        public static string GetUserSave()
        {
            return GetUserSavesPath() + "save.dat";
        }

        public static string GetUserGraveyardPath()
        {
            return GetUserBasePath() + @"Graveyard\";
        }

        /// <summary>
        /// "grave_[id]"
        /// </summary>
        public static string GetUserNewGraveyardName() //@@MP - made static (Release 5-7)
        {
            string name;
            int i = 0;
            bool isFreeID = false;
            do
            {
                name = String.Format("grave_{0:D3}", i);
                isFreeID = !File.Exists(GraveFilePath(name));
                ++i;
            }
            while (!isFreeID);

            return name;
        }

        public static string GraveFilePath(string graveName)
        {
            return GetUserGraveyardPath() + graveName + ".txt";
        }

        public static string GetUserConfigPath()
        {
            return GetUserBasePath() + @"Config\";
        }

        public static string GetUserOptionsFilePath()
        {
            return GetUserConfigPath() + @"options.dat";
        }

        public static string GetUserScreenshotsPath()
        {
            return GetUserBasePath() + @"Screenshots\";
        }

        /// <summary>
        /// "screenshot_[id]"
        /// </summary>
        public string GetUserNewScreenshotName()
        {
            string name;
            int i = 0;
            bool isFreeID = false;
            do
            {
                name = String.Format("screenshot_{0:D3}", i);
                isFreeID = !File.Exists(ScreenshotFilePath(name));
                ++i;
            }
            while (!isFreeID);

            return name;
        }

        public string ScreenshotFilePath(string shotname)
        {
            return GetUserScreenshotsPath() + shotname + "." + m_UI.UI_ScreenshotExtension();
        }

        static bool CreateDirectory(string path) //@@MP - made static (Release 5-7)
        {
            if (!Directory.Exists(path))
            {
                Directory.CreateDirectory(path);
                return true;
            }
            else
                return false;
        }

        bool CheckDirectory(string path, string description, ref int gy)
        {
            m_UI.UI_DrawString(Color.White, String.Format("{0} : {1}...", description, path), 0, gy);
            gy += BOLD_LINE_SPACING;
            m_UI.UI_Repaint();
            bool created = CreateDirectory(path);
            m_UI.UI_DrawString(Color.White, "ok.", 0, gy);
            gy += BOLD_LINE_SPACING;
            m_UI.UI_Repaint();

            return created;
        }

        static bool CheckCopyOfManual() //@@MP - made static (Release 5-7)
        {
            string filename = GetUserManualFilePath();
            Logger.WriteLine(Logger.Stage.INIT_MAIN, "checking for manual...");

            if (File.Exists(filename))
            {
                Logger.WriteLine(Logger.Stage.INIT_MAIN, "found manual!");
            }
            else
            {
                Logger.WriteLine(Logger.Stage.INIT_MAIN, "couldn't find manual!");
                throw new InvalidOperationException(@"Cannot find <gamedir>\" + filename);
            }

            Logger.WriteLine(Logger.Stage.INIT_MAIN, "checking for manual... done!");
            return true;
        }

        static string GetUserManualFilePath() //@@MP - made static (Release 5-7)
        {
            return "MANUAL.txt";
        }

        static string GetCreditsFilePath() //@@MP - added (Release 7-6)
        {
            return "CREDITS.txt";
        }

        static string GetUserHiScorePath() //@@MP - made static (Release 5-7)
        {
            return GetUserSavesPath();
        }

        static string GetUserHiScoreFilePath() //@@MP - made static (Release 5-7)
        {
            return GetUserHiScorePath() + "hiscores.dat";
        }

        static string GetUserHiScoreTextFilePath() //@@MP - made static (Release 5-7)
        {
            return GetUserHiScorePath() + "hiscores.txt";
        }
        #endregion

        #region -GAME OPTIONS
        static void LoadOptions() //@@MP - made static (Release 5-7)
        {
            // load.
            s_Options = GameOptions.Load(GetUserOptionsFilePath());
        }

        static void SaveOptions() //@@MP - made static (Release 5-7)
        {
            // save
            GameOptions.Save(s_Options, GetUserOptionsFilePath());
        }

        void ApplyOptions() //@@MP - unused parameter (Release 5-7)
        {
            m_MusicManager.IsAudioEnabled = Options.PlayMusic;
            m_MusicManager.Volume = Options.MusicVolume;
            //@@MP (Release 2)
            m_SFXManager.IsAudioEnabled = Options.PlaySFXs;
            m_SFXManager.Volume = Options.SFXVolume;
            //@@MP (Release 6-1)
            m_AmbientSFXManager.IsAudioEnabled = Options.PlayAmbientSFXs;
            m_AmbientSFXManager.Volume = Options.AmbientSFXVolume;

            // update difficulty.
            if (m_Session != null && m_Session.Scoring != null)
            {
                m_Session.Scoring.Side = (m_Player == null || !m_Player.Model.Abilities.IsUndead) ? DifficultySide.FOR_SURVIVOR : DifficultySide.FOR_UNDEAD;
                m_Session.Scoring.DifficultyRating = Scoring.ComputeDifficultyRating(s_Options, m_Session.Scoring.Side, m_Session.Scoring.ReincarnationNumber, m_Session.GameMode);
            }

            if (!m_MusicManager.IsAudioEnabled)
                m_MusicManager.StopAll();

            if (!m_AmbientSFXManager.IsAudioEnabled)//@@MP (Release 6-1)
                m_AmbientSFXManager.StopAll();
        }
        #endregion

        #region -KEYBINDINGS
        void LoadKeybindings()
        {
            m_UI.UI_Clear(Color.Black);
            m_UI.UI_DrawStringBold(Color.White, "Loading keybindings...", 0, 0);
            m_UI.UI_Repaint();

            s_KeyBindings = Keybindings.Load(GetUserConfigPath() + "keys.dat");

            m_UI.UI_Clear(Color.Black);
            m_UI.UI_DrawStringBold(Color.White, "Loading keybindings... done!", 0, 0);
            m_UI.UI_Repaint();

        }

        void SaveKeybindings()
        {
            m_UI.UI_Clear(Color.Black);
            m_UI.UI_DrawStringBold(Color.White, "Saving keybindings...", 0, 0);
            m_UI.UI_Repaint();

            Keybindings.Save(s_KeyBindings, GetUserConfigPath() + "keys.dat");

            m_UI.UI_Clear(Color.Black);
            m_UI.UI_DrawStringBold(Color.White, "Saving keybindings... done!", 0, 0);
            m_UI.UI_Repaint();
        }
        #endregion

        #region -HINTS
        void LoadHints()
        {
            m_UI.UI_Clear(Color.Black);
            m_UI.UI_DrawStringBold(Color.White, "Loading hints...", 0, 0);
            m_UI.UI_Repaint();

            s_Hints = GameHintsStatus.Load(GetUserConfigPath() + "hints.dat");

            m_UI.UI_Clear(Color.Black);
            m_UI.UI_DrawStringBold(Color.White, "Loading hints... done!", 0, 0);
            m_UI.UI_Repaint();
        }

        static void SaveHints() //@@MP - made static (Release 5-7)
        {
            GameHintsStatus.Save(s_Hints, GetUserConfigPath() + "hints.dat");
        }
        #endregion

        #region -Data files
        void LoadDataActors()
        {
            Logger.WriteLine(Logger.Stage.INIT_MAIN, "loading Actors data file...");
            m_GameActors.LoadFromCSV(m_UI, @"Resources\Data\Actors.csv");
            Logger.WriteLine(Logger.Stage.INIT_MAIN, "loading Actors data file... done!");
        }

        void LoadDataItems()
        {
            // load all data.
            Logger.WriteLine(Logger.Stage.INIT_MAIN, "loading Items data files...");
            m_GameItems.LoadMedicineFromCSV(m_UI, @"Resources\Data\Items_Medicine.csv");
            m_GameItems.LoadFoodFromCSV(m_UI, @"Resources\Data\Items_Food.csv");
            m_GameItems.LoadMeleeWeaponsFromCSV(m_UI, @"Resources\Data\Items_MeleeWeapons.csv");
            m_GameItems.LoadRangedWeaponsFromCSV(m_UI, @"Resources\Data\Items_RangedWeapons.csv");
            m_GameItems.LoadExplosivesFromCSV(m_UI, @"Resources\Data\Items_Explosives.csv");
            m_GameItems.LoadBarricadingMaterialFromCSV(m_UI, @"Resources\Data\Items_Barricading.csv");
            m_GameItems.LoadArmorsFromCSV(m_UI, @"Resources\Data\Items_Armors.csv");
            m_GameItems.LoadTrackersFromCSV(m_UI, @"Resources\Data\Items_Trackers.csv");
            m_GameItems.LoadSpraypaintsFromCSV(m_UI, @"Resources\Data\Items_Spraypaints.csv");
            m_GameItems.LoadLightsFromCSV(m_UI, @"Resources\Data\Items_Lights.csv");
            m_GameItems.LoadScentspraysFromCSV(m_UI, @"Resources\Data\Items_Scentsprays.csv");
            m_GameItems.LoadTrapsFromCSV(m_UI, @"Resources\Data\Items_Traps.csv");
            m_GameItems.LoadEntertainmentFromCSV(m_UI, @"Resources\Data\Items_Entertainment.csv");
            m_GameItems.LoadBackpacksFromCSV(m_UI, @"Resources\Data\Items_Backpacks.csv");
            Logger.WriteLine(Logger.Stage.INIT_MAIN, "loading Items data files... done!");

            // create.
            Logger.WriteLine(Logger.Stage.INIT_MAIN, "loading Items models...");
            m_GameItems.CreateModels();
            Logger.WriteLine(Logger.Stage.INIT_MAIN, "loading Items models... done!");
        }

        void LoadDataSkills()
        {
            Logger.WriteLine(Logger.Stage.INIT_MAIN, "loading Skills data file...");
            Skills.LoadSkillsFromCSV(m_UI, @"Resources\Data\Skills.csv");
            Logger.WriteLine(Logger.Stage.INIT_MAIN, "loading Skills data file... done!");
        }

        #endregion
        #endregion

        #region 2. NEW GAME
        #region -CHARACTER CREATION
        bool HandleNewCharacter(out string suppliedName) //@@MP - added parameter for user to supply a name (Release 5-7)
        {
            suppliedName = ""; //@@MP - added parameter for user to supply a name (Release 5-7)
            DiceRoller roller = new DiceRoller();

            /////////////////
            // Reset session
            /////////////////
            m_Session.Reset();

            ///////////////
            // Game Mode //
            ///////////////
            if (!HandleNewGameMode())
                return false;

            ////////////////////////
            // Choose living/undead 
            ////////////////////////
            bool isUndead;
            if (!HandleNewCharacterRace(roller, out isUndead))
                return false;
            m_CharGen.IsUndead = isUndead;

            /////////////////////////////
            // Choose gender/undead type
            /////////////////////////////
            if (isUndead)
            {
                GameActors.IDs modelID;
                if (!HandleNewCharacterUndeadType(roller, out modelID))
                    return false;
                m_CharGen.UndeadModel = modelID;
            }
            else
            {
                bool isMale;
                if (!HandleNewCharacterGender(roller, out isMale))
                    return false;
                m_CharGen.IsMale = isMale;
            }

            /////////////////////////////
            // Choose skill (living only)
            /////////////////////////////
            if (!isUndead)
            {
                Skills.IDs skID;
                if (!HandleNewCharacterSkill(roller, out skID))
                    return false;
                m_CharGen.StartingSkill = skID;
                // scoring : starting skill.
                m_Session.Scoring.StartingSkill = skID;
            }

            /////////////////////////////
            // Choose name (living only)  //@@MP (Release 5-7)
            /////////////////////////////
            if (!isUndead)
            {
                if (!HandleNewCharacterName(out suppliedName))
                    return false;
            }

            /////////////////////////////
            // Choose difficulty inc helicopter arrival day  //@@MP (Release 6-3), (Release 7-4)
            /////////////////////////////
            int chosenDay = s_Options.HiddenRescueDay; //default
            if (!HandleNewCharacterDifficulty(out chosenDay))
                return false;
            m_Session.ArmyHelicopterRescue_Day = chosenDay;

            // done
            return true;
        }

        bool HandleNewGameMode()
        {
            string[] menuEntries = new string[]
            {
                Session.DescGameMode(GameMode.GM_STANDARD),
                Session.DescGameMode(GameMode.GM_CORPSES_INFECTION),
                Session.DescGameMode(GameMode.GM_VINTAGE)
            };
            string[] descs = new string[]
            {
                "Rogue Survivor standard game. Corpses won't rise, but zombies evolve.",
                "Don't get infected. Infected corpses might rise again. Zombies evolve.",
                "The classic zombies experience. Zombies are mindless shamblers."
            };

            bool loop = true;
            bool choiceDone = false;
            int selected = 0;
            do
            {
                // display.
                m_UI.UI_Clear(Color.Black);
                int gx, gy;
                gx = gy = 0;
                m_UI.UI_DrawStringBold(Color.Yellow, "New Game - Choose Game Mode", gx, gy);
                gy += 2 * BOLD_LINE_SPACING;
                DrawMenuOrOptions(selected, Color.White, menuEntries, Color.LightGray, descs, gx, ref gy);
                gy += 2 * BOLD_LINE_SPACING;

                string[] descMode = { };
                switch (selected)
                {
                    case 0: //STD
                        descMode = new string[] {
                            "This is the standard game mode:",
                            "- All the various types of undeads.",
                            "- Undeads can evolve and gain abilities.",
                            "- Undeads will not infect livings when hurting them.",
                            "- Certain types of undeads will zombify their victim upon death.",
                            "- If enabled, livings may zombify instantly if starved to death,",
                            "  otherwise (and by default) corpses will not rise again.",
                            "> Suited to beginners or those looking for a different take on undeads.",
                            "",
                            "Note: Undead evolution and starvation-zombification can be disabled at new game creation."
                        };
                        break;
                    case 1: //CORP & INF
                        descMode = new string[] {
                            "This is the standard game mode plus infection: ",
                            "- All the various types of undeads.",
                            "- Undeads can gain abilities and evolve to stronger forms.",
                            "- Some undeads can infect livings when hurting them.",
                            "- Infection, if not controlled, will eventually lead to death.",
                            "- Human corpses will slowly rot, but may rise as undead if infected.",
                            "- Undead (and even livings when desperate) can eat corpses.",
                            "> Suited to veterans or those looking for more of a challenge.",
                            "",
                            "Note: Undead evolution can be disabled at new game creation."
                        };
                        break;
                    case 2: //VTG
                        descMode = new string[] {
                            "This is the mode for classic zombie fans: ",
                            "- Undeads are only zombified men and women.",
                            "- Undeads don't evolve nor gain abilities.",
                            "- Undeads can infect livings when hurting them.",
                            "- Infection, if not controlled, will eventually lead to death.",
                            "- Human corpses will slowly rot, but may rise as undead if infected.",
                            "- Undead (and even livings when desperate) can eat corpses.",
                            "> Suited to those who want the classic zombie apocalypse experience.",
                            "",
                             //@@MP (Release 5-2)
                            //"IMPORTANT: This mode forces undead evolution OFF.",
                            //"Remember to set them back ON again when you play other modes!",
                            "Note: You can also choose to disable antiviral pills from the",
                            "  at new game creation, to ensure there is no way to undo infection."
                        };
                        break;
                }
                foreach (String str in descMode)
                {
                    m_UI.UI_DrawStringBold(Color.Gray, str, gx, gy);
                    gy += BOLD_LINE_SPACING;
                }

                DrawFootnote(Color.White, "cursor to move, ENTER to select, ESC to cancel");
                m_UI.UI_Repaint();

                // get menu action.
                KeyEventArgs key = m_UI.UI_WaitKey();
                switch (key.KeyCode)
                {
                    case Keys.Up:       // move up
                        if (selected > 0) --selected;
                        else selected = menuEntries.Length - 1;
                        break;
                    case Keys.Down:     // move down
                        selected = (selected + 1) % menuEntries.Length;
                        break;

                    case Keys.Escape:
                        choiceDone = false;
                        loop = false;
                        break;

                    case Keys.Enter:    // validate
                        {
                            switch (selected)
                            {
                                case 0: // standard
                                    m_Session.GameMode = GameMode.GM_STANDARD;
                                    choiceDone = true;
                                    loop = false;
                                    break;

                                case 1: // corpses & infection
                                    m_Session.GameMode = GameMode.GM_CORPSES_INFECTION;
                                    choiceDone = true;
                                    loop = false;
                                    break;

                                case 2: // vintage
                                    m_Session.GameMode = GameMode.GM_VINTAGE;

                                    // force some options off. //@@MP - disabled as this will now be handled in-code rather than forcing options which is messy (Release 5-2)
                                    /*s_Options.AllowUndeadsEvolution = false;
                                    s_Options.ShamblersUpgrade = false;
                                    s_Options.RatsUpgrade = false;
                                    s_Options.SkeletonsUpgrade = false;
                                    ApplyOptions(false);*/

                                    choiceDone = true;
                                    loop = false;
                                    break;
                            }
                            break;
                        }
                }

            }
            while (loop);

            // done.
            return choiceDone;
        }

        bool HandleNewCharacterRace(DiceRoller roller, out bool isUndead)
        {
            string[] menuEntries = new string[] //@@MP - re-ordered (Release 6-2)
            {
                "Living",
                "Undead",
                "*random*"
            };
            string[] descs = new string[] //@@MP - re-ordered (Release 6-2)
            {
                "Try to survive.",
                "Eat brains!",
                "(picks a race at random for you)"
            };

            isUndead = false;
            bool loop = true;
            bool choiceDone = false;
            int selected = 0;
            do
            {
                // display.
                m_UI.UI_Clear(Color.Black);
                int gx, gy;
                gx = gy = 0;
                m_UI.UI_DrawStringBold(Color.Yellow, String.Format("[{0}] New Character - Choose Race", Session.DescGameMode(m_Session.GameMode)), gx, gy);
                gy += 2 * BOLD_LINE_SPACING;
                DrawMenuOrOptions(selected, Color.White, menuEntries, Color.LightGray, descs, gx, ref gy);
                gy += 2 * BOLD_LINE_SPACING;

                DrawFootnote(Color.White, "cursor to move, ENTER to select, ESC to cancel");
                m_UI.UI_Repaint();

                // get menu action.
                KeyEventArgs key = m_UI.UI_WaitKey();
                switch (key.KeyCode)
                {
                    case Keys.Up:       // move up
                        if (selected > 0) --selected;
                        else selected = menuEntries.Length - 1;
                        break;
                    case Keys.Down:     // move down
                        selected = (selected + 1) % menuEntries.Length;
                        break;

                    case Keys.Escape:
                        choiceDone = false;
                        loop = false;
                        break;

                    case Keys.Enter:    // validate
                        {
                            switch (selected) //@@MP - re-ordered (Release 6-2)
                            {
                                case 0: // living
                                    isUndead = false;
                                    choiceDone = true;
                                    loop = false;
                                    break;

                                case 1: // undead
                                    isUndead = true;
                                    choiceDone = true;
                                    loop = false;
                                    break;

                                case 2: // random
                                    isUndead = roller.RollChance(50);

                                    gy += BOLD_LINE_SPACING;
                                    m_UI.UI_DrawStringBold(Color.White, String.Format("Race : {0}.", isUndead ? "Undead" : "Living"), gx, gy);
                                    //@@MP - remove choice confirmation (Release 1)
                                    /*gy += BOLD_LINE_SPACING;
                                    m_UI.UI_DrawStringBold(Color.Yellow, "Is that OK? Y to confirm, N to cancel.", gx, gy);
                                    m_UI.UI_Repaint();
                                    if (WaitYesOrNo())
                                    {*/
                                    choiceDone = true;
                                    loop = false;
                                    //}
                                    break;
                            }
                            break;
                        }
                }

            }
            while (loop);

            // done.
            return choiceDone;
        }

        bool HandleNewCharacterGender(DiceRoller roller, out bool isMale)
        {
            ActorModel maleModel = GameActors.MaleCivilian;
            ActorModel femaleModel = GameActors.FemaleCivilian;

            string[] menuEntries = new string[]
            {
                "*random*",
                "Male",
                "Female"
            };
            string[] descs = new string[]
            {
                "(picks a gender at random for you)",
                String.Format("HP:{0:D2}  Def:{1:D2}  Dmg:{2:D1}", maleModel.StartingSheet.BaseHitPoints, maleModel.StartingSheet.BaseDefence.Value,  maleModel.StartingSheet.UnarmedAttack.DamageValue),
                String.Format("HP:{0:D2}  Def:{1:D2}  Dmg:{2:D1}", femaleModel.StartingSheet.BaseHitPoints, femaleModel.StartingSheet.BaseDefence.Value, femaleModel.StartingSheet.UnarmedAttack.DamageValue),
            };

            isMale = true;
            bool loop = true;
            bool choiceDone = false;
            int selected = 0;
            do
            {
                // display.
                m_UI.UI_Clear(Color.Black);
                int gx, gy;
                gx = gy = 0;
                m_UI.UI_DrawStringBold(Color.Yellow, String.Format("[{0}] New Living - Choose Gender", Session.DescGameMode(m_Session.GameMode)), gx, gy);
                gy += 2 * BOLD_LINE_SPACING;
                DrawMenuOrOptions(selected, Color.White, menuEntries, Color.LightGray, descs, gx, ref gy);
                DrawFootnote(Color.White, "cursor to move, ENTER to select, ESC to cancel");
                m_UI.UI_Repaint();

                // get menu action.
                KeyEventArgs key = m_UI.UI_WaitKey();
                switch (key.KeyCode)
                {
                    case Keys.Up:       // move up
                        if (selected > 0) --selected;
                        else selected = menuEntries.Length - 1;
                        break;
                    case Keys.Down:     // move down
                        selected = (selected + 1) % menuEntries.Length;
                        break;

                    case Keys.Escape:
                        choiceDone = false;
                        loop = false;
                        break;

                    case Keys.Enter:    // validate
                        {
                            switch (selected)
                            {
                                case 0: // random
                                    isMale = roller.RollChance(50);

                                    gy += BOLD_LINE_SPACING;
                                    m_UI.UI_DrawStringBold(Color.White, String.Format("Gender : {0}.", isMale ? "Male" : "Female"), gx, gy);
                                    /*gy += BOLD_LINE_SPACING;
                                    m_UI.UI_DrawStringBold(Color.Yellow, "Is that OK? Y to confirm, N to cancel.", gx, gy);
                                    m_UI.UI_Repaint();
                                    if (WaitYesOrNo())
                                    {*/
                                    choiceDone = true;
                                    loop = false;
                                    //}
                                    break;

                                case 1: // male
                                    isMale = true;
                                    choiceDone = true;
                                    loop = false;
                                    break;

                                case 2: // female
                                    isMale = false;
                                    choiceDone = true;
                                    loop = false;
                                    break;
                            }
                            break;
                        }
                }

            }
            while (loop);

            // done.
            return choiceDone;
        }

        static string DescribeUndeadModelStatLine(ActorModel m) //@@MP - made static (Release 5-7)
        {
            return String.Format("HP:{0:D3}  Spd:{1:F2}  Atk:{2:D2}  Def:{3:D2}  Dmg:{4:D2}  FoV:{5:D1}  Sml:{6:F2}",
                m.StartingSheet.BaseHitPoints, m.DollBody.Speed / 100f,
                m.StartingSheet.UnarmedAttack.HitValue, m.StartingSheet.BaseDefence.Value, m.StartingSheet.UnarmedAttack.DamageValue,
                m.StartingSheet.BaseViewRange, m.StartingSheet.BaseSmellRating);
        }

        bool HandleNewCharacterUndeadType(DiceRoller roller, out GameActors.IDs modelID)
        {
            ActorModel skeletonModel = GameActors.Skeleton;
            ActorModel shamblerModel = GameActors.Zombie;
            ActorModel maleModel = GameActors.MaleZombified;
            ActorModel femaleModel = GameActors.FemaleZombified;
            ActorModel masterModel = GameActors.ZombieMaster;

            string[] menuEntries = new string[]
            {
                "*random*",
                skeletonModel.Name,
                shamblerModel.Name,
                maleModel.Name,
                femaleModel.Name,
                masterModel.Name,
            };
            string[] descs = new string[]
            {
                "(picks a type at random for you)",
                DescribeUndeadModelStatLine(skeletonModel),
                DescribeUndeadModelStatLine(shamblerModel),
                DescribeUndeadModelStatLine(maleModel),
                DescribeUndeadModelStatLine(femaleModel),
                DescribeUndeadModelStatLine(masterModel)
            };

            modelID = GameActors.IDs.UNDEAD_MALE_ZOMBIFIED;
            bool loop = true;
            bool choiceDone = false;
            int selected = 0;
            do
            {
                // display.
                m_UI.UI_Clear(Color.Black);
                int gx, gy;
                gx = gy = 0;
                m_UI.UI_DrawStringBold(Color.Yellow, String.Format("[{0}] New Undead - Choose Type", Session.DescGameMode(m_Session.GameMode)), gx, gy);
                gy += 2 * BOLD_LINE_SPACING;
                DrawMenuOrOptions(selected, Color.White, menuEntries, Color.LightGray, descs, gx, ref gy);
                DrawFootnote(Color.White, "cursor to move, ENTER to select, ESC to cancel");
                m_UI.UI_Repaint();

                // get menu action.
                KeyEventArgs key = m_UI.UI_WaitKey();
                switch (key.KeyCode)
                {
                    case Keys.Up:       // move up
                        if (selected > 0) --selected;
                        else selected = menuEntries.Length - 1;
                        break;
                    case Keys.Down:     // move down
                        selected = (selected + 1) % menuEntries.Length;
                        break;

                    case Keys.Escape:
                        choiceDone = false;
                        loop = false;
                        break;

                    case Keys.Enter:    // validate
                        {
                            switch (selected)
                            {
                                case 0: // random
                                    selected = roller.Roll(0, 5);
                                    switch (selected)
                                    {
                                        case 0: modelID = GameActors.IDs.UNDEAD_SKELETON; break;
                                        case 1: modelID = GameActors.IDs.UNDEAD_ZOMBIE; break;
                                        case 2: modelID = GameActors.IDs.UNDEAD_MALE_ZOMBIFIED; break;
                                        case 3: modelID = GameActors.IDs.UNDEAD_FEMALE_ZOMBIFIED; break;
                                        case 4: modelID = GameActors.IDs.UNDEAD_ZOMBIE_MASTER; break;
                                        default:
                                            throw new ArgumentOutOfRangeException("unhandled select " + selected);
                                    }

                                    gy += BOLD_LINE_SPACING;
                                    m_UI.UI_DrawStringBold(Color.White, String.Format("Type : {0}.", GameActors[modelID].Name), gx, gy);
                                    /*gy += BOLD_LINE_SPACING;
                                    m_UI.UI_DrawStringBold(Color.Yellow, "Is that OK? Y to confirm, N to cancel.", gx, gy);
                                    m_UI.UI_Repaint();
                                    if (WaitYesOrNo())
                                    {*/
                                    choiceDone = true;
                                    loop = false;
                                    //}
                                    break;

                                case 1: // skeleton
                                    modelID = GameActors.IDs.UNDEAD_SKELETON;
                                    choiceDone = true;
                                    loop = false;
                                    break;

                                case 2: // shambler
                                    modelID = GameActors.IDs.UNDEAD_ZOMBIE;
                                    choiceDone = true;
                                    loop = false;
                                    break;

                                case 3: // male zombified
                                    modelID = GameActors.IDs.UNDEAD_MALE_ZOMBIFIED;
                                    m_CharGen.IsMale = true;
                                    choiceDone = true;
                                    loop = false;
                                    break;

                                case 4: // female zombified
                                    modelID = GameActors.IDs.UNDEAD_FEMALE_ZOMBIFIED;
                                    m_CharGen.IsMale = false;
                                    choiceDone = true;
                                    loop = false;
                                    break;

                                case 5: // zm
                                    modelID = GameActors.IDs.UNDEAD_ZOMBIE_MASTER;
                                    choiceDone = true;
                                    loop = false;
                                    break;
                            }
                            break;
                        }
                }

            }
            while (loop);

            // done.
            return choiceDone;
        }

        bool HandleNewCharacterSkill(DiceRoller roller, out Skills.IDs skID)
        {
            /////////////////////////////
            // Make table of all skills.
            /////////////////////////////
            Skills.IDs[] allSkills = new Skills.IDs[(int)Skills.IDs._LAST_LIVING + 1];
            string[] menuEntries = new string[allSkills.Length + 1];
            string[] skillDesc = new string[allSkills.Length + 1];
            menuEntries[0] = "*random*";
            skillDesc[0] = "(picks a skill at random for you)";
            int sanitySkillIndex = 0;
            for (int i = (int)Skills.IDs._FIRST_LIVING; i < (int)Skills.IDs._LAST_LIVING + 1; i++)
            {
                allSkills[i] = (Skills.IDs)i;
                if ((!Options.IsSanityEnabled) && (Skills.Name(allSkills[i]) == "Strong Psyche")) //@@MP - check if Sanity is disabled and remove it as an option if so (Release 1), fixed crappy implem (Release 5-2)
                {
                    sanitySkillIndex = i + 1; //remember the index location of the array where Strong Psyche would have been
                    continue;   // Skip the remainder of this iteration
                }
                else //add it to the list of skills we'll present to the user
                {
                    menuEntries[i + 1] = Skills.Name(allSkills[i]);
                    skillDesc[i + 1] = String.Format("{0} max - {1}", Skills.MaxSkillLevel(i), DescribeSkillShort(allSkills[i]));
                }
            }
            if (!Options.IsSanityEnabled) //resize the list of skills to eliminate where Strong Psyche would have been //@@MP (Release 1), fixed crappy implem (Release 5-2)
            {
                menuEntries = menuEntries.Where(w => w != menuEntries[sanitySkillIndex]).ToArray();
                skillDesc = skillDesc.Where(w => w != skillDesc[sanitySkillIndex]).ToArray();
            }

            //////////////////////////
            // Loop until choice done
            //////////////////////////
            skID = Skills.IDs._FIRST;
            bool loop = true;
            bool choiceDone = false;
            int selected = 0;
            do
            {
                // display.
                m_UI.UI_Clear(Color.Black);
                int gx, gy;
                gx = gy = 0;
                m_UI.UI_DrawStringBold(Color.Yellow, String.Format("[{0}] New {1} Character - Choose Starting Skill",
                    Session.DescGameMode(m_Session.GameMode),
                    m_CharGen.IsMale ? "Male" : "Female"), gx, gy);
                gy += 2 * BOLD_LINE_SPACING;
                DrawMenuOrOptions(selected, Color.White, menuEntries, Color.LightGray, skillDesc, gx, ref gy);
                DrawFootnote(Color.White, "cursor to move, ENTER to select, ESC to cancel");
                m_UI.UI_Repaint();

                // get menu action.
                KeyEventArgs key = m_UI.UI_WaitKey();
                switch (key.KeyCode)
                {
                    case Keys.Up:       // move up
                        if (selected > 0) --selected;
                        else selected = menuEntries.Length - 1;
                        break;
                    case Keys.Down:     // move down
                        selected = (selected + 1) % menuEntries.Length;
                        break;

                    case Keys.Escape:
                        choiceDone = false;
                        loop = false;
                        break;

                    case Keys.Enter:    // validate
                        if (selected == 0) // random
                            skID = Skills.RollLiving(roller);
                        else
                            skID = (Skills.IDs)(selected - 1 + (int)Skills.IDs._FIRST);

                        gy += BOLD_LINE_SPACING;
                        m_UI.UI_DrawStringBold(Color.White, String.Format("Skill : {0}.", Skills.Name(skID)), gx, gy);
                        /*gy += BOLD_LINE_SPACING;
                        m_UI.UI_DrawStringBold(Color.Yellow, "Is that OK? Y to confirm, N to cancel.", gx, gy);
                        m_UI.UI_Repaint();
                        if (WaitYesOrNo())
                        {*/
                        choiceDone = true;
                        loop = false;
                        //}
                        break;
                }
            }
            while (loop);

            // done.
            return choiceDone;
        }

        /// <summary>
        /// If the player wants to pick a name they type it here
        /// </summary>
        bool HandleNewCharacterName(out string suppliedName) //@@MP (Release 5-7)
        {
            bool loop = true;
            bool choiceDone = false;
            suppliedName = "";
            int maxCharactersAllowed = 24;

            do
            {
                //display
                int usedCharacters = suppliedName.Length;
                m_UI.UI_Clear(Color.Black);
                int gx, gy;
                gx = gy = 0;
                m_UI.UI_DrawStringBold(Color.Yellow, String.Format("[{0}] New Living - Choose Name", Session.DescGameMode(m_Session.GameMode)), gx, gy);
                gy += 2 * BOLD_LINE_SPACING;
                m_UI.UI_DrawStringBold(Color.White, String.Format("--->  {0}     [{1}/{2}]", suppliedName, usedCharacters, maxCharactersAllowed), gx, gy);
                DrawFootnote(Color.White, "Type a name or leave it blank to be given a random one, ENTER to proceed, ESC to cancel");
                m_UI.UI_Repaint();

                // get menu action.
                KeyEventArgs key = m_UI.UI_WaitKey();
                switch (key.KeyCode)
                {
                    #region the character keys
                    case Keys.A:
                        if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                            suppliedName += "A";
                        else
                            suppliedName += "a";
                        break;

                    case Keys.B:
                        if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                            suppliedName += "B";
                        else
                            suppliedName += "b";
                        break;

                    case Keys.C:
                        if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                            suppliedName += "C";
                        else
                            suppliedName += "c";
                        break;

                    case Keys.D:
                        if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                            suppliedName += "D";
                        else
                            suppliedName += "d";
                        break;

                    case Keys.E:
                        if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                            suppliedName += "E";
                        else
                            suppliedName += "e";
                        break;

                    case Keys.F:
                        if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                            suppliedName += "F";
                        else
                            suppliedName += "f";
                        break;

                    case Keys.G:
                        if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                            suppliedName += "G";
                        else
                            suppliedName += "g";
                        break;

                    case Keys.H:
                        if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                            suppliedName += "H";
                        else
                            suppliedName += "h";
                        break;

                    case Keys.I:
                        if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                            suppliedName += "I";
                        else
                            suppliedName += "i";
                        break;

                    case Keys.J:
                        if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                            suppliedName += "J";
                        else
                            suppliedName += "j";
                        break;

                    case Keys.K:
                        if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                            suppliedName += "K";
                        else
                            suppliedName += "k";
                        break;

                    case Keys.L:
                        if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                            suppliedName += "L";
                        else
                            suppliedName += "l";
                        break;

                    case Keys.M:
                        if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                            suppliedName += "M";
                        else
                            suppliedName += "m";
                        break;

                    case Keys.N:
                        if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                            suppliedName += "N";
                        else
                            suppliedName += "n";
                        break;

                    case Keys.O:
                        if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                            suppliedName += "O";
                        else
                            suppliedName += "o";
                        break;

                    case Keys.P:
                        if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                            suppliedName += "P";
                        else
                            suppliedName += "p";
                        break;

                    case Keys.Q:
                        if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                            suppliedName += "Q";
                        else
                            suppliedName += "q";
                        break;

                    case Keys.R:
                        if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                            suppliedName += "R";
                        else
                            suppliedName += "r";
                        break;

                    case Keys.S:
                        if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                            suppliedName += "S";
                        else
                            suppliedName += "s";
                        break;

                    case Keys.T:
                        if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                            suppliedName += "T";
                        else
                            suppliedName += "t";
                        break;

                    case Keys.U:
                        if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                            suppliedName += "U";
                        else
                            suppliedName += "u";
                        break;

                    case Keys.V:
                        if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                            suppliedName += "V";
                        else
                            suppliedName += "v";
                        break;

                    case Keys.W:
                        if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                            suppliedName += "W";
                        else
                            suppliedName += "w";
                        break;

                    case Keys.X:
                        if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                            suppliedName += "X";
                        else
                            suppliedName += "x";
                        break;

                    case Keys.Y:
                        if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                            suppliedName += "Y";
                        else
                            suppliedName += "y";
                        break;

                    case Keys.Z:
                        if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                            suppliedName += "Z";
                        else
                            suppliedName += "z";
                        break;

                    case Keys.NumPad0:
                        suppliedName += "0";
                        break;

                    case Keys.D0:
                        suppliedName += "0";
                        break;

                    case Keys.NumPad1:
                        suppliedName += "1";
                        break;

                    case Keys.D1:
                        suppliedName += "1";
                        break;

                    case Keys.NumPad2:
                        suppliedName += "2";
                        break;

                    case Keys.D2:
                        suppliedName += "2";
                        break;

                    case Keys.NumPad3:
                        suppliedName += "3";
                        break;

                    case Keys.D3:
                        suppliedName += "3";
                        break;

                    case Keys.NumPad4:
                        suppliedName += "4";
                        break;

                    case Keys.D4:
                        suppliedName += "4";
                        break;

                    case Keys.NumPad5:
                        suppliedName += "5";
                        break;

                    case Keys.D5:
                        suppliedName += "5";
                        break;

                    case Keys.NumPad6:
                        suppliedName += "6";
                        break;

                    case Keys.D6:
                        suppliedName += "6";
                        break;

                    case Keys.NumPad7:
                        suppliedName += "7";
                        break;

                    case Keys.D7:
                        suppliedName += "7";
                        break;

                    case Keys.NumPad8:
                        suppliedName += "8";
                        break;

                    case Keys.D8:
                        suppliedName += "8";
                        break;

                    case Keys.NumPad9:
                        suppliedName += "9";
                        break;

                    case Keys.D9:
                        suppliedName += "9";
                        break;

                    case Keys.Space:
                        suppliedName += " ";
                        break;

                    #endregion

                    case Keys.Back: //backspace
                        if (suppliedName.Length > 0)
                            suppliedName = suppliedName.Remove(suppliedName.Length - 1);
                        break;

                    case Keys.Escape: //cancelled
                        choiceDone = false;
                        loop = false;
                        break;

                    case Keys.Enter: //name entered or gimme a random
                        choiceDone = true;
                        loop = false;
                        break;
                }

                if (suppliedName.Length > maxCharactersAllowed) //trim it back to the character cap
                    suppliedName = suppliedName.Remove(suppliedName.Length - 1);
            }
            while (loop);

            // done.
            return choiceDone;
        }

        /// <summary>
        /// Allows tweaking any difficulty-related options, including heli rescue day
        /// </summary>
        bool HandleNewCharacterDifficulty(out int chosenDay) //@@MP (Release 7-4)
        {
            bool choiceDone = false;

            #region Order
            GameOptions.IDs[] list = new GameOptions.IDs[]  //@@MP provides the order in which they appear in the menu
            {
                // living
                GameOptions.IDs.DIFFICULTY_RESCUE_DAY, //@@MP (Release 6-3)
                GameOptions.IDs.DIFFICULTY_RESOURCES_AVAILABILITY, //@@MP (Release 7-4)
                GameOptions.IDs.DIFFICULTY_LIVING_DAMAGE_PERCENT, //@@MP (Release 7-4)
                GameOptions.IDs.DIFFICULTY_AGGRESSIVE_HUNGRY_CIVILIANS,
                GameOptions.IDs.DIFFICULTY_SANITY, //@@MP (Release 1)
                GameOptions.IDs.DIFFICULTY_ANTIVIRAL_PILLS, //@@MP (Release 5-2)
                GameOptions.IDs.DIFFICULTY_ZOMBIFICATION_CHANCE,
                GameOptions.IDs.DIFFICULTY_NPC_CAN_STARVE_TO_DEATH,
                GameOptions.IDs.DIFFICULTY_STARVED_ZOMBIFICATION,
                GameOptions.IDs.DIFFICULTY_BACKPACKS, //@@MP (Release 8-2)
                GameOptions.IDs.DIFFICULTY_MAX_CIVILIANS,
                // undeads
                GameOptions.IDs.DIFFICULTY_MAX_UNDEADS,
                GameOptions.IDs.DIFFICULTY_UNDEAD_DAMAGE_PERCENT, //@@MP (Release 7-4)
                GameOptions.IDs.DIFFICULTY_DAY_ZERO_UNDEADS_PERCENT,
                GameOptions.IDs.DIFFICULTY_UNDEADS_UPGRADE_DAYS,
                GameOptions.IDs.DIFFICULTY_ALLOW_UNDEADS_EVOLUTION,
                GameOptions.IDs.DIFFICULTY_ZOMBIE_INVASION_DAILY_INCREASE,
                GameOptions.IDs.DIFFICULTY_SHAMBLERS_UPGRADE,
                GameOptions.IDs.DIFFICULTY_SKELETONS_UPGRADE,
                /*GameOptions.IDs.DIFFICULTY_SPAWN_SKELETON_CHANCE,
                GameOptions.IDs.DIFFICULTY_SPAWN_ZOMBIE_CHANCE,
                GameOptions.IDs.DIFFICULTY_SPAWN_ZOMBIE_MASTER_CHANCE,*/
                //GameOptions.IDs.DIFFICULTY_RATS_UPGRADE, //@@MP (Release 5-7)
                // events
                GameOptions.IDs.DIFFICULTY_NATGUARD_FACTOR,
                GameOptions.IDs.DIFFICULTY_BLACKOPS_RAIDS, //@@MP (Release 7-5)
                GameOptions.IDs.DIFFICULTY_SUPPLIESDROP_FACTOR,
            };
            #endregion

            //exceptions           //@@MP (Release 7-6)
            //if (!Rules.HasImmediateZombification(m_Session.GameMode))
            if (m_Session.GameMode != GameMode.GM_STANDARD)
            {
                list = list.Where(val => val != GameOptions.IDs.DIFFICULTY_ZOMBIFICATION_CHANCE).ToArray();
                list = list.Where(val => val != GameOptions.IDs.DIFFICULTY_STARVED_ZOMBIFICATION).ToArray();
            }
            if (m_Session.GameMode != GameMode.GM_VINTAGE)
            {
                list = list.Where(val => val != GameOptions.IDs.DIFFICULTY_ANTIVIRAL_PILLS).ToArray();
            }
            else if(m_Session.GameMode == GameMode.GM_VINTAGE)
            {
                list = list.Where(val => val != GameOptions.IDs.DIFFICULTY_ALLOW_UNDEADS_EVOLUTION).ToArray();
                list = list.Where(val => val != GameOptions.IDs.DIFFICULTY_SHAMBLERS_UPGRADE).ToArray();
                list = list.Where(val => val != GameOptions.IDs.DIFFICULTY_SKELETONS_UPGRADE).ToArray();
                //list = list.Where(val => val != GameOptions.IDs.DIFFICULTY_RATS_UPGRADE).ToArray();   //@@MP - release 5 removed rats upgrades
            }

            //choices
            string[] menuEntries = new string[list.Length];
            string[] values = new string[list.Length];
            for (int i = 0; i < list.Length; i++)
            {
                menuEntries[i] = GameOptions.Name(list[i]);
                /*// alpha10 special mode notes
                GameOptions.IDs id = list[i];
                if (id == GameOptions.IDs.GAME_ALLOW_UNDEADS_EVOLUTION ||
                    id == GameOptions.IDs.GAME_SKELETONS_UPGRADE ||
                    id == GameOptions.IDs.GAME_SHAMBLERS_UPGRADE) //id == GameOptions.IDs.GAME_RATS_UPGRADE || //@@MP - release 5 removed rats upgrades
                    menuEntries[i] += " -V";
                else if (id == GameOptions.IDs.GAME_ZOMBIFICATION_CHANCE || id == GameOptions.IDs.GAME_STARVED_ZOMBIFICATION_CHANCE)
                    menuEntries[i] += " =S";*/
            }

            bool loop = true;
            int selected = 0;
            char[] newlines = { '\n' };  // alpha10
            char[] spaces = { ' ' }; // alpha10
            do
            {
                for (int i = 0; i < list.Length; i++)
                    values[i] = s_Options.DescribeValue(list[i]); //@@MP - unused parameter (Release 5-7)

                int gx, gy;
                //heading
                gx = gy = 0;
                m_UI.UI_Clear(Color.Black);
                m_UI.UI_DrawStringBold(Color.Yellow, String.Format("[{0}] Set Difficulty Options", Session.DescGameMode(m_Session.GameMode)), gx, gy);

                //intro
                gy += 2 * BOLD_LINE_SPACING;
                m_UI.UI_DrawStringBold(Color.White, String.Format("The army have established a safe zone and are evacuating towns all around the region."), gx, gy);
                gy += BOLD_LINE_SPACING;
                m_UI.UI_DrawStringBold(Color.White, String.Format("You must find a way to survive until helicopter rescue arrives (choose the day below)."), gx, gy);
                gy += BOLD_LINE_SPACING;
                m_UI.UI_DrawStringBold(Color.White, String.Format("You don't have to make it to the helicopter, but after that point you'll be on your own..."), gx, gy);

                //the options
                gy += 2 * BOLD_LINE_SPACING;
                DrawMenuOrOptions(selected, Color.White, menuEntries, Color.LightGreen, values, gx, ref gy, false, 400);

                // describe current option.    // alpha10
                gy += BOLD_LINE_SPACING;
                m_UI.UI_DrawStringBold(Color.White, menuEntries[selected].TrimStart(spaces), gx, gy);
                gy += BOLD_LINE_SPACING;
                string desc = GameOptions.Describe(list[selected]);
                string[] descLines = desc.Split(newlines);
                foreach (string d in descLines)
                {
                    m_UI.UI_DrawString(Color.White, "  " + d, gx, gy);
                    gy += BOLD_LINE_SPACING;
                }

                // difficulty rating.
                gy += BOLD_LINE_SPACING;
                int diffForSurvivor = (int)(100 * Scoring.ComputeDifficultyRating(s_Options, DifficultySide.FOR_SURVIVOR, 0, m_Session.GameMode));
                int diffforUndead = (int)(100 * Scoring.ComputeDifficultyRating(s_Options, DifficultySide.FOR_UNDEAD, 0, m_Session.GameMode));
                m_UI.UI_DrawStringBold(Color.Yellow, String.Format("Difficulty Rating : {0}% as survivor / {1}% as undead.", diffForSurvivor, diffforUndead), gx, gy);
                gy += BOLD_LINE_SPACING;
                m_UI.UI_DrawStringBold(Color.White, "Note: your game score decreases with each reincarnation.", gx, gy);

                // caution.
                gy += BOLD_LINE_SPACING;
                m_UI.UI_DrawStringBold(Color.Red, "* Caution : increasing these values can make the game run slower and saving/loading longer.", gx, gy);
                gy += BOLD_LINE_SPACING;
                /*// legend //alpha 10
                m_UI.UI_DrawStringBold(Color.White, "-V : option always OFF when playing Vintage (VTG) mode", gx, gy);
                gy += BOLD_LINE_SPACING;
                m_UI.UI_DrawStringBold(Color.White, "=S : option used only when playing Standard (STD) mode", gx, gy);
                gy += BOLD_LINE_SPACING;*/

                // footnote.
                DrawFootnote(Color.White, "Move cursor then left/right to change values, R to restore defaults, ENTER to proceed, ESC to cancel");

                //redraw
                m_UI.UI_Repaint();

                // handle
                // get menu action.
                KeyEventArgs key = m_UI.UI_WaitKey();
                switch (key.KeyCode)
                {
                    case Keys.Up:       // move up
                        if (selected > 0) --selected;
                        else selected = menuEntries.Length - 1;
                        break;
                    case Keys.Down:     // move down
                        selected = (selected + 1) % menuEntries.Length;
                        break;

                    case Keys.R:        // restore defaults.
                        s_Options.ResetToDefaultValues(GameOptions.OptionsCategory.DIFFICULTY); //prevOptions; //@@MP - used to restore changes in this session, now resets defaults (Release 6-1)
                        break;

                    case Keys.Escape:   // validate and leave
                        loop = false;
                        choiceDone = false;
                        break;

                    case Keys.Enter:
                        loop = false;
                        choiceDone = true;
                        break;

                    case Keys.Left:
                        switch ((GameOptions.IDs)list[selected])
                        {
                            case GameOptions.IDs.DIFFICULTY_RESCUE_DAY: s_Options.VisibleRescueDay -= 1; break;
                            case GameOptions.IDs.DIFFICULTY_LIVING_DAMAGE_PERCENT: s_Options.LivingDamagePercent -= 25; break;
                            case GameOptions.IDs.DIFFICULTY_UNDEAD_DAMAGE_PERCENT: s_Options.UndeadDamagePercent -= 25; break;
                            case GameOptions.IDs.DIFFICULTY_MAX_CIVILIANS: s_Options.MaxCivilians -= 5; break;
                            case GameOptions.IDs.DIFFICULTY_MAX_UNDEADS: s_Options.MaxUndeads -= 10; break;
                            case GameOptions.IDs.DIFFICULTY_DAY_ZERO_UNDEADS_PERCENT: s_Options.DayZeroUndeadsPercent -= 5; break;
                            case GameOptions.IDs.DIFFICULTY_ZOMBIE_INVASION_DAILY_INCREASE: --s_Options.ZombieInvasionDailyIncrease; break;
                            case GameOptions.IDs.DIFFICULTY_NPC_CAN_STARVE_TO_DEATH: s_Options.NPCCanStarveToDeath = !s_Options.NPCCanStarveToDeath; break;
                            case GameOptions.IDs.DIFFICULTY_STARVED_ZOMBIFICATION: s_Options.StarvedZombification = !s_Options.StarvedZombification; break;
                            case GameOptions.IDs.DIFFICULTY_ZOMBIFICATION_CHANCE: s_Options.ZombificationChance -= 5; break;
                            case GameOptions.IDs.DIFFICULTY_ALLOW_UNDEADS_EVOLUTION:
                                s_Options.AllowUndeadsEvolution = !s_Options.AllowUndeadsEvolution;
                                break;
                            case GameOptions.IDs.DIFFICULTY_UNDEADS_UPGRADE_DAYS:
                                if (s_Options.ZombifiedsUpgradeDays != GameOptions.ZupDays._FIRST)
                                    s_Options.ZombifiedsUpgradeDays = (GameOptions.ZupDays)(s_Options.ZombifiedsUpgradeDays - 1);
                                break;
                            case GameOptions.IDs.DIFFICULTY_SANITY: s_Options.IsSanityEnabled = !s_Options.IsSanityEnabled; break; //@@MP (Release 1)
                            case GameOptions.IDs.DIFFICULTY_AGGRESSIVE_HUNGRY_CIVILIANS: s_Options.IsAggressiveHungryCiviliansOn = !s_Options.IsAggressiveHungryCiviliansOn; break;
                            case GameOptions.IDs.DIFFICULTY_NATGUARD_FACTOR: s_Options.NatGuardFactor -= 10; break;
                            case GameOptions.IDs.DIFFICULTY_BLACKOPS_RAIDS: s_Options.BlackOpsRaidsEnabled = !s_Options.BlackOpsRaidsEnabled; break; //@@MP (Release 7-5)
                            case GameOptions.IDs.DIFFICULTY_SUPPLIESDROP_FACTOR: s_Options.SuppliesDropFactor -= 10; break;
                            case GameOptions.IDs.DIFFICULTY_ANTIVIRAL_PILLS: s_Options.AntiviralPills = !s_Options.AntiviralPills; break; //@@MP (Release 5-2)
                            case GameOptions.IDs.DIFFICULTY_RESOURCES_AVAILABILITY: //@@MP (Release 7-4)
                                if (s_Options.ResourcesAvailability != GameOptions.Resources.LOW)
                                    s_Options.ResourcesAvailability = (GameOptions.Resources)(s_Options.ResourcesAvailability - 1);
                                break;
                            case GameOptions.IDs.DIFFICULTY_SHAMBLERS_UPGRADE:
                                s_Options.ShamblersUpgrade = !s_Options.ShamblersUpgrade;
                                break;
                            case GameOptions.IDs.DIFFICULTY_SKELETONS_UPGRADE:
                                s_Options.SkeletonsUpgrade = !s_Options.SkeletonsUpgrade;
                                break;
                            case GameOptions.IDs.DIFFICULTY_BACKPACKS: s_Options.BackpacksEnabled = !s_Options.BackpacksEnabled; break; //@@MP (Release 8-2)
                        }
                        break;
                    case Keys.Right:
                        switch ((GameOptions.IDs)list[selected])
                        {
                            case GameOptions.IDs.DIFFICULTY_RESCUE_DAY: s_Options.VisibleRescueDay += 1; break;
                            case GameOptions.IDs.DIFFICULTY_LIVING_DAMAGE_PERCENT: s_Options.LivingDamagePercent += 25; break;
                            case GameOptions.IDs.DIFFICULTY_UNDEAD_DAMAGE_PERCENT: s_Options.UndeadDamagePercent += 25; break;
                            case GameOptions.IDs.DIFFICULTY_MAX_CIVILIANS: s_Options.MaxCivilians += 5; break;
                            case GameOptions.IDs.DIFFICULTY_MAX_UNDEADS: s_Options.MaxUndeads += 10; break;
                            case GameOptions.IDs.DIFFICULTY_DAY_ZERO_UNDEADS_PERCENT: s_Options.DayZeroUndeadsPercent += 5; break;
                            case GameOptions.IDs.DIFFICULTY_ZOMBIE_INVASION_DAILY_INCREASE: ++s_Options.ZombieInvasionDailyIncrease; break;
                            case GameOptions.IDs.DIFFICULTY_NPC_CAN_STARVE_TO_DEATH: s_Options.NPCCanStarveToDeath = !s_Options.NPCCanStarveToDeath; break;
                            case GameOptions.IDs.DIFFICULTY_STARVED_ZOMBIFICATION: s_Options.StarvedZombification = !s_Options.StarvedZombification; break;
                            case GameOptions.IDs.DIFFICULTY_ZOMBIFICATION_CHANCE: s_Options.ZombificationChance += 5; break;
                            case GameOptions.IDs.DIFFICULTY_ALLOW_UNDEADS_EVOLUTION:
                                s_Options.AllowUndeadsEvolution = !s_Options.AllowUndeadsEvolution;
                                break;
                            case GameOptions.IDs.DIFFICULTY_UNDEADS_UPGRADE_DAYS:
                                if (s_Options.ZombifiedsUpgradeDays != GameOptions.ZupDays._COUNT - 1)
                                    s_Options.ZombifiedsUpgradeDays = (GameOptions.ZupDays)(s_Options.ZombifiedsUpgradeDays + 1);
                                break;
                            case GameOptions.IDs.DIFFICULTY_SANITY: s_Options.IsSanityEnabled = !s_Options.IsSanityEnabled; break; //@@MP (Release 1)
                            case GameOptions.IDs.DIFFICULTY_AGGRESSIVE_HUNGRY_CIVILIANS: s_Options.IsAggressiveHungryCiviliansOn = !s_Options.IsAggressiveHungryCiviliansOn; break;
                            case GameOptions.IDs.DIFFICULTY_NATGUARD_FACTOR: s_Options.NatGuardFactor += 10; break;
                            case GameOptions.IDs.DIFFICULTY_BLACKOPS_RAIDS: s_Options.BlackOpsRaidsEnabled = !s_Options.BlackOpsRaidsEnabled; break; //@@MP (Release 7-5)
                            case GameOptions.IDs.DIFFICULTY_SUPPLIESDROP_FACTOR: s_Options.SuppliesDropFactor += 10; break;
                            case GameOptions.IDs.DIFFICULTY_ANTIVIRAL_PILLS: s_Options.AntiviralPills = !s_Options.AntiviralPills; break; //@@MP (Release 5-2)
                            case GameOptions.IDs.DIFFICULTY_RESOURCES_AVAILABILITY: //@@MP (Release 7-4)
                                if (s_Options.ResourcesAvailability != GameOptions.Resources.HIGH)
                                    s_Options.ResourcesAvailability = (GameOptions.Resources)(s_Options.ResourcesAvailability + 1);
                                break;
                            case GameOptions.IDs.DIFFICULTY_SHAMBLERS_UPGRADE:
                                s_Options.ShamblersUpgrade = !s_Options.ShamblersUpgrade;
                                break;
                            case GameOptions.IDs.DIFFICULTY_SKELETONS_UPGRADE:
                                s_Options.SkeletonsUpgrade = !s_Options.SkeletonsUpgrade;
                                break;
                            case GameOptions.IDs.DIFFICULTY_BACKPACKS: s_Options.BackpacksEnabled = !s_Options.BackpacksEnabled; break; //@@MP (Release 8-2)
                        }
                        break;
                }
            }
            while (loop);

            // apply options.
            if (choiceDone)
            {
                //lock in the rescue day according to what the player chose
                if (s_Options.VisibleRescueDay == 6) //user chose for a random day
                    s_Options.HiddenRescueDay = new Random().Next(14, 28);
                else
                    s_Options.HiddenRescueDay = s_Options.VisibleRescueDay; //save

                ApplyOptions();
                SaveOptions();
            }
            else
                LoadOptions(); //has the effect of dropping any changes to the settings. this ensure we can't tweak difficulty then load into a saved game that was started with different settings (ie cheat)

            chosenDay = s_Options.HiddenRescueDay;
            return choiceDone;
        }
        #endregion

        void StartNewGame(string suppliedName) //@@MP - added parameter for user to supply a name (Release 5-7)
        {
            bool isUndead = m_CharGen.IsUndead;
            m_MusicManager.StopAll();

            // generate world.
            bool worldMade = false;
            do
            {
                worldMade = GenerateWorld(true, s_Options.CitySize, suppliedName); //@@MP - added parameter for user to supply a name (Release 5-7)
            }
            while (worldMade == false);
            CheckAmbientSFX(m_Player.Location.Map); //@@MP (Release 5-3)

#if DEBUG
            m_TownGenerator.GiveStartingSkillToActor(m_Player, Skills.IDs.HAULER);
            m_TownGenerator.GiveStartingSkillToActor(m_Player, Skills.IDs.HAULER);
            m_TownGenerator.GiveStartingSkillToActor(m_Player, Skills.IDs.HAULER);
            m_TownGenerator.GiveStartingSkillToActor(m_Player, Skills.IDs.LEADERSHIP);
            m_TownGenerator.GiveStartingSkillToActor(m_Player, Skills.IDs.LEADERSHIP);
            m_TownGenerator.GiveStartingSkillToActor(m_Player, Skills.IDs.LEADERSHIP);

            /*Item nvg = new ItemLight(GameItems.NIGHT_VISION);
            m_Player.Inventory.AddAll(nvg);
            Item binoc = new ItemLight(GameItems.BINOCULARS);
            m_Player.Inventory.AddAll(binoc);*/
            Item gun = new ItemRangedWeapon(GameItems.MINIGUN);
            m_Player.Inventory.AddAll(gun);
            Item backpack = new ItemBackpack(GameItems.WAIST_POUCH);
            m_Player.Inventory.AddAll(backpack);
            /*Item ammo = new ItemAmmo(GameItems.AMMO_FUEL);
            m_Player.Inventory.AddAll(ammo);
            Item set = new Item(GameItems.SIPHON_KIT);
            m_Player.Inventory.AddAll(set);
            Item liquor1 = new ItemMedicine(GameItems.ALCOHOL_BEER_CAN_BLUE);
            liquor1.Quantity = 6;
            m_Player.Inventory.AddAll(liquor1);
            Item fb = new ItemGrenade(GameItems.FLASHBANG, GameItems.FLASHBANG_PRIMED);
            m_Player.Inventory.AddAll(fb);
            Item saw = new ItemMeleeWeapon(GameItems.CHAINSAW);
            m_Player.Inventory.AddAll(saw);
            Item flares = new Item(GameItems.FLARES_KIT);
            flares.IsForbiddenToAI = true;
            m_Player.Inventory.AddAll(flares);
            Item glowsticks = new Item(GameItems.CANDLES_BOX);
            glowsticks.IsForbiddenToAI = true;
            m_Player.Inventory.AddAll(glowsticks);
            Item suit = new ItemBodyArmor(GameItems.FIRE_HAZARD_SUIT);
            m_Player.Inventory.AddAll(suit);
            Item molo = new ItemGrenade(GameItems.MOLOTOV, GameItems.MOLOTOV_PRIMED);
            m_Player.Inventory.AddAll(molo);
            Item liquor1 = new Item(GameItems.LIQUOR_AMBER);
            m_Player.Inventory.AddAll(liquor1);*/
            Item torch = new ItemLight(GameItems.BIG_FLASHLIGHT);
            m_Player.Inventory.AddAll(torch);
            /*Item meds = new ItemMedicine(GameItems.ENERGY_DRINK);
            m_Player.Inventory.AddAll(meds);*/
            //m_TownGenerator.GiveStartingSkillToActor(m_Player, Skills.IDs.CARPENTRY);
#else
            // grant some starting items based on difficulty  //@@MP (Release 7-4)
            switch (s_Options.ResourcesAvailability)
            {
                case GameOptions.Resources.HIGH:
                    Item groceries = new ItemFood(GameItems.GROCERIES);
                    m_Player.Inventory.AddAll(groceries);
                    Item melee = new ItemMeleeWeapon(GameItems.IMPROVISED_CLUB);
                    break;
                case GameOptions.Resources.MED:
                    Item snack = new ItemFood(GameItems.SNACK_BAR);
                    snack.Quantity = 2;
                    m_Player.Inventory.AddAll(snack);
                    break;
                case GameOptions.Resources.LOW:
                    //nothing
                    break;
            }
#endif

            // scoring : hello there.
            m_Session.Scoring.AddVisit(m_Player.Location.Map); //@@MP - unused parameter (Release 5-7)
            m_Session.Scoring.AddEvent(m_Session.WorldTime.TurnCounter, String.Format(isUndead ? "Rose in {0}." : "Woke up in {0}.", m_Player.Location.Map.Name));
            m_Session.Scoring.GameMode = Session.DescShortGameMode(m_Session.GameMode); //@@MP (Release 5-2)

            // setup proper scoring mode.
            m_Session.Scoring.Side = (isUndead ? DifficultySide.FOR_UNDEAD : DifficultySide.FOR_SURVIVOR);

            // welcome banner.
            ClearMessages();
            ClearMessagesHistory();
            AddMessage(new Message("*** Welcome to Rogue Survivor: Still Alive ***", 0, Color.LightGreen));
            AddMessage(new Message("**********************************************", 0, Color.LightGreen));
            AddMessage(new Message(String.Format("Press {0} for help", s_KeyBindings.GetFriendlyFormat(PlayerCommand.HELP_MODE)), 0, Color.LightGreen));
            AddMessage(new Message(String.Format("Press {0} to redefine keybindings", s_KeyBindings.GetFriendlyFormat(PlayerCommand.KEYBINDING_MODE)), 0, Color.LightGreen));
            AddMessage(new Message(String.Format("Press {0} for a legend of icons", s_KeyBindings.GetFriendlyFormat(PlayerCommand.ICONS_LEGEND)), 0, Color.LightGreen));
            int iTip = m_Rules.Roll(0, GameTips.TIPS.Length);
            AddMessage(new Message(String.Format("TIP: {0} ", GameTips.TIPS[iTip]), 0, Color.LightGreen)); //@@MP (Release 6-3)
            AddMessage(new Message("<press ENTER>", 0, Color.Yellow));
            //RefreshPlayer();
            RedrawPlayScreen();
            WaitEnter();

            // advisor on?
            if (s_Options.IsAdvisorEnabled)
            {
                ClearMessages();
                ClearMessagesHistory();
                if (m_Player.Model.Abilities.IsUndead) // alpha10 not if undead
                {
                    AddMessage(new Message("The Advisor is enabled but there are no hints for playing the undead.", 0, Color.Red));
                }
                else
                {
                    AddMessage(new Message("The Advisor is enabled and will give you hints during the game.", 0, Color.LightGreen));
                    AddMessage(new Message("The hints help a beginner to learn the controls.", 0, Color.LightGreen));
                    AddMessage(new Message("You can disable the Advisor in the Options menu.", 0, Color.LightGreen));
                }
                AddMessage(new Message(String.Format("Press {0} during the game to change the options.", s_KeyBindings.GetFriendlyFormat(PlayerCommand.OPTIONS_MODE)), 0, Color.LightGreen));
                AddMessage(new Message("<press ENTER>", 0, Color.Yellow));
                RedrawPlayScreen();
                WaitEnter();
            }

            //@@MP - tweaked opening sequence (Release 6-1)
            ClearMessages();
            ClearMessagesHistory();
            RefreshPlayer();
            AddMessage(new Message(String.Format(isUndead ? "{0} rises..." : "{0} hears commotion...", m_Player.Name), 0, Color.Red));
            AddMessage(new Message(String.Format(isUndead ? "Hungry..." : "Oh my god! The world has gone to hell!", m_Player.Name), 0, Color.Red)); //@@MP (Release 6-3)
            AddMessage(new Message(String.Format(isUndead ? "Must eat..." : "I need to find a way out of here!", m_Player.Name), 0, Color.Red)); //@@MP (Release 6-3)
            AddMessage(new Message(String.Format(isUndead ? "Hungry..." : "Surely the army will send a rescue force...", m_Player.Name), 0, Color.Red)); //@@MP (Release 6-3)
            RedrawPlayScreen();

            /*// wake up!
            ClearMessages();
            ClearMessagesHistory();
            RedrawPlayScreen();*/

            // alpha10.1 reset/cleanup bot from previous session
#if DEBUG
            if (m_isBotMode)
                BotReleaseControl();
#endif

            // start simulation thread.
            StopSimThread(false);  // alpha10 stop-start
            StartSimThread();
        }

        #region GENERATING WORLD
        private bool GenerateWorld(bool isVerbose, int size, string suppliedName) //@@MP - added parameter for user to supply a name (Release 5-7)
        {
            // say so.
            if (isVerbose)
            {
                m_UI.UI_Clear(Color.Black);
                m_UI.UI_DrawStringBold(Color.White, "Generating game world...", 0, 0);
                m_UI.UI_Repaint();
            }

            //////////////////////
            // Create blank world
            //////////////////////
            if (isVerbose)
            {
                m_UI.UI_Clear(Color.Black);
                m_UI.UI_DrawStringBold(Color.White, "Creating empty world...", 0, 0);
                m_UI.UI_Repaint();
            }
            m_Session.World = new World(size);
            World world = m_Session.World;

            ////////////////////////
            // Roll initial weather
            ////////////////////////
            world.Weather = (Weather)m_Rules.Roll((int)Weather._FIRST, (int)Weather._COUNT - 1); //@@MP - removed the chance for Heavy Rain (Release 7-6)

            //////////////////////////////////////////////
            // Roll locations of special buildings.
            // Only ONE special building max per district.
            //////////////////////////////////////////////
            List<Point> noSpecialDistricts = new List<Point>();
            for (int x = 0; x < world.Size; x++)
                for (int y = 0; y < world.Size; y++)
                    noSpecialDistricts.Add(new Point(x, y));

            Point policeStationDistrictPos = noSpecialDistricts[m_Rules.Roll(0, noSpecialDistricts.Count)];
            noSpecialDistricts.Remove(policeStationDistrictPos);

            Point hospitalDistrictPos = noSpecialDistricts[m_Rules.Roll(0, noSpecialDistricts.Count)];
            noSpecialDistricts.Remove(hospitalDistrictPos);

            Point mallDistrictPos = noSpecialDistricts[m_Rules.Roll(0, noSpecialDistricts.Count)];  //@@MP (Release 7-3)
            noSpecialDistricts.Remove(mallDistrictPos);

            /////////////////////////
            // Create districts maps
            /////////////////////////
            // Surface, Sewers and Subways.
            #region
            for (int x = 0; x < world.Size; x++)
            {
                for (int y = 0; y < world.Size; y++)
                {
                    if (isVerbose)
                    {
                        m_UI.UI_Clear(Color.Black);
                        m_UI.UI_DrawStringBold(Color.White, String.Format("Creating District@{0}...", World.CoordToString(x, y)), 0, 0);
                        m_UI.UI_Repaint();
                    }

                    // create the district.
                    District district = new District(new Point(x, y), GenerateDistrictKind(x, y)); //@@MP - unused parameter (Release 5-7)
                    world[x, y] = district;

                    // create the entry map.
                    district.EntryMap = GenerateDistrictEntryMap(world, district, policeStationDistrictPos, hospitalDistrictPos, mallDistrictPos);
                    district.Name = district.EntryMap.Name;

                    // create other maps.
                    // - sewers
                    Map sewers = GenerateDistrictSewersMap(district);
                    district.SewersMap = sewers;
                    // - subway (only in the middle district line)
                    if (y == world.Size / 2)
                    {
                        Map subwayMap = GenerateDistrictSubwayMap(district);
                        district.SubwayMap = subwayMap;
                    }
                }
            }
            #endregion

            ///////////////
            // Unique Maps
            ///////////////
            if (isVerbose)
            {
                m_UI.UI_Clear(Color.Black);
                m_UI.UI_DrawStringBold(Color.White, "Generating unique maps...", 0, 0);
                m_UI.UI_Repaint();
            }
            m_Session.UniqueMaps.ArmyBase = CreateUniqueMap_ArmyUndegroundBase(world); //@MP (Release 6-3)
            if (m_Session.UniqueMaps.ArmyBase == null)
                return false; //@@MP - the army base couln't be generated for some reason
            m_Session.UniqueMaps.CHARUndergroundFacility = CreateUniqueMap_CHARUndegroundFacility(world);
            if (m_Session.UniqueMaps.CHARUndergroundFacility == null)
                return false; //@@MP - the char base couldn't be generated for some reason (Release 6-3)

            /////////////////
            // Unique Actors
            /////////////////
            if (isVerbose)
            {
                m_UI.UI_Clear(Color.Black);
                m_UI.UI_DrawStringBold(Color.White, "Generating unique actors...", 0, 0);
                m_UI.UI_Repaint();
            }
            m_Session.UniqueActors.TheSewersThing = SpawnUniqueSewersThing(world);

            // alpha10 Make all uniques npcs invincible until spotted
            foreach (UniqueActor uniqueActor in m_Session.UniqueActors.ToArray())
                uniqueActor.TheActor.IsInvincible = true;

            /////////////////
            // Unique Items
            /////////////////
            m_Session.UniqueItems.TheSubwayWorkerBadge = SpawnUniqueSubwayWorkerBadge(world); // "Subway Worker Badge" - somewhere on the subway tracks...
            m_Session.UniqueItems.TheArmyOfficePass = SpawnUniqueArmyOfficePass(); //@@MP - access card for the army offices (Release 6-3)

            //////////////////
            // Link districts
            //////////////////
            #region
            for (int x = 0; x < world.Size; x++)
            {
                for (int y = 0; y < world.Size; y++)
                {
                    if (isVerbose)
                    {
                        m_UI.UI_Clear(Color.Black);
                        m_UI.UI_DrawStringBold(Color.White, String.Format("Linking District@{0}...", World.CoordToString(x, y)), 0, 0);
                        m_UI.UI_Repaint();
                    }

                    #region Entry maps (surface)
                    // add exits (from and to).
                    Map map = world[x, y].EntryMap;

                    if (y > 0)
                    {
                        // north.
                        Map toMap = world[x, y - 1].EntryMap;
                        for (int fromX = 0; fromX < map.Width; fromX++)
                        {
                            int toX = fromX;
                            if (toX >= toMap.Width)
                                continue;
                            // link?
                            if (m_Rules.RollChance(DISTRICT_EXIT_CHANCE_PER_TILE))
                            {
                                Point ptMapFrom = new Point(fromX, -1);
                                Point ptMapTo = new Point(fromX, toMap.Height - 1);
                                Point ptFromMapFrom = new Point(fromX, toMap.Height);
                                Point ptFromMapTo = new Point(fromX, 0);
                                if (CheckIfExitIsGood(toMap, ptMapTo) && CheckIfExitIsGood(map, ptFromMapTo)) //(map, ptMapFrom, ) && (toMap, ptFromMapFrom, )
                                {
                                    GenerateExit(map, ptMapFrom, toMap, ptMapTo);
                                    GenerateExit(toMap, ptFromMapFrom, map, ptFromMapTo);
                                }
                            }
                        }
                    }
                    if (x > 0)
                    {
                        // west.
                        Map toMap = world[x - 1, y].EntryMap;
                        for (int fromY = 0; fromY < map.Height; fromY++)
                        {
                            int toY = fromY;
                            if (toY >= toMap.Height)
                                continue;
                            // link?
                            if (m_Rules.RollChance(DISTRICT_EXIT_CHANCE_PER_TILE))
                            {
                                Point ptMapFrom = new Point(-1, fromY);
                                Point ptMapTo = new Point(toMap.Width - 1, fromY);
                                Point ptFromMapFrom = new Point(toMap.Width, fromY);
                                Point ptFromMapTo = new Point(0, fromY);
                                if (CheckIfExitIsGood(toMap, ptMapTo) && CheckIfExitIsGood(map, ptFromMapTo)) //(map, ptMapFrom, ) && (toMap, ptFromMapFrom, )
                                {
                                    GenerateExit(map, ptMapFrom, toMap, ptMapTo);
                                    GenerateExit(toMap, ptFromMapFrom, map, ptFromMapTo);
                                }
                            }
                        }
                    }
                    #endregion

                    #region Sewers
                    map = world[x, y].SewersMap;
                    if (y > 0)
                    {
                        // north.
                        Map toMap = world[x, y - 1].SewersMap;
                        for (int fromX = 0; fromX < map.Width; fromX++)
                        {
                            int toX = fromX;
                            if (toX >= toMap.Width)
                                continue;
                            Point ptMapFrom = new Point(fromX, -1);
                            Point ptMapTo = new Point(fromX, toMap.Height - 1);
                            Point ptFromMapFrom = new Point(fromX, toMap.Height);
                            Point ptFromMapTo = new Point(fromX, 0);
                            GenerateExit(map, ptMapFrom, toMap, ptMapTo);
                            GenerateExit(toMap, ptFromMapFrom, map, ptFromMapTo);
                        }
                    }
                    if (x > 0)
                    {
                        // west.
                        Map toMap = world[x - 1, y].SewersMap;
                        for (int fromY = 0; fromY < map.Height; fromY++)
                        {
                            int toY = fromY;
                            if (toY >= toMap.Height)
                                continue;

                            Point ptMapFrom = new Point(-1, fromY);
                            Point ptMapTo = new Point(toMap.Width - 1, fromY);
                            Point ptFromMapFrom = new Point(toMap.Width, fromY);
                            Point ptFromMapTo = new Point(0, fromY);

                            GenerateExit(map, ptMapFrom, toMap, ptMapTo);
                            GenerateExit(toMap, ptFromMapFrom, map, ptFromMapTo);

                        }
                    }
                    #endregion

                    #region Subways
                    map = world[x, y].SubwayMap;
                    if (map != null)
                    {
                        if (x > 0)
                        {
                            // west.
                            Map toMap = world[x - 1, y].SubwayMap;
                            for (int fromY = 0; fromY < map.Height; fromY++)
                            {
                                int toY = fromY;
                                if (toY >= toMap.Height)
                                    continue;

                                Point ptMapFrom = new Point(-1, fromY);
                                Point ptMapTo = new Point(toMap.Width - 1, fromY);
                                Point ptFromMapFrom = new Point(toMap.Width, fromY);
                                Point ptFromMapTo = new Point(0, fromY);

                                if (!map.IsWalkable(map.Width - 1, fromY))
                                    continue;
                                if (!toMap.IsWalkable(0, fromY))
                                    continue;

                                GenerateExit(map, ptMapFrom, toMap, ptMapTo);
                                GenerateExit(toMap, ptFromMapFrom, map, ptFromMapTo);

                            }
                        }
                    }
                    #endregion
                }
            }
            #endregion

            //////////////////////////////////////////
            // Easter egg: "roguedjack was here" tag.
            //////////////////////////////////////////
            #region
            Map easterEggTagMap = world[0, 0].SewersMap;
            easterEggTagMap.RemoveMapObjectAt(1, 1);
            easterEggTagMap.GetTileAt(1, 1).RemoveAllDecorations();
            easterEggTagMap.GetTileAt(1, 1).AddDecoration(GameImages.DECO_ROGUEDJACK_TAG);
            #endregion

            //////////////////////////////////////////
            // Pick location for helicopter rescue //@@MP (Release 6-3)
            //////////////////////////////////////////
            #region
            if (isVerbose)
            {
                m_UI.UI_Clear(Color.Black);
                m_UI.UI_DrawStringBold(Color.White, "Picking helicopter location...", 0, 0);
                m_UI.UI_Repaint();
            }
            // 1. Find all green districts
            // 2. Pick one green district at random.
            // 3. Find a clear spot for helicopter landing (4x2 tiles).

            // 1. Find all green districts with offices.
            List<District> goodDistricts = null;
            for (int x = 0; x < world.Size; x++)
                for (int y = 0; y < world.Size; y++)
                {
                    if (world[x, y].Kind == DistrictKind.GREEN)
                    {
                        bool hasPark = false;
                        foreach (Zone z in world[x, y].EntryMap.Zones)
                        {
                            if (z.Name.Contains("Park"))
                            {
                                hasPark = true;
                                break;
                            }
                        }
                        if (hasPark)
                        {
                            if (goodDistricts == null)
                                goodDistricts = new List<District>();
                            goodDistricts.Add(world[x, y]);
                        }
                    }
                }

            // 2. Pick one green district at random.
            if (goodDistricts == null)
            {
#if DEBUG
                throw new InvalidOperationException("world generation failure: no green district spot for helicopter landing");
#else
                Logger.WriteLine(Logger.Stage.RUN_MAIN, "world generation failure: no green district spot for helicopter landing");
                return false;
#endif
            }

            // 3. Find a spot with a 3x1 rectangle of object-free grass tiles.
            bool foundSpot = false;
            District chosenDistrict = null;
            Random r = new Random();
            foreach (int i in Enumerable.Range(0, goodDistricts.Count).OrderBy(x => r.Next()))
            {
                foreach (Zone z in goodDistricts[i].EntryMap.Zones)
                {
                    if (z.Name.Contains("Park") || z.Name.Contains("Graveyard") || z.Name.Contains("court"))
                    {
                        Map heliRescueMap = goodDistricts[i].EntryMap;

                        //check if there's clear space for a chopper to land
                        for (int x = z.Bounds.Left; x < z.Bounds.Right; x++)
                        {
                            for (int y = z.Bounds.Top; y < z.Bounds.Bottom; y++)
                            {
                                if (!TileIsGoodForHelicopter(heliRescueMap, new Point(x, y)) || (heliRescueMap.GetMapObjectAt(x, y) != null))
                                    continue;

                                if (!TileIsGoodForHelicopter(heliRescueMap, new Point(x + 1, y)) || (heliRescueMap.GetMapObjectAt(x + 1, y) != null))
                                    continue;

                                if (!TileIsGoodForHelicopter(heliRescueMap, new Point(x + 2, y)) || (heliRescueMap.GetMapObjectAt(x + 2, y) != null))
                                    continue;

                                //if we've made it this far, we have found a suitable 3*1 rectangle of tiles where the chopper can 'land'
                                foundSpot = true;
                                chosenDistrict = goodDistricts[i];
                                m_Session.ArmyHelicopterRescue_DistrictRef = World.CoordToString(chosenDistrict.WorldPosition.X, chosenDistrict.WorldPosition.Y);
                                m_Session.ArmyHelicopterRescue_Coordinates = new Point(x, y);
                                m_Session.ArmyHelicopterRescue_Map = chosenDistrict.EntryMap; //@@MP (Release 6-4)
                                break;
                            }
                            if (foundSpot == true)
                                break;
                        }
                    }
                    if (foundSpot == true)
                        break;
                }
                if (foundSpot == true)
                    break;
            }
            if (foundSpot == true)
            {
#if DEBUG
                Logger.WriteLine(Logger.Stage.RUN_MAIN, "Found suitable district for helicopter landing: " + (World.CoordToString(chosenDistrict.WorldPosition.X, chosenDistrict.WorldPosition.Y)));
                Logger.WriteLine(Logger.Stage.RUN_MAIN, "Found suitable coords for helicopter landing: {" + m_Session.ArmyHelicopterRescue_Coordinates.X + "}-{" + m_Session.ArmyHelicopterRescue_Coordinates.Y + "}");
#endif
            }
            else
            {
                Logger.WriteLine(Logger.Stage.RUN_MAIN, "Could not find suitable location for helicopter landing");
                return false;
            }
            #endregion

            //////////////////////////////
            // Spawn player on center map
            //////////////////////////////
            if (isVerbose)
            {
                m_UI.UI_Clear(Color.Black);
                m_UI.UI_DrawStringBold(Color.White, "Spawning player...", 0, 0);
                m_UI.UI_Repaint();
            }
            int gridCenter = world.Size / 2;

            Map startMap = world[gridCenter, gridCenter].EntryMap;
            GeneratePlayerOnMap(startMap, m_TownGenerator, suppliedName); //@@MP - added parameter for user to supply a name (Release 5-7)
            SetCurrentMap(startMap);
            RefreshPlayer();
            UpdatePlayerFOV(m_Player);  // to make sure we get notified of actors acting before us in turn 0.
#if DEBUG
            AddDevCheatItems();
            AddDevCheatSkills();
            AddDevMiscStuff();
#endif

            //@@MP - option removed (Release 6-1)
            ////////////////////////
            // Reveal starting map?
            ////////////////////////
            #region
            /*if (s_Options.RevealStartingDistrict)
            {
                List<Zone> startZones = startMap.GetZonesAt(m_Player.Location.Position.X, m_Player.Location.Position.Y);
                if (startZones != null)
                {
                    Zone startZone = startZones[0];
                    for (int x = 0; x < startMap.Width; x++)
                        for (int y = 0; y < startMap.Height; y++)
                        {
                            bool revealThisTile = false;

                            // reveal if:
                            // - starting zone (house).
                            // - outside.

                            // - starting zone (house).
                            List<Zone> zones = startMap.GetZonesAt(x, y);
                            if (zones != null && zones[0] == startZone)
                                revealThisTile = true;
                            else if (!startMap.GetTileAt(x, y).IsInside)
                                revealThisTile = true;

                            // reveal?
                            if (revealThisTile)
                                startMap.GetTileAt(x, y).IsVisited = true;
                        }
                }
            }*/
            #endregion

            /////////
            // Done.
            /////////
            if (isVerbose)
            {
                m_UI.UI_Clear(Color.Black);
                m_UI.UI_DrawStringBold(Color.White, "Generating game world... done!", 0, 0);
                m_UI.UI_Repaint();
            }
            return true;
        }

        private bool TileIsGoodForHelicopter(Map map, Point pt) //@@MP (Release 7-3)
        {
            // good tiles
            if (map.GetTileAt(pt).Model == GameTiles.FLOOR_GRASS || GameTiles.IsSportsCourtTile(map.GetTileAt(pt).Model))
                return true;

            // bad spot.
            return true;
        }

        static bool CheckIfExitIsGood(Map toMap, Point to) //Map fromMap, Point from, ) //@@MP - made static, unused parameter (Release 5-7)
        {
            // Don't if tile not walkable or map object there.
            if (!toMap.GetTileAt(to.X, to.Y).Model.IsWalkable)
                return false;
            if (toMap.GetMapObjectAt(to.X, to.Y) != null)
                return false;

            // good spot.
            return true;
        }

        static void GenerateExit(Map fromMap, Point from, Map toMap, Point to) //@@MP - made static (Release 5-7)
        {
            // add exit.
            fromMap.SetExitAt(from, new Exit(toMap, to));
        }

        #region -Uniques
        UniqueActor SpawnUniqueSewersThing(World world)
        {
            ///////////////////////////////////////////////////////
            // 1. Pick a random sewers map.
            // 2. Create Sewers Thing.
            // 3. Spawn in sewers map.
            // 4. Add warning board in maintenance rooms (if any).
            ///////////////////////////////////////////////////////

            // 1. Pick a random sewers map.
            Map map = world[m_Rules.Roll(0, world.Size), m_Rules.Roll(0, world.Size)].SewersMap;

            // 2. Create Sewers Thing.
            ActorModel model = GameActors.SewersThing;
            Actor actor = model.CreateNamed(GameFactions.TheUndeads, "The Sewers Thing", false, 0);
            actor.IsUnique = true;  //@@MP (Release 7-5)

            // 3. Spawn in sewers map.
            DiceRoller roller = new DiceRoller(map.Seed);
            bool spawned = m_TownGenerator.ActorPlace(roller, 10000, map, actor);
            if (!spawned)
                throw new InvalidOperationException("could not spawn unique The Sewers Thing");

            // 4. Add warning board in maintenance rooms (if any).
            Zone maintenanceZone = map.GetZoneByPartialName(NAME_SEWERS_MAINTENANCE);
            if (maintenanceZone != null)
            {
                m_TownGenerator.MapObjectPlaceInGoodPosition(map, maintenanceZone.Bounds,
                    (pt) => map.IsWalkable(pt.X, pt.Y) && map.GetActorAt(pt) == null && map.GetItemsAt(pt) == null,
                    roller,
                    (pt) => m_TownGenerator.MakeObjBoard(GameImages.OBJ_BOARD,
                        new string[] { "TO SEWER WORKERS :",
                                       "- It lives here.",
                                       "- Do not disturb it.",
                                       //"- Approach with caution.",
                                       "- Watch your back.",
                                       //"- Do not interact with it!",
                                       "- In case of emergency, take refuge here."}));
            }

            // done.
            //Logger.WriteLine(Logger.Stage.RUN_MAIN, String.Format("sewer thing spawned at {0}", actor.Location.Map.District.Name));
            return new UniqueActor() { TheActor = actor, IsSpawned = true };
        }

        UniqueItem SpawnUniqueSubwayWorkerBadge(World world)
        {
            ///////////////////////////////////
            // 1. Pick a random Subway map.
            //    Fails if not found.
            // 2. Pick a position in the rails.
            // 3. Drop it.
            ///////////////////////////////////

            Item it = new Item(GameItems.UNIQUE_SUBWAY_BADGE) { IsUnique = true, IsForbiddenToAI = true };

            // 1. Pick a random Subway map.
            List<Map> allSubways = new List<Map>();
            for (int x = 0; x < world.Size; x++)
                for (int y = 0; y < world.Size; y++)
                    if (world[x, y].HasSubway)
                        allSubways.Add(world[x, y].SubwayMap);
            if (allSubways.Count == 0)
                return new UniqueItem() { TheItem = it, IsSpawned = false };
            Map subway = allSubways[m_Rules.Roll(0, allSubways.Count)];

            // 2. Pick a position in the rails.
            Rectangle railsRect = subway.GetZoneByPartialName(NAME_SUBWAY_RAILS).Bounds;
            Point dropPt = new Point(m_Rules.Roll(railsRect.Left, railsRect.Right), m_Rules.Roll(railsRect.Top, railsRect.Bottom));

            // 3. Drop it.
            subway.DropItemAt(it, dropPt);
            // blood! deceased worker.
            subway.GetTileAt(dropPt).AddDecoration(GameImages.DECO_BLOODIED_FLOOR);

            // done.
            return new UniqueItem() { TheItem = it, IsSpawned = true };
        }

        UniqueItem SpawnUniqueArmyOfficePass() //@@MP (Release 6-3)
        {
            ///////////////////////////////////
            // 1. Select the CHAR underground
            // 2. Pick a clear spot
            // 3. Drop it.
            ///////////////////////////////////

            Item it = new Item(GameItems.UNIQUE_ARMY_ACCESS_BADGE) { IsUnique = true, IsForbiddenToAI = true };

            // 1. Select the CHAR Underground
            Map map = m_Session.UniqueMaps.CHARUndergroundFacility.TheMap;

            // 2. Pick a random position near a lab vat
            foreach (MapObject mapObj in map.MapObjects)
            {
                if (mapObj.ImageID == GameImages.OBJ_CHAR_VAT)
                {
                    Point next = mapObj.Location.Position;
                    foreach (Direction d in Direction.COMPASS)
                    {
                        if (map.IsWalkable(next))
                        {
                            Inventory groundInv = map.GetItemsAt(next);
                            MapObject adjacentObj = map.GetMapObjectAt(next);
                            if (groundInv == null && adjacentObj == null) //looking for a spot clear of items and objects
                            {
                                // 3. Drop it.
                                map.DropItemAt(it, next);
                                SplatterBlood(map, next); // blood of a deceased army member.

                                // done.
#if DEBUG
                                Logger.WriteLine(Logger.Stage.RUN_MAIN, "Army pass location in CHAR underground: " + next.ToString());
#endif
                                return new UniqueItem() { TheItem = it, IsSpawned = true };
                            }
                        }
                        next = mapObj.Location.Position + d;
                    }
                }
            }

            //fall through if no spot was found. (if no spot was found, someting went very wrong)
            throw new InvalidOperationException("Suitable army pass location not found");
            //return new UniqueItem() { TheItem = it, IsSpawned = false };
        }

        UniqueMap CreateUniqueMap_CHARUndegroundFacility(World world)
        {
            ////////////////////////////////////////////////
            // 1. Find all business districts with offices.
            // 2. Pick one business district at random.
            // 3. Generate underground map there.
            ////////////////////////////////////////////////

            // 1. Find all business districts with offices.
            List<District> goodDistricts = null;
            for (int x = 0; x < world.Size; x++)
                for (int y = 0; y < world.Size; y++)
                {
                    if (world[x, y].Kind == DistrictKind.BUSINESS)
                    {
                        bool hasOffice = false;
                        foreach (Zone z in world[x, y].EntryMap.Zones)
                        {
                            if (z.HasGameAttribute(ZoneAttributes.IS_CHAR_OFFICE))
                            {
                                hasOffice = true;
                                break;
                            }
                        }
                        if (hasOffice)
                        {
                            if (goodDistricts == null)
                                goodDistricts = new List<District>();
                            goodDistricts.Add(world[x, y]);
                        }
                    }
                }

            // 2. Pick one business district at random.
            if (goodDistricts == null)
            {
                Logger.WriteLine(Logger.Stage.RUN_MAIN, "world has no business districts with offices"); //@@MP (Release 6-3)
                return null; //@@MP (Release 6-3)
                //throw new InvalidOperationException("world has no business districts with offices");
            }
            District chosenDistrict = goodDistricts[m_Rules.Roll(0, goodDistricts.Count)];

            // 3. Generate underground map there.
            List<Zone> offices = new List<Zone>();
            foreach (Zone z in chosenDistrict.EntryMap.Zones)
            {
                if (z.HasGameAttribute(ZoneAttributes.IS_CHAR_OFFICE))
                {
                    offices.Add(z);
                }
            }
            Zone chosenOffice = offices[m_Rules.Roll(0, offices.Count)];
            Point baseEntryPos;  // alpha10
            Map map = m_TownGenerator.GenerateUniqueMap_CHARUnderground(chosenDistrict.EntryMap, chosenOffice, s_Options.DistrictSize, out baseEntryPos);
            map.District = chosenDistrict;
            map.Name = String.Format("CHAR Underground Facility @{0}-{1}", baseEntryPos.X, baseEntryPos.Y); // alpha10
            chosenDistrict.AddUniqueMap(map);
#if DEBUG
            Logger.WriteLine(Logger.Stage.RUN_MAIN, String.Format("CHAR base at {0}", chosenDistrict.Name));
#endif
            return new UniqueMap() { TheMap = map };

        }

        UniqueMap CreateUniqueMap_ArmyUndegroundBase(World world) //@@MP (Release 6-3)
        {
            ////////////////////////////////////////////////
            // 1. Find all green districts with army offices.
            // 2. Pick one green district at random.
            // 3. Generate underground map there.
            ////////////////////////////////////////////////

            // 1. Find all green districts with offices.
            List<District> goodDistricts = null;
            for (int x = 0; x < world.Size; x++)
                for (int y = 0; y < world.Size; y++)
                {
                    if (world[x, y].Kind == DistrictKind.GREEN)// || world[x, y].Kind == DistrictKind.GENERAL)
                    {
                        bool hasOffice = false;
                        foreach (Zone z in world[x, y].EntryMap.Zones)
                        {
                            if (z.HasGameAttribute(ZoneAttributes.IS_ARMY_OFFICE))
                            {
                                hasOffice = true;
                                break;
                            }
                        }
                        if (hasOffice)
                        {
                            if (goodDistricts == null)
                                goodDistricts = new List<District>();
                            goodDistricts.Add(world[x, y]);
                        }
                    }
                }

            // 2. Pick one green district at random.
            if (goodDistricts == null)
            {
                Logger.WriteLine(Logger.Stage.RUN_MAIN, "world generation failure: no green districts with army offices");
                return null;
                //throw new InvalidOperationException("world generation failure: no green districts with army offices");
            }
            District chosenDistrict = goodDistricts[m_Rules.Roll(0, goodDistricts.Count)];

            // 3. Generate underground map there.
            List<Zone> offices = new List<Zone>();
            foreach (Zone z in chosenDistrict.EntryMap.Zones)
            {
                if (z.HasGameAttribute(ZoneAttributes.IS_ARMY_OFFICE))
                {
                    offices.Add(z);
                }
            }
            Zone chosenOffice = offices[m_Rules.Roll(0, offices.Count)];
            Point baseEntryPos;  // alpha10
            Map map = m_TownGenerator.GenerateUniqueMap_ArmyBase(chosenDistrict.EntryMap, chosenOffice, s_Options.DistrictSize, out baseEntryPos);
            map.District = chosenDistrict;
            map.Name = String.Format("Army Base @{0}-{1}", baseEntryPos.X, baseEntryPos.Y);
            chosenDistrict.AddUniqueMap(map);
#if DEBUG
            Logger.WriteLine(Logger.Stage.RUN_MAIN, String.Format("Army base at {0}", chosenDistrict.Name));
#endif
            return new UniqueMap() { TheMap = map };
        }
        #endregion

        #region -District Maps
        DistrictKind GenerateDistrictKind(int gridX, int gridY) //@@MP - unused parameter (Release 5-7)
        {
            // Decide district kind - some districts are harcoded:
            //   - (0,0) : always Business.
            if (gridX == 0 && gridY == 0)
                return DistrictKind.BUSINESS;
            else
                return (DistrictKind)m_Rules.Roll((int)DistrictKind._FIRST, (int)DistrictKind._COUNT);
        }

        Map GenerateDistrictEntryMap(World world, District district, Point policeStationDistrictPos, Point hospitalDistrictPos, Point mallDistrictPos)
        {
            int gridX = district.WorldPosition.X;
            int gridY = district.WorldPosition.Y;

            ///////////////////////////
            // 1. Compute unique seed.
            // 2. Set params for kind.
            // 3. Generate map.
            ///////////////////////////

            // 1. Compute unique seed.
            int gridSeed = m_Session.Seed + gridY * world.Size + gridX;

            // 3. Set gen params.
            #region
            BaseTownGenerator.Parameters genParams = BaseTownGenerator.DEFAULT_PARAMS;
            genParams.MapWidth = genParams.MapHeight = s_Options.DistrictSize;
            genParams.District = district;
            int factor = 8;
            string kindName = "District";
            switch (district.Kind)
            {
                case DistrictKind.SHOPPING:
                    // more shops, less other types.
                    kindName = "Shopping District";
                    genParams.CHARBuildingChance /= factor;
                    genParams.ShopBuildingChance *= factor;
                    genParams.ParkBuildingChance /= factor;
                    break;
                case DistrictKind.GREEN:
                    // more parks, less other types.
                    kindName = "Green District";
                    genParams.CHARBuildingChance /= factor;
                    genParams.ParkBuildingChance *= factor;
                    genParams.ShopBuildingChance /= factor;
                    break;
                case DistrictKind.BUSINESS:
                    // more offices, less other types.
                    kindName = "Business District";
                    genParams.CHARBuildingChance *= factor;
                    genParams.ParkBuildingChance /= factor;
                    genParams.ShopBuildingChance /= factor;
                    break;
                case DistrictKind.RESIDENTIAL:
                    // more housings, less other types.
                    kindName = "Residential District";
                    genParams.CHARBuildingChance /= factor;
                    genParams.ParkBuildingChance /= factor;
                    genParams.ShopBuildingChance /= factor;
                    break;
                case DistrictKind.GENERAL:
                    // use default params.
                    kindName = "District";
                    break;
                default:
                    throw new ArgumentOutOfRangeException("district", "unhandled district kind");
            }

            // Special params.
            genParams.GeneratePoliceStation = (district.WorldPosition == policeStationDistrictPos);
            genParams.GenerateHospital = (district.WorldPosition == hospitalDistrictPos);
            genParams.GenerateShoppingMall = (district.WorldPosition == mallDistrictPos); //@@MP (Release 7-3)
            #endregion

            // 4. Generate map.
            BaseTownGenerator.Parameters prevParams = m_TownGenerator.Params;
            m_TownGenerator.Params = genParams;
            Map map = m_TownGenerator.Generate(gridSeed);
            map.Name = String.Format("{0}@{1}", kindName, World.CoordToString(gridX, gridY));
            m_TownGenerator.Params = prevParams;

            // done.
            return map;
        }

        Map GenerateDistrictSewersMap(District district)
        {
            // Compute uniqueseed.
            int sewersSeed = (district.EntryMap.Seed << 1) ^ district.EntryMap.Seed;

            // Generate map.
            Map sewers = m_TownGenerator.GenerateSewersMap(sewersSeed, district);
            sewers.Name = String.Format("Sewers@{0}-{1}", district.WorldPosition.X, district.WorldPosition.Y);

            // done.
            return sewers;
        }

        Map GenerateDistrictSubwayMap(District district)
        {
            // Compute uniqueseed.
            int subwaySeed = (district.EntryMap.Seed << 2) ^ district.EntryMap.Seed;

            // Generate map.
            Map subway = m_TownGenerator.GenerateSubwayMap(subwaySeed, district);
            subway.Name = String.Format("Subway@{0}-{1}", district.WorldPosition.X, district.WorldPosition.Y);

            // done.
            return subway;
        }
        #endregion

        void GeneratePlayerOnMap(Map map, BaseTownGenerator townGen, string suppliedName) //@@MP - added parameter for user to supply a name (Release 5-7)
        {
            DiceRoller roller = new DiceRoller(map.Seed);

            /////////////////////////////////////////////////////
            // Create player actor : living/undead x male/female
            /////////////////////////////////////////////////////
            #region
            ActorModel playerModel;
            Actor player;
            if (m_CharGen.IsUndead)
            {
                // Handle specific undead type.
                // Zombified : need living, then zombify.
                switch (m_CharGen.UndeadModel)
                {
                    case GameActors.IDs.UNDEAD_SKELETON:
                        {
                            // Create the Skeleton.
                            player = m_GameActors.Skeleton.CreateNumberedName(m_GameFactions.TheUndeads, 0);
                            break;
                        }

                    case GameActors.IDs.UNDEAD_ZOMBIE:
                        {
                            // Create the Zombie.
                            player = m_GameActors.Zombie.CreateNumberedName(m_GameFactions.TheUndeads, 0);
                            break;
                        }

                    case GameActors.IDs.UNDEAD_MALE_ZOMBIFIED:
                    case GameActors.IDs.UNDEAD_FEMALE_ZOMBIFIED:
                        {
                            // First create as living.
                            playerModel = m_CharGen.IsMale ? m_GameActors.MaleCivilian : m_GameActors.FemaleCivilian;
                            player = playerModel.CreateAnonymous(m_GameFactions.TheCivilians, 0);
                            townGen.DressCivilian(roller, player);
                            townGen.GiveNameToActor(roller, player);
                            // Then zombify.
                            player = Zombify(null, player, player.Location.Map, player.Location.Position, true);
                            break;
                        }

                    case GameActors.IDs.UNDEAD_ZOMBIE_MASTER:
                        {
                            // Create the ZM.
                            player = m_GameActors.ZombieMaster.CreateNumberedName(m_GameFactions.TheUndeads, 0);
                            break;
                        }
                    default:
                        throw new InvalidOperationException("unhandled undeadModel");
                }

                // Then make sure player related stuff are setup properly.
                PrepareActorForPlayerControl(player);
            }
            else
            {
                // Create living.
                playerModel = m_CharGen.IsMale ? m_GameActors.MaleCivilian : m_GameActors.FemaleCivilian;
                player = playerModel.CreateAnonymous(m_GameFactions.TheCivilians, 0);
                townGen.DressCivilian(roller, player);
                if (!string.IsNullOrEmpty(suppliedName)) //@@MP - gave player ability to supply their name (Release 5-7)
                    player.Name = suppliedName;
                else //generate one randomly
                    townGen.GiveNameToActor(roller, player);
                player.Sheet.SkillTable.AddOrIncreaseSkill((int)m_CharGen.StartingSkill);
                townGen.RecomputeActorStartingStats(player);
                OnSkillUpgrade(player, m_CharGen.StartingSkill);
                // slightly randomize Food and Sleep - 0..25%.
                int foodDeviation = (int)(0.25f * player.FoodPoints);
                player.FoodPoints = player.FoodPoints - m_Rules.Roll(0, foodDeviation);
                int sleepDeviation = (int)(0.25f * player.SleepPoints);
                player.SleepPoints = player.SleepPoints - m_Rules.Roll(0, sleepDeviation);
            }

            player.Controller = new PlayerController();
            #endregion

            /////////////
            // Spawn him.
            /////////////
            #region
            // living: try to spawn inside on a couch, then if failed spawn anywhere inside.
            // undead: spawn outside.
            // NEVER spawn in CHAR or army office!!
            bool preferedSpawnOk = townGen.ActorPlace(roller, 10 * map.Width * map.Height, map, player,
                (pt) =>
                {
                    bool isInside = map.GetTileAt(pt.X, pt.Y).IsInside;
                    if ((m_CharGen.IsUndead && isInside) || (!m_CharGen.IsUndead && !isInside))
                        return false;

                    if (IsInCHAROffice(new Location(map, pt)))
                        return false;

                    if (IsInArmyOffice(new Location(map, pt))) //@@MP (Release 6-5)
                        return false;

                    MapObject mapObj = map.GetMapObjectAt(pt);
                    if (m_CharGen.IsUndead)
                        return mapObj == null;
                    else
                        return mapObj != null && mapObj.IsCouch;
                });

            if (!preferedSpawnOk)
            {
                // no couch, try inside but never in char office.
                bool spawnedInside = townGen.ActorPlace(roller, map.Width * map.Height, map, player,
                    (pt) => map.GetTileAt(pt.X, pt.Y).IsInside && !IsInCHAROffice(new Location(map, pt)) && !IsInArmyOffice(new Location(map, pt))); //@@MP added Army (Release 6-5)

                if (!spawnedInside)
                {
                    // could not spawn inside, do it outside...
                    while (!townGen.ActorPlace(roller, int.MaxValue, map, player, (pt) => !IsInCHAROffice(new Location(map, pt)) && !IsInArmyOffice(new Location(map, pt)))) //@@MP added Army (Release 6-5)
                        ;
                }
            }
            #endregion
        }

        void RefreshPlayer()
        {
            // get player.
            foreach (Actor a in m_Session.CurrentMap.Actors)
            {
                if (a.IsPlayer)
                {
                    m_Player = a;
                    break;
                }
            }

            // compute view.
            if (m_Player != null)
                ComputeViewRect(m_Player.Location.Position);

        }

        static void PrepareActorForPlayerControl(Actor newPlayerAvatar) //@@MP - made static (Release 5-7)
        {
            // inventory && skills.
            if (newPlayerAvatar.Inventory == null)
                newPlayerAvatar.Inventory = new Inventory(1);
            if (newPlayerAvatar.Sheet.SkillTable == null)
                newPlayerAvatar.Sheet.SkillTable = new SkillTable();

            // if follower, leave leader.
            if (newPlayerAvatar.Leader != null)
                newPlayerAvatar.Leader.RemoveFollower(newPlayerAvatar);
        }
        #endregion
        #endregion

        #region 3. GAME FLOW
        /// <summary>
        /// Main game loop.
        /// </summary>
        public void Run()
        {
            // track the main thread for use around simulation  //@@MP (Release 7-1)
            MainThread = Thread.CurrentThread;
            MainThread.Name = "Main Thread";

            // first run inits.
            InitDirectories();

            // load data files.
            LoadDataSkills();
            LoadDataItems();
            LoadDataActors();

            // load options.
            LoadOptions();

            // load hints.
            LoadHints();

            // apply options.
            ApplyOptions(); //@@MP - unused parameter (Release 5-7)

            // load keys.
            LoadKeybindings();

            // load music & sfxs.
            m_UI.UI_Clear(Color.Black);
            m_UI.UI_DrawStringBold(Color.White, "Loading music...", 0, 0);
            m_UI.UI_Repaint();

            #region MUSIC - event or location-specific
            m_MusicManager.Load(GameMusics.ARMY, GameMusics.ARMY_FILE);
            m_MusicManager.Load(GameMusics.BIKER, GameMusics.BIKER_FILE);
            m_MusicManager.Load(GameMusics.BLACK_OPS, GameMusics.BLACK_OPS_FILE);
            m_MusicManager.Load(GameMusics.CHAR_RESEARCHERS, GameMusics.CHAR_RESEARCHERS_FILE);
            m_MusicManager.Load(GameMusics.CHAR_UNDERGROUND_FACILITY, GameMusics.CHAR_UNDERGROUND_FACILITY_FILE);
            m_MusicManager.Load(GameMusics.FIGHT, GameMusics.FIGHT_FILE);
            m_MusicManager.Load(GameMusics.GANGSTA, GameMusics.GANGSTA_FILE);
            m_MusicManager.Load(GameMusics.HEYTHERE, GameMusics.HEYTHERE_FILE);
            m_MusicManager.Load(GameMusics.HOSPITAL, GameMusics.HOSPITAL_FILE);
            m_MusicManager.Load(GameMusics.INSANE, GameMusics.INSANE_FILE);
            m_MusicManager.Load(GameMusics.INTERLUDE, GameMusics.INTERLUDE_FILE);
            m_MusicManager.Load(GameMusics.INTRO, GameMusics.INTRO_FILE);
            m_MusicManager.Load(GameMusics.LIMBO, GameMusics.LIMBO_FILE);
            m_MusicManager.Load(GameMusics.PLAYER_DEATH, GameMusics.PLAYER_DEATH_FILE);
            m_MusicManager.Load(GameMusics.POST_RESCUE, GameMusics.POST_RESCUE_FILE);
            m_MusicManager.Load(GameMusics.SEWERS, GameMusics.SEWERS_FILE);
            m_MusicManager.Load(GameMusics.SHOPPING_MALL, GameMusics.SHOPPING_MALL_FILE);
            m_MusicManager.Load(GameMusics.SLEEP, GameMusics.SLEEP_FILE);
            m_MusicManager.Load(GameMusics.SUBWAY, GameMusics.SUBWAY_FILE);
            m_MusicManager.Load(GameMusics.SURVIVORS, GameMusics.SURVIVORS_FILE);
            m_MusicManager.Load(GameMusics.TEST_MUSIC, GameMusics.TEST_MUSIC_FILE);
            #endregion

            #region BACKGROUND MUSIC
            //@@MP (Release 6-1)
            m_MusicManager.Load(GameMusics.SURFACE, GameMusics.SURFACE_FILE); // alpha10

            //add each to a playlist //@@MP (Release 6-1)
            m_bgMusicPlaylist.Add(GameMusics.SURFACE);
            #endregion

            m_UI.UI_Clear(Color.Black);
            m_UI.UI_DrawStringBold(Color.White, "Loading music... done!", 0, 0);
            m_UI.UI_Repaint();

            m_UI.UI_Clear(Color.Black);
            m_UI.UI_DrawStringBold(Color.White, "Loading sfxs...", 0, 0);
            m_UI.UI_Repaint();

            #region SOUND EFFECTS
            m_SFXManager.Load(GameSounds.UNDEAD_EAT_PLAYER, GameSounds.UNDEAD_EAT_PLAYER_FILE);
            m_SFXManager.Load(GameSounds.NIGHTMARE, GameSounds.NIGHTMARE_FILE);
            m_SFXManager.Load(GameSounds.MELEE_ATTACK_PLAYER, GameSounds.MELEE_ATTACK_PLAYER_FILE);
            m_SFXManager.Load(GameSounds.MELEE_ATTACK_NEARBY, GameSounds.MELEE_ATTACK_NEARBY_FILE);
            m_SFXManager.Load(GameSounds.MELEE_ATTACK_MISS_PLAYER, GameSounds.MELEE_ATTACK_MISS_PLAYER_FILE);
            m_SFXManager.Load(GameSounds.MELEE_ATTACK_MISS_NEARBY, GameSounds.MELEE_ATTACK_MISS_NEARBY_FILE);
            m_SFXManager.Load(GameSounds.PISTOL_SINGLE_SHOT_PLAYER, GameSounds.PISTOL_SINGLE_SHOT_PLAYER_FILE);
            m_SFXManager.Load(GameSounds.PISTOL_RAPID_FIRE_PLAYER, GameSounds.PISTOL_RAPID_FIRE_PLAYER_FILE);
            m_SFXManager.Load(GameSounds.HUNTING_RIFLE_FIRE_PLAYER, GameSounds.HUNTING_RIFLE_FIRE_PLAYER_FILE);
            m_SFXManager.Load(GameSounds.SHOTGUN_FIRE_PLAYER, GameSounds.SHOTGUN_FIRE_PLAYER_FILE);
            m_SFXManager.Load(GameSounds.CROSSBOW_FIRE_PLAYER, GameSounds.CROSSBOW_FIRE_PLAYER_FILE);
            m_SFXManager.Load(GameSounds.PRECISION_RIFLE_FIRE_PLAYER, GameSounds.PRECISION_RIFLE_FIRE_PLAYER_FILE);
            m_SFXManager.Load(GameSounds.REVOLVER_SINGLE_SHOT_PLAYER, GameSounds.REVOLVER_SINGLE_SHOT_PLAYER_FILE);
            m_SFXManager.Load(GameSounds.REVOLVER_RAPID_FIRE_PLAYER, GameSounds.REVOLVER_RAPID_FIRE_PLAYER_FILE);
            m_SFXManager.Load(GameSounds.ARMY_RIFLE_SINGLE_SHOT_PLAYER, GameSounds.ARMY_RIFLE_SINGLE_SHOT_PLAYER_FILE);
            m_SFXManager.Load(GameSounds.ARMY_RIFLE_RAPID_FIRE_PLAYER, GameSounds.ARMY_RIFLE_RAPID_FIRE_PLAYER_FILE);
            m_SFXManager.Load(GameSounds.PISTOL_SINGLE_SHOT_NEARBY, GameSounds.PISTOL_SINGLE_SHOT_NEARBY_FILE);
            m_SFXManager.Load(GameSounds.PISTOL_RAPID_FIRE_NEARBY, GameSounds.PISTOL_RAPID_FIRE_NEARBY_FILE);
            m_SFXManager.Load(GameSounds.HUNTING_RIFLE_FIRE_NEARBY, GameSounds.HUNTING_RIFLE_FIRE_NEARBY_FILE);
            m_SFXManager.Load(GameSounds.SHOTGUN_FIRE_NEARBY, GameSounds.SHOTGUN_FIRE_NEARBY_FILE);
            m_SFXManager.Load(GameSounds.CROSSBOW_FIRE_NEARBY, GameSounds.CROSSBOW_FIRE_NEARBY_FILE);
            m_SFXManager.Load(GameSounds.PRECISION_RIFLE_FIRE_NEARBY, GameSounds.PRECISION_RIFLE_FIRE_NEARBY_FILE);
            m_SFXManager.Load(GameSounds.REVOLVER_SINGLE_SHOT_NEARBY, GameSounds.REVOLVER_SINGLE_SHOT_NEARBY_FILE);
            m_SFXManager.Load(GameSounds.REVOLVER_RAPID_FIRE_NEARBY, GameSounds.REVOLVER_RAPID_FIRE_NEARBY_FILE);
            m_SFXManager.Load(GameSounds.ARMY_RIFLE_SINGLE_SHOT_NEARBY, GameSounds.ARMY_RIFLE_SINGLE_SHOT_NEARBY_FILE);
            m_SFXManager.Load(GameSounds.ARMY_RIFLE_RAPID_FIRE_NEARBY, GameSounds.ARMY_RIFLE_RAPID_FIRE_NEARBY_FILE);
            m_SFXManager.Load(GameSounds.PISTOL_SINGLE_SHOT_FAR, GameSounds.PISTOL_SINGLE_SHOT_FAR_FILE);
            m_SFXManager.Load(GameSounds.PISTOL_RAPID_FIRE_FAR, GameSounds.PISTOL_RAPID_FIRE_FAR_FILE);
            m_SFXManager.Load(GameSounds.HUNTING_RIFLE_FIRE_FAR, GameSounds.HUNTING_RIFLE_FIRE_FAR_FILE);
            m_SFXManager.Load(GameSounds.SHOTGUN_FIRE_FAR, GameSounds.SHOTGUN_FIRE_FAR_FILE);
            m_SFXManager.Load(GameSounds.PRECISION_RIFLE_FIRE_FAR, GameSounds.PRECISION_RIFLE_FIRE_FAR_FILE);
            m_SFXManager.Load(GameSounds.REVOLVER_SINGLE_SHOT_FAR, GameSounds.REVOLVER_SINGLE_SHOT_FAR_FILE);
            m_SFXManager.Load(GameSounds.REVOLVER_RAPID_FIRE_FAR, GameSounds.REVOLVER_RAPID_FIRE_FAR_FILE);
            m_SFXManager.Load(GameSounds.ARMY_RIFLE_SINGLE_SHOT_FAR, GameSounds.ARMY_RIFLE_SINGLE_SHOT_FAR_FILE);
            m_SFXManager.Load(GameSounds.ARMY_RIFLE_RAPID_FIRE_FAR, GameSounds.ARMY_RIFLE_RAPID_FIRE_FAR_FILE);
            m_SFXManager.Load(GameSounds.ARMOR_ZIPPER, GameSounds.ARMOR_ZIPPER_FILE);
            m_SFXManager.Load(GameSounds.EQUIP_GUN_PLAYER, GameSounds.EQUIP_GUN_PLAYER_FILE);
            m_SFXManager.Load(GameSounds.TORCH_CLICK_PLAYER, GameSounds.TORCH_CLICK_PLAYER_FILE);
            m_SFXManager.Load(GameSounds.CLIMB_FENCE_PLAYER, GameSounds.CLIMB_FENCE_PLAYER_FILE);
            m_SFXManager.Load(GameSounds.CLIMB_FENCE_NEARBY, GameSounds.CLIMB_FENCE_NEARBY_FILE);
            m_SFXManager.Load(GameSounds.CLIMB_CAR_PLAYER, GameSounds.CLIMB_CAR_PLAYER_FILE);
            m_SFXManager.Load(GameSounds.CLIMB_CAR_NEARBY, GameSounds.CLIMB_CAR_NEARBY_FILE);
            m_SFXManager.Load(GameSounds.SPRAY_SCENT, GameSounds.SPRAY_SCENT_FILE);
            m_SFXManager.Load(GameSounds.SPRAY_TAG, GameSounds.SPRAY_TAG_FILE);
            m_SFXManager.Load(GameSounds.EAT_FOOD, GameSounds.EAT_FOOD_FILE);
            m_SFXManager.Load(GameSounds.VOMIT_PLAYER, GameSounds.VOMIT_PLAYER_FILE);
            m_SFXManager.Load(GameSounds.GLASS_DOOR, GameSounds.GLASS_DOOR_FILE);
            m_SFXManager.Load(GameSounds.WOODEN_DOOR_OPEN, GameSounds.WOODEN_DOOR_OPEN_FILE);
            m_SFXManager.Load(GameSounds.WOODEN_DOOR_CLOSE, GameSounds.WOODEN_DOOR_CLOSE_FILE);
            m_SFXManager.Load(GameSounds.USE_MEDICINE, GameSounds.USE_MEDICINE_FILE);
            m_SFXManager.Load(GameSounds.USE_PILLS, GameSounds.USE_PILLS_FILE);
            m_SFXManager.Load(GameSounds.SCREAM_NEARBY_01, GameSounds.SCREAM_NEARBY_01_FILE);
            m_SFXManager.Load(GameSounds.SCREAM_NEARBY_02, GameSounds.SCREAM_NEARBY_02_FILE);
            m_SFXManager.Load(GameSounds.SCREAM_NEARBY_03, GameSounds.SCREAM_NEARBY_03_FILE);
            m_SFXManager.Load(GameSounds.SCREAM_NEARBY_04, GameSounds.SCREAM_NEARBY_04_FILE);
            m_SFXManager.Load(GameSounds.SCREAM_NEARBY_05, GameSounds.SCREAM_NEARBY_05_FILE);
            m_SFXManager.Load(GameSounds.SCREAM_NEARBY_07, GameSounds.SCREAM_NEARBY_07_FILE);
            m_SFXManager.Load(GameSounds.SCREAM_NEARBY_08, GameSounds.SCREAM_NEARBY_08_FILE);
            m_SFXManager.Load(GameSounds.SCREAM_NEARBY_09, GameSounds.SCREAM_NEARBY_09_FILE);
            m_SFXManager.Load(GameSounds.SCREAM_FAR_01, GameSounds.SCREAM_FAR_01_FILE);
            m_SFXManager.Load(GameSounds.SCREAM_FAR_02, GameSounds.SCREAM_FAR_02_FILE);
            m_SFXManager.Load(GameSounds.SCREAM_FAR_03, GameSounds.SCREAM_FAR_03_FILE);
            m_SFXManager.Load(GameSounds.SCREAM_FAR_04, GameSounds.SCREAM_FAR_04_FILE);
            m_SFXManager.Load(GameSounds.SCREAM_FAR_05, GameSounds.SCREAM_FAR_05_FILE);
            m_SFXManager.Load(GameSounds.SCREAM_FAR_07, GameSounds.SCREAM_FAR_07_FILE);
            m_SFXManager.Load(GameSounds.SCREAM_FAR_08, GameSounds.SCREAM_FAR_08_FILE);
            m_SFXManager.Load(GameSounds.SCREAM_FAR_09, GameSounds.SCREAM_FAR_09_FILE);
            m_SFXManager.Load(GameSounds.BASH_WOOD_PLAYER, GameSounds.BASH_WOOD_PLAYER_FILE);
            m_SFXManager.Load(GameSounds.BASH_WOOD_NEARBY, GameSounds.BASH_WOOD_NEARBY_FILE);
            m_SFXManager.Load(GameSounds.TURN_PAGE, GameSounds.TURN_PAGE_FILE);
            m_SFXManager.Load(GameSounds.UNDEAD_EAT_NEARBY, GameSounds.UNDEAD_EAT_NEARBY_FILE);
            m_SFXManager.Load(GameSounds.VOMIT_NEARBY, GameSounds.VOMIT_NEARBY_FILE);
            m_SFXManager.Load(GameSounds.SHOVE_PLAYER, GameSounds.SHOVE_PLAYER_FILE);
            m_SFXManager.Load(GameSounds.SHOVE_NEARBY, GameSounds.SHOVE_NEARBY_FILE);
            m_SFXManager.Load(GameSounds.PUSH_METAL_OBJECT_VISIBLE, GameSounds.PUSH_METAL_OBJECT_VISIBLE_FILE);
            m_SFXManager.Load(GameSounds.PUSH_METAL_OBJECT_AUDIBLE, GameSounds.PUSH_METAL_OBJECT_AUDIBLE_FILE);
            m_SFXManager.Load(GameSounds.BUILDING_PLAYER, GameSounds.BUILDING_PLAYER_FILE);
            m_SFXManager.Load(GameSounds.BUILDING_NEARBY, GameSounds.BUILDING_NEARBY_FILE);
            m_SFXManager.Load(GameSounds.CAN_TRAP_PLAYER, GameSounds.CAN_TRAP_PLAYER_FILE);
            m_SFXManager.Load(GameSounds.BEAR_TRAP_PLAYER, GameSounds.BEAR_TRAP_PLAYER_FILE);
            m_SFXManager.Load(GameSounds.SPIKE_TRAP, GameSounds.SPIKE_TRAP_FILE);
            m_SFXManager.Load(GameSounds.BARBED_WIRE_TRAP_PLAYER, GameSounds.BARBED_WIRE_TRAP_PLAYER_FILE);
            m_SFXManager.Load(GameSounds.CAN_TRAP_NEARBY, GameSounds.CAN_TRAP_NEARBY_FILE);
            m_SFXManager.Load(GameSounds.BEAR_TRAP_NEARBY, GameSounds.BEAR_TRAP_NEARBY_FILE);
            m_SFXManager.Load(GameSounds.CAN_TRAP_FAR, GameSounds.CAN_TRAP_FAR_FILE);
            m_SFXManager.Load(GameSounds.BEAR_TRAP_FAR, GameSounds.BEAR_TRAP_FAR_FILE);
            m_SFXManager.Load(GameSounds.DYNAMITE_VISIBLE, GameSounds.DYNAMITE_VISIBLE_FILE);
            m_SFXManager.Load(GameSounds.DYNAMITE_AUDIBLE, GameSounds.DYNAMITE_AUDIBLE_FILE);
            m_SFXManager.Load(GameSounds.GRENADE_VISIBLE, GameSounds.GRENADE_VISIBLE_FILE);
            m_SFXManager.Load(GameSounds.GRENADE_AUDIBLE, GameSounds.GRENADE_AUDIBLE_FILE);
            m_SFXManager.Load(GameSounds.MOLOTOV_VISIBLE, GameSounds.MOLOTOV_VISIBLE_FILE);
            m_SFXManager.Load(GameSounds.MOLOTOV_AUDIBLE, GameSounds.MOLOTOV_AUDIBLE_FILE);
            m_SFXManager.Load(GameSounds.FLASHBANG_VISIBLE, GameSounds.FLASHBANG_VISIBLE_FILE);
            m_SFXManager.Load(GameSounds.FLASHBANG_AUDIBLE, GameSounds.FLASHBANG_AUDIBLE_FILE);
            m_SFXManager.Load(GameSounds.SMOKING, GameSounds.SMOKING_FILE);
            m_SFXManager.Load(GameSounds.ROLLER_DOOR, GameSounds.ROLLER_DOOR_FILE);
            m_SFXManager.Load(GameSounds.NAIL_GUN, GameSounds.NAIL_GUN_FILE);
            m_SFXManager.Load(GameSounds.BREAK_WOODENDOOR_PLAYER, GameSounds.BREAK_WOODENDOOR_PLAYER_FILE);
            m_SFXManager.Load(GameSounds.BREAK_WOODENDOOR_NEARBY, GameSounds.BREAK_WOODENDOOR_NEARBY_FILE);
            m_SFXManager.Load(GameSounds.BREAK_GLASSDOOR_PLAYER, GameSounds.BREAK_GLASSDOOR_PLAYER_FILE);
            m_SFXManager.Load(GameSounds.BREAK_GLASSDOOR_NEARBY, GameSounds.BREAK_GLASSDOOR_NEARBY_FILE);
            m_SFXManager.Load(GameSounds.BREAK_METALDOOR_PLAYER, GameSounds.BREAK_METALDOOR_PLAYER_FILE);
            m_SFXManager.Load(GameSounds.BREAK_METALDOOR_NEARBY, GameSounds.BREAK_METALDOOR_NEARBY_FILE);
            m_SFXManager.Load(GameSounds.BASH_OTHER_OBJECTS_PLAYER, GameSounds.BASH_OTHER_OBJECTS_PLAYER_FILE);
            m_SFXManager.Load(GameSounds.BASH_OTHER_OBJECTS_NEARBY, GameSounds.BASH_OTHER_OBJECTS_NEARBY_FILE);
            m_SFXManager.Load(GameSounds.BREAK_CERAMIC_VISIBLE, GameSounds.BREAK_CERAMIC_VISIBLE_FILE);
            m_SFXManager.Load(GameSounds.BASH_CERAMIC_VISIBLE, GameSounds.BASH_CERAMIC_VISIBLE_FILE);
            m_SFXManager.Load(GameSounds.BASH_METALDOOR_PLAYER, GameSounds.BASH_METALDOOR_PLAYER_FILE);
            m_SFXManager.Load(GameSounds.BASH_METALDOOR_NEARBY, GameSounds.BASH_METALDOOR_NEARBY_FILE);
            m_SFXManager.Load(GameSounds.PUSH_WOODEN_OBJECT_VISIBLE, GameSounds.PUSH_WOODEN_OBJECT_VISIBLE_FILE);
            m_SFXManager.Load(GameSounds.PUSH_WOODEN_OBJECT_AUDIBLE, GameSounds.PUSH_WOODEN_OBJECT_AUDIBLE_FILE);
            m_SFXManager.Load(GameSounds.REINCARNATE, GameSounds.REINCARNATE_FILE);
            m_SFXManager.Load(GameSounds.NIGHT_VISION, GameSounds.NIGHT_VISION_FILE);
            m_SFXManager.Load(GameSounds.ACCESS_DENIED, GameSounds.ACCESS_DENIED_FILE);
            m_SFXManager.Load(GameSounds.ACCESS_GRANTED, GameSounds.ACCESS_GRANTED_FILE);
            m_SFXManager.Load(GameSounds.ACHIEVEMENT, GameSounds.ACHIEVEMENT_FILE);
            m_SFXManager.Load(GameSounds.DRINK, GameSounds.DRINK_FILE);
            m_SFXManager.Load(GameSounds.DIG_GROUND, GameSounds.DIG_GROUND_FILE);
            m_SFXManager.Load(GameSounds.PLACE_TRAP, GameSounds.PLACE_TRAP_FILE);
            m_SFXManager.Load(GameSounds.MAKE_MOLOTOV, GameSounds.MAKE_MOLOTOV_FILE);
            m_SFXManager.Load(GameSounds.MALE_HURT, GameSounds.MALE_HURT_FILE);
            m_SFXManager.Load(GameSounds.FEMALE_HURT, GameSounds.FEMALE_HURT_FILE);
            m_SFXManager.Load(GameSounds.CHAINSAW_PLAYER, GameSounds.CHAINSAW_PLAYER_FILE);
            m_SFXManager.Load(GameSounds.CHAINSAW_NEARBY, GameSounds.CHAINSAW_NEARBY_FILE);
            m_SFXManager.Load(GameSounds.CHAINSAW_FAR, GameSounds.CHAINSAW_FAR_FILE);
            m_SFXManager.Load(GameSounds.FLAMETHROWER_AUDIBLE, GameSounds.FLAMETHROWER_AUDIBLE_FILE);
            m_SFXManager.Load(GameSounds.FLAMETHROWER_VISIBLE, GameSounds.FLAMETHROWER_VISIBLE_FILE);
            m_SFXManager.Load(GameSounds.FUEL_CAN_VISIBLE, GameSounds.FUEL_CAN_VISIBLE_FILE);
            m_SFXManager.Load(GameSounds.FUEL_CAN_AUDIBLE, GameSounds.FUEL_CAN_AUDIBLE_FILE);
            m_SFXManager.Load(GameSounds.FUEL_PUMP_VISIBLE, GameSounds.FUEL_PUMP_VISIBLE_FILE);
            m_SFXManager.Load(GameSounds.FUEL_PUMP_AUDIBLE, GameSounds.FUEL_PUMP_AUDIBLE_FILE);
            m_SFXManager.Load(GameSounds.FLARE, GameSounds.FLARE_FILE);
            m_SFXManager.Load(GameSounds.GLOWSTICK, GameSounds.GLOWSTICK_FILE);
            m_SFXManager.Load(GameSounds.EQUIP, GameSounds.EQUIP_FILE);
            m_SFXManager.Load(GameSounds.SHIELD_BLOCK_PLAYER, GameSounds.SHIELD_BLOCK_PLAYER_FILE);
            m_SFXManager.Load(GameSounds.SHIELD_BLOCK_NEARBY, GameSounds.SHIELD_BLOCK_NEARBY_FILE);
            m_SFXManager.Load(GameSounds.SMOKE_GRENADE, GameSounds.SMOKE_GRENADE_FILE);
            m_SFXManager.Load(GameSounds.STUN_GUN_PLAYER, GameSounds.STUN_GUN_PLAYER_FILE);
            m_SFXManager.Load(GameSounds.STUN_GUN_NEARBY, GameSounds.STUN_GUN_NEARBY_FILE);
            m_SFXManager.Load(GameSounds.DOG_BARK_NEARBY, GameSounds.DOG_BARK_NEARBY_FILE);
            m_SFXManager.Load(GameSounds.DOG_BARK_FAR, GameSounds.DOG_BARK_FAR_FILE);
            m_SFXManager.Load(GameSounds.DOG_FLEE, GameSounds.DOG_FLEE_FILE);
            m_SFXManager.Load(GameSounds.DOG_GROWL, GameSounds.DOG_GROWL_FILE);
            m_SFXManager.Load(GameSounds.RAT_SCREECH, GameSounds.RAT_SCREECH_FILE);
            m_SFXManager.Load(GameSounds.SEWERS_THING_GROWL, GameSounds.SEWERS_THING_GROWL_FILE);
            m_SFXManager.Load(GameSounds.SKELETON_GROWL, GameSounds.SKELETON_GROWL_FILE);
            m_SFXManager.Load(GameSounds.SHAMBLER_GROWL, GameSounds.SHAMBLER_GROWL_FILE);
            m_SFXManager.Load(GameSounds.ZOMBIE_MASTER_GROWL, GameSounds.ZOMBIE_MASTER_GROWL_FILE);
            m_SFXManager.Load(GameSounds.ZOMBIFIED_GROAN, GameSounds.ZOMBIFIED_GROAN_FILE);
            m_SFXManager.Load(GameSounds.PSST_WHISPER, GameSounds.PSST_WHISPER_FILE);
            m_SFXManager.Load(GameSounds.MALE_SHOUT_PLAYER, GameSounds.MALE_SHOUT_PLAYER_FILE);
            m_SFXManager.Load(GameSounds.FEMALE_SHOUT_PLAYER, GameSounds.FEMALE_SHOUT_PLAYER_FILE);
            m_SFXManager.Load(GameSounds.MALE_SHOUT_NEARBY, GameSounds.MALE_SHOUT_NEARBY_FILE);
            m_SFXManager.Load(GameSounds.FEMALE_SHOUT_NEARBY, GameSounds.FEMALE_SHOUT_NEARBY_FILE);
            m_SFXManager.Load(GameSounds.METAL_DOOR_OPEN, GameSounds.METAL_DOOR_OPEN_FILE);
            m_SFXManager.Load(GameSounds.METAL_DOOR_CLOSE, GameSounds.METAL_DOOR_CLOSE_FILE);
            m_SFXManager.Load(GameSounds.SMG_SINGLE_SHOT_PLAYER, GameSounds.SMG_SINGLE_SHOT_PLAYER_FILE);
            m_SFXManager.Load(GameSounds.SMG_RAPID_FIRE_PLAYER, GameSounds.SMG_RAPID_FIRE_PLAYER_FILE);
            m_SFXManager.Load(GameSounds.SMG_SINGLE_SHOT_NEARBY, GameSounds.SMG_SINGLE_SHOT_NEARBY_FILE);
            m_SFXManager.Load(GameSounds.SMG_RAPID_FIRE_NEARBY, GameSounds.SMG_RAPID_FIRE_NEARBY_FILE);
            m_SFXManager.Load(GameSounds.SMG_SINGLE_SHOT_FAR, GameSounds.SMG_SINGLE_SHOT_FAR_FILE);
            m_SFXManager.Load(GameSounds.SMG_RAPID_FIRE_FAR, GameSounds.SMG_RAPID_FIRE_FAR_FILE);
            m_SFXManager.Load(GameSounds.MINIGUN_RAPID_FIRE_PLAYER, GameSounds.MINIGUN_RAPID_FIRE_PLAYER_FILE);
            m_SFXManager.Load(GameSounds.MINIGUN_RAPID_FIRE_NEARBY, GameSounds.MINIGUN_RAPID_FIRE_NEARBY_FILE);
            m_SFXManager.Load(GameSounds.MINIGUN_RAPID_FIRE_FAR, GameSounds.MINIGUN_RAPID_FIRE_FAR_FILE);
            m_SFXManager.Load(GameSounds.GRENADE_LAUNCHER_SINGLE_SHOT_PLAYER, GameSounds.GRENADE_LAUNCHER_SINGLE_SHOT_PLAYER_FILE);
            m_SFXManager.Load(GameSounds.GRENADE_LAUNCHER_SINGLE_SHOT_NEARBY, GameSounds.GRENADE_LAUNCHER_SINGLE_SHOT_NEARBY_FILE);
            m_SFXManager.Load(GameSounds.FISHING_CAST_PLAYER, GameSounds.FISHING_CAST_PLAYER_FILE);
            m_SFXManager.Load(GameSounds.FISHING_CAST_NEARBY, GameSounds.FISHING_CAST_NEARBY_FILE);
            m_SFXManager.Load(GameSounds.FISHING_REEL_PLAYER, GameSounds.FISHING_REEL_PLAYER_FILE);
            m_SFXManager.Load(GameSounds.FISHING_REEL_NEARBY, GameSounds.FISHING_REEL_NEARBY_FILE);
            m_SFXManager.Load(GameSounds.COOKING_SIZZLE_PLAYER, GameSounds.COOKING_SIZZLE_PLAYER_FILE);
            m_SFXManager.Load(GameSounds.COOKING_SIZZLE_NEARBY, GameSounds.COOKING_SIZZLE_NEARBY_FILE);
            m_SFXManager.Load(GameSounds.FIRE_EXTINGUISHER_PLAYER, GameSounds.FIRE_EXTINGUISHER_PLAYER_FILE);
            m_SFXManager.Load(GameSounds.FIRE_EXTINGUISHER_NEARBY, GameSounds.FIRE_EXTINGUISHER_NEARBY_FILE);
            m_SFXManager.Load(GameSounds.MATCH_STRIKE_START_FIRE_PLAYER, GameSounds.MATCH_STRIKE_START_FIRE_PLAYER_FILE);
            m_SFXManager.Load(GameSounds.EQUIP_BFG_PLAYER, GameSounds.EQUIP_BFG_PLAYER_FILE);
            m_SFXManager.Load(GameSounds.BIO_FORCE_GUN_PLAYER, GameSounds.BIO_FORCE_GUN_PLAYER_FILE);
            m_SFXManager.Load(GameSounds.PLASMA_BURST_AUDIBLE, GameSounds.PLASMA_BURST_AUDIBLE_FILE);
            m_SFXManager.Load(GameSounds.PLASMA_BURST_VISIBLE, GameSounds.PLASMA_BURST_VISIBLE_FILE);
            m_SFXManager.Load(GameSounds.OPEN_BACKPACK, GameSounds.OPEN_BACKPACK_FILE);
            #endregion

            #region AMBIENT SOUND
            m_AmbientSFXManager.Load(GameAmbients.RAIN_OUTSIDE, GameAmbients.RAIN_OUTSIDE_FILE);
            m_AmbientSFXManager.Load(GameAmbients.RAIN_INSIDE, GameAmbients.RAIN_INSIDE_FILE);
            m_AmbientSFXManager.Load(GameAmbients.HELICOPTER_FLYOVER, GameAmbients.HELICOPTER_FLYOVER_FILE);
            m_AmbientSFXManager.Load(GameAmbients.STATIONARY_HELICOPTER_FARTHEST, GameAmbients.STATIONARY_HELICOPTER_FARTHEST_FILE);
            m_AmbientSFXManager.Load(GameAmbients.STATIONARY_HELICOPTER_FAR, GameAmbients.STATIONARY_HELICOPTER_FAR_FILE);
            m_AmbientSFXManager.Load(GameAmbients.STATIONARY_HELICOPTER_NEAR, GameAmbients.STATIONARY_HELICOPTER_NEAR_FILE);
            m_AmbientSFXManager.Load(GameAmbients.STATIONARY_HELICOPTER_VISIBLE, GameAmbients.STATIONARY_HELICOPTER_VISIBLE_FILE);
            m_AmbientSFXManager.Load(GameAmbients.THUNDERING_RAIN_OUTSIDE, GameAmbients.THUNDERING_RAIN_OUTSIDE_FILE);
            m_AmbientSFXManager.Load(GameAmbients.THUNDERING_RAIN_INSIDE, GameAmbients.THUNDERING_RAIN_INSIDE_FILE);
            m_AmbientSFXManager.Load(GameAmbients.NIGHT_ANIMALS, GameAmbients.NIGHT_ANIMALS_FILE);
            m_AmbientSFXManager.Load(GameAmbients.CHURCH_BELLS_WITHIN_MAP, GameAmbients.CHURCH_BELLS_WITHIN_MAP_FILE);
            m_AmbientSFXManager.Load(GameAmbients.CHURCH_BELLS_OUTSIDE_MAP, GameAmbients.CHURCH_BELLS_OUTSIDE_MAP_FILE);
            m_AmbientSFXManager.Load(GameAmbients.TEST_AMBIENT, GameAmbients.TEST_AMBIENT_FILE);
            #endregion

            m_UI.UI_Clear(Color.Black);
            m_UI.UI_DrawStringBold(Color.White, "Loading sfxs... done!", 0, 0);
            m_UI.UI_Repaint();

            // load and parse manual.
            LoadManual();

            // load and parse credits.       /@@MP (Release 7-6)
            LoadCredits();

            // load hi score table.
            LoadHiScoreTable();

            // loop.
            while (m_IsGameRunning)
            {
                GameLoop();
            }

            //@@MP - game has been quit and will now close
            // stop & dispose music.
            m_MusicManager.StopAll();
            m_MusicManager.Dispose();
            //@@MP (Release 2)
            m_SFXManager.StopAll();
            m_SFXManager.Dispose();
            //@@MP (Release 6-1)
            m_AmbientSFXManager.StopAll();
            m_AmbientSFXManager.Dispose();

            // quit.
            m_UI.UI_DoQuit();
        }

        void GameLoop()
        {
            // main menu.
            HandleMainMenu();

            // play until player dies or quits.
            while (m_Player != null && !m_Player.IsDead && m_IsGameRunning && !m_PlayerWasRescued) //@@MP - added check for player rescue endgame (Release 6-4)
            {
                // timer.
                DateTime timeBefore = DateTime.Now;

                // play.
                m_HasLoadedGame = false;
                AdvancePlay(m_Session.CurrentMap.District, SimFlags.NOT_SIMULATING);

                // if quit, don't bother.
                if (!m_IsGameRunning)
                    break;

                // timer.
                DateTime timeAfter = DateTime.Now;
                m_Session.Scoring.RealLifePlayingTime = m_Session.Scoring.RealLifePlayingTime.Add(timeAfter - timeBefore);

                // check background music every N game hours // alpha10
                if (m_Session.WorldTime.TurnCounter % BGMUSIC_UPDATE_TURNS == 0)
                    UpdateBgMusic();

                //autosave every 540 turns (18 world hours) //@@MP (Release 6-1)
#if !DEBUG
                if (s_Options.Autosaving && (m_Session.WorldTime.TurnCounter % 540 == 0))
                    DoSaveGame(GetUserSave(), true);
#endif
            }
        }

        /// <summary>
        /// Advance play in district : could be player district (live district) or simulated district.
        /// </summary>
        void AdvancePlay(District district, SimFlags sim)
        {
            lock (district)  // alpha10 lock district
            {
                // 0. Remember if current district.
                bool wasNight = m_Session.WorldTime.IsNight;
                DayPhase prevPhase = m_Session.WorldTime.Phase;

                // 1. Advance all maps.
                // if player quit/loaded at any time, don't bother!
                #region
                foreach (Map map in district.Maps)
                {
                    //a workaround for terrible performance caused by simulating both the nearby districts, the entry map, and the CHAR underground. CHAR Ug is 100x100,
                    //so we're always simulating at least 150x150. even just 50x50 will push low-spec systems, so this would be a show-stopper otherwise.
                    if (map == m_Session.UniqueMaps.CHARUndergroundFacility.TheMap || map == m_Session.UniqueMaps.ArmyBase.TheMap) //@@MP (Release 7-4)
                    {
                        if (m_Player.Location.Map != map)
                            continue; //don't simulate below ground
                    }
                    else
                    {
                        if (m_Player.Location.Map == m_Session.UniqueMaps.CHARUndergroundFacility.TheMap || m_Player.Location.Map == m_Session.UniqueMaps.ArmyBase.TheMap)
                            continue; //don't simulate above ground
                    }

                    // clear to proceed
                    int prevLocalTurn = map.LocalTime.TurnCounter;
                    do
                    {
                        // play this map.
                        AdvancePlay(map, sim);
                        // check for reincarnation.
                        if (m_Player.IsDead)
                            HandleReincarnation();
                        // check stopping game.
                        if (!m_IsGameRunning || m_HasLoadedGame || m_Player.IsDead)
                            return;
                    }
                    while (map.LocalTime.TurnCounter == prevLocalTurn);
                }
                #endregion

                // 2. Advance district.
                #region
                // 2.1. Advance world time if current district, or grow plants if other district and a new day
                #region
                if (district == m_Session.CurrentMap.District)
                {
                    ++m_Session.WorldTime.TurnCounter;
                    // sunrise/sunset.
                    bool canSeeSky = m_Rules.CanActorSeeSky(m_Player);  // alpha10 message ony if can see sky
                    bool isNight = m_Session.WorldTime.IsNight;
                    DayPhase newPhase = m_Session.WorldTime.Phase;
                    //sunrise started
                    if (wasNight && !isNight)
                    {
                        if (canSeeSky)
                            AddMessage(new Message("The sun is rising again for you...", m_Session.WorldTime.TurnCounter, DAY_COLOR));
                        OnNewDay();
                        CheckIfPlantsFruit(district.EntryMap); //@@MP - added (Release 5-5), limited to entrymap (Release 7-6)
                    }
                    //sunset over
                    else if (!wasNight && isNight)
                    {
                        if (canSeeSky)
                            AddMessage(new Message("Night is falling upon you...", m_Session.WorldTime.TurnCounter, NIGHT_COLOR));
                        OnNewNight();
                        //after a period of time, some objects and tiles around the world show decay        //@@MP - added (Release 7-6)
                        if ((s_Options.IsWorldDecayOn) && (m_Session.WorldTime.TurnCounter >= (s_Options.DaysBeforeWorldDecays * WorldTime.TURNS_PER_DAY)))
                        {
                            for (int x = 0; x < m_Session.World.Size; x++)
                                for (int y = 0; y < m_Session.World.Size; y++)
                                {
                                    District dist = m_Session.World[x, y];
                                    CheckIfWorldDecays(dist.EntryMap);
                                }
                        }
                    }
                    else if (prevPhase != newPhase)
                    {
                        if (canSeeSky)
                            AddMessage(new Message(String.Format("Time passes, it is now {0}...", DescribeDayPhase(newPhase)), m_Session.WorldTime.TurnCounter, isNight ? NIGHT_COLOR : DAY_COLOR));

                        //weather and ambients
                        CheckWeatherChange(); //@@MP (Release 6-1)
                        if (newPhase == DayPhase.SUNSET) //@@MP (Release 6-6)
                        {
                            if (m_Player.Location.Map.HasChurch && !m_Player.IsSleeping)
                                m_AmbientSFXManager.PlayIfNotAlreadyPlaying(GameAmbients.CHURCH_BELLS_WITHIN_MAP, AudioPriority.PRIORITY_BGM);
                            else
                                m_AmbientSFXManager.PlayIfNotAlreadyPlaying(GameAmbients.CHURCH_BELLS_OUTSIDE_MAP, AudioPriority.PRIORITY_BGM);
                        }

                        if (m_Session.WorldTime.TurnCounter > (s_Options.DaysBeforeDiscardedItemDespawns * WorldTime.TURNS_PER_DAY))
                        {
                            foreach (Map map in district.Maps)
                            {
                                //empty player-dropped backpacks         //@@MP (Release 8-2)
                                //EmptyBackpacksSittingIdle(map, map.LocalTime.TurnCounter); //opted not to use this in the end

                                //NPC-discarded items cleanup          //@@MP (Release 7-6)
                                DeleteItemsSittingIdle(map, map.LocalTime.TurnCounter);
                            }
                        }
                    }
                }
                else if (wasNight && !m_Session.WorldTime.IsNight)// && (m_Session.WorldTime.Day % 2 == 0))
                {
                    //@@MP - a new day in the other districts (Release 5-5), now only happens every 2nd day (Release 6-1), not sure why I set it to 2 when 1 makes sense (Release 8-2)

                    //this won't work for districts checked before the player's one, but that won't occur because the entry point from GameLoop() is m_Session.CurrentMap.District, and then each is simulated from that.
                    //this piece of code is only relevant when AdvancePlay() is called by SimulateNearbyDistricts()
                    CheckIfPlantsFruit(district.EntryMap); //@@MP - added a restriction to only process entrymaps (Release 7-6)
                }

                #endregion

                // 2.2. Check for events.

                #region Entry/Surface map
                // 1 Invasion?
                if (CheckForEvent_ZombieInvasion(district.EntryMap))
                {
                    FireEvent_ZombieInvasion(district.EntryMap);
                }
                // 2 Refugees?
                if (CheckForEvent_RefugeesWave(district.EntryMap))
                {
                    FireEvent_RefugeesWave(district);
                }
                // 3 National guard?
                if (CheckForEvent_NationalGuard(district.EntryMap))
                {
                    FireEvent_NationalGuard(district.EntryMap);
                }
                // 4 Army drop supplies?
                if (CheckForEvent_ArmySupplies(district.EntryMap))
                {
                    FireEvent_ArmySupplies(district.EntryMap);
                }
                // 5 Bikers raid?
                if (CheckForEvent_BikersRaid(district.EntryMap))
                {
                    FireEvent_BikersRaid(district.EntryMap);
                }
                // 6 Gangsta raid?
                if (CheckForEvent_GangstasRaid(district.EntryMap))
                {
                    FireEvent_GangstasRaid(district.EntryMap);
                }
                // 7 Blackops raid?
                if (CheckForEvent_BlackOpsRaid(district.EntryMap))
                {
                    FireEvent_BlackOpsRaid(district.EntryMap);
                }
                // 8 Band of Survivors?
                if (CheckForEvent_BandOfSurvivors(district.EntryMap))
                {
                    FireEvent_BandOfSurvivors(district.EntryMap);
                }
                // 9 CHAR scientists research team?
                if (CheckForEvent_CHARScientists(district.EntryMap))
                {
                    FireEvent_CHARScientists(district.EntryMap);
                }
                #endregion

                #region Sewers
                // 1 Sewers Invasion?
                if (CheckForEvent_SewersInvasion(district.SewersMap))
                {
                    FireEvent_SewersInvasion(district.SewersMap);
                }
                #endregion

                #region DISABLED Subway
#if false
                if (district.SubwayMap != null)
                {
                    // 1 Subway Invasion?
                    if (CheckForEvent_SubwayInvasion(district.SubwayMap))
                    {
                        FireEvent_SubwayInvasion(district.SubwayMap);
                    }
                }
#endif
                #endregion
                #endregion

                // 3. Simulate nearby districts?
                #region
                // if player is sleeping in this map and option enabled.
                if (s_Options.IsSimON && m_Player != null && m_Player.IsSleeping && s_Options.SimulateWhenSleeping && m_Player.Location.Map.District == district)
                {
                    SimulateNearbyDistricts(district);
                }
                #endregion
            }  // end lock district
        }

        void AdvancePlay(Map map, SimFlags sim)
        {
            //////////////////////////////////////////////////////////
            // 0. Secret maps.
            // 1. Get next actor to Act.
            // 2. If none move to next turn and return.
            // 3. Ask actor to act. Handle player and AI differently.
            //////////////////////////////////////////////////////////

            // 0. Secret maps.
            #region
            if (map.IsSecret)
            {
                // don't play the map at all, jump in time.
                ++map.LocalTime.TurnCounter;
                return;
            }
            #endregion

            // 1. Get next actor to Act.
            #region
            Actor actor = m_Rules.GetNextActorToAct(map); //@@MP - unused parameter (Release 5-7)
            if (actor != null)
            {
                if (actor.IsBotPlayer || !actor.IsPlayer)
                {
                    //@@MP - workaround for actors getting too many turns in succession [detection code by zaimoni] (Release 6-4)
                    if (actor.ActionPoints > actor.Doll.Body.Speed)
                    {
                        Logger.WriteLine(Logger.Stage.RUN_MAIN, actor.Name + " is hyperactive. Max speed: " + actor.Doll.Body.Speed.ToString() + ", actual: " + actor.ActionPoints.ToString() + " [turn#" + m_Session.WorldTime.TurnCounter.ToString() + "]");
                        do
                        {
                            actor.ActionPoints -= actor.Doll.Body.Speed; //@@MP - ensures it can't go beyond maximum (Release 6-4)
                        }
                        while (actor.ActionPoints > actor.Doll.Body.Speed);
                    }

                    // alpha10 ai loop bug detection
                    if (actor == m_DEBUG_prevAiActor)
                    {
                        if (++m_DEBUG_sameAiActorCount >= DEBUG_AI_ACTOR_LOOP_COUNT_WARNING)
                        {
                            // TO DEVS: you might want to add a debug breakpoint here ->
                            Point pt = new Point(actor.Location.Position.X, actor.Location.Position.Y);
                            Logger.WriteLine(Logger.Stage.RUN_MAIN, "WARNING: " + actor.Name + " is possibly looping.... [district: " + actor.Location.Map.District.Name + "] [coords: " + pt.ToString() + "] [turn #" + m_Session.WorldTime.TurnCounter + "] [tally= " + m_DEBUG_sameAiActorCount + "]");
                            Logger.WriteLine(Logger.Stage.RUN_MAIN, actor.Name + " last action turn: " + actor.LastActionTurn.ToString() + ", activity: " + actor.Activity.ToString());
                            Logger.WriteLine(Logger.Stage.RUN_MAIN, actor.Name + " repetitive AP-free actions this turn: " + actor.RepetitiveNoAPCostActionsThisTurnCount.ToString());
#if DEBUG
                            //pause the AI to let us find the looping actor and see what they're doing
                            if (m_Player.IsBotPlayer && m_Player.Location.Map == actor.Location.Map)
                            {
                                BotReleaseControl();
                                AddMessage(new Message("IN-DISTRICT AI LOOPING DETECTED. Released bot control", m_Session.WorldTime.TurnCounter, Color.Pink));
                            }
#endif
#if DEBUGAILOOPING
                            actor.IsLooping = true; //@@MP (Release 6-6)
#endif
                            // when not debugging AI looping, just spend a turn. it's better than crashing the game! workaround
                            DoWait(actor);
                        }
                    }
                    else
                    {
                        m_DEBUG_sameAiActorCount = 0;
                        m_DEBUG_prevAiActor = actor;
                    }
                }
            }
            #endregion

            // 2. If none move to next turn and return.
            #region
            if (actor == null)
            {
                NextMapTurn(map, sim);
                return;
            }
            #endregion

            // 3. Ask actor to act. Handle player and AI differently.
            #region
            int actionPointsBeforeTurn = actor.ActionPoints;
            Location locationBeforeTurn = actor.Location;
            actor.PreviousStaminaPoints = actor.StaminaPoints;
            if (actor.Controller == null)
            {
                SpendActorActionPoints(actor, Rules.BASE_ACTION_COST);
            }
            else if (actor.IsPlayer)
            {
                HandlePlayerActor(actor);
                // if quit, dead or loaded, don't bother.
                if (!m_IsGameRunning || m_HasLoadedGame || m_Player.IsDead)
                    return;
                // Check special player events
                CheckSpecialPlayerEventsAfterAction(actor);
            }
            else
            {
                HandleAiActor(actor);
#if DEBUGAILOOPING
                if (actor.IsLooping) //@@MP (Release 6-6)
                    Logger.WriteLine(Logger.Stage.RUN_MAIN, actor.Name + " activity in progress: " + actor.ActivityInProgress);
#endif
            }
            actor.PreviousHitPoints = actor.HitPoints;
            actor.PreviousFoodPoints = actor.FoodPoints;
            actor.PreviousSleepPoints = actor.SleepPoints;
            if (s_Options.IsSanityEnabled) actor.PreviousSanity = actor.Sanity; //@@MP (Release 1)
            actor.PreviousBloodAlcohol = actor.BloodAlcohol; //@@MP (Release 7-1)

#if DEBUG && DEBUGAILOOPING
            //clues as to what happened if an actor might be looping  //@@MP - added (Release 6-4)
            if (++m_DEBUG_sameAiActorCount >= DEBUG_AI_ACTOR_LOOP_COUNT_WARNING)
            {
                if (actor.ActionPoints == actionPointsBeforeTurn)
                {
                    if (actor.Location == locationBeforeTurn)
                        Logger.WriteLine(Logger.Stage.RUN_MAIN, "... " + actor.Name + " spent no AP and did NOT move to another tile [turn# " + m_Session.WorldTime.TurnCounter.ToString() + "]");
                    else
                        Logger.WriteLine(Logger.Stage.RUN_MAIN, "... " + actor.Name + " reduced no AP and DID move to another tile [turn# " + m_Session.WorldTime.TurnCounter.ToString() + "]");
                }
                else if (actor.ActionPoints > actionPointsBeforeTurn)
                    Logger.WriteLine(Logger.Stage.RUN_MAIN, "... " + actor.Name + " has more AP than when the turn started [turn# " + m_Session.WorldTime.TurnCounter.ToString() + "]");
            }
#endif
            #endregion
        }

        void NextMapTurn(Map map, SimFlags sim)
        {
            ////////////////////////////////////////
            // (the following are skipped in lodetail turns)
            // 0. Establish current weather
            // 1. Raise the deads; Check infections (non STD)
            // 2. Update odors.
            //      2.1 **OBSOLETE** Odor suppression/generation. 
            //      2.2 Odors on map decay.
            //      2.3 Actor scents.
            // 3. Update actors.
            //      3.1 Check those on fire
            //      3.2 Hunger and rot.
            //      3.3 Actor gauges & states : Hunger, Sleep, Sanity, Leader Trust.
            //           3.3.1 Handle sleeping actors.
            //           3.3.2 Regen AP & STA. Stop tired actors from running.
            //           3.3.3 Exhausted collapses
            //           3.3.4 Sanity and trust.
            //           3.3.5 Check batteries : lights, trackers, NVGs.
            //           3.3.6 Intoxication and stunned
            //           3.3.7 Food poisoning
            // 4. Check explosives and item lights.
            //      4.1 Update fuses and light 'batteries'.
            //      4.2 Explode.
            // 5. Check fires.
            //      5.1 Extinguish object fires / cook meat.
            //      5.2 Spread and extinguish tile fires.
            // (the following are always performed)
            // - Check timers.
            // - Advance local time.
            // - Check for NPC upgrade.
            ////////////////////////////////////////

            /*bool isLoDetail = (sim & SimFlags.LODETAIL_TURN) != 0;  //@@MP - reducing local variables, to keep all within this method enregistered (Release 5-7)
            if (!isLoDetail)*/
            if (!((sim & SimFlags.LODETAIL_TURN) != 0)) //@@MP - it's not a Low Detail (limited simulation) turn, so check everything
            {
                // 0. Establish current weather      //@@MP - weather alters the chance of fires being extinguished at 3.1 and 5.1.1 (Release 6-1)
                int baseExtinguishChance = 0;
                if (m_Session.World.Weather == Weather.RAIN)
                    baseExtinguishChance = LIGHT_RAIN_FIRE_EXTINGUISH_CHANCE;
                else if (m_Session.World.Weather == Weather.HEAVY_RAIN)
                    baseExtinguishChance = HEAVY_RAIN_FIRE_EXTINGUISH_CHANCE; //@@MP - heavy rain is now more likely to extinguish fires (Release 6-1)
                else //dry weather
                    baseExtinguishChance = CLEAR_WEATHER_FIRE_EXTINGUISH_CHANCE;

                // 1. Raise the deads. Check infections (non-STD)
                #region

                #region Corpses
                if (map.CountCorpses > 0)
                {
                    // decide who zombifies or rots.
                    List<Corpse> tryZombifyCorpses = new List<Corpse>(map.CountCorpses);
                    List<Corpse> rottenCorpses = new List<Corpse>(map.CountCorpses);
                    foreach (Corpse c in map.Corpses)
                    {
                        // zombify?
                        if (!Rules.HasImmediateZombification(m_Session.GameMode) && m_Rules.RollChance(m_Rules.CorpseZombifyChance(c, map.LocalTime))) //@@MP - added game mode check now that all modes have corpses (Release 7-1)
                        {
                            //animals won't zombify     //@@MP (Release 7-3)
                            //TODO? make a zombified version?
                            //FIXME: make a property for this: ActorModel?   
                            if (c.DeadGuy.Model.Abilities.IsLivingAnimal)
                                continue;

                            // zombify this one.
                            tryZombifyCorpses.Add(c);
                        }
                        else
                        {
                            // or rot away?
                            InflictDamageToCorpse(c, Rules.CorpseDecayPerTurn()); //@@MP - unused parameter (Release 5-7)
                            // tile fires damage   //@@MP (Release 7-6)
                            if (map.GetTileAt(c.Position).IsOnFire)
                                InflictDamageToCorpse(c, TILE_FIRE_DAMAGE_TO_CORPSE);

                            if (c.HitPoints <= 0)
                                rottenCorpses.Add(c);
                        }
                    }
                    // zombify!
                    if (tryZombifyCorpses.Count > 0)
                    {
                        List<Corpse> zombifiedCorpses = new List<Corpse>(tryZombifyCorpses.Count);
                        foreach (Corpse c in tryZombifyCorpses)
                        {
                            // only one actor per tile!
                            if (map.GetActorAt(c.Position) == null)
                            {
                                if (c.DeadGuy.Model.Abilities.IsLivingAnimal) //@@MP - not animals (Release 7-4)
                                    continue;

                                //float corpseState = (float)c.HitPoints / (float)c.MaxHitPoints; //@@MP - unused (Release 5-7)
                                //int zombifiedHP = (int)(corpseState * m_Rules.ActorMaxHPs(c.DeadGuy)); //@@MP - unused (Release 5-7)
                                zombifiedCorpses.Add(c);
                                Zombify(null, c.DeadGuy, map, c.Position, false);

                                if (IsVisibleToPlayer(map, c.Position))
                                    AddMessage(new Message(String.Format("The corpse of {0} rises again!!", c.DeadGuy.Name), map.LocalTime.TurnCounter, Color.Red));

                                if (IsAudibleToPlayer(new Location(map, c.Position), Rules.QUIET_NOISE_RADIUS))
                                    m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.ZOMBIFIED_GROAN, AudioPriority.PRIORITY_BGM);
                            }
                        }
                        foreach (Corpse c in zombifiedCorpses)
                            DestroyCorpse(c, map);
                    }
                    // rot!
                    if (m_Player != null && m_Player.Location.Map == map)
                    {
                        foreach (Corpse c in rottenCorpses)
                        {
                            DestroyCorpse(c, map);
                            if (IsVisibleToPlayer(map, c.Position))
                                AddMessage(new Message(String.Format("The corpse of {0} turns into dust.", c.DeadGuy.Name), map.LocalTime.TurnCounter, Color.Purple));
                        }
                    }
                }
                #endregion

                #region Infection effects
                if (Rules.HasInfection(m_Session.GameMode))
                {
                    List<Actor> infectedToKill = null;
                    foreach (Actor a in map.Actors)
                    {
                        if (a.Infection >= Rules.INFECTION_LEVEL_1_WEAK && !a.Model.Abilities.IsUndead)
                        {
                            int infectionP = m_Rules.ActorInfectionPercent(a);

                            #region
                            if (m_Rules.Roll(0, 1000) < m_Rules.InfectionEffectTriggerChance1000(infectionP))
                            {
                                bool isVisible = IsVisibleToPlayer(a);
                                bool isPlayer = a.IsPlayer;  // alpha10.1 consistency fix
                                bool isBot = a.IsBotPlayer;  // alpha10.1 handle bot

                                // if sleeping, wake up.
                                if (a.IsSleeping)
                                    DoWakeUp(a);

                                // apply effect.
                                bool killHim = false;
                                if (infectionP >= Rules.INFECTION_LEVEL_5_DEATH)
                                {
                                    killHim = true;
                                }
                                else if (infectionP >= Rules.INFECTION_LEVEL_4_BLEED)
                                {
                                    DoVomit(a);
                                    a.HitPoints -= Rules.INFECTION_LEVEL_4_BLEED_HP;
                                    if (isVisible)
                                    {
                                        if (isPlayer) ClearMessages();
                                        AddMessage(MakeMessage(a, String.Format("{0} blood.", Conjugate(a, VERB_VOMIT)), Color.Purple));
                                        if (isPlayer && !isBot)
                                        {
                                            AddMessagePressEnter();
                                            ClearMessages();
                                        }
                                    }
                                    if (a.HitPoints <= 0)
                                        killHim = true;
                                }
                                else if (infectionP >= Rules.INFECTION_LEVEL_3_VOMIT)
                                {
                                    DoVomit(a);
                                    if (isVisible)
                                    {
                                        if (isPlayer) ClearMessages();
                                        AddMessage(MakeMessage(a, String.Format("{0}.", Conjugate(a, VERB_VOMIT)), Color.Purple));
                                        if (isPlayer && !isBot)
                                        {
                                            AddMessagePressEnter();
                                            ClearMessages();
                                        }
                                    }
                                }
                                else if (infectionP >= Rules.INFECTION_LEVEL_2_TIRED)
                                {
                                    SpendActorStaminaPoints(a, Rules.INFECTION_LEVEL_2_TIRED_STA);
                                    a.SleepPoints -= Rules.INFECTION_LEVEL_2_TIRED_SLP;
                                    if (a.SleepPoints < 0) a.SleepPoints = 0;
                                    if (isVisible)
                                    {
                                        if (isPlayer) ClearMessages();
                                        AddMessage(MakeMessage(a, String.Format("{0} sick and tired.", Conjugate(a, VERB_FEEL)), Color.Purple));
                                        if (isPlayer && !isBot)
                                        {
                                            AddMessagePressEnter();
                                            ClearMessages();
                                        }
                                    }
                                }
                                else if (infectionP >= Rules.INFECTION_LEVEL_1_WEAK)
                                {
                                    SpendActorStaminaPoints(a, Rules.INFECTION_LEVEL_1_WEAK_STA);
                                    if (isVisible)
                                    {
                                        if (isPlayer) ClearMessages();
                                        AddMessage(MakeMessage(a, String.Format("{0} sick and weak.", Conjugate(a, VERB_FEEL)), Color.Purple));
                                        if (isPlayer && !isBot)
                                        {
                                            AddMessagePressEnter();
                                            ClearMessages();
                                        }
                                    }
                                }

                                // if it kills him, remember.
                                if (killHim)
                                {
                                    if (infectedToKill == null) infectedToKill = new List<Actor>(map.CountActors);
                                    infectedToKill.Add(a);
                                }
                            } // trigged effect
                            #endregion
                        } // is infected
                    } // each actor

                    // kill infected to kill (duh)
                    if (infectedToKill != null)
                    {
                        foreach (Actor a in infectedToKill)
                        {
                            KillActor(null, a, "infection");

                            if (IsVisibleToPlayer(a))
                                AddMessage(MakeMessage(a, String.Format("{0} of infection!", Conjugate(a, VERB_DIE))));

                            // if player, force zombify NOW.
                            if (a.IsPlayer)
                            {
                                // remove player corpse!
                                map.TryRemoveCorpseOf(a);

                                // zombify player!
                                Zombify(null, a, a.Location.Map, a.Location.Position, false);

                                // show
                                AddMessage(MakeMessage(a, Conjugate(a, "turn") + " into a Zombie!"));
                                RedrawPlayScreen();
                                AnimDelay(DELAY_LONG, true);
                            }
                        }
                    }
                }
                #endregion
                #endregion

                // 2. Update odors.
                #region
                //      2.1 **OBSOLETE** Odor suppression/generation. //alpha 10 obsolete
                #region
                /*List<OdorScent> scentGenerated = new List<OdorScent>();
                foreach (OdorScent scent in map.Scents)
                {
                    switch (scent.Odor)
                    {
                        case Odor.PERFUME_LIVING_SUPRESSOR:
                            // remember to suppress living scent.
                            scentGenerated.Add(new OdorScent(Odor.LIVING, -scent.Strength, scent.Position));
                            break;

                        case Odor.PERFUME_LIVING_GENERATOR:
                            // remember to generate living scent here.
                            scentGenerated.Add(new OdorScent(Odor.LIVING, scent.Strength, scent.Position));
                            break;
                    }
                }
                foreach (OdorScent genScent in scentGenerated)
                    map.ModifyScentAt(genScent.Odor, genScent.Strength, genScent.Position);*/
                #endregion

                //      2.2 Odors on map decay.
                #region
                List<OdorScent> scentGarbage = null;
                foreach (OdorScent scent in map.Scents)
                {
                    // alpha10 refactored weather decay calculation
                    int decay = m_Rules.OdorsDecay(map, scent.Position, m_Session.World.Weather);

                    // decay.
                    map.ModifyScentAt(scent.Odor, -decay, scent.Position);

                    // garbage?
                    if (scent.Strength < OdorScent.MIN_STRENGTH)
                    {
                        if (scentGarbage == null) scentGarbage = new List<OdorScent>(1);
                        scentGarbage.Add(scent);
                    }
                }
                if (scentGarbage != null)
                {
                    foreach (OdorScent scent in scentGarbage)
                        map.RemoveScent(scent);
                    scentGarbage = null;
                }
                #endregion

                //      2.3 Actor scents.
                #region
                foreach (Actor actor in map.Actors)
                {
                    DropActorScent(actor);
                    DecayActorScents(actor); //alpha 10, decay moved in
                }
                #endregion
                #endregion

                // 3. Update actors.
                //@@MP - reordered for performance. checks the things that will kill first, then the rest (Release 5-7)
                #region
                // 3.1. Check those on fire
                #region
                List<Actor> exemptFromTileFireDMGThisTurn = new List<Actor>(); //@@MP - added (Release 6-6)
                foreach (Actor actor in map.Actors.ToList()) //@@MP - ToList avoids illegally trying to modify a collection whilst iterating through it
                {
                    if (actor.IsOnFire) //Burning actors? //@@MP (Release 5-7)
                    {
                        //outside whilst raining? chance to extinguish
                        if (m_Rules.IsWeatherRain(m_Session.World.Weather) && !map.GetTileAt(actor.Location.Position).IsInside) //@@MP - added check for inside (Release 6-1)
                        { // FIXME there still the weather bug when simulating = weather used is current world weather, not map weather
                            if (m_Rules.RollChance(baseExtinguishChance))
                            {
                                ExtinguishOnFireActor(actor); //@@MP - remove fire decoration and status
                                continue;
                            }
                        }
                        else
                        {
                            if (!actor.Model.Abilities.IsUndead) //undead aren't smart enough to stop, drop & roll
                            {
                                if (m_Rules.RollChance(CLEAR_WEATHER_FIRE_EXTINGUISH_CHANCE))
                                {
                                    ExtinguishOnFireActor(actor);
                                    continue;
                                }
                            }
                        }

                        if (actor.IsOnFire) //@@MP - they weren't extinguished
                        {
                            Actor actorReceivingDamage = actor as Actor; //@@MP - can't alter a foreach collection
                            ApplyBurnDamageToOnFireActor(actorReceivingDamage);
                            exemptFromTileFireDMGThisTurn.Add(actorReceivingDamage); //@@MP - record so that we don't burn them again later when checking tile fires, because that would be excessive (Release 6-6)
                        }
                    }
                }
                // reset actor index.
                map.CheckNextActorIndex = 0;
                #endregion

                // 3.2 Hunger and rot.
                #region
                List<Actor> actorsStarvedToDeath = null;
                foreach (Actor actor in map.Actors)
                {
                    if (actor.Model.Abilities.HasToEat)
                    {
                        // food points loss.
                        --actor.FoodPoints;
                        if (actor.FoodPoints < 0) actor.FoodPoints = 0;

                        // kill starved actors.
                        if (actor.FoodPoints <= 0) //(m_Rules.IsActorStarving(actor))  //@@MP - fix (Release 7-1)
                        {
                            //@@MP - removed randonmess (Release 6-4)
                            if (s_Options.NPCCanStarveToDeath || actor.IsPlayer)
                            {
                                if (actorsStarvedToDeath == null)
                                    actorsStarvedToDeath = new List<Actor>();
                                actorsStarvedToDeath.Add(actor);
                            }
                        }
                    }
                    else if (actor.Model.Abilities.IsRotting)
                    {
                        // rot.
                        --actor.FoodPoints;
                        if (actor.FoodPoints < 0) actor.FoodPoints = 0;

                        // rot effects.
                        if (m_Rules.IsRottingActorStarving(actor))
                        {
                            // loose 1 HP.
                            if (m_Rules.Roll(0, 1000) < Rules.ROT_STARVING_HP_CHANCE)
                            {
                                if (IsVisibleToPlayer(actor))
                                {
                                    AddMessage(MakeMessage(actor, "is rotting away."));
                                }
                                if (--actor.HitPoints <= 0)
                                {
                                    if (actorsStarvedToDeath == null)
                                        actorsStarvedToDeath = new List<Actor>();
                                    actorsStarvedToDeath.Add(actor);
                                }
                            }
                        }
                        else if (m_Rules.IsRottingActorHungry(actor))
                        {
                            // loose a skill.
                            if (m_Rules.Roll(0, 1000) < Rules.ROT_HUNGRY_SKILL_CHANCE)
                                DoLoseRandomSkill(actor);
                        }
                    }
                }
                #region Kill (zombify) starved actors.
                if (actorsStarvedToDeath != null)
                {
                    foreach (Actor actor in actorsStarvedToDeath)
                    {
                        // message.
                        if (IsVisibleToPlayer(actor))
                        {
                            AddMessage(MakeMessage(actor, String.Format("{0} !!", Conjugate(actor, VERB_DIE_FROM_STARVATION))));
                            RedrawPlayScreen();
                        }

                        // kill.
                        KillActor(null, actor, "starvation");

                        // zombify?
                        if (!actor.Model.Abilities.IsUndead && Rules.HasImmediateZombification(m_Session.GameMode) && s_Options.StarvedZombification) //@@MP - remove % chance to zombify (Release 7-3)
                        {
                            //animals won't zombify     //@@MP (Release 7-6)
                            //TODO? make a zombified version?
                            if (actor.Model.Abilities.IsLivingAnimal)
                                continue;

                            // remove corpse
                            map.TryRemoveCorpseOf(actor);

                            // zombify!
                            Zombify(null, actor, actor.Location.Map, actor.Location.Position, false);

                            // show.
                            if (IsVisibleToPlayer(actor))
                            {
                                AddMessage(MakeMessage(actor, String.Format("{0} into a Zombie!", Conjugate(actor, "turn"))));
                                RedrawPlayScreen();
                                AnimDelay(DELAY_LONG, true);
                            }
                        }
                    }
                }
                #endregion

                // reset actor index.
                map.CheckNextActorIndex = 0;
                #endregion

                // 3.3 Actor gauges & states
                #region
                foreach (Actor actor in map.Actors)
                {
                    // 3.3.1 Handle sleeping actors.
                    #region
                    if (actor.Model.Abilities.HasToSleep)
                    {
                        // sleep vs sleep points loss.
                        if (actor.IsSleeping)
                        {
                            bool wakeUp = m_Rules.IsActorHungry(actor) || actor.SleepPoints >= m_Rules.ActorMaxSleep(actor);
                            // wake up if hungry or fully slept, but not if drunk
                            if (!actor.IsDrunk && wakeUp)  //@@MP - added drunk check (Release 7-1)
                            {
                                DoWakeUp(actor);
                            }
                            // nightmare?
                            else if (!actor.IsDrunk && m_Rules.IsActorDisturbed(actor) && m_Rules.RollChance(Rules.SANITY_NIGHTMARE_CHANCE))
                            {
                                // wake up, shout, and lose sleep and sta.
                                DoWakeUp(actor);
                                DoShout(actor, "NO! LEAVE ME ALONE!");
                                actor.SleepPoints -= Rules.SANITY_NIGHTMARE_SLP_LOSS;
                                if (actor.SleepPoints < 0) actor.SleepPoints = 0;
                                SpendActorSanity(actor, Rules.SANITY_NIGHTMARE_SAN_LOSS);
                                SpendActorStaminaPoints(actor, Rules.SANITY_NIGHTMARE_STA_LOSS); //alpha 10 added
                                // msg.
                                if (IsVisibleToPlayer(actor))
                                    AddMessage(MakeMessage(actor, String.Format("{0} from a horrible nightmare!", Conjugate(actor, VERB_WAKE_UP))));
                                // if player, sfx.
                                if (actor.IsPlayer)
                                    m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.NIGHTMARE, AudioPriority.PRIORITY_EVENT);
                            }
                            else
                            {
                                actor.Activity = Activity.SLEEPING;

                                // regen sleep pts.
                                bool isOnCouch = m_Rules.IsOnCouch(actor); //IsCouch is a flag on mapobjects, indicating they can be slept on
                                Inventory groundInv = map.GetItemsAt(actor.Location.Position);  //@MP - added sleeping bags (Release 7-3)
                                bool isOnSleepingBag = false;
                                if (groundInv != null)
                                    isOnSleepingBag = groundInv.HasItemMatching((it) => it.Model.ID == (int)GameItems.IDs.SLEEPING_BAG);
                                int sleepRegen = m_Rules.ActorSleepRegen(actor, isOnCouch || isOnSleepingBag); //@MP - added sleeping bags (Release 7-3)
                                RegenActorSleep(actor, sleepRegen); //@@MP - switched to using the pre-existing method that was made for it (Release 7-4)

                                // heal?
                                if (actor.HitPoints < m_Rules.ActorMaxHPs(actor))
                                {
                                    int healChance = (isOnCouch ? Rules.SLEEP_ON_COUCH_HEAL_CHANCE : 0);
                                    healChance += m_Rules.ActorHealChanceBonus(actor);
                                    if (m_Rules.RollChance(healChance))
                                        RegenActorHitPoints(actor, Rules.SLEEP_HEAL_HITPOINTS);
                                }

                                if (actor.IsPlayer)
                                {
                                    // check music.
                                    if (m_MusicManager.Track != GameMusics.SLEEP)
                                    {
                                        m_MusicManager.StopAll();
                                        m_MusicManager.PlayLooping(GameMusics.SLEEP, AudioPriority.PRIORITY_EVENT);
                                    }
                                    // message.
                                    AddMessage(new Message("...zzZZZzzZ...", map.LocalTime.TurnCounter, Color.DarkCyan));
                                    RedrawPlayScreen();
                                    // give some time to sim thread.
                                    if (s_Options.SimThread)
                                        Thread.Sleep(10);
                                }
                                else if (m_Rules.RollChance(MESSAGE_NPC_SLEEP_SNORE_CHANCE) && IsVisibleToPlayer(actor))
                                {
                                    AddMessage(MakeMessage(actor, String.Format("{0}.", Conjugate(actor, VERB_SNORE))));
                                    RedrawPlayScreen();
                                }
                            }
                        }
                        else
                        {
                            // awake.
                            --actor.SleepPoints;
                            if (map.LocalTime.IsNight)
                                --actor.SleepPoints;
                            if (actor.SleepPoints < 0) actor.SleepPoints = 0;
                        }
                    }
                    #endregion

                    // 3.3.2 AP, STA, stop running if tired
                    #region
                    //regen AP
                    if (!actor.IsSleeping)
                        actor.ActionPoints = Math.Min(actor.Doll.Body.Speed, actor.ActionPoints += m_Rules.ActorSpeed(actor)); //@@MP - force stop them going "hyperactive" (Release 7-3)

                    //regen STA
                    if (actor.StaminaPoints < m_Rules.ActorMaxSTA(actor))
                        RegenActorStaminaPoints(actor, Rules.STAMINA_REGEN_PER_TURN);

                    //stop running if tired
                    if (actor.IsRunning)
                    {
                        if (actor.StaminaPoints < Rules.STAMINA_MIN_FOR_ACTIVITY)
                        {
                            actor.IsRunning = false;
                            if (actor == m_Player)
                            {
                                AddMessage(MakeMessage(actor, String.Format("{0} too tired to continue running!", Conjugate(actor, VERB_BE))));
                                RedrawPlayScreen();
                            }
                        }
                    }
                    #endregion

                    // 3.3.3 Exhausted actors might collapse.
                    #region
                    else if (m_Rules.IsActorExhausted(actor))
                    {
                        if (m_Rules.RollChance(Rules.SLEEP_EXHAUSTION_COLLAPSE_CHANCE))
                        {
                            // do it
                            DoStartSleeping(actor);

                            // message.
                            if (IsVisibleToPlayer(actor))
                            {
                                AddMessage(MakeMessage(actor, String.Format("{0} from exhaustion !!", Conjugate(actor, VERB_COLLAPSE))));
                                RedrawPlayScreen();
                            }

                            // player?
                            if (actor == m_Player)
                            {
                                UpdatePlayerFOV(m_Player);
                                ComputeViewRect(m_Player.Location.Position);
                                RedrawPlayScreen();
                            }
                        }
                    }
                    #endregion

                    // 3.3.4 Sanity and trust
                    #region
                    // sanity loss.
                    #region
                    if (actor.Model.Abilities.HasSanity && s_Options.IsSanityEnabled && !actor.IsSleeping) //@@MP - this is where the each-turn sanity loss happens (Release 1), only when awake (Release 7-3)
                        if (--actor.Sanity <= 0) actor.Sanity = 0;
                    #endregion

                    // leader trust & leader/follower bond.
                    #region
                    if (actor.HasLeader)
                    {
                        // trust.
                        ModifyActorTrustInLeader(actor, m_Rules.ActorTrustIncrease(actor.Leader), false);
                        // bond with leader.
                        if (m_Rules.HasActorBondWith(actor, actor.Leader) && m_Rules.RollChance(Rules.SANITY_RECOVER_BOND_CHANCE))
                        {
                            RegenActorSanity(actor, m_Rules.ActorSanRegenValue(actor, Rules.SANITY_RECOVER_BOND));
                            RegenActorSanity(actor.Leader, m_Rules.ActorSanRegenValue(actor.Leader, Rules.SANITY_RECOVER_BOND));
                            if (IsVisibleToPlayer(actor))
                                AddMessage(MakeMessage(actor, String.Format("{0} reassured knowing {1} is with {2}.",
                                            Conjugate(actor, VERB_FEEL), actor.Leader.Name, HimOrHer(actor))));
                            if (IsVisibleToPlayer(actor.Leader))
                                AddMessage(MakeMessage(actor.Leader, String.Format("{0} reassured knowing {1} is with {2}.",
                                            Conjugate(actor.Leader, VERB_FEEL), actor.Name, HimOrHer(actor.Leader))));
                        }
                    }
                    #endregion
                    #endregion

                    // 3.3.5 Check batteries : lights, trackers, NVGs.
                    #region
                    //night vision goggles //@@MP (Release 6-3)
                    Item eyesItem = actor.GetEquippedItem(DollPart.EYES);
                    if (eyesItem != null)
                    {
                        ItemLight NVGs = eyesItem as ItemLight;
                        if (NVGs != null)
                        {
                            if (actor.IsPlayer)  //@MP - fixed logic that caused infite batteries (Release 7-5)
                            {
                                if (NVGs.Batteries > 0)
                                    --NVGs.Batteries;

                                if (NVGs.Batteries <= 0)
                                {
                                    AddMessage(MakeMessage(actor, String.Format(": {0} ran out of battery charge.", NVGs.TheName)));
                                }
                            }
                        }
                    }

                    Item leftItem = actor.GetEquippedItem(DollPart.LEFT_HAND);
                    if (leftItem != null)
                    {
                        // light?
                        ItemLight light = leftItem as ItemLight;
                        if (light != null)
                        {
                            if (actor.IsPlayer)  //@MP - fixed logic that caused infite batteries (Release 7-5)
                            {
                                if (light.Batteries > 0)
                                    --light.Batteries;

                                if (light.Batteries <= 0)
                                {
                                    AddMessage(MakeMessage(actor, String.Format(": {0} ran out of battery charge.", light.TheName)));
                                }
                            }
                        }

                        // tracker?
                        ItemTracker tracker = leftItem as ItemTracker;
                        if (tracker != null)
                        {
                            if (actor.IsPlayer)  //@MP - fixed logic that caused infite batteries (Release 7-5)
                            {
                                if (tracker.Batteries > 0)
                                    --tracker.Batteries;

                                if (tracker.Batteries <= 0)
                                {
                                    AddMessage(MakeMessage(actor, String.Format(": {0} ran out of battery charge.", tracker.TheName)));
                                }
                            }
                        }
                    }
                    #endregion

                    // 3.3.6 Intoxication and incapacitation
                    #region
                    if (--actor.BloodAlcohol < 0) actor.BloodAlcohol = 0; //@@MP (Release 7-1)
                    if (actor.IsStunned) --actor.StunnedTurns;  //@@MP (Release 7-2)
                    if (actor.IsFlashbanged) --actor.FlashbangedTurns;  //@@MP (Release 7-2)
                    #endregion

                    // 3.3.7 Food poisoning
                    #region
                    if (actor.IsFoodPoisoned) //@@MP (Release 7-6)
                    {
                        //roll to see if time has cured it
                        if (m_Rules.RollChance(Rules.BASE_FOOD_POISONING_RECOVERY_CHANCE + m_Rules.ActorRecoverFromFoodPoisoningChanceBonus(actor)))
                        {
                            actor.IsFoodPoisoned = false;
                            if (actor.IsPlayer || actor.Leader == m_Player)
                                AddMessage(MakeMessage(actor, "is no longer food poisoned."));
                        }
                        else if (!actor.IsPlayer) //still unwell, suffer?
                        {
                            if (m_Rules.RollChance(Rules.FOOD_POISONING_AFFECTED_ACTION_CHANCE))
                            {
                                if (IsVisibleToPlayer(actor))
                                    AddMessage(MakeMessage(actor, "feels unwell and vomits"));
                                DoVomit(actor);
                            }
                        }
                    }
                    #endregion
                }
                #endregion
                #endregion

                // 4. Check explosives and lights.
                #region
                // 4.1 Update fuses and light 'batteries'.
                bool hasExplosivesToExplode = false;
                #region
                // on ground.
                List<KeyValuePair<Point, Item>> deadItemLights = new List<KeyValuePair<Point, Item>>();
                foreach (Inventory groundInv in map.GroundInventories)
                {
                    foreach (Item it in groundInv.Items)
                    {
                        // update each explosive fuse there, remember which should explode.
                        ItemPrimedExplosive primed = it as ItemPrimedExplosive;
                        if (primed != null)
                        {
                            // primed explosive, burn fuse.
                            --primed.FuseTimeLeft;
                            if (primed.FuseTimeLeft <= 0)
                                hasExplosivesToExplode = true;

                            continue;
                        }

                        // lights like thrown flares and glowsticks //@@MP (Release 7-1)
                        ItemLight light = it as ItemLight;
                        if (light != null)
                        {
                            // active light, reduce 'battery charge'.
                            --light.Batteries;
                            if (light.Batteries <= 0 && light.MaxBatteries > 0) //@@MP - maxbattery condition ensures binoculars aren't removed (Release 7-2)
                                deadItemLights.Add(new KeyValuePair<Point, Item>(map.GetGroundInventoryPosition(groundInv).Value, light));
                        }
                    }
                }
                //now remove any expended ItemLights  //@@MP (Release 7-1)
                for (int i = 0; i < deadItemLights.Count; i++)
                {
                    Inventory inv = map.GetItemsAt(deadItemLights[i].Key);
                    inv.RemoveAllQuantity(deadItemLights[i].Value);
                }

                // on actors.
                foreach (Actor actor in map.Actors)
                {
                    Inventory inv = actor.Inventory;
                    if (inv == null || inv.IsEmpty)
                        continue;

                    // update each explosive fuse there, remember which should explode.
                    foreach (Item it in inv.Items)
                    {
                        ItemPrimedExplosive primed = it as ItemPrimedExplosive;
                        if (primed == null)
                            continue;

                        // primed explosive, burn fuse.
                        --primed.FuseTimeLeft;
                        if (primed.FuseTimeLeft <= 0)
                            hasExplosivesToExplode = true;
                    }
                }
                #endregion

                // 4.2 Explode.
                #region
                if (hasExplosivesToExplode)
                {
                    bool hasExplodedSomething = false;
                    do
                    {
                        // nothing exploded by default.
                        hasExplodedSomething = false;

                        // on ground.
                        if (!hasExplodedSomething)
                        {
                            foreach (Inventory groundInv in map.GroundInventories)
                            {
                                Point? pos = map.GetGroundInventoryPosition(groundInv);
                                if (pos == null)
                                    throw new InvalidOperationException("explosives : GetGroundInventoryPosition returned null point");

                                foreach (Item it in groundInv.Items)
                                {
                                    ItemPrimedExplosive primed = it as ItemPrimedExplosive;
                                    if (primed == null)
                                        continue;

                                    if (primed.FuseTimeLeft <= 0)
                                    {
                                        // boom!
                                        map.RemoveItemAt(primed, pos.Value);
                                        DoBlast(new Location(map, pos.Value), (primed.Model as ItemExplosiveModel).BlastAttack, it.Model, primed.Owner); //@@MP - added Owner (Release 6-6)
                                        hasExplodedSomething = true;
                                        break;
                                    }
                                }

                                if (hasExplodedSomething)
                                    break;
                            }
                        }

                        // on actors.
                        if (!hasExplodedSomething)
                        {
                            foreach (Actor actor in map.Actors)
                            {
                                Inventory inv = actor.Inventory;
                                if (inv == null || inv.IsEmpty)
                                    continue;

                                foreach (Item it in inv.Items)
                                {
                                    ItemPrimedExplosive primed = it as ItemPrimedExplosive;
                                    if (primed == null)
                                        continue;

                                    if (primed.FuseTimeLeft <= 0)
                                    {
                                        // boom!
                                        actor.Inventory.RemoveAllQuantity(primed);
                                        DoBlast(new Location(map, actor.Location.Position), (primed.Model as ItemExplosiveModel).BlastAttack, it.Model, primed.Owner); //@@MP - added thrower (Release 6-6)
                                        hasExplodedSomething = true;
                                        break;
                                    }
                                }
                            }
                        }
                    }

                    while (hasExplodedSomething);
                }
                #endregion
                #endregion

                // 5. Check fires.
                #region
                // 5.1 Extinguish burning objects.
                #region
                //MP: was not implemented in vanilla RS, but was drafted. I'm utilising it, but deliberately exempting Car fires
                //@@MP (Release 7-6)
                foreach (MapObject obj in map.MapObjects)
                {
                    if (obj.IsOnFire)
                    {
                        Campfire campfire = obj as Campfire;
                        Barrel barrel = obj as Barrel;
                        Car car = obj as Car;

                        //there's stuff to do for this particular MapObject
                        if (campfire != null || barrel != null || car != null)
                        {
                            if (map == m_Player.Location.Map) //only the player has to wait for meat to cook. for NPCs it happens instantly
                            {
                                // was a piece of raw meat cooked?
                                Inventory inv = map.GetItemsAt(obj.Location.Position);
                                if (inv != null && inv.CountItems > 0)
                                {
                                    Inventory temp = new Inventory(inv.CountItems); //need to store raw items that finish cooking this turn, as we can't modify an invetory whilst looping through it
                                    foreach (Item it in inv.Items)
                                    {
                                        ItemFood food = it as ItemFood;
                                        if (food != null && food.CanBeCooked)
                                        {
                                            if (food.CookedDegree < food.MaxCookedDegree)
                                            {
                                                ++food.CookedDegree;
                                                if (IsAudibleToPlayer(obj.Location, Rules.QUIET_NOISE_RADIUS))
                                                    m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.COOKING_SIZZLE_NEARBY, AudioPriority.PRIORITY_BGM);

                                                if (food.CookedDegree >= food.MaxCookedDegree) //it's finished cooking. we'll replace raw item with a cooked one
                                                    temp.AddAll(food);
                                            }
                                        }
                                    }
                                    if (temp != null && temp.CountItems > 0) //food finished cooking, so handle the swapover to the cooked item
                                    {
                                        foreach (Item it in temp.Items)
                                        {
                                            ItemFood rawFood = it as ItemFood; //no need for a null check, as we built this Inventory
                                            ItemFood cookedFood;
                                            switch (rawFood.AName)
                                            {
                                                case "some raw fish":
                                                    cookedFood = new ItemFood(GameItems.COOKED_FISH, rawFood.BestBefore.TurnCounter, false, false); break;
                                                case "some raw rabbit":
                                                    cookedFood = new ItemFood(GameItems.COOKED_RABBIT, rawFood.BestBefore.TurnCounter, false, false); break;
                                                case "some raw chicken":
                                                    cookedFood = new ItemFood(GameItems.COOKED_CHICKEN, rawFood.BestBefore.TurnCounter, false, false); break;
                                                case "some raw dog meat":
                                                    cookedFood = new ItemFood(GameItems.COOKED_DOG_MEAT, rawFood.BestBefore.TurnCounter, false, false); break;
                                                case "some raw human flesh":
                                                    cookedFood = new ItemFood(GameItems.COOKED_HUMAN_FLESH, rawFood.BestBefore.TurnCounter, false, false); break;
                                                default:
                                                    throw new ArgumentException("unhandled raw food AName");
                                            }
                                            // remove the raw item (it has to happen first, to ensure there is room for the cooked version)
                                            map.RemoveItemAt(rawFood, obj.Location.Position); //assume stackinglimit of 1 and no more than 1
                                            // assumption: it's taken multiple turns to cook thus it must have been the player's piece of meat. we don't want it stolen
                                            cookedFood.IsForbiddenToAI = true;
                                            // ready for the player to collect
                                            map.DropItemAt(cookedFood, obj.Location.Position);
                                            // message.
                                            if (IsVisibleToPlayer(obj.Location))
                                                AddMessage(new Message(String.Format("{0} is ready.", cookedFood.TheName), m_Session.WorldTime.TurnCounter, Color.Yellow));
                                        }
                                    }
                                }
                            }

                            // rain may extinguish outdoor campfires
                            if (campfire != null)
                            {
                                bool rainExtinguishedIt = false;
                                if (!map.GetTileAt(campfire.Location.Position.X, campfire.Location.Position.Y).IsInside)
                                {
                                    if (m_Rules.RollChance(Rules.FIRE_RAIN_PUT_OUT_CHANCE))
                                    {
                                        UnapplyOnFire(campfire);
                                        rainExtinguishedIt = true;
                                    }
                                }

                                if (!rainExtinguishedIt)
                                {
                                    //consume wood fuel.
                                    --campfire.FuelUnits;
                                    if (campfire.FuelUnits <= 0)
                                        UnapplyOnFire(campfire);
                                }

                                continue;
                            }

                            // consume wood fuel.
                            if (barrel != null)
                            {
                                --barrel.FuelUnits;
                                if (barrel.FuelUnits <= 0)
                                    UnapplyOnFire(barrel);
                            }
                        }
                    }
                }
                #endregion
                // 5.2 Spread and extinguish tile fires, and burn victims on those tiles.     //@@MP - fires on grass, carpet and wood tiles may spread (Release 5-2)
                #region
                List<Point> alreadyTestedForFireSpreadThisTurnPoints = new List<Point>(); //hold each position that rolled a check against for the fire to spread to (whether it caught fire or not, or was already burnt or burning)
                List<Point> spreadToThisTurnPoints = new List<Point>(); //hold each position the fire spread to this turn, so that if the position is ahead of the outer x and y loops the actor won't be burnt by targettileactor then sourcetileactor on the same turn
                for (int x = 0; x < map.Width; x++)
                {
                    for (int y = 0; y < map.Height; y++)
                    {
                        if (map.IsAnyTileFireThere(map, new Point(x, y))) //is the tile on fire?
                        {
                            //already on fire so no need to check if fire will spread to it; just add these coordinates to the list of checked positions
                            alreadyTestedForFireSpreadThisTurnPoints.Add(new Point { X = x, Y = y });

                            #region 5.2.1 First, check if this fire spreads to an adjacent tile/s
                            Point position = new Point(x, y);
                            map.ForEachAdjacentInMap(position, (adj) =>
                            {
                                //determine if the fire could possibly spread to this tile

                                //don't bother testing tiles that aren't flammable by spreading
                                if (!map.IsInflammableTile(adj, true)) //the second parameter checks for both active and extinguished fires now (Release 6-1)
                                {
                                    //check if we've already tested the adjacent tile this turn
                                    bool checkedForFireSpreadAlready = false;
                                    for (int z = 0; z < alreadyTestedForFireSpreadThisTurnPoints.Count; z++)
                                    {
                                        Point pointbeingchecked = alreadyTestedForFireSpreadThisTurnPoints[z]; //walk through the list by position
                                        if (pointbeingchecked.X == adj.X && pointbeingchecked.Y == adj.Y)
                                        {
                                            checkedForFireSpreadAlready = true;
                                            break;
                                        }
                                    }
                                    //if the tile hasn't already been tested this turn do so now
                                    if (!checkedForFireSpreadAlready)
                                    {
                                        alreadyTestedForFireSpreadThisTurnPoints.Add(new Point { X = adj.X, Y = adj.Y }); //add these coordinates to the list of checked positions

                                        if (m_Rules.RollChance(TILE_FIRE_SPREAD_CHANCE)) //chance to spread the fire
                                        {
                                            //add these coordinates to the list of positions already caught on fire this turn, so that we don't double handle it
                                            spreadToThisTurnPoints.Add(new Point { X = adj.X, Y = adj.Y });
                                            //set the tile on fire
                                            SetTileOnFire(map, adj.X, adj.Y, false); //@@MP - new property-based approach (Release 6-1), false stops fires spreading through walls (Release 7-6)
                                            //if there's an actor or corpse/s on the tile that just caught on fire, burn them
                                            ApplyBurnDamageFromTileFire(map, new Point(adj.X, adj.Y), exemptFromTileFireDMGThisTurn); //@@MP - added list of excluded actors (Release 6-6)
                                        }
                                    }
                                }
                            });
                            #endregion

                            #region 5.2.2 Now, roll to extinguish fires that existed prior to this turn
                            //check if the fire started on this tile this turn, in which case we don't want to extinguish it
                            bool fireSpreadToThisTileThisTurn = false;
                            for (int z = 0; z < spreadToThisTurnPoints.Count; z++)
                            {
                                Point pointbeingchecked = spreadToThisTurnPoints[z]; //walk through the list by position
                                if (pointbeingchecked.X == x && pointbeingchecked.Y == y)
                                {
                                    fireSpreadToThisTileThisTurn = true;
                                    break;
                                }
                            }
                            //don't try to extinguish fires only just started this turn
                            if (!fireSpreadToThisTileThisTurn)
                            {
                                //tile fires always extinguish eventually, but rain has a chance to accelerate that
                                //    Ideally each fire will last about x days based on weather:
                                //       FIRE_DURATION_HEAVY_RAIN = 2;
                                //       FIRE_DURATION_LIGHT_RAIN = 3;
                                //       FIRE_DURATION_CLEAR_WEATHER = 6;

                                int extinguishChanceDivisor = 2; //2 means half, which allows tile fires chance to burn longer than actors on fire
                                if (map.GetTileAt(x, y).IsInside)
                                    extinguishChanceDivisor = 4; //fires inside arent affected by weather

                                int thisTileExtinguishChance = (int)Math.Round((decimal)(baseExtinguishChance / extinguishChanceDivisor), MidpointRounding.AwayFromZero); //ensure it's an int, rounded away from 0 to ensure there is always a chance

                                //roll to extinguish the fire on this tile
                                if (m_Rules.RollChance(thisTileExtinguishChance))
                                    ExtinguishOnFireTile(map.GetTileAt(x, y));
                                #endregion
                                #region 5.2.3 Finally, burn the actor if they stood in the fire for a turn (ie not extinguished)
                                else //if (map.IsAnyTileFireThere(map, new Point(x, y))) //is it still on fire?
                                {
                                    //it was already on fire when this turn started, so the fire did not spread here this turn and we must therefore
                                    //burn the actor (ie they were waiting/sleeping/trapped/silly/molotoved/flamethrowered) and also any corpse or plant here
                                    ApplyBurnDamageFromTileFire(map, new Point(x, y), exemptFromTileFireDMGThisTurn); //@@MP - added list of excluded actors (Release 6-6)
                                }
                                #endregion
                            }
                        }
                    }
                }
                #endregion

                #endregion
            }   // skipped in lodetail turns.

            // -- Check timers.
            #region
            if (map.CountTimers > 0)
            {
                List<TimedTask> timersGarbage = null;
                foreach (TimedTask t in map.Timers)
                {
                    t.Tick(map);
                    if (t.IsCompleted)
                    {
                        if (timersGarbage == null) timersGarbage = new List<TimedTask>(map.CountTimers);
                        timersGarbage.Add(t);
                    }
                }
                if (timersGarbage != null)
                {
                    foreach (TimedTask t in timersGarbage)
                        map.RemoveTimer(t);
                }
            }
            #endregion

            // -- Advance local time.
            #region
            bool wasLocalNight = map.LocalTime.IsNight;
            ++map.LocalTime.TurnCounter;
            bool isLocalDay = !map.LocalTime.IsNight;
            #endregion

            // -- Check for NPC upgrade.
            #region
            if (wasLocalNight && isLocalDay)
            {
                HandleLivingNPCsUpgrade(map);
            }
            else if (s_Options.ZombifiedsUpgradeDays != GameOptions.ZupDays.OFF && !wasLocalNight && !isLocalDay && GameOptions.IsZupDay(s_Options.ZombifiedsUpgradeDays, map.LocalTime.Day))
            {
                HandleUndeadNPCsUpgrade(map);
            }
            #endregion

            // -- Reset looping blocker  //@@MP (Release 7-1)
            #region
            foreach (Actor a in map.Actors)
            {
                a.RepetitiveNoAPCostActionsThisTurnCount = 0;
#if DEBUGAILOOPING
                a.IsLooping = false; //@@MP (Release 6-6), relocated (Release 7-1)
#endif

                /*if (a.HitPoints <= 0)// && !a.IsDead)
                    Logger.WriteLine(Logger.Stage.RUN_MAIN, String.Format("{0} down to {1} HP <{2}>", a.Name, a.HitPoints.ToString(), a.CauseOfDeath));*/ //DELETETHIS

                #endregion
            }
        }

        static void SpendActorActionPoints(Actor actor, int actionCost) //@@MP - made static (Release 5-7)
        {
            actor.ActionPoints -= actionCost;
            actor.LastActionTurn = actor.Location.Map.LocalTime.TurnCounter;
        }

        void SpendActorStaminaPoints(Actor actor, int staminaCost)
        {
            if (actor.Model.Abilities.CanTire)
            {
                // night penalty?
                if (actor.Location.Map.LocalTime.IsNight && staminaCost > 0)
                    staminaCost += m_Rules.NightStaminaPenalty(actor);

                // exhausted?
                if (m_Rules.IsActorExhausted(actor))
                    staminaCost *= 2;

                // apply.
                actor.StaminaPoints -= staminaCost;
            }
            else
                actor.StaminaPoints = Rules.STAMINA_INFINITE;
        }

        void RegenActorStaminaPoints(Actor actor, int staminaRegen)
        {
            if (actor.Model.Abilities.CanTire)
                actor.StaminaPoints = Math.Min(m_Rules.ActorMaxSTA(actor), actor.StaminaPoints + staminaRegen);
            else
                actor.StaminaPoints = Rules.STAMINA_INFINITE;
        }

        void RegenActorHitPoints(Actor actor, int hpRegen)
        {
            actor.HitPoints = Math.Min(m_Rules.ActorMaxHPs(actor), actor.HitPoints + hpRegen);
        }

        void RegenActorSleep(Actor actor, int sleepRegen)
        {
            actor.SleepPoints = Math.Min(m_Rules.ActorMaxSleep(actor), actor.SleepPoints + sleepRegen);
        }

        static void SpendActorSanity(Actor actor, int sanCost) //@@MP - made static (Release 5-7)
        {
            if (s_Options.IsSanityEnabled) actor.Sanity -= sanCost;
            if (actor.Sanity < 0) actor.Sanity = 0;
        }

        public void RegenActorSanity(Actor actor, int sanRegen) //@@MP - made public for use with AI SelectAction (Release 7-6)
        {
            actor.Sanity = Math.Min(m_Rules.ActorMaxSanity(actor), actor.Sanity + sanRegen);
        }

        void ModifyActorTrustInLeader(Actor a, int mod, bool addMessage)
        {
            // do it.
            a.TrustInLeader += mod;
            if (a.TrustInLeader > Rules.TRUST_MAX)
                a.TrustInLeader = Rules.TRUST_MAX;
            else if (a.TrustInLeader < Rules.TRUST_MIN)
                a.TrustInLeader = Rules.TRUST_MIN;

            // if leader is player, message.
            if (addMessage && a.Leader.IsPlayer)
                AddMessage(new Message(String.Format("({0} trust with {1})", mod, a.TheName), m_Session.WorldTime.TurnCounter, Color.White));
        }

        #region -SIMULATION ***
        static SimFlags ComputeSimFlagsForTurn(int turn) //@@MP - made static (Release 5-7)
        {
            bool loDetail = false;

            switch (s_Options.SimulateDistricts)
            {
                case GameOptions.SimRatio.FULL:
                    loDetail = false;
                    break;
                case GameOptions.SimRatio.THREE_QUARTER:    // 3/4, skip 1 out of 4.
                    loDetail = (turn % 4 == 3);
                    break;
                case GameOptions.SimRatio.TWO_THIRDS:    // 2/3, skip 1 out of 3.
                    loDetail = (turn % 3 == 2);
                    break;
                case GameOptions.SimRatio.HALF:    // 1/2, skip 1 out of 2.
                    loDetail = (turn % 2 == 1);
                    break;
                case GameOptions.SimRatio.ONE_THIRD:    // 1/3, play 1 out of 3.
                    loDetail = (turn % 3 != 0);
                    break;
                case GameOptions.SimRatio.ONE_QUARTER:    // 1/4, play 1 out of 4.
                    loDetail = (turn % 4 != 0);
                    break;
                case GameOptions.SimRatio.OFF:
                    loDetail = true;
                    break;
                default:
                    throw new InvalidOperationException("unhandled simRatio");
            }

            return loDetail ? SimFlags.LODETAIL_TURN : SimFlags.HIDETAIL_TURN;
        }

        void SimulateDistrict(District d)
        {
            AdvancePlay(d, ComputeSimFlagsForTurn(d.EntryMap.LocalTime.TurnCounter));
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns>true if simulated a district; false if didn't need to simulate.</returns>
        bool SimulateNearbyDistricts(District d)
        {
            bool hadToSim = false;
            int xmin = d.WorldPosition.X - 1;
            int xmax = d.WorldPosition.X + 1;
            int ymin = d.WorldPosition.Y - 1;
            int ymax = d.WorldPosition.Y + 1;
            m_Session.World.TrimToBounds(ref xmin, ref ymin);
            m_Session.World.TrimToBounds(ref xmax, ref ymax);

            for (int dx = xmin; dx <= xmax; dx++)
                for (int dy = ymin; dy <= ymax; dy++)
                {
                    // don't sim same district!
                    if (dx == d.WorldPosition.X && dy == d.WorldPosition.Y)
                        continue;

                    District otherDistrict = m_Session.World[dx, dy];

                    // don't sim if up to date!
                    int dTurns = d.EntryMap.LocalTime.TurnCounter - otherDistrict.EntryMap.LocalTime.TurnCounter;
                    if (dTurns > 0)
                    {
                        //Logger.WriteLine(Logger.Stage.RUN_MAIN, "sim has to catch " + dTurns + " turns");
                        // simulate district.
                        hadToSim = true;
                        SimulateDistrict(otherDistrict);
                        //Console.Out.WriteLine("  sim simulated district " + otherDistrict.Name+ " turn now "+otherDistrict.EntryMap.LocalTime.TurnCounter);
                    }
                    //else  // DEBUG
                    //    Console.Out.WriteLine("  sim district " + otherDistrict.Name + " is up to date " + otherDistrict.EntryMap.LocalTime.TurnCounter);
                }

            return hadToSim;
        }

        #region --Simulation Thread
        /*void RestartSimThread() // alpha10 obsolete, we do it "manually" in some places
        {
            StopSimThread();
            StartSimThread();
        }*/

        void StartSimThread()
        {
            if (s_Options.IsSimON && s_Options.SimThread)
            {
                Logger.WriteLine(Logger.Stage.RUN_MAIN, "starting sim...");

                if (m_SimThread == null)
                {
                    Logger.WriteLine(Logger.Stage.RUN_MAIN, "...allocating sim thread");
                    m_SimThread = new Thread(new ThreadStart(SimThreadProc));
                    m_SimThread.Name = "Simulation Thread";
                }
                else
                    Logger.WriteLine(Logger.Stage.RUN_MAIN, "...sim thread already allocated");

                Logger.WriteLine(Logger.Stage.RUN_MAIN, "...sim thread start.");
                lock (m_SimStateLock) { m_SimThreadDoRun = true; }; // alpha10
                m_SimThread.Start();
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="abort">true to stop the thread forcefully, false to stop it cleanly (recommended)</param>
        void StopSimThread(bool abort)
        {
            // alpha10 StopSimThread is now blocking until the sim thread has actually stopped
            // allowed to abort when ending a game or dying because of weird bug in release build where the sim thread 
            // doesnt want to stop when dying as undead and we have to abort it(!)

            Logger.WriteLine(Logger.Stage.RUN_MAIN, "stopping & clearing sim thread...");

            if (m_SimThread != null)
            {
                if (abort) // stop thread forcefully
                {
                    Logger.WriteLine(Logger.Stage.RUN_MAIN, "...aborting sim thread");
                    try
                    {
                        m_SimThread.Abort();
                    }
                    catch (Exception e)
                    {
                        Logger.WriteLine(Logger.Stage.RUN_MAIN, "...exception when aborting (ignored) " + e.Message);
                    }
                    m_SimThread = null;
                    m_SimThreadDoRun = false;
                }
                else // try to stop cleanly
                {
                    Logger.WriteLine(Logger.Stage.RUN_MAIN, "...telling sim thread to stop");
                    lock (m_SimStateLock) { m_SimThreadDoRun = false; };
                    Logger.WriteLine(Logger.Stage.RUN_MAIN, "...sim thread told to stop");
                    for (; ; )
                    {
                        Logger.WriteLine(Logger.Stage.RUN_MAIN, "...waiting for sim thread to stop");
                        Thread.Sleep(10);
                        bool stopped = false;
                        lock (m_SimStateLock) { stopped = !m_SimThreadIsWorking; }
                        if (!stopped && !m_SimThread.IsAlive)
                        {
                            Logger.WriteLine(Logger.Stage.RUN_MAIN, "...sim thread is not alive and did not stop properly, consider it stopped");
                            stopped = true;
                        }
                        if (stopped)
                            break;
                    }
                    Logger.WriteLine(Logger.Stage.RUN_MAIN, "...sim thread has stopped");
                    m_SimThread = null;
                }
            }

            Logger.WriteLine(Logger.Stage.RUN_MAIN, "stopping & clearing sim thread done!");
        }

        void SimThreadProc()
        {
            Logger.WriteLine(Logger.Stage.RUN_MAIN, "sim thread: starting loop");

            District playerDistrict = m_Player.Location.Map.District;  // alpha10

            lock (m_SimStateLock) { m_SimThreadIsWorking = true; }  // alpha10

            for (; ; )  // alpha10
            //while (true)
            {
                //Console.Out.WriteLine("sim thread loop");
                // alpha10
                bool stop = false;
                lock (m_SimStateLock) { stop = !m_SimThreadDoRun; }
                if (stop)
                    break;

                Thread.Sleep(10);
                //Monitor.Enter(m_SimMutex); // alpha10 obsolete
                try
                {
                    if (m_Player != null)
                    {
                        SimulateNearbyDistricts(playerDistrict);
                    }
                }
                catch (Exception e)
                {
                    Logger.WriteLine(Logger.Stage.RUN_MAIN, "sim thread: exception while simulating nearby districts");
                    Logger.WriteLine(Logger.Stage.RUN_MAIN, "sim thread: " + e.Message);
                    // stop sim thread, better than crashing i guess...
                    break;
                }
                //finally
                //{
                //    Monitor.Exit(m_SimMutex); // alpha10 obsolete
                //}
            }

            Logger.WriteLine(Logger.Stage.RUN_MAIN, "sim thread: told to stop, stopping work");
            lock (m_SimStateLock) { m_SimThreadIsWorking = false; }
            Logger.WriteLine(Logger.Stage.RUN_MAIN, "sim thread: working stopped");
        }
        #endregion
        #endregion
        #endregion

        #region 4. GAME OVER
        #region -PLAYER DEATH & POST MORTEM
        void PlayerDied(Actor killer, string reason)
        {
            // stop sim thread.
            StopSimThread(true);

            // mouse.
            m_UI.UI_SetCursor(null);

            // music.
            m_AmbientSFXManager.StopAll(); //@@MP (Release 6-1)
            m_MusicManager.StopAll();
            //m_SFXManager.StopAll();
            m_MusicManager.Play(GameMusics.PLAYER_DEATH, AudioPriority.PRIORITY_EVENT);

            ///////////
            // Scoring
            ///////////
            #region
            m_Session.Scoring.TurnsSurvived = m_Session.WorldTime.TurnCounter;
            m_Session.Scoring.SetKiller(killer);
            if (m_Player.CountFollowers > 0)
            {
                foreach (Actor fo in m_Player.Followers)
                    m_Session.Scoring.AddFollowerWhenDied(fo);
            }

            List<Zone> zone = m_Player.Location.Map.GetZonesAt(m_Player.Location.Position.X, m_Player.Location.Position.Y);
            if (zone == null)
            {
                m_Session.Scoring.DeathPlace = m_Player.Location.Map.Name;
            }
            else
            {
                string zoneName = zone[0].Name;
                m_Session.Scoring.DeathPlace = String.Format("{0} at {1}", m_Player.Location.Map.Name, zoneName);
            }
            if (killer != null)
                m_Session.Scoring.DeathReason = String.Format("{0} by {1} {2}",
                    m_Rules.IsMurder(killer, m_Player) ? "Murdered" : "Killed", killer.Model.Name, killer.TheName);
            else
                m_Session.Scoring.DeathReason = String.Format("Death by {0}", reason);
            m_Session.Scoring.AddEvent(m_Session.WorldTime.TurnCounter, "Died.");
            #endregion

            /////////////////////////////////////////
            // Tip, Message, screenshot & permadeath.
            /////////////////////////////////////////
            #region
            int iTip = m_Rules.Roll(0, GameTips.TIPS.Length);
            AddOverlay(new OverlayPopup(new string[] { "TIP OF THE DEAD", "Did you know that...", GameTips.TIPS[iTip] }, Color.White, Color.White, POPUP_FILLCOLOR, new Point(0, 0)));

            ClearMessages();
            AddMessage(new Message("**** YOU DIED! ****", m_Session.WorldTime.TurnCounter, Color.Red));
            if (killer != null)
                AddMessage(new Message(String.Format("Killer : {0}.", killer.TheName), m_Session.WorldTime.TurnCounter, Color.Red));
            AddMessage(new Message(String.Format("Reason : {0}.", reason), m_Session.WorldTime.TurnCounter, Color.Red));
            if (m_Player.Model.Abilities.IsUndead)
                AddMessage(new Message("You die one last time... Game over!", m_Session.WorldTime.TurnCounter, Color.Red));
            else
                AddMessage(new Message("You join the realm of the undeads... Game over!", m_Session.WorldTime.TurnCounter, Color.Red));

            // if permadeath on delete save files.
            if (s_Options.IsPermadeathOn)
            {
                DeleteSavedGame(GetUserSave());
                DeleteSavedGame(GetUserSavesPath() + "backup.dat");  //@@MP (Release 7-5)
            }

            // screenshot.
            if (s_Options.IsDeathScreenshotOn)
            {
                RedrawPlayScreen();
                string shotname = DoTakeScreenshot();
                if (shotname == null)
                    AddMessage(MakeErrorMessage("could not save death screenshot."));
                else
                    AddMessage(new Message(String.Format("Death screenshot saved : {0}.", shotname), m_Session.WorldTime.TurnCounter, Color.Red));
            }

            AddMessagePressEnter();
            #endregion

            // post mortem.
            HandlePostMortem();

            // music.
            m_MusicManager.StopAll();
            m_MusicManager.StopAll();
            m_SFXManager.StopAll();

            // alpha10.1 bot release control
#if DEBUG
            BotReleaseControl();
#endif
        }

        void PlayerWasRescued() //@@MP (Release 6-4)
        {
            // stop sim thread.
            StopSimThread(true);

            // mouse.
            m_UI.UI_SetCursor(null);

            // audio.
            m_AmbientSFXManager.StopAll();
            m_MusicManager.StopAll();
            m_SFXManager.StopAll();
            m_MusicManager.Play(GameMusics.POST_RESCUE, AudioPriority.PRIORITY_EVENT);

            ///////////
            // Scoring
            ///////////
            #region
            m_Session.Scoring.TurnsSurvived = m_Session.WorldTime.TurnCounter;
            if (m_Player.CountFollowers > 0)
            {
                foreach (Actor fo in m_Player.Followers)
                    m_Session.Scoring.AddFollowerWhenDied(fo);
            }

            List<Zone> zone = m_Player.Location.Map.GetZonesAt(m_Player.Location.Position.X, m_Player.Location.Position.Y);
            if (zone == null)
            {
                m_Session.Scoring.DeathPlace = m_Player.Location.Map.Name;
            }
            else
            {
                string zoneName = zone[0].Name;
                m_Session.Scoring.DeathPlace = String.Format("{0} at {1}", m_Player.Location.Map.Name, zoneName);
            }

            m_Session.Scoring.DeathReason = String.Format("Rescued to Murdoch air force base");
            m_Session.Scoring.AddEvent(m_Session.WorldTime.TurnCounter, "Rescued.");
            #endregion

            /////////////////////////////////////////
            // Tip, Message, screenshot & permadeath.
            /////////////////////////////////////////
            #region
            int iTip = m_Rules.Roll(0, GameTips.TIPS.Length);
            AddOverlay(new OverlayPopup(new string[] { "TIP OF THE DEAD", "Did you know that...", GameTips.TIPS[iTip] }, Color.White, Color.White, POPUP_FILLCOLOR, new Point(0, 0)));

            ClearMessages();
            AddMessage(new Message("**** YOU WERE RESCUED! ****", m_Session.WorldTime.TurnCounter, Color.Red));
            AddMessage(new Message(String.Format("Congratulations. Survivng that dead city was no small feat."), m_Session.WorldTime.TurnCounter, Color.Red));
            AddMessage(new Message(String.Format("But could you have survived even longer...?"), m_Session.WorldTime.TurnCounter, Color.Red));

            // screenshot.
            if (s_Options.IsDeathScreenshotOn)
            {
                RedrawPlayScreen();
                string shotname = DoTakeScreenshot();
                if (shotname == null)
                    AddMessage(MakeErrorMessage("could not save rescue screenshot."));
                else
                    AddMessage(new Message(String.Format("Rescue screenshot saved : {0}.", shotname), m_Session.WorldTime.TurnCounter, Color.Red));
            }

            AddMessagePressEnter();
            #endregion

            // post-rescue.
            HandlePostRescue();

            // remove player to end the game
            m_PlayerWasRescued = true; //removing isn't enough, we must use this to stop the world
            m_Player.Location.Map.RemoveActor(m_Player);

            // audio.
            m_AmbientSFXManager.StopAll();
            m_MusicManager.StopAll();
            m_SFXManager.StopAll();

            // alpha10.1 bot release control
#if DEBUG
            BotReleaseControl();
#endif
        }

        static string TimeSpanToString(TimeSpan rt) //@@MP - made static (Release 5-7)
        {
            string timeDays = rt.Days == 0 ? "" : String.Format("{0} days ", rt.Days);
            string timeHours = rt.Hours == 0 ? "" : String.Format("{0:D2} hours ", rt.Hours);
            string timeMinutes = rt.Minutes == 0 ? "" : String.Format("{0:D2} minutes ", rt.Minutes);
            string timeSeconds = rt.Seconds == 0 ? "" : String.Format("{0:D2} seconds", rt.Seconds);
            return String.Format("{0}{1}{2}{3}", timeDays, timeHours, timeMinutes, timeSeconds);
        }

        void HandlePostMortem()
        {
            ////////////////
            // Prepare data.
            ////////////////
            WorldTime deathTime = new WorldTime();
            deathTime.TurnCounter = m_Session.Scoring.TurnsSurvived;
            bool isMale = m_Player.Model.DollBody.IsMale;
            string heOrShe = isMale ? "He" : "She";
            //string hisOrHer = HisOrHer(m_Player); //@@MP - unused (Release 5-7)
            string himOrHer = isMale ? "him" : "her";
            string name = m_Player.TheName.Replace("(YOU) ", "");
            TimeSpan rt = m_Session.Scoring.RealLifePlayingTime;
            string realTimeString = TimeSpanToString(rt);
            m_Session.Scoring.Side = m_Player.Model.Abilities.IsUndead ? DifficultySide.FOR_UNDEAD : DifficultySide.FOR_SURVIVOR;
            m_Session.Scoring.DifficultyRating = Scoring.ComputeDifficultyRating(s_Options, m_Session.Scoring.Side, m_Session.Scoring.ReincarnationNumber, m_Session.GameMode);

            ////////////////////////////////////
            // Format scoring into a text file.
            ///////////////////////////////////
            TextFile graveyard = new TextFile();

            graveyard.Append(String.Format("ROGUE SURVIVOR: {0}", SetupConfig.GAME_VERSION));
            graveyard.Append(String.Format("POST MORTEM - {0}", m_Session.Scoring.GameMode)); //m_Session.GameMode.ToString())); //@@MP - added game mode (Release 5-2)

            #region Summary
            graveyard.Append(String.Format("{0} was {1} and {2}.", name, AorAn(m_Player.Model.Name), AorAn(m_Player.Faction.MemberName)));
            graveyard.Append(String.Format("{0} survived to see {1}.", heOrShe, deathTime.ToString()));
            graveyard.Append(String.Format("{0}'s spirit guided {1} for {2}.", name, himOrHer, realTimeString));
            if (m_Session.Scoring.ReincarnationNumber > 0)
                graveyard.Append(String.Format("{0} was reincarnation #{1}.", heOrShe, m_Session.Scoring.ReincarnationNumber));
            graveyard.Append(" ");
            #endregion

            graveyard.Append("> SCORING");
            #region
            graveyard.Append(String.Format("{0} scored a net total of {1} points.", heOrShe, m_Session.Scoring.TotalPoints));
            graveyard.Append(String.Format("- difficulty rating of {0}%.", (int)(100 * m_Session.Scoring.DifficultyRating)));
            graveyard.Append(String.Format("- {0} base points for survival.", m_Session.Scoring.SurvivalPoints));
            graveyard.Append(String.Format("- {0} base points for kills.", m_Session.Scoring.KillPoints));
            graveyard.Append(String.Format("- {0} base points for achievements.", m_Session.Scoring.AchievementPoints));
            graveyard.Append(" ");
            #endregion

            graveyard.Append("> ACHIEVEMENTS");
            #region
            foreach (Achievement ach in m_Session.Scoring.Achievements)
            {
                if (ach.IsDone)
                    graveyard.Append(String.Format("- {0} for {1} points!", ach.Name, ach.ScoreValue));
                else
                    graveyard.Append(String.Format("- Fail : {0}.", ach.TeaseName));
            }
            if (m_Session.Scoring.CompletedAchievementsCount == 0)
            {
                graveyard.Append("Didn't achieve anything notable. And then died.");
                graveyard.Append(String.Format("(there are {0} available achievements in total)", Scoring.MAX_ACHIEVEMENTS)); //@@MP - removed reference to 'winning' the game (Release 6-4)
            }
            else
            {
                graveyard.Append(String.Format("Total : {0}/{1}.", m_Session.Scoring.CompletedAchievementsCount, Scoring.MAX_ACHIEVEMENTS));
                if (m_Session.Scoring.CompletedAchievementsCount >= Scoring.MAX_ACHIEVEMENTS)
                {
                    graveyard.Append("*** You achieved everything! You can consider having 'won' this version of the game! Congratulations! ***");
                }
                else
                    graveyard.Append("(unlock all the achievements to 'win' this game version)");
                graveyard.Append("(later versions of the game will feature real winning conditions and multiple endings...)");
            }
            graveyard.Append(" ");
            #endregion

            graveyard.Append("> DEATH");
            #region
            graveyard.Append(String.Format("{0} in {1}.", m_Session.Scoring.DeathReason, m_Session.Scoring.DeathPlace));
            graveyard.Append(" ");
            #endregion

            graveyard.Append("> KILLS");
            #region
            if (m_Session.Scoring.HasNoKills)
            {
                graveyard.Append(String.Format("{0} was a pacifist. Or too scared to fight.", heOrShe));
            }
            else
            {
                // models kill list.
                foreach (Scoring.KillData killData in m_Session.Scoring.Kills)
                {
                    string modelName = killData.Amount > 1 ? Models.Actors[killData.ActorModelID].PluralName : Models.Actors[killData.ActorModelID].Name;
                    graveyard.Append(String.Format("{0,4} {1}.", killData.Amount, modelName));
                }
            }
            // murders? only livings.
            if (!m_Player.Model.Abilities.IsUndead)
            {
                if (m_Player.MurdersCounter > 0)
                {
                    graveyard.Append(String.Format("{0} committed {1} murder{2}!", heOrShe, m_Player.MurdersCounter, m_Player.MurdersCounter > 1 ? "s" : ""));
                }
            }

            graveyard.Append(" ");
            #endregion

            graveyard.Append("> FUN FACTS!");
            #region
            graveyard.Append(String.Format("While {0} has died, others are still surviving", name));
            string[] funFacts = CompileDistrictFunFacts(m_Player.Location.Map.District);
            for (int i = 0; i < funFacts.Length; i++)
                graveyard.Append(funFacts[i]);
            graveyard.Append("");
            #endregion

            graveyard.Append("> SKILLS");
            #region
            if (m_Player.Sheet.SkillTable.Skills == null)
            {
                graveyard.Append(String.Format("{0} was a jack of all trades. Or incompetent.", heOrShe));
            }
            else
            {
                foreach (Skill sk in m_Player.Sheet.SkillTable.Skills)
                {
                    graveyard.Append(String.Format("{0}-{1}.", sk.Level, Skills.Name(sk.ID)));
                }
            }
            graveyard.Append(" ");
            #endregion

            graveyard.Append("> INVENTORY");
            #region
            if (m_Player.Inventory.IsEmpty)
            {
                graveyard.Append(String.Format("{0} travelled light. Or was really bad at scavenging.", heOrShe));
            }
            else
            {
                foreach (Item it in m_Player.Inventory.Items)
                {
                    string desc = DescribeItemShort(it);
                    if (it.IsEquipped)
                        graveyard.Append(String.Format("- {0} (equipped).", desc));
                    else
                        graveyard.Append(String.Format("- {0}.", desc));
                }
            }
            graveyard.Append(" ");
            #endregion

            graveyard.Append("> FOLLOWERS");
            #region
            if (m_Session.Scoring.FollowersWhendDied == null || m_Session.Scoring.FollowersWhendDied.Count == 0)
            {
                graveyard.Append(String.Format("{0} was a lone wolf. Or everyone else was dead.", heOrShe));
            }
            else
            {
                // names.
                StringBuilder sb = new StringBuilder(String.Format("{0} was leading", heOrShe));
                bool firstFo = true;
                int i = 0;
                int count = m_Session.Scoring.FollowersWhendDied.Count;
                foreach (Actor fo in m_Session.Scoring.FollowersWhendDied)
                {
                    if (firstFo)
                        sb.Append(" ");
                    else
                    {
                        if (i == count)
                            sb.Append(".");
                        else if (i == count - 1)
                            sb.Append(" and ");
                        else
                            sb.Append(", ");
                    }
                    sb.Append(fo.TheName);
                    ++i;
                    firstFo = false;
                }
                sb.Append(".");
                graveyard.Append(sb.ToString());

                // skills.
                foreach (Actor fo in m_Session.Scoring.FollowersWhendDied)
                {
                    graveyard.Append(String.Format("{0} skills : ", fo.Name));
                    if (fo.Sheet.SkillTable != null && fo.Sheet.SkillTable.Skills != null)
                    {
                        foreach (Skill sk in fo.Sheet.SkillTable.Skills)
                        {
                            graveyard.Append(String.Format("{0}-{1}.", sk.Level, Skills.Name(sk.ID)));
                        }
                    }
                }
            }
            graveyard.Append(" ");
            #endregion

            graveyard.Append("> EVENTS");
            #region
            if (m_Session.Scoring.HasNoEvents)
            {
                graveyard.Append(String.Format("{0} had a quiet life. Or dull and boring.", heOrShe));
            }
            else
            {
                foreach (Scoring.GameEventData ev in m_Session.Scoring.Events)
                {
                    WorldTime evTime = new WorldTime();
                    evTime.TurnCounter = ev.Turn;
                    graveyard.Append(String.Format("- {0,13} : {1}", evTime.ToString(), ev.Text));
                }
            }
            graveyard.Append(" ");
            #endregion

            graveyard.Append("> CUSTOM OPTIONS");
            #region
            //@@MP - want the graveyard to lists all modifiers, rather than just those changed from default (Release 4)
            graveyard.Append(String.Format("- difficulty rating of {0}%", (int)(100 * m_Session.Scoring.DifficultyRating)));
            //if (s_Options.IsPermadeathOn)
            graveyard.Append(String.Format("- {0} : {1}", GameOptions.Name(GameOptions.IDs.GAME_PERMADEATH), s_Options.IsPermadeathOn ? "yes" : "no")); //@@MP - actually shows yes or no now (Release 5-7)
            //if (s_Options.CitySize != GameOptions.DEFAULT_CITY_SIZE)
            graveyard.Append(String.Format("- {0} : {1}", GameOptions.Name(GameOptions.IDs.GAME_CITY_SIZE), s_Options.CitySize));
            //if (s_Options.DistrictSize != GameOptions.DEFAULT_DISTRICT_SIZE)
            graveyard.Append(String.Format("- {0} : {1}", GameOptions.Name(GameOptions.IDs.GAME_DISTRICT_SIZE), s_Options.DistrictSize));
            //if (s_Options.MaxCivilians != GameOptions.DEFAULT_MAX_CIVILIANS)
            graveyard.Append(String.Format("- {0} : {1}", GameOptions.Name(GameOptions.IDs.DIFFICULTY_MAX_CIVILIANS), s_Options.MaxCivilians));
            //if (s_Options.MaxUndeads != GameOptions.DEFAULT_MAX_UNDEADS)
            graveyard.Append(String.Format("- {0} : {1}", GameOptions.Name(GameOptions.IDs.DIFFICULTY_MAX_UNDEADS), s_Options.MaxUndeads));
            graveyard.Append(String.Format("- {0} : {1}", GameOptions.Name(GameOptions.IDs.DIFFICULTY_RESCUE_DAY), s_Options.HiddenRescueDay)); //@@MP (Release 7-4)
            graveyard.Append(String.Format("- {0} : {1}", GameOptions.Name(GameOptions.IDs.DIFFICULTY_RESOURCES_AVAILABILITY), s_Options.ResourcesAvailability)); //@@MP (Release 7-4)
            graveyard.Append(String.Format("- {0} : {1}%", GameOptions.Name(GameOptions.IDs.DIFFICULTY_LIVING_DAMAGE_PERCENT), s_Options.LivingDamagePercent)); //@@MP (Release 7-4)
            //if (s_Options.IsSanityEnabled)
            graveyard.Append(String.Format("- {0} : {1}", GameOptions.Name(GameOptions.IDs.DIFFICULTY_SANITY), s_Options.IsSanityEnabled ? "on" : "off"));
            //if (!s_Options.NPCCanStarveToDeath)
            graveyard.Append(String.Format("- {0} : {1}", GameOptions.Name(GameOptions.IDs.DIFFICULTY_NPC_CAN_STARVE_TO_DEATH), s_Options.NPCCanStarveToDeath ? "yes" : "no"));
            //if(s_Options.StarvedZombificationChance != GameOptions.DEFAULT_STARVED_ZOMBIFICATION_CHANCE)
            graveyard.Append(String.Format("- {0} : {1}", GameOptions.Name(GameOptions.IDs.DIFFICULTY_STARVED_ZOMBIFICATION), s_Options.StarvedZombification ? "yes" : "no"));
            //if (s_Options.ZombificationChance != GameOptions.DEFAULT_ZOMBIFICATION_CHANCE)
            graveyard.Append(String.Format("- {0} : {1}%", GameOptions.Name(GameOptions.IDs.DIFFICULTY_ZOMBIFICATION_CHANCE), s_Options.ZombificationChance));
            graveyard.Append(String.Format("- {0} : {1}", GameOptions.Name(GameOptions.IDs.DIFFICULTY_AGGRESSIVE_HUNGRY_CIVILIANS), s_Options.IsAggressiveHungryCiviliansOn ? "yes" : "no")); //@@MP (Release 5-2)
            graveyard.Append(String.Format("- {0} : {1}%", GameOptions.Name(GameOptions.IDs.DIFFICULTY_UNDEAD_DAMAGE_PERCENT), s_Options.UndeadDamagePercent)); //@@MP (Release 7-4)
            if (Rules.HasEvolution(m_Session.GameMode)) //@@MP (Release 5-2)
            {
                //if(!s_Options.AllowUndeadsEvolution)
                graveyard.Append(String.Format("- {0} : {1}", GameOptions.Name(GameOptions.IDs.DIFFICULTY_ALLOW_UNDEADS_EVOLUTION), s_Options.AllowUndeadsEvolution ? "yes" : "no"));
                graveyard.Append(String.Format("- {0} : {1}", GameOptions.Name(GameOptions.IDs.DIFFICULTY_SKELETONS_UPGRADE), s_Options.SkeletonsUpgrade ? "yes" : "no"));
                //graveyard.Append(String.Format("- {0} : {1}.", GameOptions.Name(GameOptions.IDs.DIFFICULTY_RATS_UPGRADE), s_Options.RatsUpgrade ? "yes" : "no")); //@@MP (Release 5-7)
                graveyard.Append(String.Format("- {0} : {1}", GameOptions.Name(GameOptions.IDs.DIFFICULTY_SHAMBLERS_UPGRADE), s_Options.ShamblersUpgrade ? "yes" : "no"));
                graveyard.Append(String.Format("- {0} : {1}", GameOptions.Name(GameOptions.IDs.DIFFICULTY_UNDEADS_UPGRADE_DAYS), s_Options.ZombifiedsUpgradeDays));
            }
            else
            {
                graveyard.Append(String.Format("- {0} : {1}", GameOptions.Name(GameOptions.IDs.DIFFICULTY_ANTIVIRAL_PILLS), s_Options.AntiviralPills ? "yes" : "no"));
            }
            //if (s_Options.DayZeroUndeadsPercent != GameOptions.DEFAULT_DAY_ZERO_UNDEADS_PERCENT)
            graveyard.Append(String.Format("- {0} : {1}%", GameOptions.Name(GameOptions.IDs.DIFFICULTY_DAY_ZERO_UNDEADS_PERCENT), s_Options.DayZeroUndeadsPercent));
            //if (s_Options.ZombieInvasionDailyIncrease != GameOptions.DEFAULT_ZOMBIE_INVASION_DAILY_INCREASE)
            graveyard.Append(String.Format("- {0} : {1}%", GameOptions.Name(GameOptions.IDs.DIFFICULTY_ZOMBIE_INVASION_DAILY_INCREASE), s_Options.ZombieInvasionDailyIncrease));
            graveyard.Append(String.Format("- {0} : {1}%", GameOptions.Name(GameOptions.IDs.DIFFICULTY_NATGUARD_FACTOR), s_Options.NatGuardFactor)); //@@MP (Release 5-2)
            graveyard.Append(String.Format("- {0} : {1}%", GameOptions.Name(GameOptions.IDs.DIFFICULTY_BLACKOPS_RAIDS), s_Options.BlackOpsRaidsEnabled)); //@@MP (Release 7-5)
            graveyard.Append(String.Format("- {0} : {1}%", GameOptions.Name(GameOptions.IDs.DIFFICULTY_SUPPLIESDROP_FACTOR), s_Options.SuppliesDropFactor)); //@@MP (Release 5-2)
            /*if (s_Options.IsLivingReincRestricted) //if (s_Options.MaxReincarnations != GameOptions.DEFAULT_MAX_REINCARNATIONS) //@@MP (Release 5-2), disabled IsLivingReincRestricted (Release 5-7)
                graveyard.Append(String.Format("- {0} : {1}.", GameOptions.Name(GameOptions.IDs.GAME_REINC_LIVING_RESTRICTED), s_Options.IsLivingReincRestricted ? "on" : "off"));*/
            graveyard.Append(" ");
            #endregion

            graveyard.Append("> R.I.P");
            #region
            graveyard.Append(String.Format("May {0} rest in peace, and not rise again.", HeOrShe(m_Player))); //@@MP - replaced with something better (Release 1)
                                                                                                              /*graveyard.Append(String.Format("For {0} body is now a meal for evil.", HisOrHer(m_Player)));
                                                                                                              graveyard.Append("The End.");*/
            #endregion

            /////////////////////
            // Save to graveyard
            /////////////////////
            int gx, gy;
            gx = gy = 0;
            m_UI.UI_Clear(Color.Black);
            m_UI.UI_DrawStringBold(Color.Yellow, "Saving post mortem to graveyard...", 0, 0);
            gy += BOLD_LINE_SPACING;
            m_UI.UI_Repaint();
            string graveName = GetUserNewGraveyardName();
            string graveFile = GraveFilePath(graveName);
            if (!graveyard.Save(graveFile))
            {
                m_UI.UI_DrawStringBold(Color.Red, "Could not save to graveyard.", 0, gy);
                gy += BOLD_LINE_SPACING;
            }
            else
            {
                m_UI.UI_DrawStringBold(Color.Yellow, "Grave saved to :", 0, gy);
                gy += BOLD_LINE_SPACING;
                m_UI.UI_DrawString(Color.White, graveFile, 0, gy);
                gy += BOLD_LINE_SPACING;
            }
            DrawFootnote(Color.White, "press ENTER");
            m_UI.UI_Repaint();
            WaitEnter();

            ///////////////////////////////
            // Display grave as text file.
            ///////////////////////////////
            graveyard.FormatLines(TEXTFILE_CHARS_PER_LINE);
            int iLine = 0;
            bool loop = false;
            do
            {
                // header.
                m_UI.UI_Clear(Color.Black);
                gx = gy = 0;
                DrawHeader(0);
                gy += BOLD_LINE_SPACING;

                // text.
                int linesThisPage = 0;
                m_UI.UI_DrawStringBold(Color.White, "---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+", 0, gy);
                gy += BOLD_LINE_SPACING;
                while (linesThisPage < TEXTFILE_LINES_PER_PAGE && iLine < graveyard.FormatedLines.Count)
                {
                    string line = graveyard.FormatedLines[iLine];
                    m_UI.UI_DrawStringBold(Color.White, line, gx, gy);
                    gy += BOLD_LINE_SPACING;
                    ++iLine;
                    ++linesThisPage;
                }

                // foot.
                m_UI.UI_DrawStringBold(Color.White, "---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+", 0, CANVAS_HEIGHT - 2 * BOLD_LINE_SPACING);
                if (iLine < graveyard.FormatedLines.Count)
                    DrawFootnote(Color.White, "press ENTER for more");
                else
                    DrawFootnote(Color.White, "press ENTER to leave");

                // wait.
                m_UI.UI_Repaint();
                WaitEnter();

                // loop?
                loop = (iLine < graveyard.FormatedLines.Count);
            }
            while (loop);

            ///////////////
            // High Score?
            ///////////////
            StringBuilder skillsSb = new StringBuilder();
            if (m_Player.Sheet.SkillTable.Skills != null)
            {
                foreach (Skill sk in m_Player.Sheet.SkillTable.Skills)
                {
                    skillsSb.AppendFormat("{0}-{1} ", sk.Level, Skills.Name(sk.ID));
                }
            }
            HiScore newHiScore = HiScore.FromScoring(name, m_Session.Scoring, skillsSb.ToString());
            if (m_HiScoreTable.Register(newHiScore))
            {
                SaveHiScoreTable();
                HandleHiScores(true);
            }
        }

        void HandlePostRescue() //@@MP (Release 6-4)
        {
            ////////////////
            // Prepare data.
            ////////////////
            WorldTime rescueTime = new WorldTime();
            rescueTime.TurnCounter = m_Session.Scoring.TurnsSurvived;
            bool isMale = m_Player.Model.DollBody.IsMale;
            string heOrShe = isMale ? "He" : "She";
            //string hisOrHer = HisOrHer(m_Player); //unused
            //string himOrHer = isMale ? "him" : "her"; //unused
            string name = m_Player.Name.Replace("(YOU) ", "");
            TimeSpan rt = m_Session.Scoring.RealLifePlayingTime;
            string realTimeString = TimeSpanToString(rt);
            m_Session.Scoring.Side = m_Player.Model.Abilities.IsUndead ? DifficultySide.FOR_UNDEAD : DifficultySide.FOR_SURVIVOR;
            m_Session.Scoring.DifficultyRating = Scoring.ComputeDifficultyRating(s_Options, m_Session.Scoring.Side, m_Session.Scoring.ReincarnationNumber, m_Session.GameMode);

            ////////////////////////////////////
            // Format scoring into a text file.
            ///////////////////////////////////
            TextFile graveyard = new TextFile();

            graveyard.Append(String.Format("ROGUE SURVIVOR: {0}", SetupConfig.GAME_VERSION));
            graveyard.Append(String.Format("POST-RESCUE SUMMARY - {0}", m_Session.Scoring.GameMode)); //m_Session.GameMode.ToString())); //@@MP - added game mode (Release 5-2)

            #region Summary
            graveyard.Append(String.Format("{0} was {1} and {2}.", name, AorAn(m_Player.Model.Name), AorAn(m_Player.Faction.MemberName)));
            graveyard.Append(String.Format("{0} was rescued on {1}.", heOrShe, rescueTime.ToString()));
            graveyard.Append(String.Format("{0}'s run took {1}.", name, realTimeString));
            if (m_Session.Scoring.ReincarnationNumber > 0)
                graveyard.Append(String.Format("{0} was reincarnation {1}.", heOrShe, m_Session.Scoring.ReincarnationNumber));
            graveyard.Append(" ");
            #endregion

            graveyard.Append("> SCORING");
            #region
            graveyard.Append(String.Format("{0} scored a net total of {1} points.", heOrShe, m_Session.Scoring.TotalPoints));
            graveyard.Append(String.Format("- difficulty rating of {0}%.", (int)(100 * m_Session.Scoring.DifficultyRating)));
            graveyard.Append(String.Format("- {0} base points for survival.", m_Session.Scoring.SurvivalPoints));
            graveyard.Append(String.Format("- {0} base points for kills.", m_Session.Scoring.KillPoints));
            graveyard.Append(String.Format("- {0} base points for achievements.", m_Session.Scoring.AchievementPoints));
            graveyard.Append(" ");
            #endregion

            graveyard.Append("> ACHIEVEMENTS");
            #region
            foreach (Achievement ach in m_Session.Scoring.Achievements)
            {
                if (ach.IsDone)
                    graveyard.Append(String.Format("- {0} for {1} points!", ach.Name, ach.ScoreValue));
                else
                    graveyard.Append(String.Format("- Fail : {0}.", ach.TeaseName));
            }
            graveyard.Append(String.Format("Total achievements : {0}/{1}.", m_Session.Scoring.CompletedAchievementsCount, Scoring.MAX_ACHIEVEMENTS));
            if (m_Session.Scoring.CompletedAchievementsCount >= Scoring.MAX_ACHIEVEMENTS)
                graveyard.Append("You achieved everything and managed to escape the city! Very impressive!");
            graveyard.Append(" ");
            #endregion

            graveyard.Append("> RESCUE");
            #region
            graveyard.Append(String.Format("{0} from {1}.", m_Session.Scoring.DeathReason, m_Session.Scoring.DeathPlace));
            graveyard.Append(" ");
            #endregion

            graveyard.Append("> KILLS");
            #region
            if (m_Session.Scoring.HasNoKills)
            {
                graveyard.Append(String.Format("{0} was a pacifist. Or too scared to fight.", heOrShe));
            }
            else
            {
                // models kill list.
                foreach (Scoring.KillData killData in m_Session.Scoring.Kills)
                {
                    string modelName = killData.Amount > 1 ? Models.Actors[killData.ActorModelID].PluralName : Models.Actors[killData.ActorModelID].Name;
                    graveyard.Append(String.Format("{0,4} {1}.", killData.Amount, modelName));
                }
            }
            // murders? only livings.
            if (!m_Player.Model.Abilities.IsUndead)
            {
                if (m_Player.MurdersCounter > 0)
                {
                    graveyard.Append(String.Format("{0} committed {1} murder{2}!", heOrShe, m_Player.MurdersCounter, m_Player.MurdersCounter > 1 ? "s" : ""));
                }
            }

            graveyard.Append(" ");
            #endregion

            graveyard.Append("> FUN FACTS!");
            #region
            graveyard.Append(String.Format("While {0} has escaped the city, others are still surviving", name));
            string[] funFacts = CompileDistrictFunFacts(m_Player.Location.Map.District);
            for (int i = 0; i < funFacts.Length; i++)
                graveyard.Append(funFacts[i]);
            graveyard.Append("");
            #endregion

            graveyard.Append("> SKILLS");
            #region
            if (m_Player.Sheet.SkillTable.Skills == null)
            {
                graveyard.Append(String.Format("{0} had no particular skills.", heOrShe));
            }
            else
            {
                foreach (Skill sk in m_Player.Sheet.SkillTable.Skills)
                {
                    graveyard.Append(String.Format("{0}-{1}.", sk.Level, Skills.Name(sk.ID)));
                }
            }
            graveyard.Append(" ");
            #endregion

            graveyard.Append("> INVENTORY");
            #region
            if (m_Player.Inventory.IsEmpty)
            {
                graveyard.Append(String.Format("{0} travelled light. Really light.", heOrShe));
            }
            else
            {
                foreach (Item it in m_Player.Inventory.Items)
                {
                    string desc = DescribeItemShort(it);
                    if (it.IsEquipped)
                        graveyard.Append(String.Format("- {0} (equipped).", desc));
                    else
                        graveyard.Append(String.Format("- {0}.", desc));
                }
            }
            graveyard.Append(" ");
            #endregion

            graveyard.Append("> FOLLOWERS");
            #region
            if (m_Session.Scoring.FollowersWhendDied == null || m_Session.Scoring.FollowersWhendDied.Count == 0)
            {
                graveyard.Append(String.Format("{0} was a lone wolf. Or everyone else was dead.", heOrShe));
            }
            else
            {
                // names.
                StringBuilder sb = new StringBuilder(String.Format("{0} was leading", heOrShe));
                bool firstFo = true;
                int i = 0;
                int count = m_Session.Scoring.FollowersWhendDied.Count;
                foreach (Actor fo in m_Session.Scoring.FollowersWhendDied)
                {
                    if (firstFo)
                        sb.Append(" ");
                    else
                    {
                        if (i == count)
                            sb.Append(".");
                        else if (i == count - 1)
                            sb.Append(" and ");
                        else
                            sb.Append(", ");
                    }
                    sb.Append(fo.TheName);
                    ++i;
                    firstFo = false;
                }
                sb.Append(".");
                graveyard.Append(sb.ToString());

                // skills.
                foreach (Actor fo in m_Session.Scoring.FollowersWhendDied)
                {
                    graveyard.Append(String.Format("{0} skills : ", fo.Name));
                    if (fo.Sheet.SkillTable != null && fo.Sheet.SkillTable.Skills != null)
                    {
                        foreach (Skill sk in fo.Sheet.SkillTable.Skills)
                        {
                            graveyard.Append(String.Format("{0}-{1}.", sk.Level, Skills.Name(sk.ID)));
                        }
                    }
                }
            }
            graveyard.Append(" ");
            #endregion

            graveyard.Append("> EVENTS");
            #region
            if (m_Session.Scoring.HasNoEvents)
            {
                graveyard.Append(String.Format("{0} had a relatively quiet life for an apocalypse.", heOrShe));
            }
            else
            {
                foreach (Scoring.GameEventData ev in m_Session.Scoring.Events)
                {
                    WorldTime evTime = new WorldTime();
                    evTime.TurnCounter = ev.Turn;
                    graveyard.Append(String.Format("- {0,13} : {1}", evTime.ToString(), ev.Text));
                }
            }
            graveyard.Append(" ");
            #endregion

            graveyard.Append("> CUSTOM OPTIONS");
            #region
            //@@MP - want the graveyard to lists all modifiers, rather than just those changed from default (Release 4)
            graveyard.Append(String.Format("- difficulty rating of {0}%.", (int)(100 * m_Session.Scoring.DifficultyRating)));
            //if (s_Options.IsPermadeathOn)
            graveyard.Append(String.Format("- {0} : {1}.", GameOptions.Name(GameOptions.IDs.GAME_PERMADEATH), s_Options.IsPermadeathOn ? "yes" : "no")); //@@MP - actually shows yes or no now (Release 5-7)
            //if (s_Options.CitySize != GameOptions.DEFAULT_CITY_SIZE)
            graveyard.Append(String.Format("- {0} : {1}.", GameOptions.Name(GameOptions.IDs.GAME_CITY_SIZE), s_Options.CitySize));
            //if (s_Options.DistrictSize != GameOptions.DEFAULT_DISTRICT_SIZE)
            graveyard.Append(String.Format("- {0} : {1}.", GameOptions.Name(GameOptions.IDs.GAME_DISTRICT_SIZE), s_Options.DistrictSize));
            //if (s_Options.MaxCivilians != GameOptions.DEFAULT_MAX_CIVILIANS)
            graveyard.Append(String.Format("- {0} : {1}.", GameOptions.Name(GameOptions.IDs.DIFFICULTY_MAX_CIVILIANS), s_Options.MaxCivilians));
            //if (s_Options.MaxUndeads != GameOptions.DEFAULT_MAX_UNDEADS)
            graveyard.Append(String.Format("- {0} : {1}.", GameOptions.Name(GameOptions.IDs.DIFFICULTY_MAX_UNDEADS), s_Options.MaxUndeads));
            graveyard.Append(String.Format("- {0} : {1}.", GameOptions.Name(GameOptions.IDs.DIFFICULTY_RESCUE_DAY), s_Options.HiddenRescueDay)); //@@MP (Release 7-4)
            graveyard.Append(String.Format("- {0} : {1}.", GameOptions.Name(GameOptions.IDs.DIFFICULTY_RESOURCES_AVAILABILITY), s_Options.ResourcesAvailability)); //@@MP (Release 7-4)
            graveyard.Append(String.Format("- {0} : {1}%.", GameOptions.Name(GameOptions.IDs.DIFFICULTY_LIVING_DAMAGE_PERCENT), s_Options.LivingDamagePercent)); //@@MP (Release 7-4)
            //if (s_Options.IsSanityEnabled)
            graveyard.Append(String.Format("- {0} : {1}.", GameOptions.Name(GameOptions.IDs.DIFFICULTY_SANITY), s_Options.IsSanityEnabled ? "on" : "off"));
            //if (!s_Options.NPCCanStarveToDeath)
            graveyard.Append(String.Format("- {0} : {1}.", GameOptions.Name(GameOptions.IDs.DIFFICULTY_NPC_CAN_STARVE_TO_DEATH), s_Options.NPCCanStarveToDeath ? "yes" : "no"));
            //if(s_Options.StarvedZombificationChance != GameOptions.DEFAULT_STARVED_ZOMBIFICATION_CHANCE)
            graveyard.Append(String.Format("- {0} : {1}.", GameOptions.Name(GameOptions.IDs.DIFFICULTY_STARVED_ZOMBIFICATION), s_Options.StarvedZombification ? "yes" : "no"));
            //if (s_Options.ZombificationChance != GameOptions.DEFAULT_ZOMBIFICATION_CHANCE)
            graveyard.Append(String.Format("- {0} : {1}%.", GameOptions.Name(GameOptions.IDs.DIFFICULTY_ZOMBIFICATION_CHANCE), s_Options.ZombificationChance));
            graveyard.Append(String.Format("- {0} : {1}.", GameOptions.Name(GameOptions.IDs.DIFFICULTY_AGGRESSIVE_HUNGRY_CIVILIANS), s_Options.IsAggressiveHungryCiviliansOn ? "yes" : "no")); //@@MP (Release 5-2)
            graveyard.Append(String.Format("- {0} : {1}%.", GameOptions.Name(GameOptions.IDs.DIFFICULTY_UNDEAD_DAMAGE_PERCENT), s_Options.UndeadDamagePercent)); //@@MP (Release 7-4)
            if (Rules.HasEvolution(m_Session.GameMode)) //@@MP (Release 5-2)
            {
                //if(!s_Options.AllowUndeadsEvolution)
                graveyard.Append(String.Format("- {0} : {1}.", GameOptions.Name(GameOptions.IDs.DIFFICULTY_ALLOW_UNDEADS_EVOLUTION), s_Options.AllowUndeadsEvolution ? "yes" : "no"));
                graveyard.Append(String.Format("- {0} : {1}.", GameOptions.Name(GameOptions.IDs.DIFFICULTY_SKELETONS_UPGRADE), s_Options.SkeletonsUpgrade ? "yes" : "no"));
                //graveyard.Append(String.Format("- {0} : {1}.", GameOptions.Name(GameOptions.IDs.DIFFICULTY_RATS_UPGRADE), s_Options.RatsUpgrade ? "yes" : "no")); //@@MP (Release 5-7)
                graveyard.Append(String.Format("- {0} : {1}.", GameOptions.Name(GameOptions.IDs.DIFFICULTY_SHAMBLERS_UPGRADE), s_Options.ShamblersUpgrade ? "yes" : "no"));
                graveyard.Append(String.Format("- {0} : {1}.", GameOptions.Name(GameOptions.IDs.DIFFICULTY_UNDEADS_UPGRADE_DAYS), s_Options.ZombifiedsUpgradeDays));
            }
            else
            {
                graveyard.Append(String.Format("- {0} : {1}.", GameOptions.Name(GameOptions.IDs.DIFFICULTY_ANTIVIRAL_PILLS), s_Options.AntiviralPills ? "yes" : "no"));
            }
            //if (s_Options.DayZeroUndeadsPercent != GameOptions.DEFAULT_DAY_ZERO_UNDEADS_PERCENT)
            graveyard.Append(String.Format("- {0} : {1}%.", GameOptions.Name(GameOptions.IDs.DIFFICULTY_DAY_ZERO_UNDEADS_PERCENT), s_Options.DayZeroUndeadsPercent));
            //if (s_Options.ZombieInvasionDailyIncrease != GameOptions.DEFAULT_ZOMBIE_INVASION_DAILY_INCREASE)
            graveyard.Append(String.Format("- {0} : {1}%.", GameOptions.Name(GameOptions.IDs.DIFFICULTY_ZOMBIE_INVASION_DAILY_INCREASE), s_Options.ZombieInvasionDailyIncrease));
            graveyard.Append(String.Format("- {0} : {1}%.", GameOptions.Name(GameOptions.IDs.DIFFICULTY_NATGUARD_FACTOR), s_Options.NatGuardFactor)); //@@MP (Release 5-2)
            graveyard.Append(String.Format("- {0} : {1}%.", GameOptions.Name(GameOptions.IDs.DIFFICULTY_BLACKOPS_RAIDS), s_Options.BlackOpsRaidsEnabled)); //@@MP (Release 7-5)
            graveyard.Append(String.Format("- {0} : {1}%.", GameOptions.Name(GameOptions.IDs.DIFFICULTY_SUPPLIESDROP_FACTOR), s_Options.SuppliesDropFactor)); //@@MP (Release 5-2)
            /*if (s_Options.IsLivingReincRestricted) //if (s_Options.MaxReincarnations != GameOptions.DEFAULT_MAX_REINCARNATIONS) //@@MP (Release 5-2), disabled IsLivingReincRestricted (Release 5-7)
                graveyard.Append(String.Format("- {0} : {1}.", GameOptions.Name(GameOptions.IDs.GAME_REINC_LIVING_RESTRICTED), s_Options.IsLivingReincRestricted ? "on" : "off"));*/
            graveyard.Append(" ");
            #endregion

            graveyard.Append("> Farewell");
            #region
            graveyard.Append(String.Format("May Murdoch base prove to be a haven for {0}.", m_Player.Name.Replace("(YOU) ", ""))); //@@MP - replaced with something better (Release 1)
                                                                                                                                   /*graveyard.Append(String.Format("For {0} body is now a meal for evil.", HisOrHer(m_Player)));
                                                                                                                                   graveyard.Append("The End.");*/
            #endregion

            /////////////////////
            // Save to graveyard
            /////////////////////
            #region
            int gx, gy;
            gx = gy = 0;
            m_UI.UI_Clear(Color.Black);
            m_UI.UI_DrawStringBold(Color.Yellow, "Saving rescue to graveyard...", 0, 0);
            gy += BOLD_LINE_SPACING;
            m_UI.UI_Repaint();
            string graveName = GetUserNewGraveyardName();
            string graveFile = GraveFilePath(graveName);
            if (!graveyard.Save(graveFile))
            {
                m_UI.UI_DrawStringBold(Color.Red, "Could not save to graveyard.", 0, gy);
                gy += BOLD_LINE_SPACING;
            }
            else
            {
                m_UI.UI_DrawStringBold(Color.Yellow, "Grave saved to :", 0, gy);
                gy += BOLD_LINE_SPACING;
                m_UI.UI_DrawString(Color.White, graveFile, 0, gy);
                gy += BOLD_LINE_SPACING;
            }
            DrawFootnote(Color.White, "press ENTER");
            m_UI.UI_Repaint();
            WaitEnter();
            #endregion

            ///////////////////////////////
            // Display grave as text file.
            ///////////////////////////////
            #region
            graveyard.FormatLines(TEXTFILE_CHARS_PER_LINE);
            int iLine = 0;
            bool loop = false;
            do
            {
                // header.
                m_UI.UI_Clear(Color.Black);
                gx = gy = 0;
                DrawHeader(0);
                gy += BOLD_LINE_SPACING;

                // text.
                int linesThisPage = 0;
                m_UI.UI_DrawStringBold(Color.White, "---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+", 0, gy);
                gy += BOLD_LINE_SPACING;
                while (linesThisPage < TEXTFILE_LINES_PER_PAGE && iLine < graveyard.FormatedLines.Count)
                {
                    string line = graveyard.FormatedLines[iLine];
                    m_UI.UI_DrawStringBold(Color.White, line, gx, gy);
                    gy += BOLD_LINE_SPACING;
                    ++iLine;
                    ++linesThisPage;
                }

                // footer.
                m_UI.UI_DrawStringBold(Color.White, "---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+", 0, CANVAS_HEIGHT - 2 * BOLD_LINE_SPACING);
                if (iLine < graveyard.FormatedLines.Count)
                    DrawFootnote(Color.White, "press ENTER for more");
                else
                    DrawFootnote(Color.White, "press ENTER to leave");

                // wait.
                m_UI.UI_Repaint();
                WaitEnter();

                // loop?
                loop = (iLine < graveyard.FormatedLines.Count);
            }
            while (loop);
            #endregion

            ///////////////
            // High Score?
            ///////////////
            #region
            StringBuilder skillsSb = new StringBuilder();
            if (m_Player.Sheet.SkillTable.Skills != null)
            {
                foreach (Skill sk in m_Player.Sheet.SkillTable.Skills)
                {
                    skillsSb.AppendFormat("{0}-{1} ", sk.Level, Skills.Name(sk.ID));
                }
            }
            HiScore newHiScore = HiScore.FromScoring(name, m_Session.Scoring, skillsSb.ToString());
            if (m_HiScoreTable.Register(newHiScore))
            {
                SaveHiScoreTable();
                HandleHiScores(true);
            }
            #endregion
        }

        #region -Fun Facts!
        [Flags]
        enum MapListFlags
        {
            NONE = 0,

            /// <summary>
            /// Exclude map with the IsSecret property.
            /// </summary>
            EXCLUDE_SECRET_MAPS = (1 << 0)
        }

        List<Actor> ListWorldActors(Predicate<Actor> pred, MapListFlags flags)
        {
            List<Actor> list = new List<Actor>();

            for (int dx = 0; dx < m_Session.World.Size; dx++)
                for (int dy = 0; dy < m_Session.World.Size; dy++)
                    list.AddRange(ListDistrictActors(m_Session.World[dx, dy], flags, pred));

            return list;
        }

        static List<Actor> ListDistrictActors(District d, MapListFlags flags, Predicate<Actor> pred) //@@MP - made static (Release 5-7)
        {
            List<Actor> list = new List<Actor>();

            foreach (Map m in d.Maps)
            {
                if ((flags & MapListFlags.EXCLUDE_SECRET_MAPS) != 0 && m.IsSecret)
                    continue;
                foreach (Actor a in m.Actors)
                    if (pred == null || pred(a))
                        list.Add(a);
            }

            return list;
        }

        static string FunFactActorResume(Actor a, string info) //@@MP - made static (Release 5-7)
        {
            if (a == null)
                return "(N/A)";
            return String.Format("{0} - {1}, a {2} - {3}",
                info, a.TheName, a.Model.Name, a.Location.Map.Name);
        }

        string[] CompileDistrictFunFacts(District d)
        {
            List<string> list = new List<string>();

            ///////////////////////////////////////////
            // 1. Oldest actors alive living & undead.
            // 2. Most kills living & undead.
            // 3. Most murders.
            ///////////////////////////////////////////

            // list actors.
            List<Actor> allLivings = ListDistrictActors(d, MapListFlags.EXCLUDE_SECRET_MAPS, (a) => !a.IsDead && !a.Model.Abilities.IsUndead);
            List<Actor> allUndeads = ListDistrictActors(d, MapListFlags.EXCLUDE_SECRET_MAPS, (a) => !a.IsDead && a.Model.Abilities.IsUndead);
            List<Actor> allActors = ListDistrictActors(d, MapListFlags.EXCLUDE_SECRET_MAPS, null);

            // add player (cause he's dead now)
            if (m_Player.Model.Abilities.IsUndead)
                allUndeads.Add(m_Player);
            else
                allLivings.Add(m_Player);
            allActors.Add(m_Player);

            // 1. Oldest actors alive living & undead.
            if (allLivings.Count > 0)
            {
                allLivings.Sort((a, b) => a.SpawnTime < b.SpawnTime ? -1 : a.SpawnTime == b.SpawnTime ? 0 : 1);
                list.Add("- Oldest Livings Surviving");
                list.Add(String.Format("    1st {0}.", FunFactActorResume(allLivings[0], new WorldTime(allLivings[0].SpawnTime).ToString())));
                if (allLivings.Count > 1)
                    list.Add(String.Format("    2nd {0}.", FunFactActorResume(allLivings[1], new WorldTime(allLivings[1].SpawnTime).ToString())));
            }
            else
                list.Add("    No living actors alive!");

            if (allUndeads.Count > 0)
            {
                allUndeads.Sort((a, b) => a.SpawnTime < b.SpawnTime ? -1 : a.SpawnTime == b.SpawnTime ? 0 : 1);
                list.Add("- Oldest Undeads Rotting Around");
                list.Add(String.Format("    1st {0}.", FunFactActorResume(allUndeads[0], new WorldTime(allUndeads[0].SpawnTime).ToString())));
                if (allUndeads.Count > 1)
                    list.Add(String.Format("    2nd {0}.", FunFactActorResume(allUndeads[1], new WorldTime(allUndeads[1].SpawnTime).ToString())));
            }
            else
                list.Add("    No undeads shambling around!");

            // 2. Most kills living & undead.
            if (allLivings.Count > 0)
            {
                allLivings.Sort((a, b) => a.KillsCount > b.KillsCount ? -1 : a.KillsCount == b.KillsCount ? 0 : 1);
                list.Add("- Deadliest Livings Kicking ass");
                if (allLivings[0].KillsCount > 0)
                {
                    list.Add(String.Format("    1st {0}.", FunFactActorResume(allLivings[0], allLivings[0].KillsCount.ToString())));
                    if (allLivings.Count > 1 && allLivings[1].KillsCount > 0)
                        list.Add(String.Format("    2nd {0}.", FunFactActorResume(allLivings[1], allLivings[1].KillsCount.ToString())));
                }
                else
                    list.Add("    Livings can't fight for their lives apparently.");
            }
            if (allUndeads.Count > 0)
            {
                allUndeads.Sort((a, b) => a.KillsCount > b.KillsCount ? -1 : a.KillsCount == b.KillsCount ? 0 : 1);
                list.Add("- Deadliest Undeads Chewing Brains");
                if (allUndeads[0].KillsCount > 0)
                {
                    list.Add(String.Format("    1st {0}.", FunFactActorResume(allUndeads[0], allUndeads[0].KillsCount.ToString())));
                    if (allUndeads.Count > 1 && allUndeads[1].KillsCount > 0)
                        list.Add(String.Format("    2nd {0}.", FunFactActorResume(allUndeads[1], allUndeads[1].KillsCount.ToString())));
                }
                else
                    list.Add("    Undeads don't care for brains apparently.");
            }

            // 3. Most murders.
            if (allLivings.Count > 0)
            {
                allLivings.Sort((a, b) => a.MurdersCounter > b.MurdersCounter ? -1 : a.MurdersCounter == b.MurdersCounter ? 0 : 1);
                list.Add("- Most Murderous Murderer Murdering");
                if (allLivings[0].MurdersCounter > 0)
                {
                    list.Add(String.Format("    1st {0}.", FunFactActorResume(allLivings[0], allLivings[0].MurdersCounter.ToString())));
                    if (allLivings.Count > 1 && allLivings[1].MurdersCounter > 0)
                        list.Add(String.Format("    2nd {0}.", FunFactActorResume(allLivings[1], allLivings[1].MurdersCounter.ToString())));
                }
                else
                    list.Add("    No murders committed!");
            }

            // done.
            return list.ToArray();
        }
        #endregion
        #endregion

        #region -High Score
        void HandleHiScores(bool saveToTextfile)
        {
            TextFile file = null;
            if (saveToTextfile)
                file = new TextFile();

            m_UI.UI_Clear(Color.Black);
            int gy = 0;
            DrawHeader(0);
            gy += BOLD_LINE_SPACING;
            m_UI.UI_DrawStringBold(Color.Yellow, "High Scores", 0, gy);
            gy += BOLD_LINE_SPACING;
            m_UI.UI_DrawStringBold(Color.White, "---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+", 0, gy);
            gy += BOLD_LINE_SPACING;

            // display.
            m_UI.UI_DrawStringBold(Color.White, "Rank | Name, Skills, Death       |  Score |Difficulty|Survival|  Kills |Achievm.|      Game Time | Playing time", 0, gy);
            gy += BOLD_LINE_SPACING;

            // text.
            if (saveToTextfile)
            {
                file.Append(String.Format("ROGUE SURVIVOR: {0}", SetupConfig.GAME_VERSION));
                file.Append("High Scores");
                file.Append("Rank | Name, Skills, Death       |  Score |Difficulty|Survival|  Kills |Achievm.|      Game Time | Playing time");
            }

            // individual entries.
            for (int i = 0; i < m_HiScoreTable.Count; i++)
            {
                // display.
                Color rankColor = (i == 0 ? Color.LightYellow : i == 1 ? Color.LightCyan : i == 2 ? Color.LightGreen : Color.DimGray);
                m_UI.UI_DrawStringBold(rankColor, "------------------------------------------------------------------------------------------------------------------------", 0, gy);
                gy += BOLD_LINE_SPACING;
                HiScore hi = m_HiScoreTable[i];
                string line = String.Format("{0,3}. | {1,-25} | {2,6} |     {3,3}% | {4,6} | {5,6} | {6,6} | {7,14} | {8}",
                    i + 1, TruncateString(hi.Name, 25),
                    hi.TotalPoints, hi.DifficultyPercent, hi.SurvivalPoints, hi.KillPoints, hi.AchievementPoints,
                    new WorldTime(hi.TurnSurvived).ToString(), TimeSpanToString(hi.PlayingTime));
                m_UI.UI_DrawStringBold(rankColor, line, 0, gy);
                gy += BOLD_LINE_SPACING;
                m_UI.UI_DrawStringBold(rankColor, String.Format("     | {0}.", hi.SkillsDescription), 0, gy);
                gy += BOLD_LINE_SPACING;
                m_UI.UI_DrawStringBold(rankColor, String.Format("     | {0}. Game mode: {1}", hi.Death, hi.GameMode), 0, gy); //@MP - added game mode (Release 5-2). FIXME: Add modded flag here in future release
                gy += BOLD_LINE_SPACING;

                // text.
                if (saveToTextfile)
                {
                    file.Append("------------------------------------------------------------------------------------------------------------------------");
                    file.Append(line);
                    file.Append(String.Format("     | {0}", hi.SkillsDescription));
                    file.Append(String.Format("     | {0}. Game mode: {1}", hi.Death, hi.GameMode)); //@MP - added game mode (Release 5-2). FIXME: Add modded flag here in future release
                }
            }

            // save.
            string textfilePath = GetUserHiScoreTextFilePath();
            if (saveToTextfile)
                file.Save(textfilePath);

            // display.
            m_UI.UI_DrawStringBold(Color.White, "---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+", 0, gy);
            gy += BOLD_LINE_SPACING;
            if (saveToTextfile)
            {
                m_UI.UI_DrawStringBold(Color.White, textfilePath, 0, gy);
                gy += BOLD_LINE_SPACING;
            }
            DrawFootnote(Color.White, "press ESC to leave");
            m_UI.UI_Repaint();
            WaitEscape();
        }

        void LoadHiScoreTable()
        {
            m_UI.UI_Clear(Color.Black);
            m_UI.UI_DrawStringBold(Color.White, "Loading high scores table...", 0, 0);
            m_UI.UI_Repaint();

            m_HiScoreTable = HiScoreTable.Load(GetUserHiScoreFilePath());
            if (m_HiScoreTable == null)
            {
                m_HiScoreTable = new HiScoreTable(HiScoreTable.DEFAULT_MAX_ENTRIES);
                m_HiScoreTable.Clear();
            }

            m_UI.UI_Clear(Color.Black);
            m_UI.UI_DrawStringBold(Color.White, "Loading high scores table... done!", 0, 0);
            m_UI.UI_Repaint();
        }

        void SaveHiScoreTable()
        {
            m_UI.UI_Clear(Color.Black);
            m_UI.UI_DrawStringBold(Color.White, "Saving high scores table...", 0, 0);
            m_UI.UI_Repaint();

            HiScoreTable.Save(m_HiScoreTable, GetUserHiScoreFilePath());

            m_UI.UI_Clear(Color.Black);
            m_UI.UI_DrawStringBold(Color.White, "Saving high scores table... done!", 0, 0);
            m_UI.UI_Repaint();
        }
        #endregion

        #region -REINCARNATION
        void HandleReincarnation()
        {
            m_MusicManager.StopAll();
            m_SFXManager.StopAll();
            m_AmbientSFXManager.StopAll();

            // Reincarnate?
            // don't bother if option set to zero.
            if (s_Options.MaxReincarnations <= 0 || !AskForReincarnation())
                return;

            // play music.
            m_MusicManager.Play(GameMusics.LIMBO, AudioPriority.PRIORITY_EVENT);

            // Waiting screen...
            m_UI.UI_Clear(Color.Black);
            m_UI.UI_DrawStringBold(Color.Yellow, "Reincarnation - Purgatory", 0, 0);
            m_UI.UI_DrawStringBold(Color.White, "(preparing reincarnations, please wait...)", 0, 2 * BOLD_LINE_SPACING);
            m_UI.UI_Repaint();

            // Decide available reincarnation targets.
            int countDummy;
            Actor randomR = FindReincarnationAvatar(GameOptions.ReincMode.RANDOM_ACTOR, out countDummy);
            int countLivings;
            Actor livingR = FindReincarnationAvatar(GameOptions.ReincMode.RANDOM_LIVING, out countLivings);
            int countUndead;
            Actor undeadR = FindReincarnationAvatar(GameOptions.ReincMode.RANDOM_UNDEAD, out countUndead);
            int countFollower;
            Actor followerR = FindReincarnationAvatar(GameOptions.ReincMode.RANDOM_FOLLOWER, out countFollower);
            Actor killerR = FindReincarnationAvatar(GameOptions.ReincMode.KILLER, out countDummy);
            Actor zombifiedR = FindReincarnationAvatar(GameOptions.ReincMode.ZOMBIFIED, out countDummy);

            // Get fun facts.
            string[] funFacts = CompileDistrictFunFacts(m_Player.Location.Map.District);

            // Reincarnate.
            // Choose avatar from a set of reincarnation modes.
            bool choiceMade = false;
            string[] entries =
            {
                GameOptions.Name(GameOptions.ReincMode.RANDOM_ACTOR),
                GameOptions.Name(GameOptions.ReincMode.RANDOM_LIVING),
                GameOptions.Name(GameOptions.ReincMode.RANDOM_UNDEAD),
                GameOptions.Name(GameOptions.ReincMode.RANDOM_FOLLOWER),
                GameOptions.Name(GameOptions.ReincMode.KILLER),
                GameOptions.Name(GameOptions.ReincMode.ZOMBIFIED)
            };
            string[] values =
            {
                DescribeAvatar(randomR),
                String.Format("{0}   (out of {1} possibilities)", DescribeAvatar(livingR), countLivings),
                String.Format("{0}   (out of {1} possibilities)", DescribeAvatar(undeadR), countUndead),
                String.Format("{0}   (out of {1} possibilities)", DescribeAvatar(followerR), countFollower),
                DescribeAvatar(killerR),
                DescribeAvatar(zombifiedR)
            };
            int selected = 0;
            Actor avatar = null;
            do
            {
                // show screen.
                int gx, gy;
                gx = gy = 0;
                m_UI.UI_Clear(Color.Black);
                m_UI.UI_DrawStringBold(Color.Yellow, "Reincarnation - Choose Avatar", gx, gy);
                gy += 2 * BOLD_LINE_SPACING;

                DrawMenuOrOptions(selected, Color.White, entries, Color.LightGreen, values, gx, ref gy);
                gy += 2 * BOLD_LINE_SPACING;

                m_UI.UI_DrawStringBold(Color.Pink, ".-* District Fun Facts! *-.", gx, gy);
                gy += BOLD_LINE_SPACING;
                m_UI.UI_DrawStringBold(Color.Pink, String.Format("at current date : {0}.", new WorldTime(m_Session.WorldTime.TurnCounter).ToString()), gx, gy);
                gy += 2 * BOLD_LINE_SPACING;
                for (int i = 0; i < funFacts.Length; i++)
                {
                    m_UI.UI_DrawStringBold(Color.Pink, funFacts[i], gx, gy);
                    gy += BOLD_LINE_SPACING;
                }

                DrawFootnote(Color.White, "cursor to move, ENTER to select, ESC to cancel and end game");

                m_UI.UI_Repaint();

                // get menu action.
                KeyEventArgs key = m_UI.UI_WaitKey();
                switch (key.KeyCode)
                {
                    case Keys.Up:       // move up
                        if (selected > 0) --selected;
                        else selected = entries.Length - 1;
                        break;
                    case Keys.Down:     // move down
                        selected = (selected + 1) % entries.Length;
                        break;
                    case Keys.Escape:   // cancel & end game
                        choiceMade = true;
                        avatar = null;
                        break;

                    case Keys.Enter:    // validate
                        {
                            switch (selected)
                            {
                                case 0: // random actor
                                    avatar = randomR;
                                    break;
                                case 1: // random survivor
                                    avatar = livingR;
                                    break;
                                case 2: // random undead
                                    avatar = undeadR;
                                    break;
                                case 3: // random follower
                                    avatar = followerR;
                                    break;
                                case 4: // killer
                                    avatar = killerR;
                                    break;
                                case 5: // zombified
                                    avatar = zombifiedR;
                                    break;
                            }
                            choiceMade = avatar != null;
                            break;
                        }
                }
            }
            while (!choiceMade);

            // If canceled, stop.
            if (avatar == null)
            {
                m_MusicManager.StopAll();
                return;
            }

            // Perform reincarnation.
            // 1. Make actor the player.
            // 2. Update all player-centric data.
            #region
            // 1. Make actor the player.
            avatar.Controller = new PlayerController();
            if (avatar.Activity != Activity.SLEEPING)
                avatar.Activity = Activity.IDLE;
            PrepareActorForPlayerControl(avatar);

            // 2. Update all player-centric data.
            m_Player = avatar;
            m_Session.CurrentMap = avatar.Location.Map;
            m_Session.Scoring.StartNewLife(m_Session.WorldTime.TurnCounter);
            m_Session.Scoring.AddEvent(m_Session.WorldTime.TurnCounter, String.Format("(reincarnation {0})", m_Session.Scoring.ReincarnationNumber));
            m_Session.Scoring.Side = m_Player.Model.Abilities.IsUndead ? DifficultySide.FOR_UNDEAD : DifficultySide.FOR_SURVIVOR;
            m_Session.Scoring.DifficultyRating = Scoring.ComputeDifficultyRating(s_Options, m_Session.Scoring.Side, m_Session.Scoring.ReincarnationNumber, m_Session.GameMode);
            /// forget all maps memory.
            for (int dx = 0; dx < m_Session.World.Size; dx++)
                for (int dy = 0; dy < m_Session.World.Size; dy++)
                {
                    District d = m_Session.World[dx, dy];
                    foreach (Map m in d.Maps)
                        m.SetAllAsUnvisited();
                }
            #endregion

            // Cleanup and refresh.
            m_MusicManager.StopAll();
            m_SFXManager.StopAll();
            m_AmbientSFXManager.StopAll();
            UpdatePlayerFOV(m_Player);
            ComputeViewRect(m_Player.Location.Position);
            CheckAmbientSFX(m_Player.Location.Map);
            ClearMessages();
            AddMessage(new Message(String.Format("{0} feels disoriented for a second...", m_Player.Name), m_Session.WorldTime.TurnCounter, Color.Yellow));
            RedrawPlayScreen();

            // Play reinc sfx or special music for actor.
            if (m_Player == m_Session.UniqueActors.DerangedPatient.TheActor)
                m_MusicManager.Play(GameMusics.INSANE, AudioPriority.PRIORITY_EVENT);
            else
                m_SFXManager.Play(GameSounds.REINCARNATE, AudioPriority.PRIORITY_EVENT);

            // restart sim thread.
            StopSimThread(false);  // alpha10 stop-start
            StartSimThread();
        }

        static string DescribeAvatar(Actor a) //@@MP - made static (Release 5-7)
        {
            if (a == null)
                return "(N/A)";
            bool isLeader = a.CountFollowers > 0;
            bool isFollower = a.HasLeader;
            return String.Format("{0}, a {1}{2}", a.Name, a.Model.Name, isLeader ? ", leader" : isFollower ? ", follower" : "");
        }

        bool AskForReincarnation()
        {
            // show screen.
            int gx, gy;
            gx = gy = 0;
            m_UI.UI_Clear(Color.Black);
            m_UI.UI_DrawStringBold(Color.Yellow, "Limbo", gx, gy);
            gy += 2 * BOLD_LINE_SPACING;
            m_UI.UI_DrawStringBold(Color.White, String.Format("Leave body {0}/{1}.", (1 + m_Session.Scoring.ReincarnationNumber), (1 + s_Options.MaxReincarnations)), gx, gy);
            gy += BOLD_LINE_SPACING;
            m_UI.UI_DrawStringBold(Color.White, "Remember lives.", gx, gy);
            gy += BOLD_LINE_SPACING;
            m_UI.UI_DrawStringBold(Color.White, "Remember purpose.", gx, gy);
            gy += BOLD_LINE_SPACING;
            m_UI.UI_DrawStringBold(Color.White, "Clear again.", gx, gy);
            gy += BOLD_LINE_SPACING;

            // ask question or no more lives left.
            if (m_Session.Scoring.ReincarnationNumber >= s_Options.MaxReincarnations)
            {
                // no more lives left.
                m_UI.UI_DrawStringBold(Color.LightGreen, "Humans interesting.", gx, gy);
                gy += BOLD_LINE_SPACING;
                m_UI.UI_DrawStringBold(Color.LightGreen, "Time to leave.", gx, gy);
                gy += BOLD_LINE_SPACING;
                gy += 2 * BOLD_LINE_SPACING;
                m_UI.UI_DrawStringBold(Color.Yellow, "No more reincarnations left.", gx, gy);
                DrawFootnote(Color.White, "press ENTER");
                m_UI.UI_Repaint();
                WaitEnter();
                return false;
            }
            else
            {
                // one more life available.
                m_UI.UI_DrawStringBold(Color.White, "Leave?", gx, gy);
                gy += BOLD_LINE_SPACING;
                m_UI.UI_DrawStringBold(Color.White, "Live?", gx, gy);

                gy += 2 * BOLD_LINE_SPACING;
                m_UI.UI_DrawStringBold(Color.White, "WARNING: your high score multiplier decreases with each reincarnation!", gx, gy); //@@MP - added (Release 7-4)
                gy += 2 * BOLD_LINE_SPACING;

                gy += 2 * BOLD_LINE_SPACING;
                m_UI.UI_DrawStringBold(Color.Yellow, "Reincarnate? Y to confirm, N to cancel.", gx, gy);
                m_UI.UI_Repaint();

                // ask question.
                return WaitYesOrNo();
            }
        }

        bool IsSuitableReincarnation(Actor a, bool asLiving)
        {
            if (a == null)
                return false;
            if (a.IsDead || a.IsPlayer)
                return false;

            // same district only.
            if (a.Location.Map.District != m_Session.CurrentMap.District)
                return false;

            // forbid some special maps.
            if (a.Location.Map == m_Session.UniqueMaps.CHARUndergroundFacility.TheMap || a.Location.Map == m_Session.UniqueMaps.ArmyBase.TheMap) //@@MP - added army base (Release 6-3)
                return false;

            // forbid animals   //@@MP (Release 7-3), added simple animals (Release 7-6)
            if (a.Faction == GameFactions.TheFerals || a.Faction == GameFactions.TheUnintelligentAnimals || a.Model.Abilities.IsLivingAnimal)
                return false;

            // forbid some special actors.
            if (a == m_Session.UniqueActors.PoliceStationPrisonner.TheActor)
                return false;

            // forbid in hospital storage room when the power is off (because nurses spawn behind the locked gate)         //@@MP (Release 7-6)
            if (a.Location.Map == m_Session.UniqueMaps.Hospital_Storage.TheMap)
            {
                bool gateIsLocked = false;
                foreach (MapObject obj in a.Location.Map.MapObjects)
                {
                    if (obj.ImageID == GameImages.OBJ_GATE_CLOSED)
                    {
                        gateIsLocked = true;
                        break;
                    }
                }

                if (gateIsLocked) //don't want to reinc as a trapped nurse
                {
                    List<Zone> zones = a.Location.Map.GetZonesAt(a.Location.Position.X, a.Location.Position.Y); //@@MP - improved method (Release 8-1)
                    if (zones != null && zones.Count > 0)
                    {
                        foreach (Zone z in zones)
                        {
                            if (z.Name.Contains(String.Format("{0}@", "central corridor")) || z.Name.Contains(String.Format("{0}@", "south corridor")) ||
                                z.Name.Contains(String.Format("{0}@", "west corridor")) || z.Name.Contains(String.Format("{0}@", "storeroom")))
                                return false;
                        }
                    }
                }
            }

            // forbid prisoner if they're in the locked jail cells       //@@MP (Release 7-6)
            if (a.Location.Map == m_Session.UniqueMaps.PoliceStation_JailsLevel.TheMap)
            {
                bool cellsAreLocked = false;
                foreach (MapObject obj in a.Location.Map.MapObjects)
                {
                    if (obj.ImageID == GameImages.OBJ_GATE_CLOSED)
                    {
                        cellsAreLocked = true;
                        break;
                    }
                }

                if (cellsAreLocked) //don't want to reinc as a trapped prisoner
                {
                    List<Zone> zones = a.Location.Map.GetZonesAt(a.Location.Position.X, a.Location.Position.Y); //@@MP - improved method (Release 8-1)
                    if (zones != null && zones.Count > 0)
                    {
                        foreach (Zone z in zones)
                        {
                            if (z.Name.Contains(String.Format("{0}@", NAME_POLICE_STATION_JAILS_CELL)))
                                return false;
                        }
                    }
                }
            }

            // (option) not in sewers.
            /*if (a.Location.Map == a.Location.Map.District.SewersMap) //@@MP - disabled as the option wasn't actually used, and it offered nothing much anyway (Release 5-7)
                return false;*/

            // living vs undead checks.
            if (asLiving)
            {
                if (a.Model.Abilities.IsUndead)
                    return false;
                // (option) civilians only.
                /*if (s_Options.IsLivingReincRestricted && a.Faction != GameFactions.TheCivilians) //@@MP (Release 5-7)
                    return false;*/

                return true;
            }
            else
            {
                if (a.Model.Abilities.IsUndead)
                {
                    // not rats.
                    //if (!s_Options.CanReincarnateAsRat && a.Model == GameActors.RatZombie) //@@MP - disabled IsLivingReincRestricted (Release 5-7)
                    if (a.Model == GameActors.RatZombie) //@@MP (Release 5-7)
                        return false;
                    else
                        return true;
                }
                else
                    return false;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="reincMode"></param>
        /// <param name="matchingActors">how many actors where matching the reincarnation mode</param>
        /// <returns>null if not found</returns>
        Actor FindReincarnationAvatar(GameOptions.ReincMode reincMode, out int matchingActors)
        {
            switch (reincMode)
            {
                case GameOptions.ReincMode.RANDOM_FOLLOWER:
                    #region
                    {
                        if (m_Session.Scoring.FollowersWhendDied == null)
                        {
                            matchingActors = 0;
                            return null;
                        }

                        // list all suitable followers.
                        List<Actor> suitableFollowers = new List<Actor>(m_Session.Scoring.FollowersWhendDied.Count);
                        foreach (Actor fo in m_Session.Scoring.FollowersWhendDied)
                            if (IsSuitableReincarnation(fo, true))
                                suitableFollowers.Add(fo);

                        // make sure we have at least one suitable!
                        matchingActors = suitableFollowers.Count;
                        if (suitableFollowers.Count == 0)
                            return null;

                        // random one.
                        return suitableFollowers[m_Rules.Roll(0, suitableFollowers.Count)];
                    }
                #endregion

                case GameOptions.ReincMode.KILLER:
                    #region
                    {
                        Actor killer = m_Session.Scoring.Killer;
                        if (IsSuitableReincarnation(killer, true) || IsSuitableReincarnation(killer, false))
                        {
                            matchingActors = 1;
                            return killer;
                        }
                        else
                        {
                            matchingActors = 0;
                            return null;
                        }
                    }
                #endregion

                case GameOptions.ReincMode.RANDOM_ACTOR:
                case GameOptions.ReincMode.RANDOM_LIVING:
                case GameOptions.ReincMode.RANDOM_UNDEAD:
                    #region
                    {
                        // get a list of all suitable actors in the world.
                        bool asLiving = (reincMode == GameOptions.ReincMode.RANDOM_LIVING || (reincMode == GameOptions.ReincMode.RANDOM_ACTOR && m_Rules.RollChance(50)));
                        List<Actor> allSuitables = new List<Actor>();
                        for (int dx = 0; dx < m_Session.World.Size; dx++)
                            for (int dy = 0; dy < m_Session.World.Size; dy++)
                            {
                                District district = m_Session.World[dx, dy];
                                foreach (Map map in district.Maps)
                                    foreach (Actor a in map.Actors)
                                        if (IsSuitableReincarnation(a, asLiving))
                                        {
                                            allSuitables.Add(a);
                                            Logger.WriteLine(Logger.Stage.RUN_MAIN, a.Name);
                                        }
                            }

                        // pick one at random.
                        matchingActors = allSuitables.Count;
                        if (allSuitables.Count == 0)
                            return null;
                        else
                            return allSuitables[m_Rules.Roll(0, allSuitables.Count)];
                    }
                #endregion

                case GameOptions.ReincMode.ZOMBIFIED:
                    #region
                    {
                        Actor zombie = m_Session.Scoring.ZombifiedPlayer;
                        if (IsSuitableReincarnation(zombie, false))
                        {
                            matchingActors = 1;
                            return zombie;
                        }
                        else
                        {
                            matchingActors = 0;
                            return null;
                        }
                    }
                #endregion

                default:
                    throw new ArgumentOutOfRangeException("unhandled reincarnation mode " + reincMode.ToString());
            }
        }
        #endregion
        #endregion

        //----------------

        #region NEW DAY/NIGHT, SCORING, ADVANCEMENT, AND WEATHER
        void OnNewNight()
        {
            //----- De-spawn helicopter if it's end of rescue day  //@@MP (Release 6-4)
            if (m_Session.WorldTime.Day == m_Session.ArmyHelicopterRescue_Day)
            {
                Map helicopterMap = m_Session.ArmyHelicopterRescue_Map;
                DespawnArmyHelicopter(helicopterMap);
            }

            UpdatePlayerFOV(m_Player);

            //----- Upgrade Player (undead only once every 2 nights)
            if (m_Player.Model.Abilities.IsUndead && m_Player.Location.Map.LocalTime.Day % 2 == 1)
            {
                // Mode.
                ClearOverlays();
                AddOverlay(new OverlayPopup(UPGRADE_MODE_TEXT, MODE_TEXTCOLOR, MODE_BORDERCOLOR, MODE_FILLCOLOR, Point.Empty));

                // music.
                m_MusicManager.StopAll();
                m_MusicManager.Play(GameMusics.INTERLUDE, AudioPriority.PRIORITY_EVENT);

                // Message.
                ClearMessages();
                AddMessage(new Message("You will hunt another day!", m_Session.WorldTime.TurnCounter, Color.Green));
                UpdatePlayerFOV(m_Player);
                if (!m_Player.IsBotPlayer) //alpha 10.1
                    AddMessagePressEnter();

                // Upgrade time!
                // alpha10.1 handle bot skill upgrade, bot followers will upgrade as npcs
                if (m_Player.IsBotPlayer)
                {
                    HandleNPCSkillUpgrade(m_Player);
                }
                else
                {
                    HandlePlayerDecideUpgrade(m_Player);
                    HandlePlayerFollowersUpgrade();
                }

                // Resume play.
                ClearMessages();
                AddMessage(new Message("Welcome to the night.", m_Session.WorldTime.TurnCounter, Color.White));
                ClearOverlays();
                RedrawPlayScreen();

                // music
                m_MusicManager.StopAll();
            }
        }

        void OnNewDay()
        {
            /////////////////////////
            // Normal day processing
            /////////////////////////

            //----- Upgrade Player (living only)
            if (!m_Player.Model.Abilities.IsUndead)
            {
                // Mode.
                ClearOverlays();
                AddOverlay(new OverlayPopup(UPGRADE_MODE_TEXT, MODE_TEXTCOLOR, MODE_BORDERCOLOR, MODE_FILLCOLOR, Point.Empty));

                // music.
                m_MusicManager.StopAll();
                m_MusicManager.Play(GameMusics.INTERLUDE, AudioPriority.PRIORITY_EVENT);

                // Message.
                ClearMessages();
                AddMessage(new Message("You survived another night!", m_Session.WorldTime.TurnCounter, Color.Green));
                UpdatePlayerFOV(m_Player);
                if (!m_Player.IsBotPlayer)
                    AddMessagePressEnter();

                // Upgrade time!
                // alpha10.1 handle bot skill upgrade, bot followers will upgrade as npcs
                if (m_Player.IsBotPlayer)
                {
                    HandleNPCSkillUpgrade(m_Player);
                }
                else
                {
                    HandlePlayerDecideUpgrade(m_Player);
                    HandlePlayerFollowersUpgrade();
                }

                // Resume play.
                ClearMessages();
                AddMessage(new Message("Welcome to tomorrow.", m_Session.WorldTime.TurnCounter, Color.White));
                WarnAboutNightVision(); //@@MP (Release 7-1)
                ClearOverlays();
                RedrawPlayScreen();

                // music
                m_MusicManager.StopAll();
            }

            /*// Check weather change.
            CheckWeatherChange();*/ //@@MP - time spans (part of AdvancePlay) change the weather now

            //////////////////////////////
            // New day achievements.
            //////////////////////////////
            // 1. Reached day X (living only)
            if (!m_Player.Model.Abilities.IsUndead)
            {
                if (m_Session.WorldTime.Day == 7)
                {
                    // scoring.
                    m_Session.Scoring.SetCompletedAchievement(Achievement.IDs.REACHED_DAY_07);

                    // achievement!
                    ShowNewAchievement(Achievement.IDs.REACHED_DAY_07);
                }
                else if (m_Session.WorldTime.Day == 14)
                {
                    // scoring.
                    m_Session.Scoring.SetCompletedAchievement(Achievement.IDs.REACHED_DAY_14);

                    // achievement!
                    ShowNewAchievement(Achievement.IDs.REACHED_DAY_14);
                }
                else if (m_Session.WorldTime.Day == 21)
                {
                    // scoring.
                    m_Session.Scoring.SetCompletedAchievement(Achievement.IDs.REACHED_DAY_21);

                    // achievement!
                    ShowNewAchievement(Achievement.IDs.REACHED_DAY_21);
                }
                else if (m_Session.WorldTime.Day == 28)
                {
                    // scoring.
                    m_Session.Scoring.SetCompletedAchievement(Achievement.IDs.REACHED_DAY_28);

                    // achievement!
                    ShowNewAchievement(Achievement.IDs.REACHED_DAY_28);
                }
            }

            //----- Spawn helicopter if it's rescue day  //@@MP (Release 6-4)
            if (m_Session.WorldTime.Day == m_Session.ArmyHelicopterRescue_Day)
            {
                Map helicopterMap = m_Session.ArmyHelicopterRescue_Map;
                SpawnArmyHelicopterOnMap(helicopterMap);
            }
        }

        /// <summary>
        /// When an NPC drops an item it gets the turn number attached to it. If it's been X turns since last being touched, delete it from world.
        /// </summary>
        void DeleteItemsSittingIdle(Map map, int currentTurn) //@@MP (Release 7-6)
        {
            DateTime start = DateTime.Now;
            int deletedCount = 0;
            //loop each tile in the map
            for (int x = 0; x < map.Width; x++)
            {
                for (int y = 0; y < map.Height; y++)
                {
                    if (!IsVisibleToPlayer(map, new Point(x, y)))
                    {
                        Inventory inv = map.GetItemsAt(x, y);
                        if (inv != null)
                        {
                            foreach (Item it in inv.Items.ToList())
                            {
                                if (it.DroppedOnTurnNumber != null && !(it is ItemBackpack)) //@@MP - exemption for the newly added backpacks (Release 8-2)
                                {
                                    int? idleTurns = currentTurn - it.DroppedOnTurnNumber;
                                    if (idleTurns >= (s_Options.DaysBeforeDiscardedItemDespawns * WorldTime.TURNS_PER_DAY))
                                    {
                                        map.RemoveItemAt(it, new Point(x, y));
                                        ++deletedCount;
                                    }
                                }
                            }
                        }
                    }
                }
            }
#if DEBUG
            DateTime end = DateTime.Now;
            TimeSpan duration = end - start;
            //Logger.WriteLine(Logger.Stage.RUN_MAIN, String.Format("cleaned up idle items: {0}, in {1} milliseconds", deletedCount.ToString(), duration.TotalMilliseconds.ToString()));
#endif
        }

        /// <summary>
        /// Opted not to use this. Instead chose to enforce that only one backpack can occupy a tile, to make stashing items in backpacks less exploitable
        /// </summary>
        void EmptyBackpacksSittingIdle(Map map, int currentTurn) //@@MP (Release 8-2)
        {
            DateTime start = DateTime.Now;
            int deletedCount = 0;
            foreach (Inventory groundInv in map.GroundInventories)
            {
                if (groundInv != null && groundInv.CountItems > 0)
                {
                    Point pt = (Point)map.GetGroundInventoryPosition(groundInv);
                    if (pt != null && !IsVisibleToPlayer(map, pt))
                    {
                        ItemBackpack backPack = groundInv.GetFirstByType(typeof(ItemBackpack)) as ItemBackpack;
                        if (backPack != null && backPack.DroppedOnTurnNumber != null)
                        {
                            int? idleTurns = currentTurn - backPack.DroppedOnTurnNumber;
                            if (idleTurns >= (WorldTime.TURNS_PER_DAY * 2)) //after two days items quickly disappear from backpacks
                            {
                                if (backPack.Inventory != null && backPack.Inventory.CountItems > 0)
                                {
                                    //doing it this way, running it at every DayPhase change will gradually remove items
                                    backPack.Inventory.RemoveAllQuantity(backPack.Inventory.RandomItem);
                                    ++deletedCount;
                                }
                            }
                        }
                    }
                }
            }
#if DEBUG
            if (deletedCount > 0)
            {
                DateTime end = DateTime.Now;
                TimeSpan duration = end - start;
                Logger.WriteLine(Logger.Stage.RUN_MAIN, String.Format("cleaned up backpack items: {0}, in {1} milliseconds", deletedCount.ToString(), duration.TotalMilliseconds.ToString()));
            }
#endif
        }

        void CheckIfPlantsFruit(Map map) //@@MP - called on the start of a new day (Release 5-5)
        {
            if (map == null)
                return;

            int fruitingDays; //regrow only every n days
            switch (s_Options.ResourcesAvailability)
            {
                case GameOptions.Resources.LOW: fruitingDays = 3; break;
                case GameOptions.Resources.MED: fruitingDays = 2; break;
                case GameOptions.Resources.HIGH: fruitingDays = 1; break;
                default: throw new InvalidOperationException("unhandled ResourcesAvailability");
            }

            if (m_Session.WorldTime.Day % fruitingDays == 0) //@@MP - growth schedule now tied to an option (Release 7-4)
            {
                //mapobject-based
                foreach (MapObject mapObj in map.MapObjects)
                {
                    int x = mapObj.Location.Position.X;
                    int y = mapObj.Location.Position.Y;
                    if (mapObj != null)
                    {
                        switch (mapObj.AName) //@@MP - added peanuts and grapes (Release 7-3)
                        {
                            //their nutrition is low, so it doesn't matter that there may be many farms in the world
                            case "a berry bush": GrowFoodItems(map, x, y, "wild berries"); break;
                            case "a peanut plant": GrowFoodItems(map, x, y, "peanuts"); break;
                            case "a grape vine": GrowFoodItems(map, x, y, "grapes"); break;
                        }
                    }
                }

                //tile-based
                for (int x = 0; x < map.Width; x++)
                {
                    for (int y = 0; y < map.Height; y++)
                    {
                        Tile tile = map.GetTileAt(x, y);
                        if (tile != null && tile.Model == GameTiles.FLOOR_PLANTED)
                            GrowFoodItems(map, x, y, "vegetables"); //their nutrition is high, but they must be planted from seeds by the player
                    }
                }
            }
        }

        void GrowFoodItems(Map map, int x, int y, string m_theNames) //@@MP (Release 5-5)
        {
            if (map == null)
                return;

            System.Drawing.Point pt = new System.Drawing.Point(x, y);
            int freshUntil;
            Item food = null, seeds = null;
            switch (m_theNames)
            {
                case "wild berries":
                    freshUntil = m_Session.WorldTime.TurnCounter + (WorldTime.TURNS_PER_DAY * GameItems.WILD_BERRIES.BestBeforeDays);
                    food = new ItemFood(GameItems.WILD_BERRIES, freshUntil, false, false) { Quantity = 1 };
                    break;
                case "peanuts":
                    freshUntil = m_Session.WorldTime.TurnCounter + (WorldTime.TURNS_PER_DAY * GameItems.PEANUTS.BestBeforeDays);
                    food = new ItemFood(GameItems.PEANUTS, freshUntil, false, false) { Quantity = 1 };
                    break;
                case "grapes":
                    freshUntil = m_Session.WorldTime.TurnCounter + (WorldTime.TURNS_PER_DAY * GameItems.GRAPES.BestBeforeDays);
                    food = new ItemFood(GameItems.GRAPES, freshUntil, false, false) { Quantity = 1 };
                    break;
                case "vegetables":
                    freshUntil = m_Session.WorldTime.TurnCounter + (WorldTime.TURNS_PER_DAY * GameItems.VEGETABLES.BestBeforeDays);
                    food = new ItemFood(GameItems.VEGETABLES, freshUntil, false, false) { Quantity = 1 };
                    int rolledQuantity = m_Rules.RollChance(12) ? 0 : 1; //keeps the seeds down to avoid making it too easy to get food
                    if (rolledQuantity > 0)
                    {
                        seeds = new Item(GameItems.VEGETABLE_SEEDS);
                        seeds.Quantity = rolledQuantity;
                    }
                    break;
                default: throw new NotImplementedException("GrowFoodItems: unsupported food name");
            }

            List<Item> itemTypes = new List<Item> { food, seeds };
            foreach (Item itemType in itemTypes)
            {
                if (itemType != null)
                {
                    Inventory groundInv = map.GetItemsAt(x, y);
                    if (groundInv != null) //remove any foods and seeds already there to stop it overflowing, and to prevent foods from expiring
                    {
                        Inventory itemsToDelete = new Inventory(groundInv.CountItems); //avoids modifying the inventory collection whilst looping through it, causing an exception
                        foreach (Item it in groundInv.Items)
                        {
                            if (it.Model == itemType.Model)
                                itemsToDelete.AddAll(it);
                        }
                        if (itemsToDelete != null)
                        {
                            foreach (Item it in itemsToDelete.Items)
                            {
                                groundInv.RemoveAllQuantity(it); //keeps the food down to avoid making it too plentiful
                            }
                        }
                    }
                    map.DropItemAt(itemType, pt);
                }
            }
        }

        void CheckIfWorldDecays(Map map) //@@MP (Release 7-6)
        {
            // Start/continue the world decay process
            if (m_Session.WorldTime.Day >= s_Options.DaysBeforeWorldDecays) //don't even bother before the first day of decay
            {
                double decayPhase = ((double)m_Session.WorldTime.Day / (double)s_Options.DaysBeforeWorldDecays);
                if ((int)decayPhase != decayPhase)
                    return; //not an interger

                if (decayPhase == 1)
                    ApplyWorldDecayPhase(1, map); //first phase
                else if (decayPhase == 2)
                    ApplyWorldDecayPhase(2, map); //second phase
                else if (decayPhase == 3)
                    ApplyWorldDecayPhase(3, map); //third phase
                //else, not a day where decay state changes
            }
        }

        void ApplyWorldDecayPhase(int phase, Map map) //@@MP (Release 7-6)
        {
            //walls and floors
            for (int x = 0; x < map.Width; x++)
            {
                for (int y = 0; y < map.Height; y++)
                {
                    //get tile
                    Tile tile = map.GetTileAt(x, y);

                    //is tile a decay type? (not relevant for ponds, grass, etc)
                    if (!tile.Model.CanDecay)
                        continue;

                    //does it already have a decay deco of this level or higher?
                    if (tile.DecayPhase >= phase)
                        continue;

                    //less prone to weathering than outside tiles
                    bool interiorWallForDecay = false;
                    if (tile.IsInside)
                    {
                        if (!tile.Model.IsWalkable) //indoor wall tiles
                        {
                            if (map.Lighting == Lighting.OUTSIDE) //ground level interior walls have a generic decoration applied
                                interiorWallForDecay = true;
                            else //is underground, so no decay
                                continue;
                        }
                        else  //indoor floor tile
                        {
                            //inside floor tiles only have two phases of decay, not three like outdoor tiles
                            if (tile.DecayPhase == 2)
                                continue;

                            //don't do every indoor floor tile all at once. it looks more organic if a trickle of tiles decay each day
                            if (!m_Rules.RollChance(25))
                                continue;
                        }
                    }
                    //certain outdoor floor tiles should be spread out rather than decayed all at once
                    else if (tile.Model.ImageID.Contains("basketball") || tile.Model.ImageID.Contains("tennis") || tile.Model == m_GameTiles.ROAD_ASPHALT_NS || tile.Model == m_GameTiles.ROAD_ASPHALT_EW
                        || tile.Model == m_GameTiles.FLOOR_WALKWAY || tile.Model == m_GameTiles.FLOOR_ASPHALT)
                    {
                        if (!m_Rules.RollChance(25))
                            continue;
                    }

                    //check what, if any, decorations this tile already has
                    List<string> decayDecorations = new List<string>();
                    if (tile.HasDecorations)
                    {
                        bool isDamagedWall = false;
                        foreach (string deco in tile.Decorations)
                        {
                            //don't apply to damaged walls
                            if (deco.Contains("_damaged"))
                            {
                                isDamagedWall = true;
                                break;
                            }
                            //check if it has a decay phase deco already
                            else if (deco.Contains("_phase"))
                                decayDecorations.Add(deco);
                        }
                        if (isDamagedWall)
                            continue;

                        //if we've reached here we're clear to proceed with applying a decay decoration

                        //first remove any existing decay decoration
                        if (decayDecorations.Count > 0)
                        {
                            //should only ever be one decay deco (but you never know, i am a bush league dev ;) )
                            foreach (string decayDeco in decayDecorations)
                                tile.RemoveDecoration(decayDeco);
                        }
                    }

                    //add decoration phase#
                    tile.DecayPhase = phase;
                    if (interiorWallForDecay)
                    {
                        switch (phase)
                        {
                            case 1: tile.AddDecoration(GameImages.DECO_WALL_GENERIC_INTERIOR_DECAY_PHASE1); break;
                            case 2: tile.AddDecoration(GameImages.DECO_WALL_GENERIC_INTERIOR_DECAY_PHASE2); break;
                            case 3: tile.AddDecoration(GameImages.DECO_WALL_GENERIC_INTERIOR_DECAY_PHASE3); break;
                        }
                    }
                    else
                    {
                        tile.InsertDecoration(ChooseRelevantDecayDecorationForTile(tile), 0);
                        //decorations are drawn based on their position in the tile's index of decorations. first one in is the first one drawn on the tile
                        //it's thus vital that decay decorations are drawn first, so that others such as blood splatters and fire/explosion scorches are drawn on top of them
                        //the new InsertDecoration() method fulfills this purpose
                    }
                }
            }

            #region MapObjects
            foreach (MapObject mapObj in map.MapObjects)
            {
                if (!map.GetTileAt(mapObj.Location.Position).IsInside)
                {
                    //note: in some places we dice roll. we don't do every tile all at once. for certain things it looks more organic if a trickle of tiles decay each day

                    string currentImageName = mapObj.ImageID;
                    
                    //picket fences
                    if (currentImageName.Contains("picket_fence"))
                    {
                        if (!currentImageName.Contains(String.Format("phase{0}", phase.ToString()))) //checks that it doesn't already have an image of the target phase
                        {
                            mapObj.ImageID = ChooseRelevantPicketFenceSprite(currentImageName, phase); //there are 3 different directions to handle
                        }
                    }
                    //chainwire fences (basketball and tennis courts)
                    else if (currentImageName.Contains("chainwire_fence"))
                    {
                        if (!currentImageName.Contains(String.Format("phase{0}", phase.ToString())) && m_Rules.RollChance(33))
                            mapObj.ImageID = ChooseRandomWireFenceSprite(phase); //there are 4 different sets of fence decay sprites, so gimme a random one for this phase
                    }
                    else if (currentImageName.Contains("chainwire_gate")) //(let's just ignore open ones)
                    {
                        if (!currentImageName.Contains(String.Format("phase{0}", phase.ToString())) && m_Rules.RollChance(33))
                            mapObj.ImageID = ChooseRandomWireFenceGateSprite(phase); //there are 3 different sets of fence decay sprites, so gimme a random one for this phase
                    }
                    //cars
                    else if (mapObj is Car)
                    {
                        //if imagephase is 2 or more behind the current phase do it automatically, otherwise roll
                        char currentImagePhase = currentImageName[currentImageName.Length - 1]; //get the last character only (which indicates the phase of decay)
                        //this works because all car file names end with "_phase#", where # is a number from 1 to 4
                        if (int.Parse(currentImagePhase.ToString()) < (phase - 1) || m_Rules.RollChance(33))
                        {
                            //get the sprite's filename without the final digit (which indicates the phase of decay)
                            string withoutLast = currentImageName.TrimEnd().Substring(0, currentImageName.Length - 1);
                            //set the sprite of the new phase
                            mapObj.ImageID = String.Concat(withoutLast, phase.ToString());
                        }
                    }
                }
            }
            #endregion
        }

        private string ChooseRelevantDecayDecorationForTile(Tile tile) //@@MP (Release 7-6)
        {
            //tile parameter should never be 0, as the phase is ++ by the calling parent function
            //these are order from roughly most common to least, just to reduce as many CPU cycles as possible

            if (tile.Model.IsWalkable)  //floor tiles
            {
                //note: inside floor tiles aren't exposed to the elements and thus don't suffer as much decay (ie. no phase 3)

                #region walkway
                if (tile.Model.ImageID == GameImages.TILE_FLOOR_WALKWAY)  //this method accounts for the fact that multiple tilemodels can use the same tile image
                {
                    switch (tile.DecayPhase)
                    {
                        case 1:
                            string[] Phase1Decorations = { GameImages.DECO_FLOOR_WALKWAY_DECAY_V1_PHASE1, GameImages.DECO_FLOOR_WALKWAY_DECAY_V2_PHASE1, GameImages.DECO_FLOOR_WALKWAY_DECAY_V3_PHASE1 };
                            return Phase1Decorations[m_Rules.Roll(0, Phase1Decorations.Length)];
                        case 2:
                            string[] Phase2Decorations = { GameImages.DECO_FLOOR_WALKWAY_DECAY_V1_PHASE2, GameImages.DECO_FLOOR_WALKWAY_DECAY_V2_PHASE2, GameImages.DECO_FLOOR_WALKWAY_DECAY_V3_PHASE2 };
                            return Phase2Decorations[m_Rules.Roll(0, Phase2Decorations.Length)];
                        case 3:
                            string[] Phase3Decorations = { GameImages.DECO_FLOOR_WALKWAY_DECAY_V1_PHASE3, GameImages.DECO_FLOOR_WALKWAY_DECAY_V2_PHASE3, GameImages.DECO_FLOOR_WALKWAY_DECAY_V3_PHASE3 };
                            return Phase3Decorations[m_Rules.Roll(0, Phase3Decorations.Length)];
                    }
                }
                #endregion

                #region road (asphalt - there are 3 subtypes)
                //North-South
                if (tile.Model.ImageID == GameImages.TILE_ROAD_ASPHALT_NS)
                {
                    switch (tile.DecayPhase)
                    {
                        case 1:
                            string[] Phase1Decorations = { GameImages.DECO_FLOOR_ROAD_NS_DECAY_V1_PHASE1, GameImages.DECO_FLOOR_ROAD_NS_DECAY_V2_PHASE1, GameImages.DECO_FLOOR_ROAD_NS_DECAY_V3_PHASE1 };
                            return Phase1Decorations[m_Rules.Roll(0, Phase1Decorations.Length)];
                        case 2:
                            string[] Phase2Decorations = { GameImages.DECO_FLOOR_ROAD_NS_DECAY_V1_PHASE2, GameImages.DECO_FLOOR_ROAD_NS_DECAY_V2_PHASE2, GameImages.DECO_FLOOR_ROAD_NS_DECAY_V3_PHASE2 };
                            return Phase2Decorations[m_Rules.Roll(0, Phase2Decorations.Length)];
                        case 3:
                            string[] Phase3Decorations = { GameImages.DECO_FLOOR_ROAD_NS_DECAY_V1_PHASE3, GameImages.DECO_FLOOR_ROAD_NS_DECAY_V2_PHASE3, GameImages.DECO_FLOOR_ROAD_NS_DECAY_V3_PHASE3 };
                            return Phase3Decorations[m_Rules.Roll(0, Phase3Decorations.Length)];
                    }
                }
                //East-West
                if (tile.Model.ImageID == GameImages.TILE_ROAD_ASPHALT_EW)
                {
                    switch (tile.DecayPhase)
                    {
                        case 1:
                            string[] Phase1Decorations = { GameImages.DECO_FLOOR_ROAD_EW_DECAY_V1_PHASE1, GameImages.DECO_FLOOR_ROAD_EW_DECAY_V2_PHASE1, GameImages.DECO_FLOOR_ROAD_EW_DECAY_V3_PHASE1 };
                            return Phase1Decorations[m_Rules.Roll(0, Phase1Decorations.Length)];
                        case 2:
                            string[] Phase2Decorations = { GameImages.DECO_FLOOR_ROAD_EW_DECAY_V1_PHASE2, GameImages.DECO_FLOOR_ROAD_EW_DECAY_V2_PHASE2, GameImages.DECO_FLOOR_ROAD_EW_DECAY_V3_PHASE2 };
                            return Phase2Decorations[m_Rules.Roll(0, Phase2Decorations.Length)];
                        case 3:
                            string[] Phase3Decorations = { GameImages.DECO_FLOOR_ROAD_EW_DECAY_V1_PHASE3, GameImages.DECO_FLOOR_ROAD_EW_DECAY_V2_PHASE3, GameImages.DECO_FLOOR_ROAD_EW_DECAY_V3_PHASE3 };
                            return Phase3Decorations[m_Rules.Roll(0, Phase3Decorations.Length)];
                    }
                }
                #endregion

                #region asphalt floor
                if (tile.Model.ImageID == GameImages.TILE_FLOOR_ASPHALT)
                {
                    switch (tile.DecayPhase)
                    {
                        case 1:
                            string[] Phase1Decorations = { GameImages.DECO_FLOOR_ASPHALT_DECAY_V1_PHASE1, GameImages.DECO_FLOOR_ASPHALT_DECAY_V2_PHASE1, GameImages.DECO_FLOOR_ASPHALT_DECAY_V3_PHASE1 };
                            return Phase1Decorations[m_Rules.Roll(0, Phase1Decorations.Length)];
                        case 2:
                            string[] Phase2Decorations = { GameImages.DECO_FLOOR_ASPHALT_DECAY_V1_PHASE2, GameImages.DECO_FLOOR_ASPHALT_DECAY_V2_PHASE2, GameImages.DECO_FLOOR_ASPHALT_DECAY_V3_PHASE2 };
                            return Phase2Decorations[m_Rules.Roll(0, Phase2Decorations.Length)];
                        case 3:
                            string[] Phase3Decorations = { GameImages.DECO_FLOOR_ASPHALT_DECAY_V1_PHASE3, GameImages.DECO_FLOOR_ASPHALT_DECAY_V2_PHASE3, GameImages.DECO_FLOOR_ASPHALT_DECAY_V3_PHASE3 };
                            return Phase3Decorations[m_Rules.Roll(0, Phase3Decorations.Length)];
                    }
                }
                #endregion

                #region office
                if (tile.Model.ImageID == GameImages.TILE_FLOOR_OFFICE)
                {
                    switch (tile.DecayPhase)
                    {
                        case 1:
                            string[] Phase1Decorations = { GameImages.DECO_FLOOR_OFFICE_DECAY_V1_PHASE1, GameImages.DECO_FLOOR_OFFICE_DECAY_V2_PHASE1, GameImages.DECO_FLOOR_OFFICE_DECAY_V3_PHASE1 };
                            return Phase1Decorations[m_Rules.Roll(0, Phase1Decorations.Length)];
                        case 2:
                        case 3: //I include three in case entrance tiles count as !IsInside, and are thus missed by the filters in the calling parent function
                            string[] Phase2Decorations = { GameImages.DECO_FLOOR_OFFICE_DECAY_V1_PHASE2, GameImages.DECO_FLOOR_OFFICE_DECAY_V2_PHASE2, GameImages.DECO_FLOOR_OFFICE_DECAY_V3_PHASE2 };
                            return Phase2Decorations[m_Rules.Roll(0, Phase2Decorations.Length)];
                    }
                }
                #endregion

                #region floor planks
                if (tile.Model.ImageID == GameImages.TILE_FLOOR_PLANKS)
                {
                    switch (tile.DecayPhase)
                    {
                        case 1:
                            string[] Phase1Decorations = { GameImages.DECO_FLOOR_PLANKS_DECAY_V1_PHASE1, GameImages.DECO_FLOOR_PLANKS_DECAY_V2_PHASE1, GameImages.DECO_FLOOR_PLANKS_DECAY_V3_PHASE1 };
                            return Phase1Decorations[m_Rules.Roll(0, Phase1Decorations.Length)];
                        case 2:
                        case 3: //I include three in case entrance tiles count as !IsInside, and are thus missed by the filters in the calling parent function
                            string[] Phase2Decorations = { GameImages.DECO_FLOOR_PLANKS_DECAY_V1_PHASE2, GameImages.DECO_FLOOR_PLANKS_DECAY_V2_PHASE2, GameImages.DECO_FLOOR_PLANKS_DECAY_V3_PHASE2 };
                            return Phase2Decorations[m_Rules.Roll(0, Phase2Decorations.Length)];
                    }
                }
                #endregion

                #region shop tiles
                if (tile.Model.ImageID == GameImages.TILE_FLOOR_TILES)
                {
                    switch (tile.DecayPhase)
                    {
                        case 1:
                            string[] Phase1Decorations = { GameImages.DECO_FLOOR_SHOP_TILE_DECAY_V1_PHASE1, GameImages.DECO_FLOOR_SHOP_TILE_DECAY_V2_PHASE1, GameImages.DECO_FLOOR_SHOP_TILE_DECAY_V3_PHASE1 };
                            return Phase1Decorations[m_Rules.Roll(0, Phase1Decorations.Length)];
                        case 2:
                        case 3: //I include three in case entrance tiles count as !IsInside, and are thus missed by the filters in the calling parent function
                            string[] Phase2Decorations = { GameImages.DECO_FLOOR_SHOP_TILE_DECAY_V1_PHASE2, GameImages.DECO_FLOOR_SHOP_TILE_DECAY_V2_PHASE2, GameImages.DECO_FLOOR_SHOP_TILE_DECAY_V3_PHASE2 };
                            return Phase2Decorations[m_Rules.Roll(0, Phase2Decorations.Length)];
                    }
                }
                #endregion

                #region concrete
                if (tile.Model.ImageID == GameImages.TILE_FLOOR_CONCRETE)
                {
                    switch (tile.DecayPhase)
                    {
                        case 1:
                            string[] Phase1Decorations = { GameImages.DECO_FLOOR_CONCRETE_DECAY_V1_PHASE1, GameImages.DECO_FLOOR_CONCRETE_DECAY_V2_PHASE1, GameImages.DECO_FLOOR_CONCRETE_DECAY_V3_PHASE1 };
                            return Phase1Decorations[m_Rules.Roll(0, Phase1Decorations.Length)];
                        case 2:
                            string[] Phase2Decorations = { GameImages.DECO_FLOOR_CONCRETE_DECAY_V1_PHASE2, GameImages.DECO_FLOOR_CONCRETE_DECAY_V2_PHASE2, GameImages.DECO_FLOOR_CONCRETE_DECAY_V3_PHASE2 };
                            return Phase2Decorations[m_Rules.Roll(0, Phase2Decorations.Length)];
                        case 3:
                            string[] Phase3Decorations = { GameImages.DECO_FLOOR_CONCRETE_DECAY_V1_PHASE3, GameImages.DECO_FLOOR_CONCRETE_DECAY_V2_PHASE3, GameImages.DECO_FLOOR_CONCRETE_DECAY_V3_PHASE3 };
                            return Phase3Decorations[m_Rules.Roll(0, Phase3Decorations.Length)];
                    }
                }
                #endregion

                #region white tile (shopping mall)
                if (tile.Model.ImageID == GameImages.TILE_FLOOR_WHITE_TILE)
                {
                    switch (tile.DecayPhase)
                    {
                        case 1:
                            string[] Phase1Decorations = { GameImages.DECO_FLOOR_WHITE_TILE_DECAY_V1_PHASE1, GameImages.DECO_FLOOR_WHITE_TILE_DECAY_V2_PHASE1, GameImages.DECO_FLOOR_WHITE_TILE_DECAY_V3_PHASE1 };
                            return Phase1Decorations[m_Rules.Roll(0, Phase1Decorations.Length)];
                        case 2:
                        case 3: //I include three in case entrance tiles count as !IsInside, and are thus missed by the filters in the calling parent function
                            string[] Phase2Decorations = { GameImages.DECO_FLOOR_WHITE_TILE_DECAY_V1_PHASE2, GameImages.DECO_FLOOR_WHITE_TILE_DECAY_V2_PHASE2, GameImages.DECO_FLOOR_WHITE_TILE_DECAY_V3_PHASE2 };
                            return Phase2Decorations[m_Rules.Roll(0, Phase2Decorations.Length)];
                    }
                }
                #endregion

                //parking asphalt (there are two subtypes)
                //// don't need to do this one at the moment, as it's only used in the mall underground parking so far

                #region basketball court
                if (tile.Model.ImageID.Contains("basketball")) //need to use this broad method, as courts are made up of dozens of unique tiles
                {
                    switch (tile.DecayPhase)
                    {
                        case 1:
                            string[] Phase1Decorations = { GameImages.DECO_FLOOR_BASKETBALL_COURT_DECAY_V1_PHASE1, GameImages.DECO_FLOOR_BASKETBALL_COURT_DECAY_V2_PHASE1, GameImages.DECO_FLOOR_BASKETBALL_COURT_DECAY_V3_PHASE1 };
                            return Phase1Decorations[m_Rules.Roll(0, Phase1Decorations.Length)];
                        case 2:
                            string[] Phase2Decorations = { GameImages.DECO_FLOOR_BASKETBALL_COURT_DECAY_V1_PHASE2, GameImages.DECO_FLOOR_BASKETBALL_COURT_DECAY_V2_PHASE2, GameImages.DECO_FLOOR_BASKETBALL_COURT_DECAY_V3_PHASE2 };
                            return Phase2Decorations[m_Rules.Roll(0, Phase2Decorations.Length)];
                        case 3:
                            string[] Phase3Decorations = { GameImages.DECO_FLOOR_BASKETBALL_COURT_DECAY_V1_PHASE3, GameImages.DECO_FLOOR_BASKETBALL_COURT_DECAY_V2_PHASE3, GameImages.DECO_FLOOR_BASKETBALL_COURT_DECAY_V3_PHASE3 };
                            return Phase3Decorations[m_Rules.Roll(0, Phase3Decorations.Length)];
                    }
                }
                #endregion

                #region tennis court
                if (tile.Model.ImageID.Contains("tennis")) //need to use this broad method, as courts are made up of dozens of unique tiles
                {
                    switch (tile.DecayPhase)
                    {
                        case 1:
                            string[] Phase1Decorations = { GameImages.DECO_FLOOR_TENNIS_COURT_DECAY_V1_PHASE1, GameImages.DECO_FLOOR_TENNIS_COURT_DECAY_V2_PHASE1, GameImages.DECO_FLOOR_TENNIS_COURT_DECAY_V3_PHASE1 };
                            return Phase1Decorations[m_Rules.Roll(0, Phase1Decorations.Length)];
                        case 2:
                            string[] Phase2Decorations = { GameImages.DECO_FLOOR_TENNIS_COURT_DECAY_V1_PHASE2, GameImages.DECO_FLOOR_TENNIS_COURT_DECAY_V2_PHASE2, GameImages.DECO_FLOOR_TENNIS_COURT_DECAY_V3_PHASE2 };
                            return Phase2Decorations[m_Rules.Roll(0, Phase2Decorations.Length)];
                        case 3:
                            string[] Phase3Decorations = { GameImages.DECO_FLOOR_TENNIS_COURT_DECAY_V1_PHASE3, GameImages.DECO_FLOOR_TENNIS_COURT_DECAY_V2_PHASE3, GameImages.DECO_FLOOR_TENNIS_COURT_DECAY_V3_PHASE3 };
                            return Phase3Decorations[m_Rules.Roll(0, Phase3Decorations.Length)];
                    }
                }
                #endregion
            }
            else //wall tile
            {
                #region brick
                if (tile.Model.ImageID == GameImages.TILE_WALL_BRICK)
                {
                    switch (tile.DecayPhase)
                    {
                        case 1:
                            string[] Phase1Decorations = { GameImages.DECO_WALL_BRICK_DECAY_V1_PHASE1, GameImages.DECO_WALL_BRICK_DECAY_V2_PHASE1, GameImages.DECO_WALL_BRICK_DECAY_V3_PHASE1 };
                            return Phase1Decorations[m_Rules.Roll(0, Phase1Decorations.Length)];
                        case 2:
                            string[] Phase2Decorations = { GameImages.DECO_WALL_BRICK_DECAY_V1_PHASE2, GameImages.DECO_WALL_BRICK_DECAY_V2_PHASE2, GameImages.DECO_WALL_BRICK_DECAY_V3_PHASE2 };
                            return Phase2Decorations[m_Rules.Roll(0, Phase2Decorations.Length)];
                        case 3:
                            string[] Phase3Decorations = { GameImages.DECO_WALL_BRICK_DECAY_V1_PHASE3, GameImages.DECO_WALL_BRICK_DECAY_V2_PHASE3, GameImages.DECO_WALL_BRICK_DECAY_V3_PHASE3 };
                            return Phase3Decorations[m_Rules.Roll(0, Phase3Decorations.Length)];
                    }
                }
                #endregion

                #region CHAR office
                if (tile.Model.ImageID == GameImages.TILE_WALL_CHAR_OFFICE)
                {
                    switch (tile.DecayPhase)
                    {
                        case 1:
                            string[] Phase1Decorations = { GameImages.DECO_WALL_CHAR_DECAY_V1_PHASE1, GameImages.DECO_WALL_CHAR_DECAY_V2_PHASE1, GameImages.DECO_WALL_CHAR_DECAY_V3_PHASE1 };
                            return Phase1Decorations[m_Rules.Roll(0, Phase1Decorations.Length)];
                        case 2:
                            string[] Phase2Decorations = { GameImages.DECO_WALL_CHAR_DECAY_V1_PHASE2, GameImages.DECO_WALL_CHAR_DECAY_V2_PHASE2, GameImages.DECO_WALL_CHAR_DECAY_V3_PHASE2 };
                            return Phase2Decorations[m_Rules.Roll(0, Phase2Decorations.Length)];
                        case 3:
                            string[] Phase3Decorations = { GameImages.DECO_WALL_CHAR_DECAY_V1_PHASE3, GameImages.DECO_WALL_CHAR_DECAY_V2_PHASE3, GameImages.DECO_WALL_CHAR_DECAY_V3_PHASE3 };
                            return Phase3Decorations[m_Rules.Roll(0, Phase3Decorations.Length)];
                    }
                }
                #endregion

                #region stone wall
                if (tile.Model.ImageID == GameImages.TILE_WALL_STONE)
                {
                    switch (tile.DecayPhase)
                    {
                        case 1:
                            string[] Phase1Decorations = { GameImages.DECO_WALL_STONE_DECAY_V1_PHASE1, GameImages.DECO_WALL_STONE_DECAY_V2_PHASE1 };
                            return Phase1Decorations[m_Rules.Roll(0, Phase1Decorations.Length)];
                        case 2:
                            string[] Phase2Decorations = { GameImages.DECO_WALL_STONE_DECAY_V1_PHASE2, GameImages.DECO_WALL_STONE_DECAY_V2_PHASE2 };
                            return Phase2Decorations[m_Rules.Roll(0, Phase2Decorations.Length)];
                        case 3:
                            string[] Phase3Decorations = { GameImages.DECO_WALL_STONE_DECAY_V1_PHASE3, GameImages.DECO_WALL_STONE_DECAY_V2_PHASE3 };
                            return Phase3Decorations[m_Rules.Roll(0, Phase3Decorations.Length)];
                    }
                }
                #endregion

                #region light brown wall
                if (tile.Model.ImageID == GameImages.TILE_WALL_LIGHT_BROWN)
                {
                    switch (tile.DecayPhase)
                    {
                        case 1:
                            string[] Phase1Decorations = { GameImages.DECO_WALL_LIGHT_BROWN_DECAY_V1_PHASE1, GameImages.DECO_WALL_LIGHT_BROWN_DECAY_V2_PHASE1, GameImages.DECO_WALL_LIGHT_BROWN_DECAY_V3_PHASE1 };
                            return Phase1Decorations[m_Rules.Roll(0, Phase1Decorations.Length)];
                        case 2:
                            string[] Phase2Decorations = { GameImages.DECO_WALL_LIGHT_BROWN_DECAY_V1_PHASE2, GameImages.DECO_WALL_LIGHT_BROWN_DECAY_V2_PHASE2, GameImages.DECO_WALL_LIGHT_BROWN_DECAY_V3_PHASE2 };
                            return Phase2Decorations[m_Rules.Roll(0, Phase2Decorations.Length)];
                        case 3:
                            string[] Phase3Decorations = { GameImages.DECO_WALL_LIGHT_BROWN_DECAY_V1_PHASE3, GameImages.DECO_WALL_LIGHT_BROWN_DECAY_V2_PHASE3, GameImages.DECO_WALL_LIGHT_BROWN_DECAY_V3_PHASE3 };
                            return Phase3Decorations[m_Rules.Roll(0, Phase3Decorations.Length)];
                    }
                }
                #endregion

                #region concrete (non-CHAR offices)
                if (tile.Model.ImageID == GameImages.TILE_WALL_CONCRETE)
                {
                    switch (tile.DecayPhase)
                    {
                        case 1:
                            string[] Phase1Decorations = { GameImages.DECO_WALL_CONCRETE_DECAY_V1_PHASE1, GameImages.DECO_WALL_CONCRETE_DECAY_V2_PHASE1, GameImages.DECO_WALL_CONCRETE_DECAY_V3_PHASE1 };
                            return Phase1Decorations[m_Rules.Roll(0, Phase1Decorations.Length)];
                        case 2:
                            string[] Phase2Decorations = { GameImages.DECO_WALL_CONCRETE_DECAY_V1_PHASE2, GameImages.DECO_WALL_CONCRETE_DECAY_V2_PHASE2, GameImages.DECO_WALL_CONCRETE_DECAY_V3_PHASE2 };
                            return Phase2Decorations[m_Rules.Roll(0, Phase2Decorations.Length)];
                        case 3:
                            string[] Phase3Decorations = { GameImages.DECO_WALL_CONCRETE_DECAY_V1_PHASE3, GameImages.DECO_WALL_CONCRETE_DECAY_V2_PHASE3, GameImages.DECO_WALL_CONCRETE_DECAY_V3_PHASE3 };
                            return Phase3Decorations[m_Rules.Roll(0, Phase3Decorations.Length)];
                    }
                }
                #endregion

                #region army wall
                if (tile.Model.ImageID == GameImages.TILE_WALL_ARMY_BASE)
                {
                    switch (tile.DecayPhase)
                    {
                        case 1:
                            string[] Phase1Decorations = { GameImages.DECO_WALL_ARMY_BASE_DECAY_V1_PHASE1, GameImages.DECO_WALL_ARMY_BASE_DECAY_V2_PHASE1, GameImages.DECO_WALL_ARMY_BASE_DECAY_V3_PHASE1 };
                            return Phase1Decorations[m_Rules.Roll(0, Phase1Decorations.Length)];
                        case 2:
                            string[] Phase2Decorations = { GameImages.DECO_WALL_ARMY_BASE_DECAY_V1_PHASE2, GameImages.DECO_WALL_ARMY_BASE_DECAY_V2_PHASE2, GameImages.DECO_WALL_ARMY_BASE_DECAY_V3_PHASE2 };
                            return Phase2Decorations[m_Rules.Roll(0, Phase2Decorations.Length)];
                        case 3:
                            string[] Phase3Decorations = { GameImages.DECO_WALL_ARMY_BASE_DECAY_V1_PHASE3, GameImages.DECO_WALL_ARMY_BASE_DECAY_V2_PHASE3, GameImages.DECO_WALL_ARMY_BASE_DECAY_V3_PHASE3 };
                            return Phase3Decorations[m_Rules.Roll(0, Phase3Decorations.Length)];
                    }
                }
                #endregion

                #region fuel station wall
                if (tile.Model.ImageID == GameImages.TILE_WALL_FUEL_STATION)
                {
                    switch (tile.DecayPhase)
                    {
                        case 1:
                            string[] Phase1Decorations = { GameImages.DECO_WALL_FUEL_STATION_DECAY_V1_PHASE1, GameImages.DECO_WALL_FUEL_STATION_DECAY_V2_PHASE1, GameImages.DECO_WALL_FUEL_STATION_DECAY_V3_PHASE1 };
                            return Phase1Decorations[m_Rules.Roll(0, Phase1Decorations.Length)];
                        case 2:
                            string[] Phase2Decorations = { GameImages.DECO_WALL_FUEL_STATION_DECAY_V1_PHASE2, GameImages.DECO_WALL_FUEL_STATION_DECAY_V2_PHASE2, GameImages.DECO_WALL_FUEL_STATION_DECAY_V3_PHASE2 };
                            return Phase2Decorations[m_Rules.Roll(0, Phase2Decorations.Length)];
                        case 3:
                            string[] Phase3Decorations = { GameImages.DECO_WALL_FUEL_STATION_DECAY_V1_PHASE3, GameImages.DECO_WALL_FUEL_STATION_DECAY_V2_PHASE3, GameImages.DECO_WALL_FUEL_STATION_DECAY_V3_PHASE3 };
                            return Phase3Decorations[m_Rules.Roll(0, Phase3Decorations.Length)];
                    }
                }
                #endregion

                #region wood (farm shed)
                if (tile.Model.ImageID == GameImages.TILE_WALL_WOOD_PLANKS)
                {
                    switch (tile.DecayPhase)
                    {
                        case 1:
                            string[] Phase1Decorations = { GameImages.DECO_WALL_PLANKS_DECAY_V1_PHASE1, GameImages.DECO_WALL_PLANKS_DECAY_V2_PHASE1 };
                            return Phase1Decorations[m_Rules.Roll(0, Phase1Decorations.Length)];
                        case 2:
                            string[] Phase2Decorations = { GameImages.DECO_WALL_PLANKS_DECAY_V1_PHASE2, GameImages.DECO_WALL_PLANKS_DECAY_V2_PHASE2 };
                            return Phase2Decorations[m_Rules.Roll(0, Phase2Decorations.Length)];
                        case 3:
                            string[] Phase3Decorations = { GameImages.DECO_WALL_PLANKS_DECAY_V1_PHASE3, GameImages.DECO_WALL_PLANKS_DECAY_V2_PHASE3 };
                            return Phase3Decorations[m_Rules.Roll(0, Phase3Decorations.Length)];
                    }
                }
                #endregion

                #region hospital
                if (tile.Model.ImageID == GameImages.TILE_WALL_HOSPITAL)
                {
                    switch (tile.DecayPhase)
                    {
                        case 1:
                            string[] Phase1Decorations = { GameImages.DECO_WALL_HOSPITAL_DECAY_V1_PHASE1, GameImages.DECO_WALL_HOSPITAL_DECAY_V2_PHASE1, GameImages.DECO_WALL_HOSPITAL_DECAY_V3_PHASE1 };
                            return Phase1Decorations[m_Rules.Roll(0, Phase1Decorations.Length)];
                        case 2:
                            string[] Phase2Decorations = { GameImages.DECO_WALL_HOSPITAL_DECAY_V1_PHASE2, GameImages.DECO_WALL_HOSPITAL_DECAY_V2_PHASE2, GameImages.DECO_WALL_HOSPITAL_DECAY_V3_PHASE2 };
                            return Phase2Decorations[m_Rules.Roll(0, Phase2Decorations.Length)];
                        case 3:
                            string[] Phase3Decorations = { GameImages.DECO_WALL_HOSPITAL_DECAY_V1_PHASE3, GameImages.DECO_WALL_HOSPITAL_DECAY_V2_PHASE3, GameImages.DECO_WALL_HOSPITAL_DECAY_V3_PHASE3 };
                            return Phase3Decorations[m_Rules.Roll(0, Phase3Decorations.Length)];
                    }
                }
                #endregion

                #region mall
                if (tile.Model.ImageID == GameImages.TILE_WALL_MALL)
                {
                    switch (tile.DecayPhase)
                    {
                        case 1:
                            string[] Phase1Decorations = { GameImages.DECO_WALL_MALL_DECAY_V1_PHASE1, GameImages.DECO_WALL_MALL_DECAY_V2_PHASE1, GameImages.DECO_WALL_MALL_DECAY_V3_PHASE1 };
                            return Phase1Decorations[m_Rules.Roll(0, Phase1Decorations.Length)];
                        case 2:
                            string[] Phase2Decorations = { GameImages.DECO_WALL_MALL_DECAY_V1_PHASE2, GameImages.DECO_WALL_MALL_DECAY_V2_PHASE2, GameImages.DECO_WALL_MALL_DECAY_V3_PHASE2 };
                            return Phase2Decorations[m_Rules.Roll(0, Phase2Decorations.Length)];
                        case 3:
                            string[] Phase3Decorations = { GameImages.DECO_WALL_MALL_DECAY_V1_PHASE3, GameImages.DECO_WALL_MALL_DECAY_V2_PHASE3, GameImages.DECO_WALL_MALL_DECAY_V3_PHASE3 };
                            return Phase3Decorations[m_Rules.Roll(0, Phase3Decorations.Length)];
                    }
                }
                #endregion
            }

            throw new InvalidOperationException(String.Format("unexpected tile model? tilemodel: {0}", tile.Model.ImageID.ToString()));
        }

        private static string ChooseRelevantPicketFenceSprite(string currentImageName, int newPhase) //@@MP (Release 7-6)
        {
            switch (newPhase)
            {
                case 1:
                    if (currentImageName.Contains("EW"))
                        return GameImages.OBJ_PICKET_FENCE_EW_V1_PHASE1;
                    else if (currentImageName.Contains("NS_left"))
                        return GameImages.OBJ_PICKET_FENCE_NS_LEFT_V1_PHASE1;
                    else if (currentImageName.Contains("NS_right"))
                        return GameImages.OBJ_PICKET_FENCE_NS_RIGHT_V1_PHASE1;
                    break;
                case 2:
                    if (currentImageName.Contains("EW"))
                        return GameImages.OBJ_PICKET_FENCE_EW_V1_PHASE2;
                    else if (currentImageName.Contains("NS_left"))
                        return GameImages.OBJ_PICKET_FENCE_NS_LEFT_V1_PHASE2;
                    else if (currentImageName.Contains("NS_right"))
                        return GameImages.OBJ_PICKET_FENCE_NS_RIGHT_V1_PHASE2;
                    break;
                case 3:
                    if (currentImageName.Contains("EW"))
                        return GameImages.OBJ_PICKET_FENCE_EW_V1_PHASE3;
                    else if (currentImageName.Contains("NS_left"))
                        return GameImages.OBJ_PICKET_FENCE_NS_LEFT_V1_PHASE3;
                    else if (currentImageName.Contains("NS_right"))
                        return GameImages.OBJ_PICKET_FENCE_NS_RIGHT_V1_PHASE3;
                    break;
                default: throw new ArgumentOutOfRangeException("newPhase");
            }

            throw new InvalidOperationException("unexpected picket fence image name?");
        }

        private string ChooseRandomWireFenceSprite(int newPhase) //@@MP (Release 7-6)
        {
            switch (newPhase)
            {
                case 1:
                    string[] Phase1Sprites = { GameImages.OBJ_CHAINWIRE_FENCE_V1_PHASE1, GameImages.OBJ_CHAINWIRE_FENCE_V2_PHASE1, GameImages.OBJ_CHAINWIRE_FENCE_V3_PHASE1, GameImages.OBJ_CHAINWIRE_FENCE_V4_PHASE1 };
                    return Phase1Sprites[m_Rules.Roll(0, Phase1Sprites.Length)];
                case 2:
                    string[] Phase2Sprites = { GameImages.OBJ_CHAINWIRE_FENCE_V1_PHASE2, GameImages.OBJ_CHAINWIRE_FENCE_V2_PHASE2, GameImages.OBJ_CHAINWIRE_FENCE_V3_PHASE2, GameImages.OBJ_CHAINWIRE_FENCE_V4_PHASE2 };
                    return Phase2Sprites[m_Rules.Roll(0, Phase2Sprites.Length)];
                case 3:
                    string[] Phase3Sprites = { GameImages.OBJ_CHAINWIRE_FENCE_V1_PHASE3, GameImages.OBJ_CHAINWIRE_FENCE_V2_PHASE3, GameImages.OBJ_CHAINWIRE_FENCE_V3_PHASE3, GameImages.OBJ_CHAINWIRE_FENCE_V4_PHASE3 };
                    return Phase3Sprites[m_Rules.Roll(0, Phase3Sprites.Length)];
                default: throw new ArgumentOutOfRangeException("newPhase");
            }
        }

        private string ChooseRandomWireFenceGateSprite(int newPhase) //@@MP (Release 7-6)
        {
            switch (newPhase)
            {
                case 1:
                    string[] Phase1Sprites = { GameImages.OBJ_CHAINWIRE_FENCE_GATE_V1_PHASE1, GameImages.OBJ_CHAINWIRE_FENCE_GATE_V2_PHASE1, GameImages.OBJ_CHAINWIRE_FENCE_GATE_V3_PHASE1 };
                    return Phase1Sprites[m_Rules.Roll(0, Phase1Sprites.Length)];
                case 2:
                    string[] Phase2Sprites = { GameImages.OBJ_CHAINWIRE_FENCE_GATE_V1_PHASE2, GameImages.OBJ_CHAINWIRE_FENCE_GATE_V2_PHASE2, GameImages.OBJ_CHAINWIRE_FENCE_GATE_V3_PHASE2 };
                    return Phase2Sprites[m_Rules.Roll(0, Phase2Sprites.Length)];
                case 3:
                    string[] Phase3Sprites = { GameImages.OBJ_CHAINWIRE_FENCE_GATE_V1_PHASE3, GameImages.OBJ_CHAINWIRE_FENCE_GATE_V2_PHASE3, GameImages.OBJ_CHAINWIRE_FENCE_GATE_V3_PHASE3 };
                    return Phase3Sprites[m_Rules.Roll(0, Phase3Sprites.Length)];
                default: throw new ArgumentOutOfRangeException("newPhase");
            }
        }

        void HandlePlayerDecideUpgrade(Actor upgradeActor)
        {
            // roll N skills to updgrade.
            List<Skills.IDs> upgradeChoices = RollSkillsToUpgrade(upgradeActor, 3 * 100);

            // "you" vs follower name.
            string youName = upgradeActor == m_Player ? "You" : String.Concat(upgradeActor.Name, " is");

            // loop.
            bool loop = true;
            do
            {
                OverlayPopupTitle popup = null;

                ///////////////////
                // 1. Redraw
                // 2. Read input
                // 3. Handle input
                ///////////////////

                // 1. Redraw
                ClearMessages();
                int skillUpgradeChoices = upgradeChoices.Count;  //@@MP upgradechoices.count equals how many choices to present to the user (vanilla = 5 for living, 2 for undead)

                //@@MP - if Sanity is disabled, make sure Strong Psyche is not one of the skill upgrades offered (Release 1)
                if ((skillUpgradeChoices <= 1) && (!Options.IsSanityEnabled)) //@MP - fixed crappy implem (Release 5-2)
                    AddMessage(MakeErrorMessage(youName + " fully skilled and can't learn anything new."));
                else if (skillUpgradeChoices == 0)
                    AddMessage(MakeErrorMessage(youName + " fully skilled and can't learn anything new."));
                else
                {
                    AddMessage(new Message(youName + " can improve or learn one of these skills. Choose wisely.", m_Session.WorldTime.TurnCounter, Color.Green));
                    List<string> popupLines = new List<string>();
                    popupLines.Add(" ");

                    for (int iChoice = 0; iChoice < skillUpgradeChoices; iChoice++)
                    {
                        Skills.IDs sk = upgradeChoices[iChoice];
                        int level = upgradeActor.Sheet.SkillTable.GetSkillLevel((int)sk);
                        string text = string.Format("{0}. {1} {2}/{3}", iChoice + 1, Skills.Name(sk), level + 1, Skills.MaxSkillLevel(sk)); // alpha 10, was: string text = string.Format("choice {0} : {1} from {2} to {3} - {4}", iChoice + 1, Skills.Name(sk), level, level + 1, DescribeSkillShort(sk));
                        AddMessage(new Message(text, m_Session.WorldTime.TurnCounter, Color.LightGreen));

                        popupLines.Add(text);
                        popupLines.Add("    " + DescribeSkillShort(sk));
                        popupLines.Add(" ");
                    }

                    popupLines.Add("ESC. don't upgrade");

                    if (upgradeActor != m_Player)
                    {
                        popupLines.Add(" ");
                        popupLines.Add(upgradeActor.Name + " current skills");
                        foreach (Skill sk in upgradeActor.Sheet.SkillTable.Skills)
                        {
                            popupLines.Add(string.Format("{0} {1}", Skills.Name(sk.ID), sk.Level));
                        }
                    }

                    popup = new OverlayPopupTitle(upgradeActor == m_Player ? "Select skill to upgrade" : "Select skill to upgrade for " + upgradeActor.Name, Color.White, popupLines.ToArray(), Color.White, Color.White, Color.Black, new Point(64, 64));
                    AddOverlay(popup);

                    AddMessage(new Message("ESC if you don't want to upgrade.", m_Session.WorldTime.TurnCounter, Color.White));
                }
                RedrawPlayScreen();

                // 2. Read input
                KeyEventArgs inKey = m_UI.UI_WaitKey();

                // 3. Handle input
                //PlayerCommand command = InputTranslator.KeyToCommand(inKey); //@@MP - commented useless variable, as RJ ditched EXIT_OR_CANCEL (Release 4)
                if (inKey.KeyCode == Keys.Escape)// command == PlayerCommand.EXIT_OR_CANCEL)
                {
                    loop = false;
                    if (popup != null) RemoveOverlay(popup);
                    RedrawPlayScreen();
                }
                else
                {
                    // get choice.
                    int choice = KeyToChoiceNumber(inKey.KeyCode);
                    if (choice >= 1 && choice <= upgradeChoices.Count)
                    {
                        // upgrade skill.
                        Skills.IDs skID = upgradeChoices[choice - 1];
                        Skill sk = SkillUpgrade(upgradeActor, skID);

                        // message & scoring.
                        if (sk.Level == 1)
                        {
                            AddMessage(new Message(String.Format("{0} learned skill {1}.", upgradeActor.Name, Skills.Name(sk.ID)), m_Session.WorldTime.TurnCounter, Color.LightGreen));
                            m_Session.Scoring.AddEvent(m_Session.WorldTime.TurnCounter, String.Format("{0} learned skill {1}.", upgradeActor.Name, Skills.Name(sk.ID)));
                        }
                        else
                        {
                            AddMessage(new Message(String.Format("{0} improved skill {1} to level {2}.", upgradeActor.Name, Skills.Name(sk.ID), sk.Level), m_Session.WorldTime.TurnCounter, Color.LightGreen));
                            m_Session.Scoring.AddEvent(m_Session.WorldTime.TurnCounter, String.Format("{0} improved skill {1} to level {2}.", upgradeActor.Name, Skills.Name(sk.ID), sk.Level));
                        }
                        AddMessagePressEnter();
                        if (popup != null) RemoveOverlay(popup);
                        RedrawPlayScreen();
                        loop = false;
                    }
                }

            } while (loop);
        }

        void HandlePlayerFollowersUpgrade()
        {
            // if no followers, nothing to do.
            if (m_Player.CountFollowers == 0)
                return;

            // Message.
            ClearMessages();
            AddMessage(new Message("Your followers learned new skills!", m_Session.WorldTime.TurnCounter, Color.Green));
            AddMessagePressEnter();

            // Do it.
            foreach (Actor follower in m_Player.Followers)
            {
                // player pick for the follower.
                HandlePlayerDecideUpgrade(follower);
            }
        }

        void HandleLivingNPCsUpgrade(Map map)
        {
            foreach (Actor a in map.Actors)
            {
                // ignore player, we do it separatly.
                if (a == m_Player)
                    continue;
                // ignore player followers (upgraded already)
                if (a.Leader == m_Player)
                    continue;
                // not undeads!
                if (a.Model.Abilities.IsUndead)
                    continue;
                // not dogs     //@@MP (Release 7-3)
                if (GameActors.IsDog(a.Model))

                // do it!
                HandleNPCSkillUpgrade(a);  // alpha10.1
            }
        }

        void HandleNPCSkillUpgrade(Actor a) // alpha10.1 factorized to handle bot skill upgrade
        {
            List<Skills.IDs> upgradeFrom = RollSkillsToUpgrade(a, 3 * 100);
            Skills.IDs? chosenSkill = NPCPickSkillToUpgrade(a, upgradeFrom);
            if (chosenSkill == null)
                return;
            // upgrade it!
            SkillUpgrade(a, chosenSkill.Value);
        }

        void HandleUndeadNPCsUpgrade(Map map)
        {
            foreach (Actor a in map.Actors)
            {
                // undeads only, and some branches only.
                if (!a.Model.Abilities.IsUndead)
                    continue;
                if (GameActors.IsSkeletonBranch(a.Model))
                {
                    if (!s_Options.SkeletonsUpgrade || m_Session.GameMode == GameMode.GM_VINTAGE)  //@@MP - forgot to do this after I made the Vtg mode stop forcing options off (Release 7-6)
                        continue;
                }
                if (GameActors.IsRatBranch(a.Model))
                {
                    //if (!s_Options.RatsUpgrade || m_Session.GameMode == GameMode.GM_VINTAGE)    //@@MP - disable rat upgrades entirely (Release 5-7)
                    continue;
                }
                if (GameActors.IsShamblerBranch(a.Model))
                {
                    if (!s_Options.ShamblersUpgrade || m_Session.GameMode == GameMode.GM_VINTAGE)  //@@MP - forgot to do this after I made the Vtg mode stop forcing options off (Release 7-6)
                        continue;
                }
                // ignore player, we do it separatly.
                if (a == m_Player)
                    continue;
                // ignore player followers (upgraded already)
                if (a.Leader == m_Player)
                    continue;

                // do it!
                List<Skills.IDs> upgradeFrom = RollSkillsToUpgrade(a, 3 * 100);
                Skills.IDs? chosenSkill = NPCPickSkillToUpgrade(a, upgradeFrom);
                if (chosenSkill == null)
                    continue;
                // upgrade it!
                SkillUpgrade(a, chosenSkill.Value);
            }
        }

        List<Skills.IDs> RollSkillsToUpgrade(Actor actor, int maxTries)
        {
            int count = (actor.Model.Abilities.IsUndead ? Rules.UNDEAD_UPGRADE_SKILLS_TO_CHOOSE_FROM : Rules.UPGRADE_SKILLS_TO_CHOOSE_FROM); //2 skills for undead, 5 for humans
            List<Skills.IDs> list = new List<Skills.IDs>(count);

            for (int i = 0; i < count; i++)
            {
                Skills.IDs? newSk;
                int attempt = 0;
                do
                {
                    ++attempt;
                    newSk = RollRandomSkillToUpgrade(actor, maxTries);
                    if (newSk == null)
                        return list;
                } while (list.Contains(newSk.Value) && attempt < maxTries);

                list.Add(newSk.Value);
            }

            return list;
        }

        Skills.IDs? NPCPickSkillToUpgrade(Actor npc, List<Skills.IDs> chooseFrom)
        {
            if (chooseFrom == null || chooseFrom.Count == 0)
                return null;

            // Compute skill utilities and get best utility.
            int N = chooseFrom.Count;
            int[] utilities = new int[N];
            int bestUtility = -1;
            for (int i = 0; i < N; i++)
            {
                utilities[i] = NPCSkillUtility(npc, chooseFrom[i]);
                if (utilities[i] > bestUtility)
                    bestUtility = utilities[i];
            }

            // Randomly choose on of the best.
            List<Skills.IDs> bestSkills = new List<Skills.IDs>(N);
            for (int i = 0; i < N; i++)
                if (utilities[i] == bestUtility)
                    bestSkills.Add(chooseFrom[i]);
            return bestSkills[m_Rules.Roll(0, bestSkills.Count)];
        }

        static int NPCSkillUtility(Actor actor, Skills.IDs skID) //@@MP - made static (Release 5-7)
        {
            const int USELESS_UTIL = 0;
            const int LOW_UTIL = 1;
            const int AVG_UTIL = 2;
            const int HI_UTIL = 3;

            if (actor.Model.Abilities.IsUndead)
            {
                // undeads.
                switch (skID)
                {
                    // useful one.
                    case Skills.IDs.Z_GRAB:
                    case Skills.IDs.Z_INFECTOR:
                    case Skills.IDs.Z_LIGHT_EATER:
                        return HI_UTIL;

                    // ok ones.
                    case Skills.IDs.Z_AGILE:
                    case Skills.IDs.Z_STRONG:
                    case Skills.IDs.Z_TOUGH:
                    case Skills.IDs.Z_TRACKER:
                        return AVG_UTIL;

                    // meh ones.
                    case Skills.IDs.Z_EATER:
                    case Skills.IDs.Z_LIGHT_FEET:
                        return LOW_UTIL;

                    default:
                        return USELESS_UTIL;
                }
            }
            else
            {
                switch (skID)
                {
                    case Skills.IDs.AGILE:
                        return AVG_UTIL;

                    case Skills.IDs.AWAKE:
                        // useful only if has to sleep.                    
                        return actor.Model.Abilities.HasToSleep ? HI_UTIL : USELESS_UTIL;

                    case Skills.IDs.BOWS_EXPLOSIVES:
                        {
                            // useful only if has bow. slightly useful for explosives, but low priority
                            if (actor.Inventory != null)
                            {
                                foreach (Item it in actor.Inventory.Items)
                                    if (it is ItemRangedWeapon)
                                    {
                                        if ((it.Model as ItemRangedWeaponModel).IsBow)
                                            return HI_UTIL;
                                    }
                                    else if (it is ItemExplosive) //@@MP (Release 6-6)
                                        return LOW_UTIL;
                            }
                            return USELESS_UTIL;
                        }

                    case Skills.IDs.CARPENTRY:
                        return LOW_UTIL;

                    case Skills.IDs.CHARISMATIC:
                        // useful only if leader.
                        return actor.CountFollowers > 0 ? LOW_UTIL : USELESS_UTIL;

                    case Skills.IDs.FIREARMS:
                        {
                            // useful only if has firearm weapon.
                            if (actor.Inventory != null)
                            {
                                foreach (Item it in actor.Inventory.Items)
                                    if (it is ItemRangedWeapon)
                                    {
                                        if ((it.Model as ItemRangedWeaponModel).IsFireArm)
                                            return HI_UTIL;
                                    }
                            }
                            return USELESS_UTIL;
                        }

                    case Skills.IDs.HARDY:
                        // useful only if has to sleep.                    
                        return actor.Model.Abilities.HasToSleep ? HI_UTIL : USELESS_UTIL;

                    case Skills.IDs.HAULER:
                        return HI_UTIL;

                    case Skills.IDs.HIGH_STAMINA:
                        return HI_UTIL; // alpha10; was previously rated as avg;

                    case Skills.IDs.LEADERSHIP:
                        // useful only if not follower.
                        return actor.HasLeader ? USELESS_UTIL : LOW_UTIL;

                    case Skills.IDs.LIGHT_EATER:
                        // useful only if has to eat.                    
                        return actor.Model.Abilities.HasToEat ? HI_UTIL : USELESS_UTIL;

                    case Skills.IDs.LIGHT_FEET:
                        return AVG_UTIL;

                    case Skills.IDs.LIGHT_SLEEPER:
                        // useful only if has to sleep.                    
                        return actor.Model.Abilities.HasToSleep ? AVG_UTIL : USELESS_UTIL;

                    case Skills.IDs.MARTIAL_ARTS:
                        {
                            // useless if any weapon in inventory.
                            if (actor.Inventory != null)
                            {
                                foreach (Item it in actor.Inventory.Items)
                                {
                                    if (it is ItemWeapon)
                                        return LOW_UTIL;
                                }
                            }
                            return AVG_UTIL;
                        }

                    case Skills.IDs.MEDIC:
                        return LOW_UTIL;

                    case Skills.IDs.NECROLOGY:
                        return LOW_UTIL; // alpha10 ; was previously rated as useless

                    case Skills.IDs.STRONG:
                        return AVG_UTIL;

                    case Skills.IDs.STRONG_PSYCHE: //@@MP - another location where disabling sanity has an implication (Release 1)
                        if (Options.IsSanityEnabled) //@MP - fixed crappy implementation (Release 5-2)
                            return actor.Model.Abilities.HasSanity ? HI_UTIL : USELESS_UTIL; // useful only if has sanity.
                        else
                            return USELESS_UTIL; //sanity is disabled so this skill is useless, unfortunately it doesn't completely remove the chance to take it

                    case Skills.IDs.TOUGH:
                        return HI_UTIL;

                    case Skills.IDs.UNSUSPICIOUS:
                        // useful only if murderer and not law enforcer.
                        return actor.MurdersCounter > 0 && !actor.Model.Abilities.IsLawEnforcer ? LOW_UTIL : USELESS_UTIL;

                    default:
                        return USELESS_UTIL;
                }
            }
        }

        Skills.IDs? RollRandomSkillToUpgrade(Actor actor, int maxTries)
        {
            int attempt = 0;
            int skID;
            bool isUndead = actor.Model.Abilities.IsUndead;

            if (Options.IsSanityEnabled) //@MP - fixed crappy implementation (Release 5-2)
            {
                do
                {
                    ++attempt;
                    skID = isUndead ? (int)Skills.RollUndead(Rules.DiceRoller) : (int)Skills.RollLiving(Rules.DiceRoller);
                }
                while (actor.Sheet.SkillTable.GetSkillLevel(skID) >= Skills.MaxSkillLevel(skID) && attempt < maxTries);
            }
            else //@@MP - Sanity is disabled, don't offer the 'Strong Psyche' skill (Release 1)
            {
                do
                {
                    ++attempt;
                    skID = isUndead ? (int)Skills.RollUndead(Rules.DiceRoller) : (int)Skills.RollLiving(Rules.DiceRoller);
                    if (Skills.Name(skID) == "Strong Psyche") //@@MP - this is the one we're trying to avoid, so skip it
                    {
                        skID = 0; //@@MP - if you don't negate it it can still slip through as the winner
                        continue;
                    }
                }
                while ((actor.Sheet.SkillTable.GetSkillLevel(skID) >= Skills.MaxSkillLevel(skID)) && (attempt < maxTries));
            }

            if (attempt >= maxTries) //@@MP - couldn't find any skills left to upgrade
                return null;
            else
                return (Skills.IDs)skID;
        }

        void DoLoseRandomSkill(Actor actor) //@@MP - a typo, should be Lose
        {
            int[] skills = actor.Sheet.SkillTable.SkillsList;
            if (skills == null) return;

            // pick a skill.
            int iSkill = m_Rules.Roll(0, skills.Length);
            Skills.IDs lostSkill = (Skills.IDs)skills[iSkill];

            // regress.
            actor.Sheet.SkillTable.DecOrRemoveSkill((int)lostSkill);

            // message.
            if (IsVisibleToPlayer(actor))
                AddMessage(MakeMessage(actor, String.Format("regressed in {0}!", Skills.Name(lostSkill))));
        }

        public Skill SkillUpgrade(Actor actor, Skills.IDs id)
        {
            actor.Sheet.SkillTable.AddOrIncreaseSkill((int)id);
            Skill sk = actor.Sheet.SkillTable.GetSkill((int)id);
            OnSkillUpgrade(actor, id);

            return sk;
        }

        public void OnSkillUpgrade(Actor actor, Skills.IDs id)
        {
            switch (id)
            {
                case Skills.IDs.HAULER:
                    if (actor.Inventory != null)
                        actor.Inventory.MaxCapacity = m_Rules.ActorMaxInv(actor);
                    break;

                case Skills.IDs.TOUGH: //@@MP (Release 5-7)
                    actor.HitPoints = actor.HitPoints + 6;
                    break;

                default:
                    // no special upkeep to do.
                    break;
            }
        }

        void CheckWeatherChange()
        {
            if (m_Rules.RollChance(WEATHER_CHANGE_CHANCE))
            {
                // roll & announce new weather.
                string desc;
                Weather newWeather;
                switch (m_Session.World.Weather)
                {
                    case Weather.CLEAR:
                        newWeather = Weather.CLOUDY;
                        desc = "Clouds are hiding the sky.";
                        break;
                    case Weather.CLOUDY:
                        if (m_Rules.RollChance(66))
                        {
                            newWeather = Weather.CLEAR;
                            desc = "The sky is clear again.";
                        }
                        else
                        {
                            newWeather = Weather.RAIN;
                            desc = "Rain is starting to fall.";
                        }
                        break;
                    case Weather.RAIN:
                        if (m_Rules.RollChance(66))  //@@MP - was 50 (Release 8-1)
                        {
                            newWeather = Weather.CLOUDY;
                            desc = "The rain has stopped.";
                        }
                        else
                        {
                            newWeather = Weather.HEAVY_RAIN;
                            desc = "The weather is getting worse!";
                        }
                        break;
                    case Weather.HEAVY_RAIN:
                        if (m_Rules.RollChance(33)) //@@MP - gave slight chance for rain to stop (Release 6-1), fixed (Release 8-1)
                        {
                            newWeather = Weather.RAIN;
                            desc = "The rain is less heavy.";
                        }
                        else
                        {
                            newWeather = Weather.CLOUDY;
                            desc = "The rain has stopped.";
                        }
                        break;
                    default:
                        throw new InvalidOperationException("unhandled weather type");
                }

                // change.
                m_Session.World.Weather = newWeather;
                CheckAmbientSFX(m_Player.Location.Map); //@@MP (Release 5-3)

                // message.
                if (m_Rules.CanActorSeeSky(m_Player)) //@@MP - only mention if the player can see the sky, in line with alpha 10 (Release 6-1)
                    AddMessage(new Message(desc, m_Session.WorldTime.TurnCounter, Color.White));

                // scoring.
                m_Session.Scoring.AddEvent(m_Session.WorldTime.TurnCounter, String.Format("The weather changed to {0}.", DescribeWeather(m_Session.World.Weather)));
            }
            else
            {
                if (m_Rules.CanActorSeeSky(m_Player)) //@@MP - only mention if the player can see the sky, in line with alpha 10 (Release 6-1)
                    AddMessage(new Message("The weather stays the same.", m_Session.WorldTime.TurnCounter, Color.White));
            }
        }

        /// <summary>
        /// Plays an ambient track as required
        /// </summary>
        void CheckAmbientSFX(Map map) //@@MP (Release 5-3), changed to support new ambients (Release 6-6)
        {
            if (m_Player.IsSleeping) //@@MP (Release 6-6)
            {
                return; //they'll already be stopped
            }
            else if (m_Session.CurrentMap.Name.Contains("basement") || map == map.District.SubwayMap || map == map.District.SewersMap ||
                map == m_Session.UniqueMaps.Hospital_Offices.TheMap || map == m_Session.UniqueMaps.Hospital_Patients.TheMap ||
                map == m_Session.UniqueMaps.Hospital_Power.TheMap || map == m_Session.UniqueMaps.Hospital_Storage.TheMap ||
                map == m_Session.UniqueMaps.PoliceStation_OfficesLevel.TheMap || map == m_Session.UniqueMaps.PoliceStation_JailsLevel.TheMap ||
                map == m_Session.UniqueMaps.CHARUndergroundFacility.TheMap || map == m_Session.UniqueMaps.ArmyBase.TheMap)
            {
                //stop any ambients sounds that we couldn't hear in these locations
                StopAllAmbientsExcept("all");
                return;
            }
            else // we're somewhere that we could hear ambient noise
            {
                Tile tile = map.GetTileAt(Player.Location.Position);
                if (tile == null)
                    return;

                if (m_Session.World.Weather == Weather.RAIN)
                {
                    if (tile.IsInside)
                    {
                        //start playing before we stop the other, to make the transition more seamless (no audio gap)
                        if (!m_AmbientSFXManager.IsPlaying(GameAmbients.RAIN_INSIDE))
                            m_AmbientSFXManager.PlayLooping(GameAmbients.RAIN_INSIDE, AudioPriority.PRIORITY_BGM);

                        //stop any other ambients
                        StopAllAmbientsExcept(GameAmbients.RAIN_INSIDE);
                    }
                    else
                    {
                        if (!m_AmbientSFXManager.IsPlaying(GameAmbients.RAIN_OUTSIDE))
                            m_AmbientSFXManager.PlayLooping(GameAmbients.RAIN_OUTSIDE, AudioPriority.PRIORITY_BGM);

                        StopAllAmbientsExcept(GameAmbients.RAIN_OUTSIDE);
                    }
                }
                else if (m_Session.World.Weather == Weather.HEAVY_RAIN)
                {
                    if (tile.IsInside)
                    {
                        if (!m_AmbientSFXManager.IsPlaying(GameAmbients.THUNDERING_RAIN_INSIDE))
                            m_AmbientSFXManager.PlayLooping(GameAmbients.THUNDERING_RAIN_INSIDE, AudioPriority.PRIORITY_BGM);

                        StopAllAmbientsExcept(GameAmbients.THUNDERING_RAIN_INSIDE);
                    }
                    else
                    {
                        if (!m_AmbientSFXManager.IsPlaying(GameAmbients.THUNDERING_RAIN_OUTSIDE))
                            m_AmbientSFXManager.PlayLooping(GameAmbients.THUNDERING_RAIN_OUTSIDE, AudioPriority.PRIORITY_BGM);

                        StopAllAmbientsExcept(GameAmbients.THUNDERING_RAIN_OUTSIDE);
                    }
                }
                else if (m_Session.WorldTime.IsNight)
                {
                    if (!m_AmbientSFXManager.IsPlaying(GameAmbients.NIGHT_ANIMALS))
                        m_AmbientSFXManager.PlayLooping(GameAmbients.NIGHT_ANIMALS, AudioPriority.PRIORITY_BGM);

                    StopAllAmbientsExcept(GameAmbients.NIGHT_ANIMALS);
                }
                else //none of the ambients apply for the current weather and time of day
                    StopAllAmbientsExcept("all");
            }
        }

        /// <summary>
        /// Stops all other ambient sound files except the one passed as the parameter
        /// </summary>
        /// <param name="musicname">supply blank to stop all</param>
        private void StopAllAmbientsExcept(string musicname) //@@MP (Release 6-6)
        {
            if (musicname != GameAmbients.RAIN_INSIDE)
            {
                if (m_AmbientSFXManager.IsPlaying(GameAmbients.RAIN_INSIDE))
                    m_AmbientSFXManager.Stop(GameAmbients.RAIN_INSIDE);
            }

            if (musicname != GameAmbients.RAIN_OUTSIDE)
            {
                if (m_AmbientSFXManager.IsPlaying(GameAmbients.RAIN_OUTSIDE))
                    m_AmbientSFXManager.Stop(GameAmbients.RAIN_OUTSIDE);
            }

            if (musicname != GameAmbients.THUNDERING_RAIN_INSIDE)
            {
                if (m_AmbientSFXManager.IsPlaying(GameAmbients.THUNDERING_RAIN_INSIDE))
                    m_AmbientSFXManager.Stop(GameAmbients.THUNDERING_RAIN_INSIDE);
            }

            if (musicname != GameAmbients.THUNDERING_RAIN_OUTSIDE)
            {
                if (m_AmbientSFXManager.IsPlaying(GameAmbients.THUNDERING_RAIN_OUTSIDE))
                    m_AmbientSFXManager.Stop(GameAmbients.THUNDERING_RAIN_OUTSIDE);
            }

            if (musicname != GameAmbients.NIGHT_ANIMALS)
            {
                if (m_AmbientSFXManager.IsPlaying(GameAmbients.NIGHT_ANIMALS))
                    m_AmbientSFXManager.Stop(GameAmbients.NIGHT_ANIMALS);
            }
        }

        void CheckLandedHelicopterSFX(Map map) //@@MP (Release 6-4)
        {
            //if heli is present play the ambient track
            //the heli is present on rescue day, but only during daylight hours
            if ((m_Session.WorldTime.Day == m_Session.ArmyHelicopterRescue_Day) && (map == m_Session.ArmyHelicopterRescue_Map) && (!m_Session.WorldTime.IsNight))
            {
                //find roughly the middle of the helicopter (4x2 tiles) to use as the audio source point
                Point heliPoint = new Point(m_Session.ArmyHelicopterRescue_Coordinates.X + 1, m_Session.ArmyHelicopterRescue_Coordinates.Y);

                //play the appropriate ambient depending on the player distance from the heli
                int dist = DistanceToPlayer(map, heliPoint);
                if (dist <= Rules.QUIET_NOISE_RADIUS)
                    m_AmbientSFXManager.PlayIfNotAlreadyPlaying(GameAmbients.STATIONARY_HELICOPTER_VISIBLE, AudioPriority.PRIORITY_EVENT, true);
                else if ((dist > Rules.QUIET_NOISE_RADIUS) && (dist <= Rules.MODERATE_NOISE_RADIUS))
                    m_AmbientSFXManager.PlayIfNotAlreadyPlaying(GameAmbients.STATIONARY_HELICOPTER_NEAR, AudioPriority.PRIORITY_EVENT, true);
                else if ((dist > Rules.MODERATE_NOISE_RADIUS) && (dist <= Rules.LOUD_NOISE_RADIUS))
                    m_AmbientSFXManager.PlayIfNotAlreadyPlaying(GameAmbients.STATIONARY_HELICOPTER_FAR, AudioPriority.PRIORITY_EVENT, true);
                else if (dist <= Rules.BOOMING_NOISE_RADIUS)
                    m_AmbientSFXManager.PlayIfNotAlreadyPlaying(GameAmbients.STATIONARY_HELICOPTER_FARTHEST, AudioPriority.PRIORITY_EVENT, true);

                //stop any other helicopter sounds that aren't applicable for the player's current position
                if (m_AmbientSFXManager.IsPlaying(GameAmbients.STATIONARY_HELICOPTER_VISIBLE) && (dist > Rules.QUIET_NOISE_RADIUS))
                    m_AmbientSFXManager.Stop(GameAmbients.STATIONARY_HELICOPTER_VISIBLE);

                if (m_AmbientSFXManager.IsPlaying(GameAmbients.STATIONARY_HELICOPTER_NEAR) && (dist > Rules.MODERATE_NOISE_RADIUS))
                    m_AmbientSFXManager.Stop(GameAmbients.STATIONARY_HELICOPTER_NEAR);

                if (m_AmbientSFXManager.IsPlaying(GameAmbients.STATIONARY_HELICOPTER_FAR) && (dist > Rules.LOUD_NOISE_RADIUS))
                    m_AmbientSFXManager.Stop(GameAmbients.STATIONARY_HELICOPTER_FAR);

                if (m_AmbientSFXManager.IsPlaying(GameAmbients.STATIONARY_HELICOPTER_FARTHEST) && (dist > Rules.BOOMING_NOISE_RADIUS))
                    m_AmbientSFXManager.Stop(GameAmbients.STATIONARY_HELICOPTER_FARTHEST);
            }
            else //stop any that might be playing whilst the heli isn't there or we aren't in that district/map
            {
                if (m_AmbientSFXManager.IsPlaying(GameAmbients.STATIONARY_HELICOPTER_FARTHEST))
                    m_AmbientSFXManager.Stop(GameAmbients.STATIONARY_HELICOPTER_FARTHEST);
                else if (m_AmbientSFXManager.IsPlaying(GameAmbients.STATIONARY_HELICOPTER_FAR))
                    m_AmbientSFXManager.Stop(GameAmbients.STATIONARY_HELICOPTER_FAR);
                else if (m_AmbientSFXManager.IsPlaying(GameAmbients.STATIONARY_HELICOPTER_NEAR))
                    m_AmbientSFXManager.Stop(GameAmbients.STATIONARY_HELICOPTER_NEAR);
                else if (m_AmbientSFXManager.IsPlaying(GameAmbients.STATIONARY_HELICOPTER_VISIBLE))
                    m_AmbientSFXManager.Stop(GameAmbients.STATIONARY_HELICOPTER_VISIBLE);
            }
        }
#endregion

#region ACTOR ACTION HANDLERS
        void HandlePlayerActor(Actor player)
        {
            // Update survival scoring.
            m_Session.Scoring.TurnsSurvived = m_Session.WorldTime.TurnCounter;

            // Check if long wait.
#region
            if (m_IsPlayerLongWait)
            {
                if (CanPlayerKeepLongWaiting(player))
                {
                    // continue waiting.
                    DoWait(player);
                    return;
                }
                else
                {
                    // stop long wait.
                    m_IsPlayerLongWait = false;
                    m_IsPlayerLongWaitForcedStop = false;

                    // wait ended or interrupted.
                    if (m_Session.WorldTime.TurnCounter >= m_PlayerLongWaitEnd.TurnCounter)
                        AddMessage(new Message("Wait ended.", m_Session.WorldTime.TurnCounter, Color.Yellow));
                    else
                        AddMessage(new Message("Wait interrupted!", m_Session.WorldTime.TurnCounter, Color.Red));
                }
            }
#endregion
            
            // special rules for eye-equipped ItemLights  //@@MP (Release 7-1)
#region
            ItemLight eyesLight = m_Player.GetEquippedItem(DollPart.EYES) as ItemLight;
            if (eyesLight != null)
            {
                if (m_Rules.IsItemBinoculars(eyesLight))
                {
                    bool canSeeSky = m_Rules.CanActorSeeSky(m_Player);
                    bool isNight = m_Session.WorldTime.IsNight;
                    bool outsideAtNight = (canSeeSky && isNight);
                    if (m_Session.CurrentMap.Lighting == Lighting.DARKNESS || outsideAtNight)
                    {
                        DoUnequipItem(m_Player, eyesLight); //forcibly unequip binoculars in darkness
                        AddMessage(new Message(String.Format("It's too dark to use binoculars."), 0, Color.Yellow));
                    }
                }
            }
#endregion

            // Upkeep.
            UpdatePlayerFOV(player);    // make sure LOS is up to date.
            m_Player = player;      // remember player.
            ComputeViewRect(player.Location.Position);

            /////////////////////////////////////////////////
            // Loop until the player has made a valid choice
            /////////////////////////////////////////////////
            bool loop = true;
            do
            {
                ///////////////////
                // 1. Redraw
                // 2. Get input.
                // 3. Handle input
                ///////////////////

                // 1. Redraw
                m_UI.UI_SetCursor(null);

                //// alpha10.1 bot mode?
#if DEBUG
                lock (m_botLock)
                {
                    if (m_isBotMode)
                    {
                        //AddMessagePressEnter(); //can be used to turn-by-turn watch closely what the bot is doing

                        try { Thread.Sleep(BOT_DELAY); } catch { }  // AnimDelay() does not work here because it just pause the ui
                        RedrawPlayScreen();
                        if (m_botControl != null) // for some reason even with the lock this can become null here. wth?? is thread.sleep the culprit??
                        {
                            ActorAction botAction = m_botControl.GetAction(this);
                            if (botAction == null || !botAction.IsLegal())
                            {
                                AddMessage(MakeErrorMessage("Bot issued " + (botAction == null ? "NULL" : "illegal " + botAction.ToString()) + " action"));
                                botAction = new ActionWait(player, this);
                            }
                            botAction.Perform();
                            // copy-paste is bad
                            UpdatePlayerFOV(player);
                            ComputeViewRect(player.Location.Position);
                            m_Session.LastTurnPlayerActed = m_Session.WorldTime.TurnCounter;
                            RedrawPlayScreen();
                        }
                        return;
                    }
                }
#endif

                //// hint available? // the alpha 10 method
                if (m_Player != null && !m_Player.IsDead && !m_Player.Model.Abilities.IsUndead)
                {
                    // alpha10 fix properly handle hint overlay
                    int availableHint = -1;
                    if (s_Options.IsAdvisorEnabled && (availableHint = GetAdvisorFirstAvailableHint()) != -1)
                    {
                        //@@MP - skip the prompt, just force the hint on the player (Release 7-1)
                        HandleAdvisor();

                        /*
                        //advise that a hint is available
                        Point overlayPos = MapToScreen(m_Player.Location.Position.X - 3, m_Player.Location.Position.Y - 1);
                        if (m_HintAvailableOverlay == null)
                        {
                            m_HintAvailableOverlay = new OverlayPopup(
                                null,
                                Color.White, Color.White, Color.Black,
                                overlayPos);
                            AddOverlay(m_HintAvailableOverlay);
                        }
                        else
                        {
                            m_HintAvailableOverlay.ScreenPosition = overlayPos;
                            if (!HasOverlay(m_HintAvailableOverlay))
                                AddOverlay(m_HintAvailableOverlay);
                        }

                        string hintTitle;
                        string[] hintBody;
                        GetAdvisorHintText((AdvisorHint)availableHint, out hintTitle, out hintBody);
                        m_HintAvailableOverlay.Lines = new string[] {
                            string.Format("HINT AVAILABLE PRESS <{0}>", s_KeyBindings.GetFriendlyFormat(PlayerCommand.ADVISOR)),
                            hintTitle };
                        */
                    }
                    else if (m_HintAvailableOverlay != null && HasOverlay(m_HintAvailableOverlay))
                    {
                        RemoveOverlay(m_HintAvailableOverlay);
                    }
                }

                RedrawPlayScreen();

                // 2. Get input.
                //// Peek keyboard & mouse until we got an event.
                m_UI.UI_PeekKey();  // consume keys to avoid repeats.
                bool inputLoop = true;
                bool hasKey = false;
                KeyEventArgs inKey;
                Point prevMousePos = m_UI.UI_GetMousePosition();
                Point mousePos = new Point(-1, -1);
                MouseButtons? mouseButtons = null;
                do
                {
                    inKey = m_UI.UI_PeekKey();
                    if (inKey != null)
                    {
                        hasKey = true;
                        inputLoop = false;
                    }
                    else
                    {
                        mousePos = m_UI.UI_GetMousePosition();
                        mouseButtons = m_UI.UI_PeekMouseButtons();
                        if (mousePos != prevMousePos || mouseButtons != null)
                        {
                            inputLoop = false;
                        }
                    }
                }
                while (inputLoop);
                

                // 3. Handle input
                if (hasKey)
                {
                    //////////////
                    // Handle key
                    //////////////
#region
                    PlayerCommand command = InputTranslator.KeyToCommand(inKey);
                    if (command == PlayerCommand.QUIT_GAME)    // quit game.
                    {
                        if (HandleQuitGame())
                        {
                            // stop sim thread.
                            StopSimThread(true);  // alpha10 abort allowed when quitting
                            // quit asap.
                            RedrawPlayScreen();
                            m_IsGameRunning = false;
                            return;
                        }
                    }
                    else
                    {
                        string blockedReason;
                        switch (command)
                        {
#region options, menu etc...
                            case PlayerCommand.ESC:  //@@MP (Release 7-4)
                                HandleHelpMode();
                                break;

                            case PlayerCommand.ABANDON_GAME:
                                if (HandleAbandonGame())
                                {
                                    StopSimThread(true); // alpha10 abort allowed when quitting
                                    loop = false;
                                    KillActor(null, m_Player, "suicide");
                                }
                                break;

                            case PlayerCommand.HELP_MODE:
                                HandleHelpMode();
                                break;

                            case PlayerCommand.HINTS_SCREEN_MODE:
                                HandleHintsScreen();
                                break;

                            case PlayerCommand.ADVISOR:
                                HandleAdvisor(); //@@MP - unused parameter (Release 5-7)
                                break;

                            case PlayerCommand.OPTIONS_MODE:
                                HandleOptions(); //@@MP - unused parameter (Release 5-7)
                                ApplyOptions(); //@@MP - unused parameter (Release 5-7)
                                break;

                            case PlayerCommand.KEYBINDING_MODE:
                                HandleRedefineKeys();
                                break;

                            case PlayerCommand.MESSAGE_LOG:
                                HandleMessageLog();
                                break;

                            case PlayerCommand.LOAD_GAME: // alpha10.1 moved sim thread responsability out to DoLoadGame
                                // load.
                                DoLoadGame(GetUserSave());
                                // refresh player local variable!!
                                player = m_Player;
                                // stop looping.
                                loop = false;
                                // stop the update loop!
                                m_HasLoadedGame = true;
                                break;

                            case PlayerCommand.SAVE_GAME: // alpha10.1 moved sim thread responsability out to DoSaveGame
                                DoSaveGame(GetUserSave(), false);
                                break;

                            case PlayerCommand.SCREENSHOT:
                                HandleScreenshot();
                                break;

                            case PlayerCommand.CITY_INFO:
                                HandleCityInfo();
                                break;

                            case PlayerCommand.ICONS_LEGEND: //@@MP (Release 6-1)
                                HandleIconsLegend();
                                break;

                            case PlayerCommand.INSPECTION_MODE: //@@MP (Release 7-1)
                                HandleInspectionMode();
                                break;
#endregion

#region actual game actions.
                            case PlayerCommand.WAIT_OR_SELF:
                                if (TryPlayerControlAlteringEffects()) { loop = false; }
                                else { loop = false; DoWait(player); }
                                break;

                            case PlayerCommand.WAIT_LONG:
                                if (TryPlayerControlAlteringEffects()) { loop = false; }
                                else { loop = false; StartPlayerWaitLong(player); }
                                break;

                            case PlayerCommand.MOVE_N:
                                if (BlockAction(out blockedReason, true, true, Direction.N)) { AddMessage(new Message(String.Format(blockedReason), 0, Color.Red)); }
                                else if (TryPlayerControlAlteringEffects()) { loop = false; }
                                else { loop = !DoPlayerBump(player, Direction.N); }
                                break;

                            case PlayerCommand.MOVE_NE:
                                if (BlockAction(out blockedReason, true, true, Direction.NE)) { AddMessage(new Message(String.Format(blockedReason), 0, Color.Red)); }
                                else if (TryPlayerControlAlteringEffects()) { loop = false; }
                                else { loop = !DoPlayerBump(player, Direction.NE); }
                                break;

                            case PlayerCommand.MOVE_E:
                                if (BlockAction(out blockedReason, true, true, Direction.E)) { AddMessage(new Message(String.Format(blockedReason), 0, Color.Red)); }
                                else if (TryPlayerControlAlteringEffects()) { loop = false; }
                                else { loop = !DoPlayerBump(player, Direction.E); }
                                break;

                            case PlayerCommand.MOVE_SE:
                                if (BlockAction(out blockedReason, true, true, Direction.SE)) { AddMessage(new Message(String.Format(blockedReason), 0, Color.Red)); }
                                else if (TryPlayerControlAlteringEffects()) { loop = false; }
                                else { loop = !DoPlayerBump(player, Direction.SE); }
                                break;

                            case PlayerCommand.MOVE_S:
                                if (BlockAction(out blockedReason, true, true, Direction.S)) { AddMessage(new Message(String.Format(blockedReason), 0, Color.Red)); }
                                else if (TryPlayerControlAlteringEffects()) { loop = false; }
                                else { loop = !DoPlayerBump(player, Direction.S); }
                                break;

                            case PlayerCommand.MOVE_SW:
                                if (BlockAction(out blockedReason, true, true, Direction.SW)) { AddMessage(new Message(String.Format(blockedReason), 0, Color.Red)); }
                                else if (TryPlayerControlAlteringEffects()) { loop = false; }
                                else { loop = !DoPlayerBump(player, Direction.SW); }
                                break;

                            case PlayerCommand.MOVE_W:
                                if (BlockAction(out blockedReason, true, true, Direction.W)) { AddMessage(new Message(String.Format(blockedReason), 0, Color.Red)); }
                                else if (TryPlayerControlAlteringEffects()) { loop = false; }
                                else { loop = !DoPlayerBump(player, Direction.W); }
                                break;
                            case PlayerCommand.MOVE_NW:
                                if (BlockAction(out blockedReason, true, true, Direction.NW)) { AddMessage(new Message(String.Format(blockedReason), 0, Color.Red)); }
                                else if (TryPlayerControlAlteringEffects()) { loop = false; }
                                else { loop = !DoPlayerBump(player, Direction.NW); }
                                break;

                            case PlayerCommand.USE_EXIT:
                                if (BlockAction(out blockedReason, true, true)) { AddMessage(new Message(String.Format(blockedReason), 0, Color.Red)); }
                                else if (TryPlayerControlAlteringEffects()) { loop = false; }
                                else { loop = !DoUseExit(player, player.Location.Position); }
                                break;

                            case PlayerCommand.ITEM_SLOT_0:
                                if (TryPlayerControlAlteringEffects()) { loop = false; }
                                else { loop = !DoPlayerItemSlot(player, 0, inKey); }
                                break;

                            case PlayerCommand.ITEM_SLOT_1:
                                if (TryPlayerControlAlteringEffects()) { loop = false; }
                                else { loop = !DoPlayerItemSlot(player, 1, inKey); }
                                break;

                            case PlayerCommand.ITEM_SLOT_2:
                                if (TryPlayerControlAlteringEffects()) { loop = false; }
                                else { loop = !DoPlayerItemSlot(player, 2, inKey); }
                                break;

                            case PlayerCommand.ITEM_SLOT_3:
                                if (TryPlayerControlAlteringEffects()) { loop = false; }
                                else { loop = !DoPlayerItemSlot(player, 3, inKey); }
                                break;

                            case PlayerCommand.ITEM_SLOT_4:
                                if (TryPlayerControlAlteringEffects()) { loop = false; }
                                else { loop = !DoPlayerItemSlot(player, 4, inKey); }
                                break;

                            case PlayerCommand.ITEM_SLOT_5:
                                if (TryPlayerControlAlteringEffects()) { loop = false; }
                                else { loop = !DoPlayerItemSlot(player, 5, inKey); }
                                break;

                            case PlayerCommand.ITEM_SLOT_6:
                                if (TryPlayerControlAlteringEffects()) { loop = false; }
                                else { loop = !DoPlayerItemSlot(player, 6, inKey); }
                                break;

                            case PlayerCommand.ITEM_SLOT_7:
                                if (TryPlayerControlAlteringEffects()) { loop = false; }
                                else { loop = !DoPlayerItemSlot(player, 7, inKey); }
                                break;

                            case PlayerCommand.ITEM_SLOT_8:
                                if (TryPlayerControlAlteringEffects()) { loop = false; }
                                else { loop = !DoPlayerItemSlot(player, 8, inKey); }
                                break;

                            case PlayerCommand.ITEM_SLOT_9:
                                if (TryPlayerControlAlteringEffects()) { loop = false; }
                                else { loop = !DoPlayerItemSlot(player, 9, inKey); }
                                break;

                            case PlayerCommand.RUN_TOGGLE:
                                if (TryPlayerControlAlteringEffects()) { loop = false; }
                                else { HandlePlayerRunToggle(player); }
                                break;

                            case PlayerCommand.CLOSE_DOOR:
                                if (BlockAction(out blockedReason, true, false)) { AddMessage(new Message(String.Format(blockedReason), 0, Color.Red)); }
                                else if (TryPlayerControlAlteringEffects()) { loop = false; }
                                else { loop = !HandlePlayerCloseDoor(player); }
                                break;

                            case PlayerCommand.BREAK_MODE:
                                if (BlockAction(out blockedReason, true, false)) { AddMessage(new Message(String.Format(blockedReason), 0, Color.Red)); }
                                else if (TryPlayerControlAlteringEffects()) { loop = false; }
                                else { loop = !HandlePlayerBreak(player); }
                                break;

                            case PlayerCommand.BUILD_MODE:
                                if (BlockAction(out blockedReason, true, false)) { AddMessage(new Message(String.Format(blockedReason), 0, Color.Red)); }
                                else if (TryPlayerControlAlteringEffects()) { loop = false; }
                                else { loop = !HandlePlayerBuildMode(player); }
                                break;

                            case PlayerCommand.ORDER_MODE:
                                if (TryPlayerControlAlteringEffects()) { loop = false; }
                                else { loop = !HandlePlayerOrderMode(player); }
                                break;

                            case PlayerCommand.PULL_MODE: // alpha10
                                if (BlockAction(out blockedReason, true, true)) { AddMessage(new Message(String.Format(blockedReason), 0, Color.Red)); }
                                else if (TryPlayerControlAlteringEffects()) { loop = false; }
                                else { loop = !HandlePlayerPull(player); }
                                break;

                            case PlayerCommand.PUSH_MODE:
                                if (BlockAction(out blockedReason, true, true)) { AddMessage(new Message(String.Format(blockedReason), 0, Color.Red)); }
                                else if (TryPlayerControlAlteringEffects()) { loop = false; }
                                else { loop = !HandlePlayerPush(player); }
                                break;

                            case PlayerCommand.FIRE_MODE:
                                if (BlockAction(out blockedReason, true, false)) { AddMessage(new Message(String.Format(blockedReason), 0, Color.Red)); }
                                else if (TryPlayerControlAlteringEffects()) { loop = false; }
                                else { loop = !HandlePlayerFireMode(player); }
                                break;

                            case PlayerCommand.SHOUT:
                                if (TryPlayerControlAlteringEffects()) { loop = false; }
                                else { loop = !HandlePlayerShout(player, null); }
                                break;

                            case PlayerCommand.SLEEP:
                                if (TryPlayerControlAlteringEffects()) { loop = false; }
                                else { loop = !HandlePlayerSleep(player); }
                                break;

                            case PlayerCommand.SWITCH_PLACE:
                                if (BlockAction(out blockedReason, true, true)) { AddMessage(new Message(String.Format(blockedReason), 0, Color.Red)); }
                                else if (TryPlayerControlAlteringEffects()) { loop = false; }
                                else { loop = !HandlePlayerSwitchPlace(player); }
                                break;

                            case PlayerCommand.USE_SPRAY:
                                if (BlockAction(out blockedReason, true, false)) { AddMessage(new Message(String.Format(blockedReason), 0, Color.Red)); }
                                else if (TryPlayerControlAlteringEffects()) { loop = false; }
                                else { loop = !HandlePlayerUseSpray(player); }
                                break;

                            case PlayerCommand.LEAD_MODE:
                                if (BlockAction(out blockedReason, true, false)) { AddMessage(new Message(String.Format(blockedReason), 0, Color.Red)); }
                                else if (TryPlayerControlAlteringEffects()) { loop = false; }
                                else { loop = !HandlePlayerTakeLead(player); }
                                break;

                            case PlayerCommand.GIVE_ITEM:
                                if (BlockAction(out blockedReason, true, false)) { AddMessage(new Message(String.Format(blockedReason), 0, Color.Red)); }
                                else if (TryPlayerControlAlteringEffects()) { loop = false; }
                                else { loop = !HandlePlayerGiveItem(player, mousePos); }
                                break;

                            case PlayerCommand.NEGOTIATE_TRADE:
                                if (BlockAction(out blockedReason, true, false)) { AddMessage(new Message(String.Format(blockedReason), 0, Color.Red)); }
                                else if (TryPlayerControlAlteringEffects()) { loop = false; }
                                else { loop = !HandlePlayerNegotiateTrade(player); }
                                break;

                            case PlayerCommand.MARK_ENEMIES_MODE:
                                HandlePlayerMarkEnemies(player);
                                break;

                            case PlayerCommand.EAT_CORPSE:
                                if (BlockAction(out blockedReason, true, false)) { AddMessage(new Message(String.Format(blockedReason), 0, Color.Red)); }
                                else if (TryPlayerControlAlteringEffects()) { loop = false; }
                                else { loop = !HandlePlayerEatCorpse(player, mousePos); }
                                break;

                            case PlayerCommand.REVIVE_CORPSE:
                                if (BlockAction(out blockedReason, true, false)) { AddMessage(new Message(String.Format(blockedReason), 0, Color.Red)); }
                                else if (TryPlayerControlAlteringEffects()) { loop = false; }
                                else { loop = !HandlePlayerReviveCorpse(player, mousePos); }
                                break;

                            case PlayerCommand.BURY_CORPSE:
                                if (BlockAction(out blockedReason, true, false)) { AddMessage(new Message(String.Format(blockedReason), 0, Color.Red)); }
                                else if (TryPlayerControlAlteringEffects()) { loop = false; }
                                else { loop = !HandlePlayerBuryCorpse(player, mousePos); }
                                break;

                            case PlayerCommand.DESTROY_ITEM:
                                HandlePlayerDestroyItem(player, mousePos);
                                break;

                            case PlayerCommand.COOK_FOOD:
                                if (BlockAction(out blockedReason, true, false)) { AddMessage(new Message(String.Format(blockedReason), 0, Color.Red)); }
                                else if (TryPlayerControlAlteringEffects()) { loop = false; }
                                else { loop = !HandlePlayerCookFood(player, mousePos); }
                                break;

                            case PlayerCommand.MAKE_COOKING_FIRE:
                                if (BlockAction(out blockedReason, true, false)) { AddMessage(new Message(String.Format(blockedReason), 0, Color.Red)); }
                                else if (TryPlayerControlAlteringEffects()) { loop = false; }
                                else { loop = !HandlePlayerMakeFireForCooking(player); }
                                break;
                            case PlayerCommand.UNLOAD_AMMO:
                                if (BlockAction(out blockedReason, true, false)) { AddMessage(new Message(String.Format(blockedReason), 0, Color.Red)); }
                                else if (TryPlayerControlAlteringEffects()) { loop = false; }
                                else { loop = !HandlePlayerUnloadAmmo(player); }
                                break;
                            case PlayerCommand.SWAP_INVENTORY:
                                if (BlockAction(out blockedReason, true, false)) { AddMessage(new Message(String.Format(blockedReason), 0, Color.Red)); }
                                else if (TryPlayerControlAlteringEffects()) { loop = false; }
                                else { loop = !HandlePlayerSwapItemInventory(player, mousePos); }
                                break;
                            #endregion

                            case PlayerCommand.NONE:
                                break;

                            default:
                                throw new ArgumentException("command unhandled");
                        }
                    }
#endregion
                } // has key
                else
                {
                    ////////////////
                    // Handle mouse
                    ////////////////
#region
                    // Look?
                    bool isLooking = HandleMouseLook(mousePos);
                    if (isLooking)
                        continue;

                    // Inventory?
                    bool hasDoneInventoryAction;
                    bool isInventory = HandleMouseInventory(mousePos, mouseButtons, out hasDoneInventoryAction);
                    if (isInventory)
                    {
                        if (hasDoneInventoryAction)
                        {
                            loop = false;
                        }
                        else
                            continue;
                    }

                    // Corpses?
                    bool hasDoneCorpsesAction;
                    bool isCorpses = HandleMouseOverCorpses(mousePos, mouseButtons, out hasDoneCorpsesAction);
                    if (isCorpses)
                    {
                        if (hasDoneCorpsesAction)
                        {
                            loop = false;
                        }
                        else
                            continue;
                    }

                    // Neither look nor inventory nor corpses, cleanup.
                    ClearOverlays();
#endregion
                }
            }
            while (loop);

            // Upkeep.
            UpdatePlayerFOV(player);    // make sure LOS is up to date.
            ComputeViewRect(player.Location.Position);
            m_Session.LastTurnPlayerActed = m_Session.WorldTime.TurnCounter;
        }

        void HandleAiActor(Actor aiActor)
        {
            // Get and perform action from AI controler.
            ActorAction desiredAction = aiActor.Controller.GetAction(this);

            // Specific effects?
            if (aiActor.IsIncapacitated) //@@MP - incapcitatedAction by a flashbang or stun gun (Release 7-2)
            {
                ActorAction incapacitatedAction = GenerateIncapacitatedAction(aiActor);
                if (incapacitatedAction != null && incapacitatedAction.IsLegal())
                    desiredAction = incapacitatedAction;
                
                SpendActorActionPoints(aiActor, Rules.BASE_ACTION_COST);
            }
            else if (m_Rules.IsActorInsane(aiActor) && m_Rules.RollChance(Rules.SANITY_INSANE_ACTION_CHANCE))
            {
                ActorAction insaneAction = GenerateInsaneAction(aiActor);
                if (insaneAction != null && insaneAction.IsLegal())
                    desiredAction = insaneAction;
            }
            else if (aiActor.IsDrunk && m_Rules.RollChance(Rules.SANITY_INSANE_ACTION_CHANCE)) //@@MP (Release 7-1)
            {
                ActorAction drunkAction = GenerateDrunkAction(aiActor);
                if (drunkAction != null && drunkAction.IsLegal())
                    desiredAction = drunkAction;
            }

            // Do action.
            if (desiredAction != null)
            {
                if (desiredAction.IsLegal())
                {
                    //@@MP - added random SFX for undead
                    if (aiActor.Model.Abilities.IsUndead || GameActors.IsDog(aiActor.Model))
                        if (m_Rules.RollChance(s_Options.AIVocalisationChance)) PlayNonHumanVocalAudio(aiActor); //@@MP - made it an option (Release 7-6)

                    desiredAction.Perform();
#if DEBUG && FALSE
                    //troubleshooting cop AI 'looping' in first two turns //@@MP (Release 6-5)
                    if (aiActor.Faction == GameFactions.ThePolice)
                    {
                        Logger.WriteLine(Logger.Stage.RUN_MAIN, aiActor.Name + " desiredAction: " + desiredAction.ToString());
                        if (desiredAction.ToString() == "djack.RogueSurvivor.Engine.Actions.ActionEquipItem")
                        {
                            Logger.WriteLine(Logger.Stage.RUN_MAIN, aiActor.Name + " left hand: " + aiActor.GetEquippedItem(DollPart.LEFT_HAND));
                            Logger.WriteLine(Logger.Stage.RUN_MAIN, aiActor.Name + " right hand: " + aiActor.GetEquippedItem(DollPart.RIGHT_HAND));
                            Logger.WriteLine(Logger.Stage.RUN_MAIN, aiActor.Name + " torso hand: " + aiActor.GetEquippedItem(DollPart.TORSO));
                        }
                    }
#endif
                }
                else
                {
                    // AI attempted illegal action.                    
                    SpendActorActionPoints(aiActor, Rules.BASE_ACTION_COST);

                    // alpha10.1 
                    // in debug build, throw exception.
#if DEBUG
                    throw new InvalidOperationException(String.Format("AI attempted illegal action {0}; actorAI: {1}; fail reason : {2}.",
                        desiredAction.GetType().ToString(), aiActor.Controller.GetType().ToString(), desiredAction.FailReason));
#else
                    // in release build just complain and do a wait action instead.
                    Logger.WriteLine(Logger.Stage.RUN_MAIN, String.Format("AI attempted illegal action {0}; actorAI: {1}; fail reason : {2}.",
                        desiredAction.GetType().ToString(), aiActor.Controller.GetType().ToString(), desiredAction.FailReason)); //@@MP (Release 6-5)
                    DoWait(aiActor);
#endif
                }
            }
            else
                throw new InvalidOperationException("AI returned null action.");
        }

#region -IN-GAME ACTIONS MODES ***
#region --Mouse use
        bool HandleMouseLook(Point mousePos)
        {
            // Ignore if out of view rect.
            Point mouseMap = MouseToMap(mousePos);
            if (!IsInViewRect(mouseMap))
                return false;

            // Nothing to do if out of map, but still handle the mouse.
            if (!m_Session.CurrentMap.IsInBounds(mouseMap))
                return true;

            // Do look.
            ClearOverlays();
            if (IsVisibleToPlayer(m_Session.CurrentMap, mouseMap))
            {
                Point tileScreenPos = MapToScreen(mouseMap);
                string[] description = DescribeStuffAt(m_Session.CurrentMap, mouseMap);
                if (description != null)
                {
                    Point popupPos = new Point(tileScreenPos.X + TILE_SIZE, tileScreenPos.Y);
                    Actor actorThere = m_Session.CurrentMap.GetActorAt(mouseMap);

                    // prevent overlays being cut off at the bottom of the screen  //@@MP (Release 7-5)
                    Inventory invThere = m_Session.CurrentMap.GetItemsAt(mouseMap);
                    bool longInvList = (invThere != null && invThere.CountItems > 5);  //theres lots of items, which will make the popup large
                    
                    if (actorThere != null || longInvList)
                    {
                        if (tileScreenPos.Y > 400)
                            popupPos.Y -= (6 * TILE_SIZE);
                    }

                    AddOverlay(new OverlayPopup(description, Color.White, Color.White, POPUP_FILLCOLOR, popupPos));
                    if (s_Options.ShowTargets)
                    {
                        if (actorThere != null)
                            DrawActorRelations(actorThere);
                    }
                }
            }

            // Handled mouse.
            return true;
        }

        bool HandleMouseInventory(Point mousePos, MouseButtons? mouseButtons, out bool hasDoneAction)
        {
            // Ignore if not on an inventory slot.
            Inventory inv;
            Point itemPos;
            int iSlot; //alpha 10
            bool isBackpack; //@@MP (Release 8-2)
            Item it = MouseToInventoryItem(mousePos, out inv, out itemPos, out iSlot, out isBackpack);
            if (inv == null)
            {
                hasDoneAction = false;
                return false;
            }

            // Do inventory stuff.
            bool isPlayerInventory = (inv == m_Player.Inventory);
            hasDoneAction = false;
            ClearOverlays();
            AddOverlay(new OverlayRect(Color.Cyan, new Rectangle(itemPos.X, itemPos.Y, 32, 32)));
            AddOverlay(new OverlayRect(Color.Cyan, new Rectangle(itemPos.X + 1, itemPos.Y + 1, 30, 30)));
            if (it != null)
            {
                string[] lines = DescribeItemLong(it, isPlayerInventory, iSlot, isBackpack);
                int longestLine = 1 + FindLongestLine(lines);
                int ovX = itemPos.X - 7 * longestLine;
                int ovY = itemPos.Y + 32;

                AddOverlay(new OverlayPopup(lines, Color.White, Color.White, POPUP_FILLCOLOR, new Point(ovX, ovY)));

                // item action?
                if (mouseButtons.HasValue)
                {
                    if (mouseButtons == MouseButtons.Left)
                        hasDoneAction = OnLMBItem(inv, it, itemPos, isBackpack);
                    else if (mouseButtons == MouseButtons.Right)
                        hasDoneAction = OnRMBItem(inv, it);
                }
            }

            // Handled mouse.
            return true;
        }

        Item MouseToInventoryItem(Point screen, out Inventory inv, out Point itemPos, out int iSlot, out bool isBackpack, bool testing = false)
        {
            inv = null;
            itemPos = Point.Empty;
            iSlot = -1; // alpha10
            isBackpack = false; //@@MP (Release 8-2)

            if (m_Player == null)
                return null;

            int mouseX = (int)(screen.X / m_UI.UI_GetCanvasScaleX());

            //INVENTORY
            Inventory playerInv = m_Player.Inventory;
            Point playerSlot = MouseToInventorySlot(INVENTORYPANEL_X, INVENTORYPANEL_Y, screen.X, screen.Y);
            int playerItemIndex = playerSlot.X + playerSlot.Y * INVENTORY_SLOTS_PER_LINE;
            if (playerItemIndex >= 0 && playerItemIndex < playerInv.MaxCapacity)
            {
                inv = playerInv;
                itemPos = InventorySlotToScreen(INVENTORYPANEL_X, INVENTORYPANEL_Y, playerSlot.X, playerSlot.Y);
                iSlot = playerItemIndex; // alpha10
                return playerInv[playerItemIndex];
            }

            //BACKPACK            //@@MP - added (Release 8-2)
            ItemBackpack backpack = m_Player.Inventory.GetFirstByType(typeof(ItemBackpack)) as ItemBackpack; //the rule is that they can only ever carry 1 backpack at a time
            if (backpack != null && !backpack.IsEquipped)
            {
                Inventory backpackInv = backpack.Inventory;
                if (backpackInv == null)
                    return null;
                Point backpackSlot = MouseToInventorySlot(INVENTORYPANEL_X, BACKPACKPANEL_Y, screen.X, screen.Y);
                int backpackItemIndex = backpackSlot.X + backpackSlot.Y * INVENTORY_SLOTS_PER_LINE;
                if (backpackItemIndex >= 0 && backpackItemIndex < backpackInv.MaxCapacity)
                {
                    inv = backpackInv;
                    itemPos = InventorySlotToScreen(INVENTORYPANEL_X, BACKPACKPANEL_Y, backpackSlot.X, backpackSlot.Y);
                    iSlot = backpackItemIndex; // alpha10
                    isBackpack = true;
                    return backpackInv[backpackItemIndex];
                }
            }

            //GROUND INVENTORY
            Inventory groundInv = m_Player.Location.Map.GetItemsAt(m_Player.Location.Position);
            if (groundInv != null)
            {
                Point groundSlot = MouseToInventorySlot(INVENTORYPANEL_X, GROUNDINVENTORYPANEL_Y, screen.X, screen.Y);
                itemPos = InventorySlotToScreen(INVENTORYPANEL_X, GROUNDINVENTORYPANEL_Y, groundSlot.X, groundSlot.Y);
                int groundItemIndex = groundSlot.X + groundSlot.Y * INVENTORY_SLOTS_PER_LINE;
                if (groundItemIndex >= 0 && groundItemIndex < groundInv.MaxCapacity)
                {
                    inv = groundInv;
                    iSlot = groundItemIndex; // alpha10
                    return groundInv[groundItemIndex];
                }
            }

            return null;
        }

        bool OnLMBItem(Inventory inv, Item it, Point itemPos, bool invIsBackpack)
        {
            if (inv == m_Player.Inventory)
            {
                // LMB in player inv = use/equip toggle
                if (it.IsEquipped)
                {
                    string reason;
                    if (m_Rules.CanActorUnequipItem(m_Player, it, out reason))
                    {
                        DoUnequipItem(m_Player, it);
                        return false;
                    }
                    else
                    {
                        AddMessage(MakeErrorMessage(String.Format("Cannot unequip {0} : {1}.", it.TheName, reason)));
                        return false;
                    }
                }
                else if (it.Model.IsEquipable)
                {
                    string reason;
                    if (it.Model == m_GameItems.FISHING_ROD && !m_Rules.CanActorEquipFishingRod(m_Player, it, out reason)) //@@MP - special case (Release 7-6)
                    {
                        AddMessage(MakeErrorMessage(String.Format("Cannot equip {0} : {1}.", it.TheName, reason)));
                        return false;
                    }
                    else if (m_Rules.IsItemBinoculars(it))
                    {
                        bool canSeeSky = m_Rules.CanActorSeeSky(m_Player);
                        bool isNight = m_Player.Location.Map.LocalTime.IsNight;
                        bool outsideAtNight = (canSeeSky && isNight);
                        if (m_Player.Location.Map.Lighting == Lighting.DARKNESS || outsideAtNight)
                        {
                            AddMessage(MakeErrorMessage("It's too dark to use binoculars"));
                            return false;
                        }
                    }

                    if (m_Rules.CanActorEquipItem(m_Player, it, out reason))
                    {
                        DoEquipItem(m_Player, it);
                        return false;
                    }
                    else
                    {
                        AddMessage(MakeErrorMessage(String.Format("Cannot equip {0} : {1}.", it.TheName, reason)));
                        return false;
                    }
                }
                else
                {
                    // try to use item.
                    string reason;
                    if (m_Rules.CanActorUseItem(m_Player, it, out reason))
                    {
                        DoUseItem(m_Player, it);
                        return true;
                    }
                    else
                    {
                        AddMessage(MakeErrorMessage(String.Format("Cannot use {0} : {1}.", it.TheName, reason)));
                    }
                }
            }
            else if (invIsBackpack) //backpack inventory        //@@MP (Release 8-2)
            {
                Point mousePos = new Point(-1, -1);
                mousePos = m_UI.UI_GetMousePosition();
                HandlePlayerSwapItemInventory(m_Player, mousePos);
            }
            else // ground inventory
            {
                // LMB in ground inv = take
                string reason;
                if (m_Rules.CanActorGetItem(m_Player, it, out reason))
                {
                    // special rules for backpacks       //@@MP (Release 8-2)
                    ItemBackpack backPack = it as ItemBackpack;
                    if (backPack != null && !m_Rules.CanActorTakeBackpack(m_Player, backPack, out reason))
                    {
                        AddMessage(MakeErrorMessage(String.Format("Cannot take {0} : {1}.", it.TheName, reason)));
                        return false;
                    }
                    
                    //return or fall through
                    DoTakeItem(m_Player, m_Player.Location.Position, it);
                    return true;
                }
                else
                {
                    AddMessage(MakeErrorMessage(String.Format("Cannot take {0} : {1}.", it.TheName, reason)));
                    return false;
                }
            }

            return false;
        }

        bool OnRMBItem(Inventory inv, Item it)
        {
            if (inv == m_Player.Inventory)
            {
                string reason;
                if (m_Rules.CanActorDropItem(m_Player, it, out reason))
                {
                    if (it is ItemBackpack) //@@MP - stops players from creating a stash that's easy to hide behind a few fortifications (Release 8-2)
                    {
                        Inventory itemsThere = m_Player.Location.Map.GetItemsAt(m_Player.Location.Position);
                        if (itemsThere != null && itemsThere.CountItems > 0)
                        {
                            ItemBackpack groundBP = itemsThere.GetFirstByType(typeof(ItemBackpack)) as ItemBackpack;
                            if (groundBP != null)
                            {
                                AddMessage(MakeErrorMessage(String.Format("Cannot drop {0} : only one backpack per tile allowed.", it.TheName)));
                                return false;
                            }
                        }
                    }

                    DoDropItem(m_Player, it);
                    return true;
                }
                else
                {
                    AddMessage(MakeErrorMessage(String.Format("Cannot drop {0} : {1}.", it.TheName, reason)));
                    return false;
                }
            }

            return false;
        }
#endregion

#region --Corpses
        bool HandleMouseOverCorpses(Point mousePos, MouseButtons? mouseButtons, out bool hasDoneAction)
        {
            // Ignore if not on a corpse slot.
            Point corpsePos;
            Corpse corpse = MouseToCorpse(mousePos, out corpsePos);
            if (corpse == null)
            {
                hasDoneAction = false;
                return false;
            }

            // Do corpse stuff.
            hasDoneAction = false;
            ClearOverlays();
            AddOverlay(new OverlayRect(Color.Cyan, new Rectangle(corpsePos.X, corpsePos.Y, 32, 32)));
            AddOverlay(new OverlayRect(Color.Cyan, new Rectangle(corpsePos.X + 1, corpsePos.Y + 1, 30, 30)));
            if (corpse != null)
            {
                string[] lines = DescribeCorpseLong(corpse, true);
                int longestLine = 1 + FindLongestLine(lines);
                int ovX = corpsePos.X - 7 * longestLine;
                int ovY = corpsePos.Y + 32;

                AddOverlay(new OverlayPopup(lines, Color.White, Color.White, POPUP_FILLCOLOR, new Point(ovX, ovY)));

                // mouse clicked?
                if (mouseButtons.HasValue)
                {
                    if (mouseButtons == MouseButtons.Left)
                        hasDoneAction = OnLMBCorpse(corpse);
                    else if (mouseButtons == MouseButtons.Right)
                        hasDoneAction = OnRMBCorpse(corpse);
                }
            }

            // Handled mouse.
            return true;
        }

        Corpse MouseToCorpse(Point screen, out Point corpsePos)
        {
            corpsePos = Point.Empty;

            if (m_Player == null)
                return null;

            List<Corpse> corpsesList = m_Player.Location.Map.GetCorpsesAt(m_Player.Location.Position);
            if (corpsesList == null)
                return null;
            Point corpseSlot = MouseToInventorySlot(INVENTORYPANEL_X, CORPSESPANEL_Y, screen.X, screen.Y);
            corpsePos = InventorySlotToScreen(INVENTORYPANEL_X, CORPSESPANEL_Y, corpseSlot.X, corpseSlot.Y);
            int corpseIndex = corpseSlot.X + corpseSlot.Y * INVENTORY_SLOTS_PER_LINE;
            if (corpseIndex >= 0 && corpseIndex < corpsesList.Count)
                return corpsesList[corpseIndex];

            return null;
        }

        bool OnLMBCorpse(Corpse c)
        {
            if (c.IsDragged)
            {
                string reason;
                if (m_Rules.CanActorStopDragCorpse(m_Player, c, out reason))
                {
                    DoStopDragCorpse(m_Player, c);
                    return false;
                }
                else
                {
                    AddMessage(MakeErrorMessage(String.Format("Cannot stop dragging {0} corpse : {1}.", c.DeadGuy.Name, reason)));
                    return false;
                }
            }
            else
            {
                string reason;
                if (m_Rules.CanActorStartDragCorpse(m_Player, c, out reason))
                {
                    DoStartDragCorpse(m_Player, c);
                    return false;
                }
                else
                {
                    AddMessage(MakeErrorMessage(String.Format("Cannot start dragging {0} corpse : {1}.", c.DeadGuy.Name, reason)));
                    return false;
                }
            }
        }

        bool OnRMBCorpse(Corpse c)
        {
            string reason;
            if (m_Player.Model.Abilities.IsUndead)
            {
                if (m_Rules.CanActorEatCorpse(m_Player, c, out reason))
                {
                    DoEatCorpse(m_Player, c);
                    return true;
                }
                else
                {
                    AddMessage(MakeErrorMessage(String.Format("Cannot eat {0} corpse : {1}.", c.DeadGuy.Name, reason)));
                    return false;
                }
            }
            else
            {
                if (m_Rules.CanActorButcherCorpse(m_Player, c, out reason))
                {
                    DoButcherCorpse(m_Player, c);
                    return true;
                }
                else
                {
                    AddMessage(MakeErrorMessage(String.Format("Cannot butcher {0} corpse : {1}.", c.DeadGuy.Name, reason)));
                    return false;
                }
            }
        }

        bool HandlePlayerEatCorpse(Actor player, Point mousePos)
        {
            // Ignore if not on a corpse slot.
            Point corpsePos;
            Corpse corpse = MouseToCorpse(mousePos, out corpsePos);
            if (corpse == null)
                return false;

            // Check legality.
            string reason;
            if (!m_Rules.CanActorEatCorpse(player, corpse, out reason))
            {
                AddMessage(MakeErrorMessage(String.Format("Cannot eat {0} corpse : {1}.", corpse.DeadGuy.Name, reason)));
                return false;
            }

            // Do it.
            DoEatCorpse(player, corpse);
            return true;
        }

        bool HandlePlayerReviveCorpse(Actor player, Point mousePos)
        {
            // Ignore if not on a corpse slot.
            Point corpsePos;
            Corpse corpse = MouseToCorpse(mousePos, out corpsePos);
            if (corpse == null)
                return false;

            // Check legality.
            string reason;
            if (!m_Rules.CanActorReviveCorpse(player, corpse, out reason))
            {
                AddMessage(MakeErrorMessage(String.Format("Cannot revive {0} : {1}.", corpse.DeadGuy.Name, reason)));
                return false;
            }

            // Do it.
            DoReviveCorpse(player, corpse);
            return true;
        }

        public void DoStartDragCorpse(Actor a, Corpse c)
        {
            c.DraggedBy = a;
            a.DraggedCorpse = c;
            if (IsVisibleToPlayer(a))
                AddMessage(MakeMessage(a, String.Format("{0} dragging {1} corpse.", Conjugate(a, VERB_START), c.DeadGuy.Name)));
        }

        public void DoStopDragCorpse(Actor a, Corpse c)
        {
            c.DraggedBy = null;
            a.DraggedCorpse = null;
            if (IsVisibleToPlayer(a))
                AddMessage(MakeMessage(a, String.Format("{0} dragging {1} corpse.", Conjugate(a, VERB_STOP), c.DeadGuy.Name)));
        }

        public void DoStopDraggingCorpses(Actor a)
        {
            if (a.DraggedCorpse != null)
            {
                DoStopDragCorpse(a, a.DraggedCorpse);
            }
        }

        public void DoButcherCorpse(Actor a, Corpse c)
        {
            bool isVisible = IsVisibleToPlayer(a);

            // spend ap.
            SpendActorActionPoints(a, Rules.BASE_ACTION_COST);

            // cause insanity.
            if (!c.DeadGuy.Model.Abilities.IsLivingAnimal) //@@MP - no sanity hit for butchering animals, which is a new addition (Release 7-6)
                SeeingCauseInsanity(a.Location, Rules.SANITY_HIT_BUTCHERING_CORPSE, String.Format("{0} butchering {1}", a.Name, c.DeadGuy.Name), a); //@@MP - updated for the change to this method (Release 5-2)

            //select the relevant type of meat to drop, and how fresh it is         //@@MP (Release 7-6)
            #region meat

            int rotLevel = Rules.CorpseRotLevel(c);
            ++rotLevel; //adjustment in order to avoid a divide-by-zero, because the actual levels start at 0:
            /*
                level 5: "The corpse is about to crumble to dust."
                level 4: "The corpse is almost entirely rotten."
                level 3: "The corpse is badly damaged."
                level 2: "The corpse is damaged."
                level 1: "The corpse is bruised and smells."
                level 0: "The corpse looks fresh."
            */
            // we factor the rot level into how much best before turns is remaining in the meat
            // bestBefore = currentTurn + (TURNS_PER_DAY * BestBeforeDays) / RotLevel

            Item meat;
            int currentTurn = a.Location.Map.LocalTime.TurnCounter;
            if (c.DeadGuy.Model.Abilities.IsLivingAnimal)
            {
                string modelName = c.DeadGuy.Model.Name;
                switch (modelName)
                {
                    case "rabbit":
                        if (c.DeadGuy.CauseOfDeath == "fire")
                            meat = new ItemFood(GameItems.COOKED_RABBIT, currentTurn + (WorldTime.TURNS_PER_DAY * GameItems.COOKED_RABBIT.BestBeforeDays) / rotLevel, true, false);
                        else
                            meat = new ItemFood(GameItems.RAW_RABBIT, currentTurn + (WorldTime.TURNS_PER_DAY * GameItems.RAW_RABBIT.BestBeforeDays) / rotLevel, true, true);
                        break;
                    case "chicken":
                        if (c.DeadGuy.CauseOfDeath == "fire")
                            meat = new ItemFood(GameItems.COOKED_CHICKEN, currentTurn + (WorldTime.TURNS_PER_DAY * GameItems.COOKED_CHICKEN.BestBeforeDays) / rotLevel, true, false);
                        else
                            meat = new ItemFood(GameItems.RAW_CHICKEN, currentTurn + (WorldTime.TURNS_PER_DAY * GameItems.RAW_CHICKEN.BestBeforeDays) / rotLevel, true, true);
                        break;
                    case "feral dog":
                        if (c.DeadGuy.CauseOfDeath == "fire")
                            meat = new ItemFood(GameItems.COOKED_DOG_MEAT, currentTurn + (WorldTime.TURNS_PER_DAY * GameItems.COOKED_DOG_MEAT.BestBeforeDays) / rotLevel, true, false);
                        else
                            meat = new ItemFood(GameItems.RAW_DOG_MEAT, currentTurn + (WorldTime.TURNS_PER_DAY * GameItems.RAW_DOG_MEAT.BestBeforeDays) / rotLevel, true, true);
                        break;
                    default: 
                        throw new ArgumentException("unhandled actor model name");
                }
                switch (s_Options.ResourcesAvailability)
                {
                    case GameOptions.Resources.HIGH: meat.Quantity = 3; break;
                    case GameOptions.Resources.MED: meat.Quantity = 2; break;
                    case GameOptions.Resources.LOW: meat.Quantity = 1; break;
                    default: meat.Quantity = 2; break;
                }
            }
            else //human
            {
                if (c.DeadGuy.CauseOfDeath == "fire")
                    meat = new ItemFood(GameItems.COOKED_HUMAN_FLESH, currentTurn + (WorldTime.TURNS_PER_DAY * GameItems.COOKED_HUMAN_FLESH.BestBeforeDays) / rotLevel, true, false);
                else
                    meat = new ItemFood(GameItems.RAW_HUMAN_FLESH, currentTurn + (WorldTime.TURNS_PER_DAY * GameItems.RAW_HUMAN_FLESH.BestBeforeDays) / rotLevel, true, true);
            }

            //try add to player inv, else put it on the ground here or nearby
            if (!a.Inventory.AddAll(meat))
                DropItem(a, meat, true);
            AddMessage(MakeMessage(a, "carved off some raw meat."));
            #endregion

            // damage.
            int dmg = m_Rules.ActorDamageVsCorpses(a);

            if (isVisible)
                AddMessage(MakeMessage(a, String.Format("{0} {1} corpse for {2} damage.", Conjugate(a, VERB_BUTCHER), c.DeadGuy.Name, dmg)));

            InflictDamageToCorpse(c, dmg);

            // destroy?
            if (c.HitPoints <= 0)
            {
                //finalise
                DestroyCorpse(c, a.Location.Map);
                if (isVisible)
                    AddMessage(new Message(String.Format("{0} corpse is no more.", c.DeadGuy.Name), a.Location.Map.LocalTime.TurnCounter, Color.Purple));
            }
        }

        public void DoEatCorpse(Actor a, Corpse c)
        {
            //@@MP - cannibalism = nasty stuff happens (Release 7-6)
            bool actorIsHuman = !a.Model.Abilities.IsUndead && !a.Model.Abilities.IsLivingAnimal;
            bool isCannibalism = actorIsHuman && !c.DeadGuy.Model.Abilities.IsLivingAnimal;
            if (!actorIsHuman)
                isCannibalism = false;

            //a pre-check to warn player about eating human flesh        //@@MP (Release 7-6)
            if (a.IsPlayer && isCannibalism) //the only other corpses are human ones
            {
                bool performCannibalism = false;
                AddMessage(new Message(String.Format("Cannibalism has consequences! See section 9 of the manual <{0}>.", s_KeyBindings.GetFriendlyFormat(PlayerCommand.HELP_MODE)),
                    a.Location.Map.LocalTime.TurnCounter));
                AddMessage(MakeYesNoMessage("Do you really want to eat the human meat"));
                RedrawPlayScreen();
                performCannibalism = WaitYesOrNo();
                ClearMessages();
                RedrawPlayScreen();
                if (!performCannibalism)
                    return;
            }

            // repercussions of cannibalism        //@@MP (Release 7-6)
            if (isCannibalism)
                RepercussionsOfCannibalism(a);

            // raw meat can cause food poisoning        //@@MP (Release 7-6)
            FoodPoisoning(a, null, c);

            bool isVisible = IsVisibleToPlayer(a);

            // spend ap.
            SpendActorActionPoints(a, Rules.BASE_ACTION_COST);

            // damage.
            int dmg = m_Rules.ActorDamageVsCorpses(a);

            // msg.
            if (isVisible)
                AddMessage(MakeMessage(a, String.Format("{0} {1} corpse.", Conjugate(a, VERB_FEAST_ON), c.DeadGuy.Name)));//dmg))); //@@MP - removed unused argument (Release 5-5)

            // sound effect
            if (a.IsPlayer) //@@MP (Release 3)
                m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.UNDEAD_EAT_PLAYER, AudioPriority.PRIORITY_EVENT);
            if (IsAudibleToPlayer(a.Location, Rules.QUIET_NOISE_RADIUS))  //@@MP (Release 7-4)
                m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.UNDEAD_EAT_NEARBY, AudioPriority.PRIORITY_BGM);

            // dmg corpse.
            InflictDamageToCorpse(c, dmg);

            // destroy?
            if (c.HitPoints <= 0)
            {
                DestroyCorpse(c, a.Location.Map);
                if (isVisible)
                    AddMessage(new Message(String.Format("{0} corpse is no more.", c.DeadGuy.Name), a.Location.Map.LocalTime.TurnCounter, Color.Purple));
            }

            // heal if undead / food.
            if (a.Model.Abilities.IsUndead)
            {
                RegenActorHitPoints(a, Rules.ActorBiteHpRegen(a, dmg));
                a.FoodPoints = Math.Min(a.FoodPoints + m_Rules.ActorBiteNutritionValue(a, dmg), m_Rules.ActorMaxRot(a));
            }
            else
            {
                // recover food points.
                a.FoodPoints = Math.Min(a.FoodPoints + m_Rules.ActorBiteNutritionValue(a, dmg), m_Rules.ActorMaxFood(a));
                // infection!
                if (Rules.HasInfection(m_Session.GameMode))
                    InfectActor(a, m_Rules.CorpseEeatingInfectionTransmission(c.DeadGuy.Infection));
            }

            // cause insanity.
            SeeingCauseInsanity(a.Location, a.Model.Abilities.IsUndead ? Rules.SANITY_HIT_UNDEAD_EATING_CORPSE : Rules.SANITY_HIT_LIVING_EATING_CORPSE,
                String.Format("{0} eating {1}", a.Name, c.DeadGuy.Name), a); //@@MP - updated for the change to this method (Release 5-2)
        }

        public void DoReviveCorpse(Actor actor, Corpse corpse)
        {
            bool visible = IsVisibleToPlayer(actor);

            // spend ap.
            SpendActorActionPoints(actor, Rules.BASE_ACTION_COST);

            // make sure there is a walkable spot for revival.
            Map map = actor.Location.Map;
            List<Point> revivePoints = actor.Location.Map.FilterAdjacentInMap(actor.Location.Position,
                (pt) =>
                {
                    if (map.GetActorAt(pt) != null) return false;
                    if (map.GetMapObjectAt(pt) != null) return false;
                    return true;
                });
            if (revivePoints == null)
            {
                if (visible)
                    AddMessage(MakeMessage(actor, String.Format("{0} not enough room for reviving {1}.", Conjugate(actor, VERB_HAVE), corpse.DeadGuy.Name)));
                return;
            }
            Point revivePt = revivePoints[m_Rules.Roll(0, revivePoints.Count)];

            // spend medikit.
            Item medikit = actor.Inventory.GetSmallestStackByModel(GameItems.LARGE_MEDIKIT);  // alpha10, was: actor.Inventory.GetFirstMatching((it) => it.Model == GameItems.MEDIKIT);
            actor.Inventory.Consume(medikit);

            // try.
            int chance = m_Rules.CorpseReviveChance(actor, corpse);
            if (m_Rules.RollChance(chance))
            {
                // do it.
                corpse.DeadGuy.IsDead = false;
                corpse.DeadGuy.HitPoints = m_Rules.CorpseReviveHPs(actor); //@@MP - unused parameter (Release 5-7)
                corpse.DeadGuy.Doll.RemoveDecoration(GameImages.BLOODIED);
                corpse.DeadGuy.Activity = Activity.IDLE;
                corpse.DeadGuy.TargetActor = null;
                map.RemoveCorpse(corpse);
                map.PlaceActorAt(corpse.DeadGuy, revivePt);
                // msg.
                if (visible)
                    AddMessage(MakeMessage(actor, Conjugate(actor, VERB_REVIVE), corpse.DeadGuy));
                // thank you... or not?
                if (!m_Rules.AreEnemies(actor, corpse.DeadGuy))
                    DoSay(corpse.DeadGuy, actor, "Thank you, you saved my life!", Sayflags.NONE);
                // add trust.
                if (!m_Rules.AreEnemies(actor, corpse.DeadGuy))
                    corpse.DeadGuy.AddTrustIn(actor, Rules.TRUST_REVIVE_BONUS);
                // regen all sanity if applicable //@@MP (Release 5-2)
                if (actor.Model.Abilities.HasSanity)
                    RegenActorSanity(actor, (m_Rules.ActorMaxSanity(actor) - actor.Sanity));
            }
            else
            {
                // msg.
                if (visible)
                    AddMessage(MakeMessage(actor, String.Format("{0} to revive", Conjugate(actor, VERB_FAIL)), corpse.DeadGuy));
            }
        }

        static void InflictDamageToCorpse(Corpse c, float dmg) //@@MP - made static (Release 5-7)
        {
            c.HitPoints -= dmg;
        }

        static void DestroyCorpse(Corpse c, Map m) //@@MP - made static (Release 5-7)
        {
            if (c.DraggedBy != null)
            {
                c.DraggedBy.DraggedCorpse = null;
                c.DraggedBy = null;
            }
            m.RemoveCorpse(c);
        }
        #endregion

        #region --Everything else
        bool DoPlayerItemSlot(Actor player, int slot, KeyEventArgs key)
        {
            // get key modifier and redirect to proper action.
            // Ctrl  -> equip/unequip/use item from player inv
            // Shift -> take item from ground inv
            // Alt -> drop item from player inv.
            if ((key.Modifiers & Keys.Control) != 0)
                return DoPlayerItemSlotUse(player, slot);
            else if (key.Shift)
                return DoPlayerItemSlotTake(player, slot);
            else if (key.Alt)
                return DoPlayerItemSlotDrop(player, slot);

            // nope.
            return false;
        }

        bool DoPlayerItemSlotUse(Actor player, int slot)
        {
            Inventory inv = player.Inventory;
            Item it = inv[slot];

            // if no item, nothing to do.
            if (it == null)
            {
                AddMessage(MakeErrorMessage(String.Format("No item at inventory slot {0}.", (slot + 1))));
                return false;
            }

            // ty to unequip/equip/use. 
            // shameful copy of OnLMBItem.
            // shame on me.
            if (it.IsEquipped)
            {
                string reason;
                if (m_Rules.CanActorUnequipItem(player, it, out reason))
                {
                    DoUnequipItem(player, it);
                    return false;
                }
                else
                {
                    AddMessage(MakeErrorMessage(String.Format("Cannot unequip {0} : {1}.", it.TheName, reason)));
                    return false;
                }
            }
            else if (it.Model.IsEquipable)
            {
                string reason;
                if (it.Model == m_GameItems.FISHING_ROD && !m_Rules.CanActorEquipFishingRod(m_Player, it, out reason)) //@@MP - special case (Release 7-6)
                {
                    AddMessage(MakeErrorMessage(String.Format("Cannot equip {0} : {1}.", it.TheName, reason)));
                    return false;
                }
                else if (m_Rules.IsItemBinoculars(it))
                {
                    bool canSeeSky = m_Rules.CanActorSeeSky(m_Player);
                    bool isNight = m_Player.Location.Map.LocalTime.IsNight;
                    bool outsideAtNight = (canSeeSky && isNight);
                    if (m_Player.Location.Map.Lighting == Lighting.DARKNESS || outsideAtNight)
                    {
                        AddMessage(MakeErrorMessage("It's too dark to use binoculars"));
                        return false;
                    }
                }

                if (m_Rules.CanActorEquipItem(player, it, out reason))
                {
                    DoEquipItem(player, it);
                    return false;
                }
                else
                {
                    AddMessage(MakeErrorMessage(String.Format("Cannot equip {0} : {1}.", it.TheName, reason)));
                    return false;
                }
            }
            else
            {
                // try to use item.
                string reason;
                if (m_Rules.CanActorUseItem(player, it, out reason))
                {
                    DoUseItem(player, it);
                    return true;
                }
                else
                {
                    AddMessage(MakeErrorMessage(String.Format("Cannot use {0} : {1}.", it.TheName, reason)));
                }
            }

            // nothing done.
            return false;
        }

        bool DoPlayerItemSlotTake(Actor player, int slot)
        {
            Inventory inv = player.Location.Map.GetItemsAt(player.Location.Position);
            string reason;

            // if no items on ground, nothing to do.
            if (inv == null || inv.IsEmpty)
            {
                AddMessage(MakeErrorMessage("No items on ground."));
                return false;
            }

            // if no item, nothing to do.
            Item it = inv[slot];
            if (it == null)
            {
                AddMessage(MakeErrorMessage(String.Format("No item at ground slot {0}.", (slot + 1))));
                return false;
            }

            // special rules for backpacks       //@@MP (Release 8-2)
            ItemBackpack backPack = it as ItemBackpack;
            if (backPack != null && !m_Rules.CanActorTakeBackpack(m_Player, backPack, out reason))
            {
                AddMessage(MakeErrorMessage(String.Format("Cannot take {0} : {1}.", it.TheName, reason)));
                return false;
            }

            // try to take.
            if (m_Rules.CanActorGetItem(player, it, out reason))
            {
                DoTakeItem(player, player.Location.Position, it);
                return true;
            }
            else
            {
                AddMessage(MakeErrorMessage(String.Format("Cannot take {0} : {1}.", it.TheName, reason)));
                return false;
            }
        }

        bool DoPlayerItemSlotDrop(Actor player, int slot)
        {
            Inventory inv = player.Inventory;
            Item it = inv[slot];

            // if no item, nothing to do.
            if (it == null)
            {
                AddMessage(MakeErrorMessage(String.Format("No item at inventory slot {0}.", (slot + 1))));
                return false;
            }

            // try to drop.
            string reason;
            if (m_Rules.CanActorDropItem(player, it, out reason))
            {
                DoDropItem(player, it);
                return true;
            }
            else
            {
                AddMessage(MakeErrorMessage(String.Format("Cannot drop {0} : {1}.", it.TheName, reason)));
                return false;
            }
        }

        bool HandlePlayerShout(Actor player, string text)
        {
            string reason;
            if (!m_Rules.CanActorShout(player, out reason))
            {
                AddMessage(MakeErrorMessage(String.Format("Can't shout : {0}.", reason)));
                return false;
            }

            DoShout(player, text);
            return true;
        }

        bool HandlePlayerGiveItem(Actor player, Point screen)
        {
            // get player inventory item under mouse.
            Inventory inv;
            Point itemPos;
            int iSlot; // alpha 10
            bool isBackpack; //@@MP (Release 8-2)
            Item gift = MouseToInventoryItem(screen, out inv, out itemPos, out iSlot, out isBackpack);
            if (inv == null || inv != player.Inventory || gift == null)
                return false;

            // handle give item.
            bool loop = true;
            bool actionDone = false;
            ClearOverlays();
            AddOverlay(new OverlayPopup(GIVE_MODE_TEXT, MODE_TEXTCOLOR, MODE_BORDERCOLOR, MODE_FILLCOLOR, new Point(0, 0)));
            do
            {
                ///////////////////
                // 1. Redraw
                // 2. Get input.
                // 3. Handle input
                ///////////////////

                // 1. Redraw
                AddMessage(new Message(String.Format("Giving {0} to...", gift.TheName), m_Session.WorldTime.TurnCounter, Color.Yellow));
                RedrawPlayScreen();

                // 2. Get input.
                Direction dir = WaitDirectionOrCancel();

                // 3. Handle input
                if (dir == null)
                {
                    loop = false;
                }
                else if (dir != Direction.NEUTRAL)
                {
                    Point pos = player.Location.Position + dir;
                    if (player.Location.Map.IsInBounds(pos))
                    {
                        Actor other = player.Location.Map.GetActorAt(pos);
                        if (other != null)
                        {
                            string reason;
                            if (m_Rules.CanActorGiveItemTo(player, other, gift, out reason))
                            {
                                // do it.
                                actionDone = true;
                                loop = false;
                                DoGiveItemTo(player, other, gift);
                            }
                            else
                            {
                                AddMessage(MakeErrorMessage(String.Format("Can't give {0} to {1} : {2}.", gift.TheName, other.TheName, reason)));
                            }
                        }
                        else
                            AddMessage(MakeErrorMessage("No one there."));
                    }
                }
            }
            while (loop);

            // cleanup.
            ClearOverlays();

            // return if we did an action.
            return actionDone;
        }

        bool HandlePlayerTradeNegotiation(Actor player, Actor npc) // alpha10 new trade window dialog
        {
            BaseAI npcAI = npc.Controller as BaseAI;
            bool isOnPlayerInventory = true;
            int iPlayerSelectedItem = -1;
            int iNpcSelectedItem = -1;
            int state = 0; // 0 selecting 1st item; 1 selecting 2nd item; 2 making the offer

            // pre-compute all possible trade deals ratings
            TradeRating[,] ratingPairs = new TradeRating[player.Inventory.CountItems, npc.Inventory.CountItems];
            for (int i = 0; i < player.Inventory.CountItems; i++)
            {
                Item offered = player.Inventory[i];
                for (int j = 0; j < npc.Inventory.CountItems; j++)
                    ratingPairs[i, j] = npcAI.RateTradeOffer(this, player, offered, npc.Inventory[j]);
            }

            /*// roll charisma to later accept or refuse "maybe" deal. //@@MP - alpha 10 way of doing it. too random for my liking (Release 6-1)
            int charismaChance = m_Rules.ActorCharismaticTradeChance(player);
            bool charismaSuccess = m_Session.Player_TurnCharismaRoll < charismaChance;*/

            // charisma determines whether a 'maybe' deal is refused or accepted
            bool charismaSuccess = m_Rules.ActorCharismaticTradeChance(player) >= m_Rules.ActorCharismaticTradeChance(npc); //@@MP - if I'm equal or more charismatic than them, trade (Release 6-1)

            // remember if player is trusted leader to notify him.
            bool isTrustedLeader = (npc.Leader == player) && m_Rules.IsActorTrustingLeader(npc);

            // loop
            bool loop = true;
            bool actionDone = false;
            List<String> lines = new List<string>();
            List<Color> colors = new List<Color>();

            Color tradeToColor(TradeRating r)
            {
                if (r == TradeRating.ACCEPT) return TRADE_COLOR_ACCEPT;
                if (r == TradeRating.REFUSE) return TRADE_COLOR_REFUSE;
                if (charismaSuccess) return TRADE_COLOR_MAYBE_SUCCESS;
                return TRADE_COLOR_MAYBE_FAILED;
            };

            do
            {
                ///////////////////
                // 1. Redraw
                // 2. Handle state
                ///////////////////

                // 1. Redraw

                lines.Clear();
                colors.Clear();

                if (state == 2)
                {
                    lines.Add("Mode: Making the offer");
                }
                else
                {
                    if (isOnPlayerInventory)
                    {
                        if (state == 0)
                            lines.Add("Mode: Proposing an item");
                        else
                            lines.Add("Mode: Selecting your item to exhange");
                    }
                    else
                    {
                        if (state == 0)
                            lines.Add("Mode: Asking for an item");
                        else
                            lines.Add("Mode: Selecting an item to exhange");
                    }
                }
                colors.Add(Color.Yellow);

                lines.Add(" ");
                colors.Add(Color.Black);

                // header help 1: trusted leader
                if (isTrustedLeader)
                {
                    lines.Add(" "); colors.Add(Color.White);
                    lines.Add(string.Format("You are {0} trusted leader, will accept all trades.", HisOrHer(npc)));
                    colors.Add(Color.LightGreen);
                }

                // header help 2: charisma roll
                if (charismaSuccess)
                {
                    //lines.Add(string.Format("Charisma roll success {0}/{1}%", m_Session.Player_TurnCharismaRoll, charismaChance));
                    lines.Add(string.Format("Charisma success {0} vs {1}", m_Rules.ActorCharismaticTradeChance(player), m_Rules.ActorCharismaticTradeChance(npc))); //@@MP (Release 6-1)
                    colors.Add(Color.LightGreen);
                }
                else
                {
                    //lines.Add(string.Format("Charisma roll failed {0}/{1}%", m_Session.Player_TurnCharismaRoll, charismaChance));
                    lines.Add(string.Format("Charisma roll failed {0} vs {1}", m_Rules.ActorCharismaticTradeChance(player), m_Rules.ActorCharismaticTradeChance(npc))); //@@MP (Release 6-1)
                    colors.Add(Color.Red);
                }

                void ListTradeItems(Actor a, bool isActive)
                {
                    lines.Add(string.Format("{0} items", a.TheName));
                    colors.Add(Color.White);
                    for (int i = 0; i < a.Inventory.CountItems; i++)
                    {
                        Item it = a.Inventory[i];
                        if (isActive)
                        {
                            lines.Add(string.Format("{0}. {1}", (i == 9 ? 0 : (i + 1)), DescribeItemShort(it)));
                            if (state == 0)  // proposing item
                                colors.Add(Color.Yellow);
                            else  // trading for current item
                            {
                                TradeRating r = (a == player && isActive ? ratingPairs[i, iNpcSelectedItem] : ratingPairs[iPlayerSelectedItem, i]);
                                colors.Add(tradeToColor(r));
                            }
                        }
                        else
                        {
                            lines.Add("-. " + DescribeItemShort(it));
                            colors.Add(i == (a == player ? iPlayerSelectedItem : iNpcSelectedItem) ? TRADE_COLOR_SELECTED_ITEM : Color.Gray);
                        }
                    }
                };

                // list items, player and npc
                lines.Add(" "); colors.Add(Color.Black);
                ListTradeItems(player, isOnPlayerInventory && state != 2);
                lines.Add(" "); colors.Add(Color.Black);
                ListTradeItems(npc, !isOnPlayerInventory && state != 2);

                // footnote help: trade ratings color legend
                if (state != 0 && !isTrustedLeader)
                {
                    lines.Add(" "); colors.Add(Color.White);
                    lines.Add("Trade color legend : "); colors.Add(Color.White);
                    lines.Add("  asked/offered"); colors.Add(TRADE_COLOR_SELECTED_ITEM);
                    lines.Add("  will accept"); colors.Add(TRADE_COLOR_ACCEPT);
                    lines.Add("  will accept due to your charisma"); colors.Add(TRADE_COLOR_MAYBE_SUCCESS);
                    lines.Add("  will refuse due to failed charisma"); colors.Add(TRADE_COLOR_MAYBE_FAILED);
                    lines.Add("  will refuse"); colors.Add(TRADE_COLOR_REFUSE);
                }

                // draw
                ClearOverlays();
                AddOverlay(new OverlayPopup(TRADING_DIALOG_MODE_TEXT, MODE_TEXTCOLOR, MODE_BORDERCOLOR, MODE_FILLCOLOR, new Point(0, 0)));
                OverlayPopupTitleColors ov = new OverlayPopupTitleColors(
                    string.Format("Trading with {0}", npc.TheName), Color.White,
                    lines.ToArray(), colors.ToArray(),
                    Color.White, Color.Black, new Point(32, 32));
                AddOverlay(ov);
                RedrawPlayScreen();

                // 2. Handle state
                if (state == 2)  // make offer
                {
                    ClearMessages();
                    Item offered = player.Inventory[iPlayerSelectedItem];
                    Item asked = npc.Inventory[iNpcSelectedItem];
                    AddMessage(MakeMessage(player, string.Format("{0} {1} for {2}.", Conjugate(player, VERB_OFFER), offered.TheName, asked.TheName)));

                    // get rating and apply charisma
                    TradeRating r = ratingPairs[iPlayerSelectedItem, iNpcSelectedItem];
                    if (r == TradeRating.MAYBE)
                        r = (charismaSuccess ? TradeRating.ACCEPT : TradeRating.REFUSE);

                    // npc accept or refuse
                    if (r == TradeRating.ACCEPT)
                    {
                        // accept: make deal and done.
                        AddMessage(MakeMessage(npc, Conjugate(npc, VERB_ACCEPT_THE_DEAL) + "."));
                        SwapActorItems(player, offered, npc, asked);
                        loop = false;
                        actionDone = true;
                        // sanity recover after player trade chat
                        // to be consistent with fast trade, should also recover san a failed trade but this will be
                        // abused by the player as a refused trade doesnt end the turn.
                        if (player.Model.Abilities.HasSanity)
                        {
                            RegenActorSanity(player, m_Rules.ActorSanRegenValue(player, Rules.SANITY_RECOVER_CHAT_OR_TRADE));
                            AddMessage(MakeMessage(player, string.Format("{0} better after trading with", Conjugate(player, VERB_FEEL)), npc));
                        }
                        if (npc.Model.Abilities.HasSanity)
                        {
                            RegenActorSanity(npc, m_Rules.ActorSanRegenValue(npc, Rules.SANITY_RECOVER_CHAT_OR_TRADE));
                            AddMessage(MakeMessage(npc, string.Format("{0} better after trading with", Conjugate(npc, VERB_FEEL)), player));
                        }
                    }
                    else if (r == TradeRating.REFUSE)
                    {
                        // refuse: can make another offer.
                        AddMessage(MakeMessage(npc, Conjugate(npc, VERB_REFUSE_THE_DEAL) + "."));
                        isOnPlayerInventory = !isOnPlayerInventory;
                        iPlayerSelectedItem = iNpcSelectedItem = -1;
                        state = 0;
                    }

                    // done
                    AddMessagePressEnter();
                }
                else
                {
                    // Select 1st or 2nd item
                    KeyEventArgs inKey = m_UI.UI_WaitKey();

                    if (inKey.KeyCode == Keys.Escape)  // back/abort
                    {
                        if (state == 0)
                            loop = false;
                        else
                        {
                            state = 0;
                            if (isOnPlayerInventory)
                                iPlayerSelectedItem = -1;
                            else
                                iNpcSelectedItem = -1;
                            isOnPlayerInventory = !isOnPlayerInventory;
                        }
                    }
                    else if (inKey.KeyCode == Keys.Tab)  // switch inventory
                    {
                        if (state == 0)
                        {
                            isOnPlayerInventory = !isOnPlayerInventory;
                            iPlayerSelectedItem = iNpcSelectedItem = -1;
                        }
                    }
                    else
                    {
                        int slot = KeyToChoiceNumber(inKey.KeyCode);
                        if (slot != -1) // select an item
                        {
                            if (slot == 0) slot = 9;
                            else slot--;

                            if (isOnPlayerInventory)
                            {
                                if (slot < player.Inventory.CountItems)
                                {
                                    iPlayerSelectedItem = slot;
                                    if (state == 0)  // offering item 1st
                                    {
                                        state = 1;
                                        isOnPlayerInventory = false;
                                    }
                                    else
                                    {
                                        // offering item 2nd
                                        state = 2;
                                    }
                                }
                            }
                            else
                            {
                                if (slot < npc.Inventory.CountItems)
                                {
                                    iNpcSelectedItem = slot;
                                    if (state == 0)  // asking item 1st
                                    {
                                        state = 1;
                                        isOnPlayerInventory = true;
                                    }
                                    else
                                    {
                                        // asking item 2nd
                                        state = 2;
                                    }
                                }
                            }
                        }
                    }
                }

            }
            while (loop);

            // if trade done, spend player ap.
            if (actionDone)
                SpendActorActionPoints(player, Rules.BASE_ACTION_COST);

            ClearOverlays(); // alpha10.1

            return actionDone;
        }

        bool HandlePlayerNegotiateTrade(Actor player)
        {
            // handle select adjacent npc
            bool loop = true;
            bool actionDone = false;
            ClearOverlays();
            AddOverlay(new OverlayPopup(NEGOTIATE_TRADE_MODE_TEXT, MODE_TEXTCOLOR, MODE_BORDERCOLOR, MODE_FILLCOLOR, new Point(0, 0)));
            do
            {
                ///////////////////
                // 1. Redraw
                // 2. Get input.
                // 3. Handle input
                ///////////////////

                // 1. Redraw
                RedrawPlayScreen();

                // 2. Get input.
                Direction dir = WaitDirectionOrCancel();

                // 3. Handle input
                if (dir == null)
                {
                    loop = false;
                }
                else if (dir != Direction.NEUTRAL)
                {
                    Point pos = player.Location.Position + dir;
                    if (player.Location.Map.IsInBounds(pos))
                    {
                        Actor other = player.Location.Map.GetActorAt(pos);
                        if (other != null)
                        {
                            string reason;
                            if (m_Rules.CanActorInitiateTradeWith(player, other, out reason))
                            {
                                actionDone = HandlePlayerTradeNegotiation(player, other);
                                loop = false;
                            }
                            else
                            {
                                AddMessage(MakeErrorMessage(String.Format("Can't trade with {0} : {1}.", other.TheName, reason)));
                            }
                        }
                        else
                            AddMessage(MakeErrorMessage("No one there."));
                    }
                }
            }
            while (loop);

            // cleanup.
            ClearOverlays();

            // return if we did an action.
            return actionDone;
        }

        void HandlePlayerRunToggle(Actor player)
        {
            string reason;
            if (!m_Rules.CanActorRun(player, out reason))
            {
                AddMessage(MakeErrorMessage(String.Format("Cannot run now : {0}.", reason)));
                return;
            }

            // ok.
            player.IsRunning = !player.IsRunning;
            AddMessage(MakeMessage(player, String.Format("{0} running.", Conjugate(player, player.IsRunning ? VERB_START : VERB_STOP))));
        }

        bool HandlePlayerCloseDoor(Actor player)
        {
            bool loop = true;
            bool actionDone = false;

            ClearOverlays();
            AddOverlay(new OverlayPopup(CLOSE_DOOR_MODE_TEXT, MODE_TEXTCOLOR, MODE_BORDERCOLOR, MODE_FILLCOLOR, new Point(0, 0)));

            do
            {
                ///////////////////
                // 1. Redraw
                // 2. Get input.
                // 3. Handle input
                ///////////////////

                // 1. Redraw
                RedrawPlayScreen();

                // 2. Get input.
                Direction dir = WaitDirectionOrCancel();

                // 3. Handle input
                if (dir == null)
                {
                    loop = false;
                }
                else if (dir != Direction.NEUTRAL)
                {
                    Point pos = player.Location.Position + dir;
                    if (player.Location.Map.IsInBounds(pos))
                    {
                        MapObject mapObj = player.Location.Map.GetMapObjectAt(pos);
                        DoorWindow door = mapObj as DoorWindow;
                        if (door != null)
                        {
                            string reason;
                            if (m_Rules.IsClosableFor(player, door, out reason))
                            {
                                DoCloseDoor(player, door);
                                RedrawPlayScreen();
                                loop = false;
                                actionDone = true;
                            }
                            else
                            {
                                AddMessage(MakeErrorMessage(String.Format("Can't close {0} : {1}.", door.TheName, reason)));
                            }
                        }
                        else
                            AddMessage(MakeErrorMessage("Nothing to close there."));
                    }
                }
            }
            while (loop);

            // cleanup.
            ClearOverlays();

            // return if we did an action.
            return actionDone;
        }

        bool HandlePlayerBuildMode(Actor player) //@@MP - one key to now handle barricading and fortification (Release 6-6)
        {
            //barricade or fortification? question player
            AddOverlay(new OverlayPopup(BUILD_MODE, MODE_TEXTCOLOR, MODE_BORDERCOLOR, MODE_FILLCOLOR, Point.Empty));
            RedrawPlayScreen();

            string buildType = "";
            KeyEventArgs inKey = m_UI.UI_WaitKey(); //  Read input
            if (inKey.KeyCode == Keys.Escape) // Handle input
            {
                //AddMessage(new Message("Aborted build mode.", m_Session.WorldTime.TurnCounter, Color.White));
                ClearOverlays();
                RedrawPlayScreen();
                return false;
            }
            // get choice.
            else if (inKey.KeyCode == Keys.B)
                buildType = "barricade";
            else if (inKey.KeyCode == Keys.F)
                buildType = "fortification";
            else if (inKey.KeyCode == Keys.R) //@@MP - added (Release 8-1)
                buildType = "repair door";
            else
            {
                AddMessage(MakeErrorMessage("Unhandled key error when choosing build type."));
                AddMessage(MakeErrorMessage("Did you perhaps hit the wrong key?"));
                ClearOverlays();
                RedrawPlayScreen();
                return false;
            }
            ClearOverlays();
            RedrawPlayScreen();

            if (buildType == "barricade")
                return HandlePlayerBarricade(player);
            else if (buildType == "fortification")
                return HandlePlayerBuildFortification(player);
            else if (buildType == "repair door")
                return HandlePlayerRepairDoor(player);
            else
                throw new InvalidOperationException("invalid buildType");
        }

        bool HandlePlayerBarricade(Actor player)
        {
            bool loop = true;
            bool actionDone = false;

            ClearOverlays();
            AddOverlay(new OverlayPopup(BARRICADE_MODE_TEXT, MODE_TEXTCOLOR, MODE_BORDERCOLOR, MODE_FILLCOLOR, new Point(0, 0)));

            do
            {
                ///////////////////
                // 1. Redraw
                // 2. Get input.
                // 3. Handle input
                ///////////////////

                // 1. Redraw
                RedrawPlayScreen();

                // 2. Get input.
                Direction dir = WaitDirectionOrCancel();

                // 3. Handle input
                if (dir == null)
                {
                    loop = false;
                }
                else if (dir != Direction.NEUTRAL)
                {
                    Point pos = player.Location.Position + dir;
                    if (player.Location.Map.IsInBounds(pos))
                    {
                        MapObject mapObj = player.Location.Map.GetMapObjectAt(pos);
                        if (mapObj != null)
                        {
                            // barricading a door.
                            if (mapObj is DoorWindow)
                            {
                                DoorWindow door = mapObj as DoorWindow;
                                string reason;
                                if (m_Rules.CanActorBarricadeDoor(player, door, m_Session.World.Weather, out reason)) //@@MP - added weather parameter (Release 6-2)
                                {
                                    DoBarricadeDoor(player, door);
                                    RedrawPlayScreen();
                                    loop = false;
                                    actionDone = true;
                                }
                                else
                                {
                                    AddMessage(MakeErrorMessage(String.Format("Cannot barricade {0} : {1}.", door.TheName, reason)));
                                }
                            }
                            // repairing a fortification.
                            else if (mapObj is Fortification)
                            {
                                Fortification fort = mapObj as Fortification;
                                string reason;
                                if (m_Rules.CanActorRepairFortification(player, m_Session.World.Weather, out reason)) //@@MP - unused parameter (Release 5-7), added weather parameter (Release 6-2)
                                {
                                    DoRepairFortification(player, fort);
                                    RedrawPlayScreen();
                                    loop = false;
                                    actionDone = true;
                                }
                                else
                                {
                                    AddMessage(MakeErrorMessage(String.Format("Cannot repair {0} : {1}.", fort.TheName, reason)));
                                }
                            }
                            else
                                AddMessage(MakeErrorMessage(String.Format("{0} cannot be repaired or barricaded.", mapObj.TheName)));
                        }
                        else
                            AddMessage(MakeErrorMessage("Nothing to barricade there."));
                    }
                }
            }
            while (loop);

            // cleanup.
            ClearOverlays();

            // return if we did an action.
            return actionDone;
        }

        bool HandlePlayerBreak(Actor player)
        {
            bool loop = true;
            bool actionDone = false;

            ClearOverlays();
            AddOverlay(new OverlayPopup(BREAK_MODE_TEXT, MODE_TEXTCOLOR, MODE_BORDERCOLOR, MODE_FILLCOLOR, new Point(0, 0)));

            do
            {
                ///////////////////
                // 1. Redraw
                // 2. Get input.
                // 3. Handle input
                ///////////////////

                // 1. Redraw
                RedrawPlayScreen();

                // 2. Get input.
                Direction dir = WaitDirectionOrCancel();

                // 3. Handle input
                if (dir == null)
                {
                    loop = false;
                }
                else
                {
                    // handle neutral direction = through exit.
                    if (dir == Direction.NEUTRAL)
                    {
                        Exit exitThere = player.Location.Map.GetExitAt(player.Location.Position);
                        if (exitThere == null)
                            AddMessage(MakeErrorMessage("No exit there."));
                        else
                        {
                            // attack/break?
                            string reason;
                            Map mapTo = exitThere.ToMap;
                            Actor actorTo = mapTo.GetActorAt(exitThere.ToPosition);
                            if (actorTo != null)
                            {
                                // only if enemy.
                                if (m_Rules.AreEnemies(player, actorTo))
                                {
                                    // check melee rule.
                                    if (m_Rules.CanActorMeleeAttack(player, actorTo, out reason))
                                    {
                                        DoMeleeAttack(player, actorTo);
                                        loop = false;
                                        actionDone = true;
                                    }
                                    else
                                        AddMessage(MakeErrorMessage(String.Format("Cannot attack {0} : {1}.", actorTo.Name, reason)));
                                }
                                else
                                    AddMessage(MakeErrorMessage(String.Format("{0} is not your enemy.", actorTo.Name)));
                            }
                            else
                            {
                                // break?
                                MapObject objTo = mapTo.GetMapObjectAt(exitThere.ToPosition);
                                if (objTo != null)
                                {
                                    // check break rule.
                                    if (m_Rules.IsBreakableFor(player, objTo, out reason))
                                    {
                                        DoBreak(player, objTo);
                                        loop = false;
                                        actionDone = true;
                                    }
                                    else
                                        AddMessage(MakeErrorMessage(String.Format("Cannot break {0} : {1}.", objTo.TheName, reason)));
                                }
                                else
                                    AddMessage(MakeErrorMessage("Nothing to break or attack on the other side."));
                            }

                        }
                    }
                    else
                    {
                        // adjacent direction.
                        Point pos = player.Location.Position + dir;
                        if (player.Location.Map.IsInBounds(pos))
                        {
                            MapObject mapObj = player.Location.Map.GetMapObjectAt(pos);
                            if (mapObj != null)
                            {
                                string reason;
                                if (m_Rules.IsBreakableFor(player, mapObj, out reason))
                                {
                                    DoBreak(player, mapObj);
                                    RedrawPlayScreen();
                                    loop = false;
                                    actionDone = true;
                                }
                                else
                                {
                                    AddMessage(MakeErrorMessage(String.Format("Cannot break {0} : {1}.", mapObj.TheName, reason)));
                                }
                            }
                            else
                                AddMessage(MakeErrorMessage("Nothing to break there."));
                        }
                    }
                }
            }
            while (loop);

            // cleanup.
            ClearOverlays();

            // return if we did an action.
            return actionDone;
        }

        bool HandlePlayerBuildFortification(Actor player)
        {
            //large or small? question player  //@@MP - turned it into a prompt to reduce keybindings (Release 6-6)
            AddOverlay(new OverlayPopup(BUILD_FORT_MODE, MODE_TEXTCOLOR, MODE_BORDERCOLOR, MODE_FILLCOLOR, Point.Empty));
            RedrawPlayScreen();

            bool isLarge = false;
            KeyEventArgs inKey = m_UI.UI_WaitKey(); //  Read input
            if (inKey.KeyCode == Keys.Escape) // Handle input
            {
                //AddMessage(new Message("Aborted building fortifications.", m_Session.WorldTime.TurnCounter, Color.White));
                ClearOverlays();
                RedrawPlayScreen();
                return false;
            }
            // get choice.
            else if (inKey.KeyCode == Keys.L)
                isLarge = true;
            else if (inKey.KeyCode == Keys.S)
                isLarge = false;
            else
            {
                AddMessage(MakeErrorMessage("Unhandled key error when building a fortification."));
                AddMessage(MakeErrorMessage("Did you perhaps hit the wrong key?"));
                ClearOverlays();
                RedrawPlayScreen();
                return false;
            }
            ClearOverlays();
            RedrawPlayScreen();

            /////////////////////////////////////
            // Check skill & has enough material.
            /////////////////////////////////////
            if (player.Sheet.SkillTable.GetSkillLevel((int)Skills.IDs.CARPENTRY) == 0)
            {
                AddMessage(MakeErrorMessage("need carpentry skill."));
                return false;
            }
            int need = m_Rules.ActorBarricadingMaterialNeedForFortification(player, isLarge);
            if (m_Rules.CountBarricadingMaterial(player) < need)
            {
                AddMessage(MakeErrorMessage(string.Format("not enough barricading material, need {0}.", need)));
                return false;
            }

            bool loop = true;
            bool actionDone = false;

            ClearOverlays();
            AddOverlay(new OverlayPopup(isLarge ? BUILD_LARGE_FORT_MODE_TEXT : BUILD_SMALL_FORT_MODE_TEXT, MODE_TEXTCOLOR, MODE_BORDERCOLOR, MODE_FILLCOLOR, new Point(0, 0)));

            do
            {
                ///////////////////
                // 1. Redraw
                // 2. Get input.
                // 3. Handle input
                ///////////////////

                // 1. Redraw
                RedrawPlayScreen();

                // 2. Get input.
                Direction dir = WaitDirectionOrCancel();

                // 3. Handle input
                if (dir == null)
                {
                    loop = false;
                }
                else if (dir != Direction.NEUTRAL)
                {
                    Point pos = player.Location.Position + dir;
                    if (player.Location.Map.IsInBounds(pos))
                    {
                        string reason;
                        if (m_Rules.CanActorBuildFortification(player, pos, isLarge, m_Session.World.Weather, out reason)) //@@MP - added weather parameter (Release 6-2)
                        {
                            DoBuildFortification(player, pos, isLarge);
                            RedrawPlayScreen();
                            loop = false;
                            actionDone = true;
                        }
                        else
                        {
                            AddMessage(MakeErrorMessage(String.Format("Cannot build here : {0}.", reason)));
                        }
                    }
                }
            }
            while (loop);

            // cleanup.
            ClearOverlays();

            // return if we did an action.
            return actionDone;
        }

        bool HandlePlayerBuryCorpse(Actor player, Point mousePos) //@@MP (Release 7-6)
        {
            // Ignore if not on a corpse slot.
            Point corpsePos;
            Corpse corpse = MouseToCorpse(mousePos, out corpsePos);
            if (corpse == null)
                return false;

            Point pos = player.Location.Position;
            Tile tile = player.Location.Map.GetTileAt(pos);

            // 1. check that a player is standing on soil (grass or dirt). it must be clear ground, soil, and empty of objects
            MapObject objectThere = player.Location.Map.GetMapObjectAt(pos);
            bool removeMapOject = false;
            if (objectThere != null)
            {
                switch (objectThere.AName) //let the player dig up plants in order to bury there
                {
                    case "a berry bush": removeMapOject = true; break;
                    case "a peanut plant": removeMapOject = true; break;
                    case "a grape vine": removeMapOject = true; break;
                }

                if (!removeMapOject)
                {
                    AddMessage(new Message("Cannot bury corpse here: object in the way.", m_Session.WorldTime.TurnCounter, Color.Red));
                    return false;
                }
            }
            else if (!GameTiles.CanBuryCorpseHere(tile.Model))
            {
                AddMessage(new Message("Cannot bury corpse here: find a spot with soil.", m_Session.WorldTime.TurnCounter, Color.Red));
                return false;
            }

            // 2. check that the player has the necessary equipment that can dig (ie. shovel or pickaxe) and a plank of wood
            Item it = player.GetEquippedWeapon() as ItemMeleeWeapon;
            if (it == null || (!(it.Model as ItemMeleeWeaponModel).CanUseForDigging))
            {
                AddMessage(new Message("You need to equip a shovel or pickaxe.", m_Session.WorldTime.TurnCounter, Color.Red));
                return false;
            }
            if (!player.Inventory.HasItemOfType(typeof(ItemBarricadeMaterial)))
            {
                AddMessage(new Message("You need at least one plank of wood.", m_Session.WorldTime.TurnCounter, Color.Red));
                return false;
            }

            // 3. determine corpse and cross image
#if false
            //TODO
            //TODO
            //this was the start of developing a non-mouse way of burying corpses, which could also have been used for eating and reviving them
            //I abandoned it due to time constraints, but left in for possible future implementation

            List<Corpse> corpses = player.Location.Map.GetCorpsesAt(pos);
            if (corpses != null)
            {
#region Select corpse
                Corpse selectedCorpse = corpses.First(); // automatically choose the first corpse by default, unless there's more than one there...
                bool selectionCancelled = false;
                if (corpses.Count > 1)
                {
                    // loop
                    bool loop = true;
                    int iSelectedCorpse = -1;
                    int state = 0; // 0 selecting 1st item; 1 selecting 2nd item; 2 making the offer
                    List<String> lines = new List<string>();
                    List<Color> colors = new List<Color>();

                    do
                    {
                        ///////////////////
                        // 1. Redraw
                        // 2. Handle state
                        ///////////////////

                        // 1. Redraw

                        lines.Clear();
                        colors.Clear();

                        // list corpses
                        foreach (Corpse c in corpses)
                        {
                            lines.Add("-. " + c.DeadGuy.Name);
                            colors.Add(Color.Yellow);
                        }

                        // draw
                        ClearOverlays();
                        AddOverlay(new OverlayPopup(TRADING_DIALOG_MODE_TEXT, MODE_TEXTCOLOR, MODE_BORDERCOLOR, MODE_FILLCOLOR, new Point(0, 0)));
                        OverlayPopupTitleColors ov = new OverlayPopupTitleColors(
                            string.Format("Select which corpse to bury:"), Color.White,
                            lines.ToArray(), colors.ToArray(),
                            Color.White, Color.Black, new Point(32, 32));
                        AddOverlay(ov);
                        RedrawPlayScreen();

                        // 2. Handle input
                        KeyEventArgs inKey = m_UI.UI_WaitKey();

                        if (inKey.KeyCode == Keys.Escape)  // back/abort
                        {
                            selectionCancelled = true;
                            loop = false;
                        }
                        else
                        {
                            int slot = KeyToChoiceNumber(inKey.KeyCode);
                            if (slot != -1) // select a corpse
                            {
                                if (slot == 0) slot = 9;
                                else slot--;

                                if (slot < corpses.Count)
                                    iSelectedCorpse = slot;

                                selectedCorpse = corpses[iSelectedCorpse];

                                // done
                                loop = false;
                                AddMessagePressEnter();
                            }
                        }

                    }
                    while (loop);
                }
#endregion
#endif

            string crossImage = GameImages.OBJ_BURIAL_CROSS_GRASS; //placeholder
            if (tile.Model == GameTiles.FLOOR_DIRT)
                crossImage = GameImages.OBJ_BURIAL_CROSS_DIRT;
            else if (tile.Model == GameTiles.FLOOR_GRASS)
                crossImage = GameImages.OBJ_BURIAL_CROSS_GRASS;
            else if (tile.Model == GameTiles.FLOOR_PLANTED)
            {
                crossImage = GameImages.OBJ_BURIAL_CROSS_GRASS;
                player.Location.Map.SetTileModelAt(pos.X, pos.Y, GameTiles.FLOOR_GRASS); //get rid of the plant
            }
            else
            {
                AddMessage(MakeErrorMessage(String.Format("<Cannot dig here. Please report this bug to the devs.>"))); //somehow slipped through the cracks. maybe someone changed/added tile models?
                return false;
            }

            // 4. no issues so proceed: remove corpse and place decal
            Item material = player.Inventory.GetFirstByType(typeof(ItemBarricadeMaterial)); //.GetFirstMatching((it) => it is ItemBarricadeMaterial);
            --material.Quantity;
            DestroyCorpse(corpse, player.Location.Map);
            m_SFXManager.Play(GameSounds.DIG_GROUND, AudioPriority.PRIORITY_EVENT);
            if (removeMapOject)
                player.Location.Map.RemoveMapObjectAt(pos.X, pos.Y);
            player.Location.Map.PlaceMapObjectAt(m_TownGenerator.MakeObjBurialCross(crossImage, String.Format((char)34 + "Here lies {0}. RIP." + (char)34, corpse.DeadGuy.Name)), pos);
            AddMessage(MakeMessage(player, string.Format("buried {0}", corpse.DeadGuy.Name)));
            if (s_Options.IsSanityEnabled)
                RegenActorSanity(player, m_Rules.ActorSanRegenValue(player, Rules.SANITY_RECOVER_BOND));
            return true;
        }

        bool HandlePlayerCookFood(Actor player, Point mousepos) //@@MP (Release 7-6)
        {
            // get player inventory item under mouse.
            Inventory inv;
            Point itemPos;
            int iSlot; // alpha 10
            bool isBackpack; //@@MP (Release 8-2)
            Item item = MouseToInventoryItem(mousepos, out inv, out itemPos, out iSlot, out isBackpack);
            if (inv == null || inv != player.Inventory || item == null)
                return false;

            ItemFood food = item as ItemFood;
            string reason;
            if (m_Rules.CanActorCookFoodItem(player, food, out reason))
            {
                bool canCookHere = false;
                Point cookingFire = player.Location.Position; //placeholder
                Map map = player.Location.Map;
                foreach (Direction dir in Direction.COMPASS)
                {
                    Point pt = player.Location.Position + dir;

                    // Out of bounds.
                    if (!map.IsInBounds(pt))
                        continue;

                    // check mapobj in each dir for .IsOnFire
                    MapObject mapObj = map.GetMapObjectAt(pt);
                    if (mapObj != null && mapObj.IsOnFire)
                    {
                        Inventory fireInv = map.GetItemsAt(pt);
                        if (fireInv == null || inv.IsEmpty)
                        {
                            canCookHere = true;
                            cookingFire = pt;
                            //prefer receptacles and campfires over cars
                            if (mapObj is Barrel || mapObj is Campfire)
                                break;
                        }
                    }
                }
                if (canCookHere)
                {
                    DoCookFood(player, food, cookingFire);
                    return true;
                }
                else
                {
                    AddMessage(MakeErrorMessage("Cannot cook : no space left on the fire for the raw meat."));
                    return false;
                }
            }
            else
            {
                AddMessage(MakeErrorMessage(String.Format("Cannot cook {0} : {1}.", food.TheName, reason)));
                return false;
            }
        }

        void HandlePlayerDestroyItem(Actor player, Point mousepos) //@@MP (Release 7-6)
        {
            // get player inventory item under mouse.
            Inventory inv;
            Point itemPos;
            int iSlot; // alpha 10
            bool isBackpack; //@@MP (Release 8-2)
            Item it = MouseToInventoryItem(mousepos, out inv, out itemPos, out iSlot, out isBackpack);
            if (inv == null || it == null)
                return;
            if (inv != player.Inventory && !isBackpack) //@@MP (Release 8-2)
                return;

            AddMessage(MakeYesNoMessage(String.Format("Permanently destroy {0}", it.TheName)));
            RedrawPlayScreen();
            if (WaitYesOrNo())
            {
                inv.RemoveAllQuantity(it);
            }
            ClearMessages();
            RedrawPlayScreen();
        }

        bool HandlePlayerFireMode(Actor player)
        {
            bool loop = true;
            bool actionDone = false;
            bool hasFuelAmmo = false;    //@@MP (Release 7-5)

            // If grenade equipped, redirected to HandlePlayerThrowGrenade.
            ItemGrenade grenade = player.GetEquippedWeapon() as ItemGrenade;
            ItemGrenadePrimed primedGrenade = player.GetEquippedWeapon() as ItemGrenadePrimed;
            if (grenade != null || primedGrenade != null)
                return HandlePlayerThrowGrenade(player);

            //check how much fuel ammo is in inventory (for flamethrowers and flaming crossbow bolts)   //@@MP (Release 7-5)
            foreach (Item item in m_Player.Inventory.Items)
            {
                ItemAmmo fuelCan = item as ItemAmmo;
                if (fuelCan != null)
                {
                    if (fuelCan.Model == GameItems.AMMO_FUEL && fuelCan.Quantity > 0)
                    {
                        hasFuelAmmo = true;
                        break;
                    }
                }
            }

            // Check if weapon ready to fire.
            ItemRangedWeapon rangedWeapon = player.GetEquippedWeapon() as ItemRangedWeapon;
            if (rangedWeapon == null)
            {
                AddMessage(MakeErrorMessage("No weapon ready to fire."));
                RedrawPlayScreen();
                return false;
            }
            else if (rangedWeapon.AmmoType == AmmoType.FUEL) //@@MP - flamethrowers (Release 7-2)
            {
                if (rangedWeapon.Ammo <= 0 && !hasFuelAmmo)   //@@MP (Release 7-5)
                {
                    AddMessage(MakeErrorMessage("No fuel for ammo in inventory."));
                    RedrawPlayScreen();
                    return false;
                }
            }
            else if (rangedWeapon.Ammo <= 0)
            {
                AddMessage(MakeErrorMessage("No ammo loaded."));
                RedrawPlayScreen();
                return false;
            }

            // Get targeting data.
#region
            HashSet<Point> fov = LOS.ComputeFOVFor(this, player, m_Session.WorldTime, m_Session.World.Weather, true);   //@@MP - fixed to true (Release 7-5)
            //-- Actors
            List<Actor> potentialActorTargets = m_Rules.GetEnemiesInFov(player, fov);
            //-- The ones only relevant for firearms (bows won't cause explosions) //@@MP (Release 7-1)
            List<KeyValuePair<Item, Point>> potentialFuelCanTargets = new List<KeyValuePair<Item, Point>>(); //firearms can be used to shoot fuel cans on the ground
            List<KeyValuePair<MapObject, Point>> potentialFuelPumpTargets = new List<KeyValuePair<MapObject, Point>>(); //firearms can be used to shoot fuel pumps
            ItemRangedWeaponModel rm = rangedWeapon.Model as ItemRangedWeaponModel;
            if (rm.IsFireArm)
            {
                //-- Fuel cans (ammo)
                potentialFuelCanTargets = m_Rules.GetFuelCansInFov(player, fov);
                //-- Fuel pumps (mapobject)
                potentialFuelPumpTargets = m_Rules.GetFuelPumpsInFov(player, fov);
            }

            int totalTargetsByIndex = 0; int actorTargets = 0; int fuelCanTargets = 0; int fuelPumpTargets = 0;
            if (potentialActorTargets != null && potentialActorTargets.Count > 0)
            {
                actorTargets = potentialActorTargets.Count;
                totalTargetsByIndex += potentialActorTargets.Count;
            }
            if (potentialFuelCanTargets != null && potentialFuelCanTargets.Count > 0)
            {
                fuelCanTargets = potentialFuelCanTargets.Count;
                totalTargetsByIndex += potentialFuelCanTargets.Count;
            }
            if (potentialFuelPumpTargets != null && potentialFuelPumpTargets.Count > 0)
            {
                fuelPumpTargets = potentialFuelPumpTargets.Count;
                totalTargetsByIndex += potentialFuelPumpTargets.Count;
            }
            --totalTargetsByIndex; //account for zero-based numbering

            if (actorTargets == 0 && fuelCanTargets == 0 && fuelPumpTargets == 0)
            {
                AddMessage(MakeErrorMessage("No targets in range to fire at.")); //@@MP - specified "range" to account for light sources beyond standard FoV (Release 6-5)
                RedrawPlayScreen();
                return false;
            }
#endregion

            // Prepare the attack
            Attack rangedAttack = m_Rules.ActorRangedAttack(player, player.CurrentRangedAttack, 0, null);
            int iCurrentTarget = 0;
            List<Point> LoF = new List<Point>(rangedAttack.Range);
            FireMode mode;
            bool singleShot = (rangedWeapon.Model as ItemRangedWeaponModel).IsSingleShot; //@@MP - some weapons are single-shot = can't rapid fire (Release 6-6)
            bool rapidFireOnly = (rangedWeapon.Model == GameItems.MINIGUN); //@@MP - the minigun is rapid-fire only, it can't single-shot (Release 7-6)

            if (rapidFireOnly) //@@MP - for the newly added minigun (Release 7-6)
                mode = FireMode.RAPID;
            else if (rangedWeapon.AmmoType == AmmoType.BOLT && !hasFuelAmmo) //@@MP - bows can have flaming bolts, but only if carrying fuel (Release 7-2), fixed (Release 7-5)
                mode = FireMode.DEFAULT;  // alpha10
            else if (!singleShot) //rapid fire-capable firearms
                mode = m_Session.Player_CurrentFireMode;  // alpha10
            else
                mode = FireMode.DEFAULT;
            m_Session.Player_CurrentFireMode = mode; //@@MP - enforce the mode in case of change eg switch from firearm to bow, or ran out of fuel (Release 7-2)

            // Loop.
            do
            {
                LoF.Clear();
                string reason = null;
                string modeDesc = null; // alpha 10
                bool canFireAtTarget = false;
                int dToTarget = 0;
                //@@MP - now that we can target either Actor or Item we need a way to handle both (Release 7-1)
                string targetType = null;
                Point targetPoint = new Point();
                Actor currentActorTarget = null;
                Item currentFuelCanTarget = null;
                MapObject currentFuelPumpTarget = null;

                //GET NEXT TARGET
#region
                if (actorTargets > 0 && iCurrentTarget < potentialActorTargets.Count) //run through any actors
                {
                    targetType = "Actor";
                    currentActorTarget = potentialActorTargets[iCurrentTarget];
                    targetPoint = currentActorTarget.Location.Position;
                    canFireAtTarget = m_Rules.CanActorFireAt(player, currentActorTarget, LoF, out reason);

                    if (mode == FireMode.RAPID)
                        modeDesc = string.Format("RAPID fire mode average hit chances {0}% {1}%", m_Rules.ComputeChancesRangedHit(player, currentActorTarget, 1), m_Rules.ComputeChancesRangedHit(player, currentActorTarget, 2));
                    else if (mode == FireMode.FLAMING) //@@MP - new fire mode for bows (Release 7-2)
                        modeDesc = string.Format("FLAMING shot average hit chance {0}%", m_Rules.ComputeChancesRangedHit(player, currentActorTarget, 0));
                    else
                        modeDesc = string.Format("Normal fire mode average hit chance {0}%", m_Rules.ComputeChancesRangedHit(player, currentActorTarget, 0));
                }
                else if ((fuelCanTargets > 0) && (iCurrentTarget < (actorTargets + fuelCanTargets))) //@@MP - now any fuel cans (Release 7-1), fixed (Release 7-3)
                {
                    int indexAdjustedForActorsCount = (actorTargets > 0) ? 0 : (iCurrentTarget);

                    targetType = "Item";
                    currentFuelCanTarget = potentialFuelCanTargets[indexAdjustedForActorsCount].Key;
                    targetPoint = potentialFuelCanTargets[indexAdjustedForActorsCount].Value;
                    canFireAtTarget = m_Rules.CanActorFireAt(player, targetPoint, LoF, out reason);

                    if (mode == FireMode.RAPID)
                        modeDesc = string.Format("RAPID fire average hit chances {0}% {1}%", m_Rules.ComputeChancesRangedHitOnItem(player, targetPoint, 1), m_Rules.ComputeChancesRangedHitOnItem(player, targetPoint, 2));
                    else
                        modeDesc = string.Format("Normal fire average hit chance {0}%", m_Rules.ComputeChancesRangedHitOnItem(player, targetPoint, 0));
                }
                else if (fuelPumpTargets > 0 && iCurrentTarget <= totalTargetsByIndex) //@@MP - now any fuel pumps (Release 7-1)
                {
                    int indexAdjustedForActorsCount = (actorTargets > 0) ? (iCurrentTarget - actorTargets) : (iCurrentTarget);
                    int indexAdjustedForFuelCansCount = (fuelCanTargets > 0) ? (indexAdjustedForActorsCount - fuelCanTargets) : (indexAdjustedForActorsCount);

                    targetType = "MapObject";
                    currentFuelPumpTarget = potentialFuelPumpTargets[indexAdjustedForFuelCansCount].Key;
                    targetPoint = potentialFuelPumpTargets[indexAdjustedForFuelCansCount].Value;
                    canFireAtTarget = m_Rules.CanActorFireAt(player, targetPoint, LoF, out reason);

                    if (mode == FireMode.RAPID)
                        modeDesc = string.Format("RAPID fire average hit chances {0}% {1}%", m_Rules.ComputeChancesRangedHitOnItem(player, targetPoint, 1), m_Rules.ComputeChancesRangedHitOnItem(player, targetPoint, 2));
                    else
                        modeDesc = string.Format("Normal fire average hit chance {0}%", m_Rules.ComputeChancesRangedHitOnItem(player, targetPoint, 0));
                }
#endregion

                ///////////////////
                // 1. Redraw
                // 2. Get input.
                // 3. Handle input
                ///////////////////

                // 1. Redraw
                List<string> overlayPopupText = new List<string>(); // alpha 10
                overlayPopupText.AddRange(FIRE_MODE_TEXT); // alpha 10
                overlayPopupText.Add(modeDesc); // alpha 10
                ClearOverlays();
                AddOverlay(new OverlayPopup(overlayPopupText.ToArray(), MODE_TEXTCOLOR, MODE_BORDERCOLOR, MODE_FILLCOLOR, new Point(0, 0)));
                Point targetScreen = MapToScreen(targetPoint);
                AddOverlay(new OverlayImage(targetScreen, GameImages.ICON_TARGET));
                dToTarget = m_Rules.GridDistance(player.Location.Position, targetPoint);
                string lineImage = canFireAtTarget ? (dToTarget <= rangedAttack.EfficientRange ? GameImages.ICON_LINE_CLEAR : GameImages.ICON_LINE_BAD) : GameImages.ICON_LINE_BLOCKED;
                foreach (Point pt in LoF)
                {
                    Point screenPt = MapToScreen(pt);
                    AddOverlay(new OverlayImage(screenPt, lineImage));
                }
                RedrawPlayScreen();

                // 2. Get input.
                KeyEventArgs key = m_UI.UI_WaitKey();
                //PlayerCommand command = InputTranslator.KeyToCommand(key); //@@MP - unused (Release 5-7)

                // 3. Handle input
                if (key.KeyCode == Keys.Escape) //command == PlayerCommand.EXIT_OR_CANCEL)
                {
                    loop = false;
                }
                else if (key.KeyCode == Keys.T)  // next target
                {
                    //iCurrentTarget = (iCurrentTarget + 1) % totalTargetsByCount;  // <============================================== LOOP THROUGH LIST/S
                    ++iCurrentTarget;
                    if (iCurrentTarget > totalTargetsByIndex)
                        iCurrentTarget = 0;
                }
                else if (key.KeyCode == Keys.M)    // next mode
                {
                    ItemRangedWeaponModel rWm = rangedWeapon.Model as ItemRangedWeaponModel;
                    if (rWm.IsBow) //@@MP - split out firearms and bows for the new flaming bolts (Release 7-2)
                    {
                        bool switched = false;
                        // switch. 
                        if (m_Player.Sheet.SkillTable.GetSkillLevel((int)Skills.IDs.BOWS_EXPLOSIVES) > 0)
                        {
                            if (m_Session.Player_CurrentFireMode == FireMode.DEFAULT) //switching to flaming
                            {
                                if (hasFuelAmmo)  //@@MP - fixed (Release 7-5)
                                {
                                    mode = FireMode.FLAMING; // save preference to session // alpha10
                                    switched = true;
                                }
                                else
                                    AddMessage(new Message(String.Format("Need fuel to make flaming bolts"), m_Session.WorldTime.TurnCounter, Color.Red));
                            }
                            else //flaming mode already
                            {
                                mode = FireMode.DEFAULT;
                                switched = true;
                            }

                            // tell.
                            if (switched) AddMessage(new Message(String.Format("Switched to {0} fire mode.", mode.ToString()), m_Session.WorldTime.TurnCounter, Color.Yellow));
                        }
                        else
                        {
                            AddMessage(new Message(String.Format("Need one level of Bows skill to use flaming bolts"), m_Session.WorldTime.TurnCounter, Color.Red));
                            mode = FireMode.DEFAULT;
                        }
                    }
                    else if (rapidFireOnly) //@@MP (Release 7-6)
                    {
                        AddMessage(new Message(String.Format("{0} is rapid-fire only.", rangedWeapon.Model.SingleName), m_Session.WorldTime.TurnCounter, Color.Red));
                    }
                    else
                    {
                        if (singleShot) //@@MP - some weapons are single-shot = can't rapid fire (Release 6-6)
                        {
                            AddMessage(new Message(String.Format("{0} is single shot only, it cannot rapid fire.", rangedWeapon.Model.SingleName), m_Session.WorldTime.TurnCounter, Color.Red));
                            mode = FireMode.DEFAULT;
                        }
                        else
                        {
                            // switch.
                            if (m_Session.Player_CurrentFireMode == FireMode.DEFAULT) //@@MP - avoid the new bows flaming mode (Release 7-2)
                                mode = FireMode.RAPID;
                            else
                                mode = FireMode.DEFAULT;
                            // tell.
                            AddMessage(new Message(String.Format("Switched to {0} fire mode.", mode.ToString()), m_Session.WorldTime.TurnCounter, Color.Yellow));
                        }
                    }
                    // save preference to session // alpha10
                    m_Session.Player_CurrentFireMode = mode;
                }
                else if (key.KeyCode == Keys.F) // do fire
                {
                    if (canFireAtTarget) //do the attack
                    {
                        if (targetType == "Actor")
                            DoRangedAttack(player, currentActorTarget, LoF, mode);
                        else if (targetType == "Item")
                            DoRangedAttackAtFuelExplosives(player, targetPoint, LoF, mode, currentFuelCanTarget);
                        else if (targetType == "MapObject")
                            DoRangedAttackAtFuelExplosives(player, targetPoint, LoF, mode, currentFuelPumpTarget);
                        else
                            throw new InvalidOperationException("Unexpected targetType");

                        RedrawPlayScreen();
                        loop = false;
                        actionDone = true;
                    }
                    else
                    {
                        string targetName;
                        switch (targetType)
                        {
                            case "Actor": targetName = currentActorTarget.TheName; break;
                            case "Item": targetName = currentFuelCanTarget.TheName; break;
                            case "MapObject": targetName = currentFuelPumpTarget.TheName; break;
                            default: throw new InvalidOperationException("Unexpected targetType");
                        }
                        AddMessage(MakeErrorMessage(String.Format("Can't fire at {0} : {1}.", targetName, reason)));
                    }
                }
            }
            while (loop);

            // cleanup.
            ClearOverlays();

            // return if we did an action.
            return actionDone;
        }

        bool HandlePlayerMakeFireForCooking(Actor player) //@@MP (Release 7-6)
        {
            // get player inventory items
            Inventory inv = player.Inventory;
            if (inv == null)
            {
                AddMessage(MakeErrorMessage("You must equip matches in order to make fires."));
                return false;
            }

            Item item = player.GetEquippedItem(DollPart.LEFT_HAND);
            if (item == null || item.Model != GameItems.MATCHES)
            {
                AddMessage(MakeErrorMessage("You must equip matches in order to make fires."));
                return false;
            }

            // handle make fire.
            bool loop = true;
            bool actionDone = false;
            ClearOverlays();
            AddOverlay(new OverlayPopup(START_FIRE_MODE_TEXT, MODE_TEXTCOLOR, MODE_BORDERCOLOR, MODE_FILLCOLOR, new Point(0, 0)));
            do
            {
                ///////////////////
                // 1. Redraw
                // 2. Get input.
                // 3. Handle input
                ///////////////////

                // 1. Redraw
                AddMessage(new Message("Choose a receptacle or a clear spot for a campfire...", m_Session.WorldTime.TurnCounter, Color.Yellow));
                RedrawPlayScreen();

                // 2. Get input.
                Direction dir = WaitDirectionOrCancel();

                // 3. Handle input
                if (dir == null)
                {
                    loop = false;
                }
                else if (dir != Direction.NEUTRAL)  //get direction
                {
                    Point pos = player.Location.Position + dir;
                    
                    if (player.Location.Map.IsInBounds(pos))
                    {
                        string reason;
                        if (!m_Rules.CanStartCookingFire(player, pos, m_Session.World.Weather, out reason))
                            AddMessage(MakeErrorMessage(String.Format("Can't light fire there : {0}.", reason)));
                        else
                        {
                            // do it.
                            actionDone = true;
                            loop = false;
                            DoMakeFireForCooking(player, pos);
                        }
                    }
                }
            }
            while (loop);

            // cleanup.
            ClearOverlays();

            // return if we did an action.
            return actionDone;
        }

        void HandlePlayerMarkEnemies(Actor player)
        {
            // Pre-conditions.
            // FIXME put all that into a rule Rule.CanMakeEnemyOf()
            if (player.Model.Abilities.IsUndead)
            {
                AddMessage(MakeErrorMessage("Undeads can't have personal enemies."));
                return;
            }

            // List all visible actors.
#region
            Map map = player.Location.Map;
            List<Actor> visibleActors = new List<Actor>();
            foreach (Point p in m_PlayerFOV)
            {
                Actor a = map.GetActorAt(p);
                if (a == null || a.IsPlayer)
                    continue;
                visibleActors.Add(a);
            }
            if (visibleActors.Count == 0)
            {
                AddMessage(MakeErrorMessage("No visible actors to mark."));
                RedrawPlayScreen();
                return;
            }
#endregion

            // Loop.
            bool loop = true;
            int iCurrentActor = 0;
            do
            {
                Actor currentActor = visibleActors[iCurrentActor];

                ///////////////////
                // 1. Redraw
                // 2. Get input.
                // 3. Handle input
                ///////////////////

                // 1. Redraw
                ClearOverlays();
                AddOverlay(new OverlayPopup(MARK_ENEMIES_MODE, MODE_TEXTCOLOR, MODE_BORDERCOLOR, MODE_FILLCOLOR, new Point(0, 0)));
                Point targetScreen = MapToScreen(currentActor.Location.Position);
                AddOverlay(new OverlayImage(targetScreen, GameImages.ICON_TARGET));
                RedrawPlayScreen();

                // 2. Get input.
                KeyEventArgs key = m_UI.UI_WaitKey();
                //PlayerCommand command = InputTranslator.KeyToCommand(key); //@@MP - unused (Release 5-7)

                // 3. Handle input
                if (key.KeyCode == Keys.Escape)// command == PlayerCommand.EXIT_OR_CANCEL)
                {
                    loop = false;
                }
                else if (key.KeyCode == Keys.T)  // next actor
                {
                    iCurrentActor = (iCurrentActor + 1) % visibleActors.Count;
                }

                else if (key.KeyCode == Keys.E) // toggle.
                {
                    // never make enemies of leader/follower/enemy faction.
                    // FIXME put all that into a rule Rule.CanMakeEnemyOf()
                    bool allowed = true;
                    if (currentActor.Leader == player)
                    {
                        AddMessage(MakeErrorMessage("Can't make a follower your enemy."));
                        allowed = false;
                    }
                    else if (player.Leader == currentActor)
                    {
                        AddMessage(MakeErrorMessage("Can't make your leader your enemy."));
                        allowed = false;
                    }
                    else if (m_Rules.AreEnemies(m_Player, currentActor))
                    {
                        AddMessage(MakeErrorMessage("Already enemies."));
                        allowed = false;
                    }

                    // do it?
                    if (allowed)
                    {
                        AddMessage(new Message(String.Format("{0} is now a personal enemy.", currentActor.TheName), m_Session.WorldTime.TurnCounter, Color.Orange));
                        DoMakeAggression(player, currentActor);
                    }
                }
            }
            while (loop);

            // cleanup.
            ClearOverlays();
        }

        bool HandlePlayerThrowGrenade(Actor player)
        {
            bool loop = true;
            bool actionDone = false;

            // Get grenade equipped.
            ItemGrenade unprimedGrenade = player.GetEquippedWeapon() as ItemGrenade;
            ItemGrenadePrimed primedGrenade = player.GetEquippedWeapon() as ItemGrenadePrimed;
            if (unprimedGrenade == null && primedGrenade == null)
            {
                AddMessage(MakeErrorMessage("No grenade to throw."));
                RedrawPlayScreen();
                return false;
            }
            ItemGrenadeModel grenadeModel;
            if (unprimedGrenade != null)
                grenadeModel = unprimedGrenade.Model as ItemGrenadeModel;
            else
                grenadeModel = (primedGrenade.Model as ItemGrenadePrimedModel).GrenadeModel;

            // Get data.
            Map map = player.Location.Map;
            Point targetThrow = player.Location.Position;
            int maxThrowDist = m_Rules.ActorMaxThrowRange(player, grenadeModel.MaxThrowDistance);

            // Loop.
            List<Point> LoT = new List<Point>();
            do
            {
                // get LoT.
                LoT.Clear();
                string reason;
                bool canThrowAtTarget = m_Rules.CanActorThrowGrenadeTo(player, targetThrow, LoT, out reason);

                ///////////////////
                // 1. Redraw
                // 2. Get input.
                // 3. Handle input
                ///////////////////

                // 1. Redraw
                ClearOverlays();
                AddOverlay(new OverlayPopup(THROW_MODE_TEXT, MODE_TEXTCOLOR, MODE_BORDERCOLOR, MODE_FILLCOLOR, new Point(0, 0)));
                //line of throw
                string lineImage = canThrowAtTarget ? GameImages.ICON_LINE_CLEAR : GameImages.ICON_LINE_BLOCKED;
                foreach (Point pt in LoT)
                {
                    Point screenPt = MapToScreen(pt);
                    AddOverlay(new OverlayImage(screenPt, lineImage));
                }
                //warn if friendlies in blast radius (civilians in the blast radius will become aggrevated by the thrower) //@@MP (Release 7-2)
                int halfBlastRadius = Convert.ToInt32((grenadeModel as ItemExplosiveModel).BlastAttack.Radius / 2);
                int provocationRadius = Math.Max(1, halfBlastRadius);
                List<Actor> actorsNearbyTargetPos = GetActorsInGivenRadius(map, targetThrow, provocationRadius);
                if (actorsNearbyTargetPos != null)
                {
                    foreach (Actor a in actorsNearbyTargetPos)
                    {
                        if (!a.IsPlayer && !m_Rules.AreEnemies(player, a) && (grenadeModel as ItemExplosiveModel).BlastAttack.IsProvocative)
                        {
                            AddOverlay(new OverlayPopup(new string[] { "Non-enemies are in the blast radius and may be provoked" }, MODE_TEXTCOLOR, MODE_BORDERCOLOR, MODE_FILLCOLOR, new Point(0, 2 * LINE_SPACING)));
                            break;
                        }
                    }
                }
                RedrawPlayScreen();

                // 2. Get input.
                KeyEventArgs key = m_UI.UI_WaitKey();
                PlayerCommand command = InputTranslator.KeyToCommand(key);

                // 3. Handle input
                if (key.KeyCode == Keys.Escape)// command == PlayerCommand.EXIT_OR_CANCEL)
                {
                    loop = false;
                }
                else if (key.KeyCode == Keys.F) // do throw.
                {
                    if (canThrowAtTarget)
                    {
                        bool doIt = true;

                        // if within the blast radius, ask for confirmation...
                        if (m_Rules.GridDistance(player.Location.Position, targetThrow) <= grenadeModel.BlastAttack.Radius)
                        {
                            ClearMessages();
                            AddMessage(new Message("You are in the blast radius!", m_Session.WorldTime.TurnCounter, Color.Yellow));
                            AddMessage(MakeYesNoMessage("Really throw there"));
                            RedrawPlayScreen();
                            doIt = WaitYesOrNo();
                            ClearMessages();
                            RedrawPlayScreen();
                        }

                        if (doIt)
                        {
                            // fire in the hole!
                            if (unprimedGrenade != null)
                                DoThrowGrenadeUnprimed(player, targetThrow);
                            else
                                DoThrowGrenadePrimed(player, targetThrow);
                            RedrawPlayScreen();
                            loop = false;
                            actionDone = true;
                        }
                    }
                    else
                    {
                        AddMessage(MakeErrorMessage(String.Format("Can't throw there : {0}.", reason)));
                    }
                }
                else
                {
                    // direction?
                    Direction dir = CommandToDirection(command);
                    if (dir != null)
                    {
                        Point pos = targetThrow + dir;
                        if (map.IsInBounds(pos) && m_Rules.GridDistance(player.Location.Position, pos) <= maxThrowDist)
                            targetThrow = pos;
                    }
                }
            }
            while (loop);

            // cleanup.
            ClearOverlays();

            // return if we did an action.
            return actionDone;
        }

        bool HandlePlayerSleep(Actor player)
        {
            // Check rule.
            string reason;
            if (!m_Rules.CanActorSleep(player, out reason))
            {
                AddMessage(MakeErrorMessage(String.Format("Cannot sleep now : {0}.", reason)));
                return false;
            }

            // Ask for confirmation.
            AddMessage(MakeYesNoMessage("Really sleep there"));
            RedrawPlayScreen();
            bool confirm = WaitYesOrNo();
            if (!confirm)
            {
                AddMessage(new Message("Good, keep those eyes wide open.", m_Session.WorldTime.TurnCounter, Color.Yellow));
                return false;
            }

            // Start sleeping.
            AddMessage(new Message("Goodnight, happy nightmares!", m_Session.WorldTime.TurnCounter, Color.Yellow));
            DoStartSleeping(player);
            RedrawPlayScreen();
            // check music.
            m_MusicManager.StopAll();
            m_AmbientSFXManager.StopAll(); //@@MP (Release 6-6)
            m_SFXManager.StopAll(); //@@MP (Release 6-6)
            m_MusicManager.PlayLooping(GameMusics.SLEEP, AudioPriority.PRIORITY_EVENT);
            return true;
        }

        bool HandlePlayerSwapItemInventory(Actor player, Point screen) //@@MP (Release 8-2)
        {
            bool actionDone = false;
            // get player/backpack inventory item under mouse.
            Inventory inv;
            Point itemPos;
            int iSlot; // alpha 10
            bool isBackpack; //@@MP (Release 8-2)
            Item it = MouseToInventoryItem(screen, out inv, out itemPos, out iSlot, out isBackpack, true);
            if (inv == null || it == null)
                return false;
            if (inv != player.Inventory && !isBackpack)
                return false;
            else if (!player.Inventory.HasItemOfType(typeof(ItemBackpack)))
            {
                AddMessage(MakeErrorMessage("You aren't carrying a backpack."));
                return false;
            }
            ItemBackpack backPack = player.Inventory.GetFirstByType(typeof(ItemBackpack)) as ItemBackpack;

            // try swap item.
            bool promptForSwap = false;
            if (!isBackpack) //inventory -> backpack
            {
                string reason;
                if (!backPack.Inventory.IsFull || backPack.Inventory.CanAddAtLeastOne(it))
                {
                    if (m_Rules.CanActorMoveItemToBackpack(player, it, backPack, false, out reason))
                    {
                        // do it.
                        //DoGiveItemTo(player, other, gift);
                        //backPack.Inventory.AddAll(it);
                        //inv.RemoveAllQuantity(it);

                        //TODO: this needs to handle adding to stacks whilst leaving a remainder
                        // add to inventory.
                        int quantityAdded;
                        int quantityBefore = it.Quantity;
                        backPack.Inventory.AddAsMuchAsPossible(it, out quantityAdded);

                        // if added all, remove from inv.
                        if (quantityAdded == quantityBefore)
                        {
                            //Inventory itemsThere = map.GetItemsAt(position);
                            //if (itemsThere != null && itemsThere.Contains(it))
                            if (player.Inventory.Contains(it))
                                player.Inventory.RemoveAllQuantity(it);
                        }

                        actionDone = true;
                    }
                    else
                    {
                        AddMessage(MakeErrorMessage(String.Format("Can't move {0} to {1} : {2}.", it.TheName, backPack.TheName, reason)));
                        actionDone = false;
                    }
                }
                else
                    promptForSwap = true;
            }
            else //backpack -> inventory
            {
                if (!player.Inventory.IsFull || player.Inventory.CanAddAtLeastOne(it))
                {
                    //inv.AddAll(it);
                    //backPack.Inventory.RemoveAllQuantity(it);

                    //TODO: this needs to handle adding to stacks whilst leaving a remainder. for example, they may be trying to top up their ammo from their backpack
                    // add to inventory.
                    int quantityAdded;
                    int quantityBefore = it.Quantity;
                    player.Inventory.AddAsMuchAsPossible(it, out quantityAdded);

                    // if added all, remove from inv.
                    if (quantityAdded == quantityBefore)
                    {
                        //Inventory itemsThere = map.GetItemsAt(position);
                        //if (itemsThere != null && itemsThere.Contains(it))
                        if (backPack.Inventory.Contains(it))
                            backPack.Inventory.RemoveAllQuantity(it);
                    }

                    actionDone = true;
                }
                else
                    promptForSwap = true;
            }

            if (promptForSwap)
            {
                //TODO: To swap items to or from, you first select the item to move, then the corresponding item to swap with if the destination is full.
                // the player's inventory is full, so we'll ask them if they want to swap the item from their backpack with one from their inventory.
                bool loop = true;
                ClearOverlays();
                if (isBackpack)
                    AddOverlay(new OverlayPopup(SWAP_ITEM_INVENTORY_MODE_TEXT, MODE_TEXTCOLOR, MODE_BORDERCOLOR, MODE_FILLCOLOR, new Point(0, 0)));
                else
                    AddOverlay(new OverlayPopup(SWAP_ITEM_BACKPACK_MODE_TEXT, MODE_TEXTCOLOR, MODE_BORDERCOLOR, MODE_FILLCOLOR, new Point(0, 0)));
                RedrawPlayScreen();
                do
                {
                    KeyEventArgs key = m_UI.UI_WaitKey();
                    int choice = KeyToChoiceNumber(key.KeyCode);
                    if (key.KeyCode == Keys.Escape)
                    {
                        loop = false;
                    }
                    else if (choice != -1) // select an item
                    {
                        int slot = choice;
                        if (slot == 0) slot = 9;
                        else slot--;

                        if (isBackpack)
                        {
                            Item swapItem = null;
                            if (slot < player.Inventory.CountItems)
                            {
                                swapItem = player.Inventory[slot];
                            }

                            //player has selected an item slot from their inventory
                            if (swapItem != null)
                            {
                                string reason;
                                if (swapItem is ItemBackpack) //can't swap if user picks inv slot of the backpack itself
                                    AddMessage(MakeErrorMessage("That's your backpack. Choose a different item."));
                                else if (m_Rules.CanActorMoveItemToBackpack(player, swapItem, backPack, false, out reason))
                                {
                                    // do it.
                                    int quantityAdded;
                                    Inventory temp = new Inventory(1);
                                    temp.AddAsMuchAsPossible(swapItem, out quantityAdded);
                                    player.Inventory.RemoveAllQuantity(swapItem);

                                    player.Inventory.AddAll(it);
                                    backPack.Inventory.RemoveAllQuantity(it);

                                    backPack.Inventory.AddAll(swapItem);
                                    temp.RemoveAllQuantity(swapItem);

                                    actionDone = true;
                                    loop = false;
                                }
                                else
                                    AddMessage(MakeErrorMessage(String.Format("Can't swap {0} to {1} : {2}.", swapItem.TheName, backPack.TheName, reason)));
                            }
                        }
                        else
                        {
                            Item swapItem = null;
                            if (slot < backPack.Inventory.CountItems)
                            {
                                swapItem = backPack.Inventory[slot];
                            }

                            //player has selected an item slot from their backpack
                            if (swapItem != null)
                            {
                                string reason;
                                if (m_Rules.CanActorMoveItemToBackpack(player, it, backPack, false, out reason))
                                {
                                    // do it.
                                    int quantityAdded;
                                    Inventory temp = new Inventory(1);
                                    temp.AddAsMuchAsPossible(it, out quantityAdded);
                                    player.Inventory.RemoveAllQuantity(it);

                                    player.Inventory.AddAll(swapItem);
                                    backPack.Inventory.RemoveAllQuantity(swapItem);

                                    backPack.Inventory.AddAll(it);
                                    temp.RemoveAllQuantity(it);

                                    actionDone = true;
                                    loop = false;
                                }
                                else
                                    AddMessage(MakeErrorMessage(String.Format("Can't swap {0} to {1} : {2}.", it.TheName, backPack.TheName, reason)));
                            }
                        }
                    }
                    RedrawPlayScreen();
                }
                while (loop);
            }

            // cleanup.
            ClearOverlays();

            // spend APs.
            if (actionDone)
                SpendActorActionPoints(player, Rules.BASE_ACTION_COST);

            // return if we did an action.
            return actionDone;
        }

        bool HandlePlayerSwitchPlace(Actor player)
        {
            bool loop = true;
            bool actionDone = false;

            ClearOverlays();
            AddOverlay(new OverlayPopup(SWITCH_PLACE_MODE_TEXT, MODE_TEXTCOLOR, MODE_BORDERCOLOR, MODE_FILLCOLOR, new Point(0, 0)));

            do
            {
                ///////////////////
                // 1. Redraw
                // 2. Get input.
                // 3. Handle input
                ///////////////////

                // 1. Redraw
                RedrawPlayScreen();

                // 2. Get input.
                Direction dir = WaitDirectionOrCancel();

                // 3. Handle input
                if (dir == null)
                {
                    loop = false;
                }
                else if (dir != Direction.NEUTRAL)
                {
                    Point pos = player.Location.Position + dir;
                    if (player.Location.Map.IsInBounds(pos))
                    {
                        Actor other = player.Location.Map.GetActorAt(pos);
                        if (other != null)
                        {
                            string reason;
                            if (m_Rules.CanActorSwitchPlaceWith(player, other, out reason))
                            {
                                // switch place.
                                actionDone = true;
                                loop = false;
                                DoSwitchPlace(player, other);
                            }
                            else
                            {
                                AddMessage(MakeErrorMessage(String.Format("Can't switch place : {0}", reason)));
                            }
                        }
                        else
                            AddMessage(MakeErrorMessage("Noone there."));
                    }
                }
            }
            while (loop);

            // cleanup.
            ClearOverlays();

            // return if we did an action.
            return actionDone;
        }

        bool HandlePlayerTakeLead(Actor player)
        {
            bool loop = true;
            bool actionDone = false;

            ClearOverlays();
            AddOverlay(new OverlayPopup(TAKE_LEAD_MODE_TEXT, MODE_TEXTCOLOR, MODE_BORDERCOLOR, MODE_FILLCOLOR, new Point(0, 0)));

            do
            {
                ///////////////////
                // 1. Redraw
                // 2. Get input.
                // 3. Handle input
                ///////////////////

                // 1. Redraw
                RedrawPlayScreen();

                // 2. Get input.
                Direction dir = WaitDirectionOrCancel();

                // 3. Handle input
                if (dir == null)
                {
                    loop = false;
                }
                else if (dir != Direction.NEUTRAL)
                {
                    Point pos = player.Location.Position + dir;
                    if (player.Location.Map.IsInBounds(pos))
                    {
                        Actor other = player.Location.Map.GetActorAt(pos);
                        if (other != null)
                        {
                            string reason;
                            if (m_Rules.CanActorTakeLead(player, other, out reason))
                            {
                                // take lead.
                                actionDone = true;
                                loop = false;

                                DoTakeLead(player, other);

                                // scoring.
                                m_Session.Scoring.AddEvent(m_Session.WorldTime.TurnCounter, String.Format("Recruited {0}.", other.TheName));

                                // help message.
                                AddMessage(new Message("(you can now set directives and orders for your new follower).", m_Session.WorldTime.TurnCounter, Color.White));
                                AddMessage(new Message(String.Format("(to give order : press <{0}>).", s_KeyBindings.GetFriendlyFormat(PlayerCommand.ORDER_MODE).ToString()), m_Session.WorldTime.TurnCounter, Color.White));

                            }
                            else if (other.Leader == player)
                            {
                                if (m_Rules.CanActorCancelLead(player, other, out reason))
                                {
                                    // ask for confirmation.
                                    AddMessage(MakeYesNoMessage(String.Format("Really ask {0} to leave", other.TheName)));
                                    RedrawPlayScreen();
                                    bool confirm = WaitYesOrNo();
                                    if (confirm)
                                    {
                                        // cancel lead.
                                        actionDone = true;
                                        loop = false;
                                        DoCancelLead(player, other);

                                        // scoring.
                                        m_Session.Scoring.AddEvent(m_Session.WorldTime.TurnCounter, String.Format("Fired {0}.", other.TheName));
                                    }
                                    else
                                        AddMessage(new Message("Good, together you are strong.", m_Session.WorldTime.TurnCounter, Color.Yellow));
                                }
                                else
                                {
                                    AddMessage(MakeErrorMessage(String.Format("{0} can't leave : {1}.", other.TheName, reason)));
                                }
                            }
                            else
                            {
                                AddMessage(MakeErrorMessage(String.Format("Can't lead {0} : {1}.", other.TheName, reason)));
                            }
                        }
                        else
                            AddMessage(MakeErrorMessage("Noone there."));
                    }
                }
            }
            while (loop);

            // cleanup.
            ClearOverlays();

            // return if we did an action.
            return actionDone;
        }

        bool HandlePlayerPlantSeeds(Item seeds) //@@MP (Release 5-5)
        {
            // 1. check that a player is standing on grass
            Tile tile = m_Player.Location.Map.GetTileAt(m_Player.Location.Position);
            MapObject objectThere = m_Player.Location.Map.GetMapObjectAt(m_Player.Location.Position);
            //it must be clear grass, empty of objects
            if (tile.Model != GameTiles.FLOOR_GRASS || objectThere != null)  //should really make these a tile property rather than hard-coded, similar to GameTiles.CanBuryCorpsesHere()
            {
                AddMessage(new Message("Find a clear, grassy spot in order to plant seeds.", m_Session.WorldTime.TurnCounter, Color.Red));
                return false;
            }

            // 2. check that the player has a digging tool equipped
            if (!m_Player.Inventory.IsEmpty)
            {
                Item itEquipped = m_Player.GetEquippedWeapon() as ItemMeleeWeapon;
                if (itEquipped == null || (!(itEquipped.Model as ItemMeleeWeaponModel).CanUseForDigging))
                {
                    AddMessage(new Message("You need to equip a shovel or pickaxe to plant seeds.", m_Session.WorldTime.TurnCounter, Color.Red));
                    return false;
                }
            }
            else
            {
                AddMessage(new Message("You need to find seeds and a shovel or pickaxe for planting.", m_Session.WorldTime.TurnCounter, Color.Red));
                return false;
            }

            // 3. no issues so plant it; swap grass for planted tile
            m_SFXManager.Play(GameSounds.DIG_GROUND, AudioPriority.PRIORITY_EVENT); //@@MP (Release 6-6)
            m_Player.Location.Map.SetTileModelAt(m_Player.Location.Position.X, m_Player.Location.Position.Y, GameTiles.FLOOR_PLANTED);
            m_Player.Inventory.Consume(seeds);

            //feels good
            if (m_Player.Model.Abilities.HasSanity)
                RegenActorSanity(m_Player, m_Rules.ActorSanRegenValue(m_Player, WorldTime.TURNS_PER_HOUR));

            return true;
        }

        bool HandlePlayerSiphonFuel() //@@MP (Release 7-1)
        {
            // Check for adjacent cars
            bool refuelled = false;
            bool fueledCar = false;
            bool pumpAdjacent = false; //@@MP (Release 7-3)
            
            m_Player.Location.Map.ForEachAdjacentInMap(m_Player.Location.Position,
                (pt) =>
                {
                    MapObject mapObj = m_Player.Location.Map.GetMapObjectAt(pt);
                    if (mapObj != null)
                    {
                        Car car = mapObj as Car;
                        if (car != null)
                        {
                            // does it have fuel?
                            if (car.FuelUnits > 0)
                            {
                                fueledCar = true;

                                //turn it into an item so that we can inventory it
                                Item it = new ItemAmmo(GameItems.AMMO_FUEL);
                                if (car.FuelUnits > GameItems.AMMO_FUEL.MaxQuantity)
                                    it.Quantity = GameItems.AMMO_FUEL.MaxQuantity;
                                else
                                    it.Quantity = car.FuelUnits;

                                // add to inventory.
                                int quantityAdded;
                                m_Player.Inventory.AddAsMuchAsPossible(it, out quantityAdded);
                                car.FuelUnits -= quantityAdded;

                                //only one car per turn
                                if (quantityAdded > 0)
                                {
                                    if (m_Rules.RollChance(Rules.VOMIT_WHILE_SIPHONING_CHANCE))
                                    {
                                        DoVomit(m_Player);
                                        AddMessage(MakeMessage(m_Player, "accidentally drank a bit of fuel"));
                                    }
                                    refuelled = true;
                                    return;
                                }
                            }
                        }
                        else if (mapObj.ImageID == GameImages.OBJ_FUEL_PUMP) //@@MP - fuel pumps added (Release 7-3)
                        {
                            pumpAdjacent = true;
                        }
                    }
                });

            if (refuelled)
                return true;
            else if (pumpAdjacent) //@@MP (Release 7-3)
            {
                AddMessage(new Message("Fuel pumps need power. It's not possible to siphon from them.", m_Session.WorldTime.TurnCounter, Color.Red));
                return false;
            }
            else if (!fueledCar)
            {
                AddMessage(new Message("Not adjacent to any cars with fuel left.", m_Session.WorldTime.TurnCounter, Color.Red));
                return false;
            }
            else if (m_Player.Inventory.IsFull)
            {
                AddMessage(new Message("Cannot siphon fuel; inventory already full.", m_Session.WorldTime.TurnCounter, Color.Red));
                return false;
            }
            else
            {
                throw new InvalidOperationException("unhandled outcome");
            }
        }

        bool HandlePlayerPush(Actor player)
        {
            // fail immediatly for stupid cases.
            if (!m_Rules.HasActorPushAbility(player))
            {
                AddMessage(MakeErrorMessage("Cannot push objects."));
                return false;
            }
            if (m_Rules.IsActorTired(player))
            {
                AddMessage(MakeErrorMessage("Too tired to push."));
                return false;
            }


            bool loop = true;
            bool actionDone = false;

            ClearOverlays();
            AddOverlay(new OverlayPopup(PUSH_MODE_TEXT, MODE_TEXTCOLOR, MODE_BORDERCOLOR, MODE_FILLCOLOR, new Point(0, 0))); //alpha 10, moved from within the do

            do
            {
                ///////////////////
                // 1. Redraw
                // 2. Get input.
                // 3. Handle input
                ///////////////////

                // 1. Redraw
                RedrawPlayScreen();

                // 2. Get input.
                Direction dir = WaitDirectionOrCancel();

                // 3. Handle input
                if (dir == null)
                {
                    loop = false;
                }
                else if (dir != Direction.NEUTRAL)
                {
                    Point pos = player.Location.Position + dir;
                    if (player.Location.Map.IsInBounds(pos))
                    {
                        // shove actor vs push object.
                        Actor other = player.Location.Map.GetActorAt(pos);
                        MapObject mapObj = player.Location.Map.GetMapObjectAt(pos);
                        string reason;
                        if (other != null)
                        {
                            // shove.
                            if (m_Rules.CanActorShove(player, other, out reason))
                            {
                                if (HandlePlayerShoveActor(player, other))
                                {
                                    loop = false;
                                    actionDone = true;
                                }
                            }
                            else
                                AddMessage(MakeErrorMessage(String.Format("Cannot shove {0} : {1}.", other.TheName, reason)));

                        }
                        else if (mapObj != null)
                        {
                            // push.
                            if (m_Rules.CanActorPush(player, mapObj, out reason))
                            {
                                if (HandlePlayerPushObject(player, mapObj))
                                {
                                    loop = false;
                                    actionDone = true;
                                }
                            }
                            else
                            {
                                AddMessage(MakeErrorMessage(String.Format("Cannot move {0} : {1}.", mapObj.TheName, reason)));
                            }
                        }
                        else
                        {
                            // nothing to push/shove.
                            AddMessage(MakeErrorMessage("Nothing to push there."));
                        }
                    }
                }
            }
            while (loop);

            // cleanup.
            ClearOverlays();

            // return if we did an action.
            return actionDone;
        }

        bool HandlePlayerPushObject(Actor player, MapObject mapObj)
        {
            bool loop = true;
            bool actionDone = false;

            ClearOverlays();
            AddOverlay(new OverlayPopup(new string[] { String.Format(PUSH_OBJECT_MODE_TEXT, mapObj.TheName) }, MODE_TEXTCOLOR, MODE_BORDERCOLOR, MODE_FILLCOLOR, new Point(0, 0)));
            AddOverlay(new OverlayRect(Color.Yellow, new Rectangle(MapToScreen(mapObj.Location.Position), new Size(TILE_SIZE, TILE_SIZE))));

            do
            {
                ///////////////////
                // 1. Redraw
                // 2. Get input.
                // 3. Handle input
                ///////////////////

                // 1. Redraw
                RedrawPlayScreen();

                // 2. Get input.
                Direction dir = WaitDirectionOrCancel();

                // 3. Handle input
                if (dir == null)
                {
                    loop = false;
                }
                else if (dir != Direction.NEUTRAL)
                {
                    Point movePos = mapObj.Location.Position + dir;
                    if (player.Location.Map.IsInBounds(movePos))
                    {
                        string reason;
                        if (m_Rules.CanPushObjectTo(mapObj, movePos, out reason))
                        {
                            DoPush(player, mapObj, movePos);
                            loop = false;
                            actionDone = true;
                        }
                        else
                        {
                            AddMessage(MakeErrorMessage(String.Format("Cannot move {0} there : {1}.", mapObj.TheName, reason)));
                        }
                    }
                }
            }
            while (loop);

            // cleanup.
            ClearOverlays();

            // return if we did an action.
            return actionDone;
        }

        bool HandlePlayerShoveActor(Actor player, Actor other)
        {
            bool loop = true;
            bool actionDone = false;

            ClearOverlays();
            AddOverlay(new OverlayPopup(new string[] { String.Format(SHOVE_ACTOR_MODE_TEXT, other.TheName) }, MODE_TEXTCOLOR, MODE_BORDERCOLOR, MODE_FILLCOLOR, new Point(0, 0)));
            AddOverlay(new OverlayRect(Color.Yellow, new Rectangle(MapToScreen(other.Location.Position), new Size(TILE_SIZE, TILE_SIZE))));

            do
            {
                ///////////////////
                // 1. Redraw
                // 2. Get input.
                // 3. Handle input
                ///////////////////

                // 1. Redraw
                RedrawPlayScreen();

                // 2. Get input.
                Direction dir = WaitDirectionOrCancel();

                // 3. Handle input
                if (dir == null)
                {
                    loop = false;
                }
                else if (dir != Direction.NEUTRAL)
                {
                    Point movePos = other.Location.Position + dir;
                    if (player.Location.Map.IsInBounds(movePos))
                    {
                        string reason;
                        if (m_Rules.CanShoveActorTo(other, movePos, out reason))
                        {
                            DoShove(player, other, movePos);
                            loop = false;
                            actionDone = true;
                        }
                        else
                        {
                            AddMessage(MakeErrorMessage(String.Format("Cannot shove {0} there : {1}.", other.TheName, reason)));
                        }
                    }
                }
            }
            while (loop);

            // cleanup.
            ClearOverlays();

            // return if we did an action.
            return actionDone;
        }

        bool HandlePlayerPull(Actor player) // alpha10
        {
            // fail immediatly for stupid cases.
            if (!m_Rules.HasActorPushAbility(player))
            {
                AddMessage(MakeErrorMessage("Cannot pull objects."));
                return false;
            }
            if (m_Rules.IsActorTired(player))
            {
                AddMessage(MakeErrorMessage("Too tired to pull."));
                return false;
            }
            MapObject otherMobj = player.Location.Map.GetMapObjectAt(player.Location.Position);
            if (otherMobj != null)
            {
                AddMessage(MakeErrorMessage(string.Format("Cannot pull : {0} is blocking.", otherMobj.TheName)));
                return false;
            }


            bool loop = true;
            bool actionDone = false;

            ClearOverlays();
            AddOverlay(new OverlayPopup(PULL_MODE_TEXT, MODE_TEXTCOLOR, MODE_BORDERCOLOR, MODE_FILLCOLOR, new Point(0, 0)));

            do
            {
                ///////////////////
                // 1. Redraw
                // 2. Get input.
                // 3. Handle input
                ///////////////////

                // 1. Redraw
                RedrawPlayScreen();

                // 2. Get input.
                Direction dir = WaitDirectionOrCancel();

                // 3. Handle input
                if (dir == null)
                {
                    loop = false;
                }
                else if (dir != Direction.NEUTRAL)
                {
                    Point pos = player.Location.Position + dir;
                    if (player.Location.Map.IsInBounds(pos))
                    {
                        MapObject mapObj = player.Location.Map.GetMapObjectAt(pos);
                        Actor other = player.Location.Map.GetActorAt(pos);
                        string reason;
                        if (other != null)
                        {
                            // pull-shove.
                            if (m_Rules.CanActorShove(player, other, out reason))  // if can shove, can pull-shove.
                            {
                                if (HandlePlayerPullActor(player, other))
                                {
                                    loop = false;
                                    actionDone = true;
                                }
                            }
                            else
                                AddMessage(MakeErrorMessage(String.Format("Cannot pull {0} : {1}.", other.TheName, reason)));
                        }
                        else if (mapObj != null)
                        {
                            // pull.
                            if (m_Rules.CanActorPush(player, mapObj, out reason))  // if can push, can pull.
                            {
                                if (HandlePlayerPullObject(player, mapObj))
                                {
                                    loop = false;
                                    actionDone = true;
                                }
                            }
                            else
                            {
                                AddMessage(MakeErrorMessage(String.Format("Cannot move {0} : {1}.", mapObj.TheName, reason)));
                            }
                        }
                        else
                        {
                            // nothing to pull.
                            AddMessage(MakeErrorMessage("Nothing to pull there."));
                        }
                    }
                }
            }
            while (loop);

            // cleanup.
            ClearOverlays();

            // return if we did an action.
            return actionDone;
        }

        bool HandlePlayerPullObject(Actor player, MapObject mapObj) // alpha10
        {
            bool loop = true;
            bool actionDone = false;

            ClearOverlays();
            AddOverlay(new OverlayPopup(new string[] { String.Format(PULL_OBJECT_MODE_TEXT, mapObj.TheName) }, MODE_TEXTCOLOR, MODE_BORDERCOLOR, MODE_FILLCOLOR, new Point(0, 0)));
            AddOverlay(new OverlayRect(Color.Yellow, new Rectangle(MapToScreen(mapObj.Location.Position), new Size(TILE_SIZE, TILE_SIZE))));

            do
            {
                ///////////////////
                // 1. Redraw
                // 2. Get input.
                // 3. Handle input
                ///////////////////

                // 1. Redraw
                RedrawPlayScreen();

                // 2. Get input.
                Direction dir = WaitDirectionOrCancel();

                // 3. Handle input
                if (dir == null)
                {
                    loop = false;
                }
                else if (dir != Direction.NEUTRAL)
                {
                    Point moveToPos = player.Location.Position + dir;
                    if (player.Location.Map.IsInBounds(moveToPos))
                    {
                        string reason;
                        if (m_Rules.CanPullObject(player, mapObj, moveToPos, out reason))
                        {
                            DoPull(player, mapObj, moveToPos);
                            loop = false;
                            actionDone = true;
                        }
                        else
                        {
                            AddMessage(MakeErrorMessage(String.Format("Cannot pull there : {0}.", reason)));
                        }
                    }
                }
            }
            while (loop);

            // cleanup.
            ClearOverlays();

            // return if we did an action.
            return actionDone;
        }

        bool HandlePlayerPullActor(Actor player, Actor other) // alpha10
        {
            bool loop = true;
            bool actionDone = false;

            ClearOverlays();
            AddOverlay(new OverlayPopup(new string[] { String.Format(PULL_ACTOR_MODE_TEXT, other.TheName) }, MODE_TEXTCOLOR, MODE_BORDERCOLOR, MODE_FILLCOLOR, new Point(0, 0)));
            AddOverlay(new OverlayRect(Color.Yellow, new Rectangle(MapToScreen(other.Location.Position), new Size(TILE_SIZE, TILE_SIZE))));

            do
            {
                ///////////////////
                // 1. Redraw
                // 2. Get input.
                // 3. Handle input
                ///////////////////

                // 1. Redraw
                RedrawPlayScreen();

                // 2. Get input.
                Direction dir = WaitDirectionOrCancel();

                // 3. Handle input
                if (dir == null)
                {
                    loop = false;
                }
                else if (dir != Direction.NEUTRAL)
                {
                    Point moveToPos = player.Location.Position + dir;
                    if (player.Location.Map.IsInBounds(moveToPos))
                    {
                        string reason;
                        if (m_Rules.CanPullActor(player, other, moveToPos, out reason))
                        {
                            DoPullActor(player, other, moveToPos);
                            loop = false;
                            actionDone = true;
                        }
                        else
                        {
                            AddMessage(MakeErrorMessage(String.Format("Cannot pull there : {0}.", reason)));
                        }
                    }
                }
            }
            while (loop);

            // cleanup.
            ClearOverlays();

            // return if we did an action.
            return actionDone;
        }

        bool HandlePlayerRepairDoor(Actor player) //@@MP (Release 8-1)
        {
            bool loop = true;
            bool actionDone = false;

            ClearOverlays();
            AddOverlay(new OverlayPopup(REPAIR_DOOR_MODE_TEXT, MODE_TEXTCOLOR, MODE_BORDERCOLOR, MODE_FILLCOLOR, new Point(0, 0)));

            do
            {
                ///////////////////
                // 1. Redraw
                // 2. Get input.
                // 3. Handle input
                ///////////////////

                // 1. Redraw
                RedrawPlayScreen();

                // 2. Get input.
                Direction dir = WaitDirectionOrCancel();

                // 3. Handle input
                if (dir == null)
                {
                    loop = false;
                }
                else if (dir != Direction.NEUTRAL)
                {
                    Point pos = player.Location.Position + dir;
                    if (player.Location.Map.IsInBounds(pos))
                    {
                        MapObject mapObj = player.Location.Map.GetMapObjectAt(pos);
                        if (mapObj != null)
                        {
                            // repairing a door.
                            if (mapObj is DoorWindow)
                            {
                                DoorWindow door = mapObj as DoorWindow;
                                string reason;
                                if (m_Rules.CanActorRepairDoor(player, door, m_Session.World.Weather, out reason))
                                {
                                    DoRepairDoor(player, door);
                                    RedrawPlayScreen();
                                    loop = false;
                                    actionDone = true;
                                }
                                else
                                {
                                    AddMessage(MakeErrorMessage(String.Format("Cannot repair {0} : {1}.", door.TheName, reason)));
                                }
                            }
                            // repairing a fortification.
                            else if (mapObj is Fortification)
                            {
                                Fortification fort = mapObj as Fortification;
                                string reason;
                                if (m_Rules.CanActorRepairFortification(player, m_Session.World.Weather, out reason))
                                {
                                    DoRepairFortification(player, fort);
                                    RedrawPlayScreen();
                                    loop = false;
                                    actionDone = true;
                                }
                                else
                                {
                                    AddMessage(MakeErrorMessage(String.Format("Cannot repair {0} : {1}.", fort.TheName, reason)));
                                }
                            }
                            else
                                AddMessage(MakeErrorMessage(String.Format("{0} cannot be repaired.", mapObj.TheName)));
                        }
                        else
                            AddMessage(MakeErrorMessage("Nothing to repair there."));
                    }
                }
            }
            while (loop);

            // cleanup.
            ClearOverlays();

            // return if we did an action.
            return actionDone;
        }

        bool HandlePlayerUnloadAmmo(Actor player) //@@MP (Release 7-6)
        {
            // get player equipped weapon
            Item item = player.GetEquippedRangedWeapon();
            if (item == null)
            {
                AddMessage(MakeErrorMessage("No weapon equipped to unload."));
                return false;
            }

            string reason;
            if (m_Rules.CanActorUnloadAmmoFromGun(player, item, out reason))
            {
                ItemRangedWeapon weapon = item as ItemRangedWeapon;
                DoUnloadAmmoFromGun(player, weapon);
                return true;
            }
            else
            {
                AddMessage(MakeErrorMessage(String.Format("Cannot unload {0} : {1}.", item.TheName, reason)));
                return false;
            }
        }

        bool HandlePlayerUseSleepingBag(Actor player, Item it) //@@MP (Release 7-3)
        {
            if (!Rules.CanActorSleep(player, out string reason))
            {
                AddMessage(MakeErrorMessage(String.Format("Can't sleep : {0}.", reason)));
                return false;
            }

            MapObject mapObj = player.Location.Map.GetMapObjectAt(player.Location.Position);
            if (mapObj != null)
            {
                AddMessage(MakeErrorMessage(String.Format("Can't place sleeping bag : {0} in the way.", mapObj.AName)));
                return false;
            }
            
            //now do it
            DoDropItem(player, it);
            return HandlePlayerSleep(player);
        }

        bool HandlePlayerUseSpray(Actor player)
        {
            // get equipped item.
            Item it = player.GetEquippedItem(DollPart.LEFT_HAND);
            if (it == null)
            {
                AddMessage(MakeErrorMessage("No spray can / extinguisher / paint thinner equipped."));
                RedrawPlayScreen();
                return false;
            }

            //////////////////////////////////////////////
            // Handle concrete action depending on spray.
            // 1. Spray paint.
            // 2. Spray scent.
            //////////////////////////////////////////////

            // 1. Spray paint.
            ItemSprayPaint sprayPaint = it as ItemSprayPaint;
            if (sprayPaint != null)
                return HandlePlayerTag(player);

            // 2. Spray scent.
            ItemSprayScent sprayScent = it as ItemSprayScent;
            if (sprayScent != null)
            {
                // alpha10 new way to use stench killer
                return HandlePlayerSprayOdorSuppressor(player);
            }

            // no spray equipped.
            AddMessage(MakeErrorMessage("No spray can / extinguisher / paint thinner equipped."));
            RedrawPlayScreen();
            return false;
        }

        bool HandlePlayerUseThrowableItem(Actor player, Item item) //@@MP - for non-grenades eg ItemLight (Release 7-1)
        {
            bool loop = true;
            bool actionDone = false;
            Map map = player.Location.Map;
            Point targetThrow = player.Location.Position;
            int maxThrowDist = MAX_THROWABLE_DISTANCE;

            // Loop.
            List<Point> LoT = new List<Point>();
            do
            {
                // get LoT.
                LoT.Clear();
                string reason;
                bool canThrowAtTarget = m_Rules.CanActorThrowItemTo(player, targetThrow, LoT, item, MAX_THROWABLE_DISTANCE, out reason);

                ///////////////////
                // 1. Redraw
                // 2. Get input.
                // 3. Handle input
                ///////////////////

                // 1. Redraw
                ClearOverlays();
                AddOverlay(new OverlayPopup(THROW_MODE_TEXT, MODE_TEXTCOLOR, MODE_BORDERCOLOR, MODE_FILLCOLOR, new Point(0, 0)));
                string lineImage = canThrowAtTarget ? GameImages.ICON_LINE_CLEAR : GameImages.ICON_LINE_BLOCKED;
                foreach (Point pt in LoT)
                {
                    Point screenPt = MapToScreen(pt);
                    AddOverlay(new OverlayImage(screenPt, lineImage));
                }
                RedrawPlayScreen();

                // 2. Get input.
                KeyEventArgs key = m_UI.UI_WaitKey();
                PlayerCommand command = InputTranslator.KeyToCommand(key);

                // 3. Handle input
                if (key.KeyCode == Keys.Escape)// command == PlayerCommand.EXIT_OR_CANCEL)
                {
                    loop = false;
                }
                else if (key.KeyCode == Keys.F) // do throw.
                {
                    if (canThrowAtTarget)
                    {
                        // spend AP.
                        SpendActorActionPoints(player, Rules.BASE_ACTION_COST);

                        // drop item at target position.
                        map.DropItemAt(item, targetThrow);

                        // consume item.
                        player.Inventory.Consume(item);

                        // message about throwing.
                        bool isVisible = IsVisibleToPlayer(player) || IsVisibleToPlayer(player.Location.Map, targetThrow);
                        if (isVisible)
                        {
                            AddOverlay(new OverlayRect(Color.Yellow, new Rectangle(MapToScreen(player.Location.Position), new Size(TILE_SIZE, TILE_SIZE))));
                            AddOverlay(new OverlayRect(Color.Red, new Rectangle(MapToScreen(targetThrow), new Size(TILE_SIZE, TILE_SIZE))));
                            AddMessage(MakeMessage(player, String.Format("{0} a {1}!", Conjugate(player, VERB_THROW), item.Model.SingleName)));
                            RedrawPlayScreen();
                            AnimDelay(DELAY_SHORT, true);
                            ClearOverlays();
                            RedrawPlayScreen();
                        }

                        RedrawPlayScreen();
                        loop = false;
                        actionDone = true;
                    }
                    else
                    {
                        AddMessage(MakeErrorMessage(String.Format("Can't throw there : {0}.", reason)));
                    }
                }
                else
                {
                    // direction?
                    Direction dir = CommandToDirection(command);
                    if (dir != null)
                    {
                        Point pos = targetThrow + dir;
                        if (map.IsInBounds(pos) && m_Rules.GridDistance(player.Location.Position, pos) <= maxThrowDist)
                            targetThrow = pos;
                    }
                }
            }
            while (loop);

            // cleanup.
            ClearOverlays();

            // return if we did an action.
            return actionDone;
        }

        void HandlePlayerUseLightPackThrowable(Actor player, Item pack) //@@MP (Release 7-1)
        {
            Item item;
            if (pack.Model == GameItems.FLARES_KIT)
                item = new ItemLight(GameItems.LIGHT_FLARE);
            else if (pack.Model == GameItems.GLOWSTICKS_BOX)
                item = new ItemLight(GameItems.LIGHT_GLOWSTICK);
            else
                throw new InvalidOperationException("unhandled item pack type");

            AddOverlay(new OverlayPopup(THROWABLE_LIGHT_TEXT, MODE_TEXTCOLOR, MODE_BORDERCOLOR, MODE_FILLCOLOR, Point.Empty));
            RedrawPlayScreen();

            KeyEventArgs inKey = m_UI.UI_WaitKey(); //  Read input
            if (inKey.KeyCode == Keys.Escape) // Handle input
            {
                ; //do nothing
            }
            // get choice.
            else if (inKey.KeyCode == Keys.T) //throw
            {
                Point pt = new Point(player.Location.Position.X, player.Location.Position.Y);
                if (HandlePlayerUseThrowableItem(player, item))
                    player.Inventory.Consume(pack);
            }
            else if (inKey.KeyCode == Keys.C) //carry
            {
                if (player.Inventory.IsFull && pack.Quantity > 1)
                {
                    AddMessage(MakeErrorMessage("No inventory space available."));
                    return;
                }

                foreach (Item i in player.Inventory.Items)
                {
                    if (i.IsEquipped && i is ItemLight)
                    {
                        AddMessage(MakeErrorMessage("You already have a light equipped."));
                        return;
                    }
                }

                //clear the light pack if it's the last item, as we may reuse that inventory slot
                bool consumedAlready = false;
                if (pack.Quantity == 1)
                {
                    player.Inventory.Consume(pack);
                    consumedAlready = true;
                }
                    

                //add a lit one
                player.Inventory.AddAsMuchAsPossible(item, out int quanitityAdded);
                //remove one from the pack, and the whole pack if it's now empty
                if (quanitityAdded > 0)
                {
                    if (pack.Model == GameItems.FLARES_KIT)
                        m_SFXManager.Play(GameSounds.FLARE, AudioPriority.PRIORITY_BGM);
                    else if (pack.Model == GameItems.GLOWSTICKS_BOX)
                        m_SFXManager.Play(GameSounds.GLOWSTICK, AudioPriority.PRIORITY_BGM);
                    DoEquipItem(player, item);

                    if (!consumedAlready)
                        player.Inventory.Consume(pack);
                }
            }
            else
            {
                AddMessage(MakeErrorMessage("Unhandled key error when using throwable light."));
                AddMessage(MakeErrorMessage("Did you perhaps hit the wrong key?"));
            }

            ClearOverlays();
            RedrawPlayScreen();
        }

        bool HandlePlayerTag(Actor player)
        {
            bool loop = true;
            bool actionDone = false;

            // Check if has spray paint.
            ItemSprayPaint sprayPaint = player.GetEquippedItem(DollPart.LEFT_HAND) as ItemSprayPaint;
            if (sprayPaint == null)
            {
                AddMessage(MakeErrorMessage("No spray item equipped equipped."));
                RedrawPlayScreen();
                return false;
            }
            if (sprayPaint.PaintQuantity <= 0) //MP: shouldn't come to this, as expended items are now aut-discarded
            {
                AddMessage(MakeErrorMessage("No spray quantity left."));
                RedrawPlayScreen();
                return false;
            }

            //get relevant type
            string[] overlayText = TAG_MODE_TEXT; //placeholder default
            string specialCase = ""; //placeholder
            if (sprayPaint.Model == GameItems.PAINT_THINNER) //@@MP - added paint thinners, for removing sprayed tags (Release 7-6)
            {
                specialCase = "paint thinner";
                overlayText = PAINT_THINNER_MODE_TEXT;
            }
            else if (sprayPaint.Model == GameItems.FIRE_EXTINGUISHER) //@@MP - added (Release 7-6)
            {
                specialCase = "fire extinguisher";
                overlayText = FIRE_EXTINGUISHER_MODE_TEXT;
            }

            ClearOverlays();
            AddOverlay(new OverlayPopup(overlayText, MODE_TEXTCOLOR, MODE_BORDERCOLOR, MODE_FILLCOLOR, new Point(0, 0)));
            do
            {
                ///////////////////
                // 1. Redraw
                // 2. Get input.
                // 3. Handle input
                ///////////////////

                // 1. Redraw
                RedrawPlayScreen();

                // 2. Get input.
                Direction dir = WaitDirectionOrCancel();

                // 3. Handle input
                if (dir == null)
                {
                    loop = false;
                }
                else if (dir != Direction.NEUTRAL)
                {
                    //can't spray further than an adjacent tile, so this suffices
                    Point pos = player.Location.Position + dir;
                    if (player.Location.Map.IsInBounds(pos))
                    {
                        
                        if (specialCase == "fire extinguisher")
                        {
                            MapObject mapObj = player.Location.Map.GetMapObjectAt(pos); //barrels, cars and campfires
                            Tile tile = player.Location.Map.GetTileAt(pos); //tiles fires (eg. molotov explosions)
                            Actor actor = player.Location.Map.GetActorAt(pos); //actor set alight by molotovs, flamethrowers, etc
                            if ((mapObj != null && mapObj.IsOnFire) || (tile != null && tile.IsOnFire) || (actor != null && actor.IsOnFire))
                            {
                                Location loc = player.Location + dir;
                                DoUseFireExtinguisher(player, sprayPaint, loc); //@@MP - added (Release 7-6)
                                loop = false;
                                actionDone = true;
                            }
                            else
                            {
                                AddMessage(MakeErrorMessage("Can't spray there : nothing to extinguish."));
                                RedrawPlayScreen();
                            }
                        }
                        else //it's paint thinner or spray can
                        {
                            string reason;
                            if (m_Rules.CanTag(player, pos, m_Session.World.Weather, out reason))
                            {
                                if (specialCase == "paint thinner")
                                    DoUsePaintThinner(player, sprayPaint, pos);
                                else //it's spray paint
                                    DoTag(player, sprayPaint, pos);

                                loop = false;
                                actionDone = true;
                            }
                            else
                            {
                                AddMessage(MakeErrorMessage(String.Format("Can't spray there : {0}.", reason)));
                                RedrawPlayScreen();
                            }
                        }
                    }
                }
            }
            while (loop);

            // cleanup.
            ClearOverlays();

            // return if we did an action.
            return actionDone;
        }

        // alpha10 new way to use stench killer
        bool HandlePlayerSprayOdorSuppressor(Actor player)
        {
            bool loop = true;
            bool actionDone = false;

            // Check if has odor suppressor.
            ItemSprayScent spray = player.GetEquippedItem(DollPart.LEFT_HAND) as ItemSprayScent;
            if (spray == null)
            {
                AddMessage(MakeErrorMessage("No spray equipped."));
                RedrawPlayScreen();
                return false;
            }
            if (spray.SprayQuantity <= 0)
            {
                AddMessage(MakeErrorMessage("No spray left."));
                RedrawPlayScreen();
                return false;
            }

            ClearOverlays();
            AddOverlay(new OverlayPopup(SPRAY_MODE_TEXT, MODE_TEXTCOLOR, MODE_BORDERCOLOR, MODE_FILLCOLOR, new Point(0, 0)));
            do
            {
                ///////////////////
                // 1. Redraw
                // 2. Get input.
                // 3. Handle input
                ///////////////////

                // 1. Redraw
                RedrawPlayScreen();

                // 2. Get input.
                Direction dir = WaitDirectionOrCancel();

                // 3. Handle input
                if (dir == null)
                    loop = false;
                else
                {
                    Actor sprayOn = null;

                    if (dir == Direction.NEUTRAL)
                        sprayOn = player;
                    else
                    {
                        Point pos = player.Location.Position + dir;
                        if (player.Location.Map.IsInBounds(pos))
                            sprayOn = player.Location.Map.GetActorAt(pos);
                    }

                    if (sprayOn == null)
                    {
                        AddMessage(MakeErrorMessage("No one to spray on here."));
                        RedrawPlayScreen();
                    }
                    else
                    {
                        string reason;
                        if (m_Rules.CanActorSprayOdorSuppressor(player, spray, sprayOn, out reason))
                        {
                            DoSprayOdorSuppressor(player, spray, sprayOn);
                            loop = false;
                            actionDone = true;
                        }
                        else
                        {
                            AddMessage(MakeErrorMessage(String.Format("Can't spray here : {0}.", reason)));
                            RedrawPlayScreen();
                        }

                    }
                }
            }
            while (loop);

            // cleanup.
            ClearOverlays();

            // return if we did an action.
            return actionDone;
        }

        void StartPlayerWaitLong(Actor player)
        {
            // start waiting.
            m_IsPlayerLongWait = true;
            m_IsPlayerLongWaitForcedStop = false;
            m_PlayerLongWaitEnd = new WorldTime(m_Session.WorldTime.TurnCounter + WorldTime.TURNS_PER_HOUR);

            // message.
            AddMessage(MakeMessage(player, String.Format("{0} waiting.", Conjugate(player, VERB_START))));
            RedrawPlayScreen();
        }

        bool CanPlayerKeepLongWaiting(Actor player)
        {
            ///////////////////////
            // Stop waiting if:
            // 1. Force stop wait flag set.
            // 2. Time reached.
            // 3. Hungry or sleepy.
            // 4. Enemy.
            // 5. Sanity check
            ///////////////////////

            // 1. Force stop wait flag set.
            if (m_IsPlayerLongWaitForcedStop)
                return false;

            // 2. Time reached.
            if (m_Session.WorldTime.TurnCounter >= m_PlayerLongWaitEnd.TurnCounter)
                return false;

            // 3. Hungry or sleepy.
            if (m_Rules.IsActorHungry(player) || m_Rules.IsActorSleepy(player) || m_Rules.IsActorExhausted(player)) //@@MP - removed unecessary starving check (Release 7-1)
                return false;

            // 4. Enemy.
            Point pt = player.Location.Position;
            foreach (Point p in m_PlayerFOV)
            {
                //@@MP - now that other lights about the place technically open up FOV, cap the range at which we care about spotted enemies (Release 7-1)
                if (m_Rules.LOSDistance(pt, p) > 5)
                    continue;

                Actor other = player.Location.Map.GetActorAt(p);
                if (other != null && m_Rules.AreEnemies(player, other))
                    return false;
            }

            // 5. Sanity check
            if (TryPlayerInsanity())
                return false;

            // all clear, waiting not interrupted.
            return true;
        }
        #endregion

        #region --Ordering followers
        bool HandlePlayerOrderMode(Actor player)
        {
            // check if we have followers to order.
            if (player.CountFollowers == 0)
            {
                AddMessage(MakeErrorMessage("No followers to give orders to."));
                return false;
            }

            // get followers data.
            Actor[] followers = new Actor[player.CountFollowers];
            HashSet<Point>[] fovs = new HashSet<Point>[player.CountFollowers];
            bool[] hasLinkWith = new bool[player.CountFollowers];
            int iFo = 0;
            foreach (Actor fo in player.Followers)
            {
                followers[iFo] = fo;
                fovs[iFo] = LOS.ComputeFOVFor(this, fo, m_Session.WorldTime, m_Session.World.Weather, true);   //@@MP - fixed to true (Release 7-5)
                bool inView = fovs[iFo].Contains(player.Location.Position) && m_PlayerFOV.Contains(fo.Location.Position);
                bool linkedByPhone = AreLinkedByPhone(player, fo);
                hasLinkWith[iFo] = inView || linkedByPhone;
                ++iFo;
            }

            // if one follower and he's linked, skip selection and directly go to its menu.
            if (player.CountFollowers == 1 && hasLinkWith[0])
            {
                bool done = HandlePlayerOrderFollower(player, followers[0]);
                // cleanup.
                ClearOverlays();
                ClearMessages();
                // done.
                return done;
            }

            // loop.
            bool loop = true;
            bool actionDone = false;
            const int maxFoOnPage = MAX_MESSAGES - 2;
            int iFirstFollower = 0;
            do
            {

                ///////////////////
                // 1. Redraw
                // 2. Get input.
                // 3. Handle input
                ///////////////////

                // 1. Redraw
                ClearOverlays();
                AddOverlay(new OverlayPopup(ORDER_MODE_TEXT, MODE_TEXTCOLOR, MODE_BORDERCOLOR, MODE_FILLCOLOR, new Point(0, 0)));
                ClearMessages();
                AddMessage(new Message("Choose a follower.", m_Session.WorldTime.TurnCounter, Color.Yellow));
                int foShown;
                for (foShown = 0; foShown < maxFoOnPage && (iFirstFollower + foShown < followers.Length); foShown++)
                {
                    iFo = foShown + iFirstFollower;
                    Actor f = followers[iFo];
                    string desc = DescribePlayerFollowerStatus(f);

                    if (hasLinkWith[iFo])
                        AddMessage(new Message(String.Format("{0}. {1}/{2} {3}... {4}.", (1 + foShown), iFo + 1, followers.Length, f.Name, desc), m_Session.WorldTime.TurnCounter, Color.LightGreen));
                    else
                        AddMessage(new Message(String.Format("{0}. {1}/{2} ({3}) {4}.", (1 + foShown), iFo + 1, followers.Length, f.Name, desc), m_Session.WorldTime.TurnCounter, Color.DarkGray));
                }
                if (foShown < followers.Length)
                {
                    AddMessage(new Message("9. next", m_Session.WorldTime.TurnCounter, Color.LightGreen));
                }
                RedrawPlayScreen();

                // 2. Get input.
                KeyEventArgs key = m_UI.UI_WaitKey();
                int choice = KeyToChoiceNumber(key.KeyCode);

                // 3. Handle input
                if (key.KeyCode == Keys.Escape)
                {
                    loop = false;
                }
                else if (choice == 9)
                {
                    iFirstFollower += maxFoOnPage;
                    if (iFirstFollower >= followers.Length)
                        iFirstFollower = 0;
                }
                else if (choice >= 1 && choice <= foShown)
                {
                    // Follower must be linked.
                    int f = iFirstFollower + choice - 1;
                    if (hasLinkWith[f])
                    {
                        /////////////////////////////////////////////
                        // Follower selected, select directive/order
                        /////////////////////////////////////////////
                        Actor selectedFollower = followers[f];
                        if (HandlePlayerOrderFollower(player, selectedFollower))
                        {
                            loop = false;
                            actionDone = true;
                        }
                    }
                }
            }
            while (loop);

            // cleanup.
            ClearOverlays();
            ClearMessages();

            // return if we did an action.
            return actionDone;
        }

        bool HandlePlayerDirectiveFollower(Actor follower) //@@MP - unused parameter (Release 5-7)
        {
            bool loop = true;
            bool actionDone = false;

            // loop.
            do
            {
                ///////////////////
                // 1. Redraw
                // 2. Get input.
                // 3. Handle input
                ///////////////////
                ActorDirective directives = (follower.Controller as AIController).Directives;

                // 1. Redraw
                ClearOverlays();
                AddOverlay(new OverlayPopup(ORDER_MODE_TEXT, MODE_TEXTCOLOR, MODE_BORDERCOLOR, MODE_FILLCOLOR, new Point(0, 0)));
                ClearMessages();
                AddMessage(new Message(String.Format("{0} directives...", follower.Name), m_Session.WorldTime.TurnCounter, Color.Yellow));
                AddMessage(new Message(String.Format("1. {0} items.", directives.CanTakeItems ? "Take" : "Don't take"), m_Session.WorldTime.TurnCounter, Color.LightGreen));
                AddMessage(new Message(String.Format("2. {0} weapons.", directives.CanFireWeapons ? "Fire" : "Don't fire"), m_Session.WorldTime.TurnCounter, Color.LightGreen));
                AddMessage(new Message(String.Format("3. {0} explosives.", directives.CanThrowGrenades ? "Throw" : "Don't throw"), m_Session.WorldTime.TurnCounter, Color.LightGreen)); //@@MP - reworded from "grenades" to "explosives" (Release 5-7)
                AddMessage(new Message(String.Format("4. {0}.", directives.CanSleep ? "Sleep" : "Don't sleep"), m_Session.WorldTime.TurnCounter, Color.LightGreen));
                AddMessage(new Message(String.Format("5. {0}.", directives.CanTrade ? "Trade" : "Don't trade"), m_Session.WorldTime.TurnCounter, Color.LightGreen));
                AddMessage(new Message(String.Format("6. {0}.", ActorDirective.CourageString(directives.Courage)), m_Session.WorldTime.TurnCounter, Color.LightGreen));
                RedrawPlayScreen();

                // 2. Get input.
                KeyEventArgs key = m_UI.UI_WaitKey();
                int choice = KeyToChoiceNumber(key.KeyCode);

                // 3. Handle input
                if (key.KeyCode == Keys.Escape)
                {
                    loop = false;
                }
                else if (choice >= 1 && choice <= 6)
                {
                    switch (choice)
                    {
                        case 1: // items
                            directives.CanTakeItems = !directives.CanTakeItems;
                            break;
                        case 2: // weapons
                            directives.CanFireWeapons = !directives.CanFireWeapons;
                            break;
                        case 3: // grenades.
                            directives.CanThrowGrenades = !directives.CanThrowGrenades;
                            break;
                        case 4: // sleep
                            directives.CanSleep = !directives.CanSleep;
                            break;
                        case 5: // trade
                            directives.CanTrade = !directives.CanTrade;
                            break;
                        case 6:  // courage: coward -> cautious -> courageous.
                            switch (directives.Courage)
                            {
                                case ActorCourage.COWARD:
                                    directives.Courage = ActorCourage.CAUTIOUS;
                                    break;
                                case ActorCourage.CAUTIOUS:
                                    directives.Courage = ActorCourage.COURAGEOUS;
                                    break;
                                case ActorCourage.COURAGEOUS:
                                    directives.Courage = ActorCourage.COWARD;
                                    break;
                            }
                            break;
                    }
                }
            }
            while (loop);

            return actionDone;
        }

        bool HandlePlayerOrderFollower(Actor player, Actor follower)
        {
            // check trust.
            if (!m_Rules.IsActorTrustingLeader(follower))
            {
                // say/phone
                if (IsVisibleToPlayer(follower))
                    DoSay(follower, player, "Sorry, I don't trust you enough yet.", Sayflags.IS_FREE_ACTION | Sayflags.IS_IMPORTANT);
                else if (AreLinkedByPhone(follower, player))
                {
                    ClearMessages();
                    AddMessage(MakeMessage(follower, "Sorry, I don't trust you enough yet."));
                    AddMessagePressEnter();
                }
                // refuse!
                return false;
            }

            // current order.
            string desc = DescribePlayerFollowerStatus(follower);

            // compute follower fov.
            HashSet<Point> followerFOV = LOS.ComputeFOVFor(this, follower, m_Session.WorldTime, m_Session.World.Weather, true);   //@@MP - fixed to true (Release 7-5)

            // loop.
            bool loop = true;
            bool actionDone = false;
            do
            {
                ///////////////////
                // 1. Redraw
                // 2. Get input.
                // 3. Handle input
                ///////////////////

                // 1. Redraw
                string startStopFollow = (follower.Controller as OrderableAI).DontFollowLeader ? "Start" : "Stop";
                ClearOverlays();
                AddOverlay(new OverlayPopup(ORDER_MODE_TEXT, MODE_TEXTCOLOR, MODE_BORDERCOLOR, MODE_FILLCOLOR, new Point(0, 0)));
                ClearMessages();
                AddMessage(new Message(String.Format("Order {0} to...", follower.Name), m_Session.WorldTime.TurnCounter, Color.Yellow));
                AddMessage(new Message(String.Format("0. Cancel current order {0}.", desc), m_Session.WorldTime.TurnCounter, Color.Green));
                AddMessage(new Message("1. Set directives...", m_Session.WorldTime.TurnCounter, Color.Cyan));
                AddMessage(new Message("2. Barricade (one)...    6. Drop all items.      A. Give me...", m_Session.WorldTime.TurnCounter, Color.LightGreen));
                AddMessage(new Message("3. Barricade (max)...    7. Build small fort.    B. Sleep now.", m_Session.WorldTime.TurnCounter, Color.LightGreen));
                AddMessage(new Message(String.Format("4. Guard...              8. Build large fort.    C. {0} following me.   ", startStopFollow), m_Session.WorldTime.TurnCounter, Color.LightGreen));
                AddMessage(new Message("5. Patrol...             9. Report events.       D. Where are you?", m_Session.WorldTime.TurnCounter, Color.LightGreen));
                RedrawPlayScreen();

                // 2. Get input.
                KeyEventArgs key = m_UI.UI_WaitKey();
                int choice = KeyToChoiceNumber(key.KeyCode);

                // 3. Handle input
                if (key.KeyCode == Keys.Escape)
                {
                    loop = false;
                }
                // first set of choices 0-9
                else if (choice >= 0 && choice <= 9)
                {

#region
                    switch (choice)
                    {
                        case 0: // cancel current order
                            DoCancelOrder(player, follower);
                            loop = false;
                            actionDone = true;
                            break;

                        case 1: // set directives.
                            HandlePlayerDirectiveFollower(follower); //@@MP - unused parameter (Release 5-7)
                            break;

                        case 2: // barricade (one)
                            if (HandlePlayerOrderFollowerToBarricade(player, follower, followerFOV, false))
                            {
                                loop = false;
                                actionDone = true;
                            }
                            break;

                        case 3: // barricade (max)
                            if (HandlePlayerOrderFollowerToBarricade(player, follower, followerFOV, true))
                            {
                                loop = false;
                                actionDone = true;
                            }
                            break;

                        case 4: // guard
                            if (HandlePlayerOrderFollowerToGuard(player, follower, followerFOV))
                            {
                                loop = false;
                                actionDone = true;
                            }
                            break;

                        case 5: // patrol
                            if (HandlePlayerOrderFollowerToPatrol(player, follower, followerFOV))
                            {
                                loop = false;
                                actionDone = true;
                            }
                            break;

                        case 6: // drop all items
                            if (HandlePlayerOrderFollowerToDropAllItems(player, follower))
                            {
                                loop = false;
                                actionDone = true;
                            }
                            break;

                        case 7: // build small fort.
                            if (HandlePlayerOrderFollowerToBuildFortification(player, follower, followerFOV, false))
                            {
                                loop = false;
                                actionDone = true;
                            }
                            break;

                        case 8: // build large fort.
                            if (HandlePlayerOrderFollowerToBuildFortification(player, follower, followerFOV, true))
                            {
                                loop = false;
                                actionDone = true;
                            }
                            break;

                        case 9: // report
                            if (HandlePlayerOrderFollowerToReport(player, follower))
                            {
                                loop = false;
                                actionDone = true;
                            }
                            break;

                    }
#endregion
                }
                // second set of choices A-xxx
#region
                else
                {
                    switch (key.KeyCode)
                    {
                        case Keys.A:    // give items...
                            if (HandlePlayerOrderFollowerToGiveItems(player, follower))
                            {
                                loop = false;
                                actionDone = true;
                            }
                            break;

                        case Keys.B: // sleep now
                            if (HandlePlayerOrderFollowerToSleep(player, follower))
                            {
                                loop = false;
                                actionDone = true;
                            }
                            break;

                        case Keys.C: // toggle follow
                            if (HandlePlayerOrderFollowerToToggleFollow(player, follower))
                            {
                                loop = false;
                                actionDone = true;
                            }
                            break;

                        case Keys.D: // where are ou?
                            if (HandlePlayerOrderFollowerToReportPosition(player, follower))
                            {
                                loop = false;
                                actionDone = true;
                            }
                            break;
                    }
                }
#endregion
            }
            while (loop);

            // return if we did an action.
            return actionDone;
        }

        bool HandlePlayerOrderFollowerToBuildFortification(Actor player, Actor follower, HashSet<Point> followerFOV, bool isLarge)
        {
            bool loop = true;
            bool actionDone = false;
            Map map = player.Location.Map;
            Point? highlightedTile = null;
            Color highlightColor = Color.White;

            do
            {
                ///////////////////
                // 1. Redraw
                // 2. Get input.
                // 3. Handle input
                ///////////////////

                // 1. Redraw
                ClearOverlays();
                AddOverlay(new OverlayPopup(ORDER_MODE_TEXT, MODE_TEXTCOLOR, MODE_BORDERCOLOR, MODE_FILLCOLOR, new Point(0, 0)));
                if (highlightedTile != null)
                    AddOverlay(new OverlayRect(highlightColor, new Rectangle(MapToScreen(highlightedTile.Value.X, highlightedTile.Value.Y), new Size(TILE_SIZE, TILE_SIZE))));
                ClearMessages();
                AddMessage(new Message(String.Format("Ordering {0} to build {1} fortification...", follower.Name, isLarge ? "large" : "small"), m_Session.WorldTime.TurnCounter, Color.Yellow));
                AddMessage(new Message("Left-Click on a map object.", m_Session.WorldTime.TurnCounter, Color.LightGreen));
                RedrawPlayScreen();

                // 2. Get input.
                KeyEventArgs key;
                Point mousePos;
                MouseButtons? mouseButtons;
                WaitKeyOrMouse(out key, out mousePos, out mouseButtons);

                if (key != null)
                {
                    if (key.KeyCode == Keys.Escape)
                        loop = false;
                }
                else
                {
                    // Get map position in view rect.
                    Point mapPos = MouseToMap(mousePos);
                    if (map.IsInBounds(mapPos) && IsInViewRect(mapPos))
                    {
                        // must be in player & follower FoV.
                        if (IsVisibleToPlayer(map, mapPos) && followerFOV.Contains(mapPos))
                        {
                            // Check if can build here.
                            string reason;
                            if (m_Rules.CanActorBuildFortification(follower, mapPos, isLarge, m_Session.World.Weather, out reason)) //@@MP - added weather parameter (Release 6-2)
                            {
                                // highlight.
                                highlightedTile = mapPos;
                                highlightColor = Color.LightGreen;
                                // if mouse down, give order.
                                if (mouseButtons.HasValue && mouseButtons.Value == MouseButtons.Left)
                                {
                                    DoGiveOrderTo(player, follower, new ActorOrder(isLarge ? ActorTasks.BUILD_LARGE_FORTIFICATION : ActorTasks.BUILD_SMALL_FORTIFICATION, new Location(player.Location.Map, mapPos)));
                                    loop = false;
                                    actionDone = true;
                                }
                            }
                            else
                            {
                                // de-hightlight.
                                highlightedTile = mapPos;
                                highlightColor = Color.Red;

                                // if mouse down, illegal.
                                if (mouseButtons.HasValue && mouseButtons.Value == MouseButtons.Left)
                                {
                                    AddMessage(MakeErrorMessage(String.Format("Can't build {0} fortification : {1}.", isLarge ? "large" : "small", reason)));
                                    AddMessagePressEnter();
                                }
                            }
                        } // visible
                        else
                        {
                            // de-hightlight.
                            highlightedTile = mapPos;
                            highlightColor = Color.Red;
                        }
                    }
                }

            }
            while (loop);

            // return if we did an action.
            return actionDone;
        }

        bool HandlePlayerOrderFollowerToBarricade(Actor player, Actor follower, HashSet<Point> followerFOV, bool toTheMax)
        {
            bool loop = true;
            bool actionDone = false;
            Map map = player.Location.Map;
            Point? highlightedTile = null;
            Color highlightColor = Color.White;

            do
            {
                ///////////////////
                // 1. Redraw
                // 2. Get input.
                // 3. Handle input
                ///////////////////

                // 1. Redraw
                ClearOverlays();
                AddOverlay(new OverlayPopup(ORDER_MODE_TEXT, MODE_TEXTCOLOR, MODE_BORDERCOLOR, MODE_FILLCOLOR, new Point(0, 0)));
                if (highlightedTile != null)
                    AddOverlay(new OverlayRect(highlightColor, new Rectangle(MapToScreen(highlightedTile.Value.X, highlightedTile.Value.Y), new Size(TILE_SIZE, TILE_SIZE))));
                ClearMessages();
                AddMessage(new Message(String.Format("Ordering {0} to barricade...", follower.Name), m_Session.WorldTime.TurnCounter, Color.Yellow));
                AddMessage(new Message("Left-Click on a map object.", m_Session.WorldTime.TurnCounter, Color.LightGreen));
                RedrawPlayScreen();

                // 2. Get input.
                KeyEventArgs key;
                Point mousePos;
                MouseButtons? mouseButtons;
                WaitKeyOrMouse(out key, out mousePos, out mouseButtons);

                if (key != null)
                {
                    if (key.KeyCode == Keys.Escape)
                        loop = false;
                }
                else
                {
                    // Get map position in view rect.
                    Point mapPos = MouseToMap(mousePos);
                    if (map.IsInBounds(mapPos) && IsInViewRect(mapPos))
                    {
                        // must be in player & follower FoV.
                        if (IsVisibleToPlayer(map, mapPos) && followerFOV.Contains(mapPos))
                        {

                            // Check if something to barricade here.
                            DoorWindow door = map.GetMapObjectAt(mapPos) as DoorWindow;
                            if (door != null)
                            {
                                // Check if can barricade here.
                                string reason;
                                if (m_Rules.CanActorBarricadeDoor(follower, door, m_Session.World.Weather, out reason)) //@@MP - added weather parameter (Release 6-2)
                                {
                                    // highlight.
                                    highlightedTile = mapPos;
                                    highlightColor = Color.LightGreen;
                                    // if mouse down, give order.
                                    if (mouseButtons.HasValue && mouseButtons.Value == MouseButtons.Left)
                                    {
                                        DoGiveOrderTo(player, follower, new ActorOrder(toTheMax ? ActorTasks.BARRICADE_MAX : ActorTasks.BARRICADE_ONE, door.Location));
                                        loop = false;
                                        actionDone = true;
                                    }
                                }
                                else
                                {
                                    // de-hightlight.
                                    highlightedTile = mapPos;
                                    highlightColor = Color.Red;
                                    // if mouse down, illegal.
                                    if (mouseButtons.HasValue && mouseButtons.Value == MouseButtons.Left)
                                    {
                                        AddMessage(MakeErrorMessage(String.Format("Can't barricade {0} : {1}.", door.TheName, reason)));
                                        AddMessagePressEnter();
                                    }
                                }
                            }
                            else
                            {
                                // de-hightlight.
                                highlightedTile = mapPos;
                                highlightColor = Color.Red;
                            }
                        } // visible
                        else
                        {
                            // de-hightlight.
                            highlightedTile = mapPos;
                            highlightColor = Color.Red;
                        }
                    }
                }

            }
            while (loop);

            // return if we did an action.
            return actionDone;
        }

        bool HandlePlayerOrderFollowerToGuard(Actor player, Actor follower, HashSet<Point> followerFOV)
        {
            bool loop = true;
            bool actionDone = false;
            Map map = player.Location.Map;
            Point? highlightedTile = null;
            Color highlightColor = Color.White;

            do
            {
                ///////////////////
                // 1. Redraw
                // 2. Get input.
                // 3. Handle input
                ///////////////////

                // 1. Redraw
                ClearOverlays();
                AddOverlay(new OverlayPopup(ORDER_MODE_TEXT, MODE_TEXTCOLOR, MODE_BORDERCOLOR, MODE_FILLCOLOR, new Point(0, 0)));
                if (highlightedTile != null)
                    AddOverlay(new OverlayRect(highlightColor, new Rectangle(MapToScreen(highlightedTile.Value.X, highlightedTile.Value.Y), new Size(TILE_SIZE, TILE_SIZE))));
                ClearMessages();
                AddMessage(new Message(String.Format("Ordering {0} to guard...", follower.Name), m_Session.WorldTime.TurnCounter, Color.Yellow));
                AddMessage(new Message("Left-Click on a map position.", m_Session.WorldTime.TurnCounter, Color.LightGreen));
                RedrawPlayScreen();

                // 2. Get input.
                KeyEventArgs key;
                Point mousePos;
                MouseButtons? mouseButtons;
                WaitKeyOrMouse(out key, out mousePos, out mouseButtons);

                if (key != null)
                {
                    if (key.KeyCode == Keys.Escape)
                        loop = false;
                }
                else
                {
                    // Get map position in view rect.
                    Point mapPos = MouseToMap(mousePos);
                    if (map.IsInBounds(mapPos) && IsInViewRect(mapPos))
                    {
                        // must be in player & follower FoV.
                        if (IsVisibleToPlayer(map, mapPos) && followerFOV.Contains(mapPos))
                        {
                            // Check if walkable here or same spot.
                            string reason;
                            if (mapPos == follower.Location.Position || m_Rules.IsWalkableFor(follower, map, mapPos.X, mapPos.Y, out reason))
                            {
                                // highlight.
                                highlightedTile = mapPos;
                                highlightColor = Color.LightGreen;
                                // if mouse down, give order.
                                if (mouseButtons.HasValue && mouseButtons.Value == MouseButtons.Left)
                                {
                                    DoGiveOrderTo(player, follower, new ActorOrder(ActorTasks.GUARD, new Location(map, mapPos)));
                                    loop = false;
                                    actionDone = true;
                                }
                            }
                            else
                            {
                                // de-hightlight.
                                highlightedTile = mapPos;
                                highlightColor = Color.Red;
                                // if mouse down, illegal.
                                if (mouseButtons.HasValue && mouseButtons.Value == MouseButtons.Left)
                                {
                                    AddMessage(MakeErrorMessage(String.Format("Can't guard here : {0}", reason)));
                                    AddMessagePressEnter();
                                }
                            }

                        } // visible
                        else
                        {
                            // de-hightlight.
                            highlightedTile = mapPos;
                            highlightColor = Color.Red;
                        }
                    }
                }

            }
            while (loop);

            // return if we did an action.
            return actionDone;
        }

        bool HandlePlayerOrderFollowerToPatrol(Actor player, Actor follower, HashSet<Point> followerFOV)
        {
            bool loop = true;
            bool actionDone = false;
            Map map = player.Location.Map;
            Point? highlightedTile = null;
            Color highlightColor = Color.White;

            do
            {
                ///////////////////
                // 1. Redraw
                // 2. Get input.
                // 3. Handle input
                ///////////////////

                // 1. Redraw
                ClearOverlays();
                AddOverlay(new OverlayPopup(ORDER_MODE_TEXT, MODE_TEXTCOLOR, MODE_BORDERCOLOR, MODE_FILLCOLOR, new Point(0, 0)));
                if (highlightedTile != null)
                {
                    AddOverlay(new OverlayRect(highlightColor, new Rectangle(MapToScreen(highlightedTile.Value.X, highlightedTile.Value.Y), new Size(TILE_SIZE, TILE_SIZE))));
                    List<Zone> zonesHere = map.GetZonesAt(highlightedTile.Value.X, highlightedTile.Value.Y);
                    if (zonesHere != null && zonesHere.Count > 0)
                    {
                        string[] zonesNames = new string[zonesHere.Count + 1];
                        zonesNames[0] = "Zone(s) here :";
                        for (int i = 0; i < zonesHere.Count; i++)
                        {
                            zonesNames[i + 1] = String.Format("- {0}", zonesHere[i].Name);
                        }
                        AddOverlay(new OverlayPopup(zonesNames, Color.White, Color.White, POPUP_FILLCOLOR, MapToScreen(highlightedTile.Value.X + 1, highlightedTile.Value.Y + 1)));
                    }
                }
                ClearMessages();
                AddMessage(new Message(String.Format("Ordering {0} to patrol...", follower.Name), m_Session.WorldTime.TurnCounter, Color.Yellow));
                AddMessage(new Message("Left-Click on a map position.", m_Session.WorldTime.TurnCounter, Color.LightGreen));
                RedrawPlayScreen();

                // 2. Get input.
                KeyEventArgs key;
                Point mousePos;
                MouseButtons? mouseButtons;
                WaitKeyOrMouse(out key, out mousePos, out mouseButtons);

                if (key != null)
                {
                    if (key.KeyCode == Keys.Escape)
                        loop = false;
                }
                else
                {
                    // Get map position in view rect.
                    Point mapPos = MouseToMap(mousePos);
                    if (map.IsInBounds(mapPos) && IsInViewRect(mapPos))
                    {
                        // must be in player & follower FoV.
                        if (IsVisibleToPlayer(map, mapPos) && followerFOV.Contains(mapPos))
                        {
                            bool validPatrol = true;
                            string reason = "";

                            // Must have a zone.
                            if (map.GetZonesAt(mapPos.X, mapPos.Y) == null)
                            {
                                validPatrol = false;
                                reason = "no zone here";
                            }
                            // Check if walkable here or same spot.
                            else if (!(mapPos == follower.Location.Position || m_Rules.IsWalkableFor(follower, map, mapPos.X, mapPos.Y, out reason)))
                            {
                                validPatrol = false;
                            }

                            if (validPatrol)
                            {
                                // highlight.
                                highlightedTile = mapPos;
                                highlightColor = Color.LightGreen;
                                // if mouse down, give order.
                                if (mouseButtons.HasValue && mouseButtons.Value == MouseButtons.Left)
                                {
                                    DoGiveOrderTo(player, follower, new ActorOrder(ActorTasks.PATROL, new Location(map, mapPos)));
                                    loop = false;
                                    actionDone = true;
                                }
                            }
                            else
                            {
                                // de-hightlight.
                                highlightedTile = mapPos;
                                highlightColor = Color.Red;
                                // if mouse down, illegal.
                                if (mouseButtons.HasValue && mouseButtons.Value == MouseButtons.Left)
                                {
                                    AddMessage(MakeErrorMessage(String.Format("Can't patrol here : {0}", reason)));
                                    AddMessagePressEnter();
                                }
                            }
                        } // visible
                        else
                        {
                            // de-hightlight.
                            highlightedTile = mapPos;
                            highlightColor = Color.Red;
                        }
                    }
                }
            }
            while (loop);

            // return if we did an action.
            return actionDone;
        }

        bool HandlePlayerOrderFollowerToDropAllItems(Actor player, Actor follower)
        {
            // if no items, nothing to drop.
            if (follower.Inventory.IsEmpty)
                return false;

            // do give order.
            DoGiveOrderTo(player, follower, new ActorOrder(ActorTasks.DROP_ALL_ITEMS, follower.Location));

            // emote.
            DoSay(follower, player, "Well ok...", Sayflags.IS_FREE_ACTION);

            // update trust. 1 give item penalty per items to drop.
            ModifyActorTrustInLeader(follower, follower.Inventory.CountItems * Rules.TRUST_GIVE_ITEM_ORDER_PENALTY, true);

            // done.
            return true;
        }

        bool HandlePlayerOrderFollowerToReport(Actor player, Actor follower)
        {
            // just give the order.
            DoGiveOrderTo(player, follower, new ActorOrder(ActorTasks.REPORT_EVENTS, follower.Location));

            // done.
            return true;
        }

        bool HandlePlayerOrderFollowerToSleep(Actor player, Actor follower)
        {
            // just give the order.
            DoGiveOrderTo(player, follower, new ActorOrder(ActorTasks.SLEEP_NOW, follower.Location));

            // done.
            return true;
        }

        bool HandlePlayerOrderFollowerToToggleFollow(Actor player, Actor follower)
        {
            // just give the order.
            DoGiveOrderTo(player, follower, new ActorOrder(ActorTasks.FOLLOW_TOGGLE, follower.Location));

            // done.
            return true;
        }

        bool HandlePlayerOrderFollowerToReportPosition(Actor player, Actor follower)
        {
            // just give the order.
            DoGiveOrderTo(player, follower, new ActorOrder(ActorTasks.WHERE_ARE_YOU, follower.Location));

            // done.
            return true;
        }

        bool HandlePlayerOrderFollowerToGiveItems(Actor player, Actor follower)
        {
            // sanity checks.
            if (follower.Inventory == null || follower.Inventory.IsEmpty)
            {
                ClearMessages();
                AddMessage(MakeErrorMessage(String.Format("{0} has no items to give.", follower.TheName)));
                AddMessagePressEnter();
                return false;
            }
            // must be adjacent.
            if (player.Location.Map != follower.Location.Map || !m_Rules.IsAdjacent(player.Location.Position, follower.Location.Position))
            {
                ClearMessages();
                AddMessage(MakeErrorMessage(String.Format("{0} is not next to you.", follower.TheName)));
                AddMessagePressEnter();
                return false;
            }

            // loop.
            bool loop = true;
            bool actionDone = false;

            int iFirstItem = 0;
            const int maxItOnPage = MAX_MESSAGES - 2;
            Inventory foInventory = follower.Inventory;
            do
            {
                ///////////////////
                // 1. Redraw
                // 2. Get input.
                // 3. Handle input
                ///////////////////

                // 1. Redraw
                ClearOverlays();
                AddOverlay(new OverlayPopup(ORDER_MODE_TEXT, MODE_TEXTCOLOR, MODE_BORDERCOLOR, MODE_FILLCOLOR, new Point(0, 0)));
                ClearMessages();
                AddMessage(new Message(String.Format("Ordering {0} to give...", follower.Name), m_Session.WorldTime.TurnCounter, Color.Yellow));

                int itShown;
                for (itShown = 0; itShown < maxItOnPage && (iFirstItem + itShown < foInventory.CountItems); itShown++)
                {
                    int iIt = iFirstItem + itShown;
                    AddMessage(new Message(String.Format("{0}. {1}/{2} {3}.", (1 + itShown), iIt + 1, foInventory.CountItems, DescribeItemShort(foInventory[iIt])), m_Session.WorldTime.TurnCounter, Color.LightGreen));
                }
                if (itShown < foInventory.CountItems)
                {
                    AddMessage(new Message("9. next", m_Session.WorldTime.TurnCounter, Color.LightGreen));
                }
                RedrawPlayScreen();

                // 2. Get input.
                KeyEventArgs key = m_UI.UI_WaitKey();
                int choice = KeyToChoiceNumber(key.KeyCode);

                // 3. Handle input
                if (key.KeyCode == Keys.Escape)
                {
                    loop = false;
                }
                else if (choice == 9)
                {
                    iFirstItem += maxItOnPage;
                    if (iFirstItem >= foInventory.CountItems)
                        iFirstItem = 0;
                }
                else if (choice >= 1 && choice <= itShown)
                {
                    // get item.
                    int i = iFirstItem + choice - 1;
                    Item it = foInventory[i];

                    // try to do it.
                    string reason;
                    if (m_Rules.CanActorGiveItemTo(follower, player, it, out reason))
                    {
                        DoGiveItemTo(follower, m_Player, it);
                        loop = false;
                        actionDone = true;
                    }
                    else
                    {
                        ClearMessages();
                        AddMessage(MakeErrorMessage(String.Format("{0} cannot give {1} : {2}.", follower.TheName, DescribeItemShort(it), reason)));
                        AddMessagePressEnter();
                    }
                }
            }
            while (loop);

            // done.
            return actionDone;
        }
#endregion
#endregion

#region -Changing map & district
        void SetCurrentMap(Map map)
        {
            // set session field.
            m_Session.CurrentMap = map;

            // update background music //alpha10
            UpdateBgMusic();

            /*// start new map music. //alpha10, obsolete
            if (map == map.District.SewersMap)
            {
                m_MusicManager.StopAll();
                m_MusicManager.PlayLooping(GameMusics.SEWERS);
            }
            else if (m_MusicManager.IsPlaying(GameMusics.SEWERS))
                m_MusicManager.Stop(GameMusics.SEWERS);

            if (map == map.District.SubwayMap)
            {
                m_MusicManager.StopAll();
                m_MusicManager.PlayLooping(GameMusics.SUBWAY);
            }
            else if (m_MusicManager.IsPlaying(GameMusics.SUBWAY))
                m_MusicManager.Stop(GameMusics.SUBWAY);

            if (map == m_Session.UniqueMaps.Hospital_Admissions.TheMap || map == m_Session.UniqueMaps.Hospital_Offices.TheMap ||
                map == m_Session.UniqueMaps.Hospital_Patients.TheMap || map == m_Session.UniqueMaps.Hospital_Power.TheMap ||
                map == m_Session.UniqueMaps.Hospital_Storage.TheMap)
            {
                if (!m_MusicManager.IsPlaying(GameMusics.HOSPITAL))
                {
                    m_MusicManager.StopAll();
                    m_MusicManager.PlayLooping(GameMusics.HOSPITAL);
                }
            }
            else if (m_MusicManager.IsPlaying(GameMusics.HOSPITAL))
                m_MusicManager.Stop(GameMusics.HOSPITAL);*/
        }

        void OnPlayerLeaveDistrict()
        {
            // remember when we left the district.
            m_Session.CurrentMap.LocalTime.TurnCounter = m_Session.WorldTime.TurnCounter;
        }

        void BeforePlayerEnterDistrict(District district)
        {
            // get entry map.
            Map entryMap = district.EntryMap;

            //@@MP the last turn that we simulated for this district (could also be when we last left the district, but unlikely as we're going into it now).
            //int lastTime = entryMap.LocalTime.TurnCounter;  //@@MP - unused (Release 7-2)

            // if option set, simulate to catch current turn.
            // otherwise just jump int time.
#region Simulation
            if (s_Options.IsSimON)
            {
                int catchupTo = m_Session.WorldTime.TurnCounter;  // alpha10
                int turnsToCatchup = (catchupTo - entryMap.LocalTime.TurnCounter); // alpha10
                int cappedTurnsToCatchup = Math.Min(GameOptions.SimCapToTurns(s_Options.SimTurnsCap), (int)turnsToCatchup);  //@@MP - added an optional cap (Release 7-3)

                // move each map forward in time if were only simulating a capped amount of turns   //@@MP (Release 7-3)
                foreach (Map map in district.Maps)
                    map.LocalTime.TurnCounter = m_Session.WorldTime.TurnCounter - cappedTurnsToCatchup;

                StopSimThread(false);  // alpha10

                if (cappedTurnsToCatchup > 0)
                {
                    // music.
                    m_MusicManager.StopAll();
                    m_MusicManager.Play(GameMusics.INTERLUDE, AudioPriority.PRIORITY_EVENT);

                    // force player view to darkness (so he gets no messages).
                    if (m_Player != null)
                    {
                        m_Player.Location.Map.ClearView();
                        entryMap.ClearView();
                    }

                    // alpha10 nope not here 
                    /*// stop simulation thread & get mutex.
                    StopSimThread();
                    Monitor.Enter(m_SimMutex);*/

                    // simulate loop.
#region
                    int turnsDone = 0;
                    double timerStart = DateTime.UtcNow.TimeOfDay.TotalMilliseconds;
                    double lastRedraw = 0;
                    bool aborted = false;
                    while (entryMap.LocalTime.TurnCounter < catchupTo) // alpha10 changed from <= to <
                    {
                        double timerNow = DateTime.UtcNow.TimeOfDay.TotalMilliseconds;

                        // time to redraw?
                        bool doRedraw = (turnsDone == 0 || timerNow >= lastRedraw + 1000);  // show on 1st turn & show at every elapsed second

                        // redraw?
#region
                        if (doRedraw)
                        {
                            // remember we redrawed.
                            lastRedraw = timerNow;

                            // show.
                            ClearMessages();
                            AddMessage(new Message(String.Format("Simulating district, please wait {0}/{1}...", turnsDone, cappedTurnsToCatchup), m_Session.WorldTime.TurnCounter, Color.White));
                            AddMessage(new Message("(this is an option you can tune)", m_Session.WorldTime.TurnCounter, Color.White));

                            // estimate turns per seconds and time left.
                            if (turnsDone > 1)
                            {
                                int turnsLeft = m_Session.WorldTime.TurnCounter - entryMap.LocalTime.TurnCounter;
                                double turnsPerSecs = 1000.0f * (float)turnsDone / (1 + timerNow - timerStart);
                                AddMessage(new Message(String.Format("Turns per second    : {0:F2}", turnsPerSecs), m_Session.WorldTime.TurnCounter, Color.White));

                                int secsLeft = (int)(turnsLeft / turnsPerSecs);
                                int mins = secsLeft / 60;
                                int secs = secsLeft % 60;
                                string etaFormat = (mins > 0 ? String.Format("{0} min {1:D2} secs", mins, secs) : String.Format("{0} secs", secs));
                                AddMessage(new Message(String.Format("Estimated time left : {0}", etaFormat), m_Session.WorldTime.TurnCounter, Color.White));
                            }
                            if (aborted)
                                AddMessage(new Message("Simulation aborted!", m_Session.WorldTime.TurnCounter, Color.Red));
                            else
                                AddMessage(new Message("<keep ESC pressed to abort the simulation>", m_Session.WorldTime.TurnCounter, Color.Yellow));
                            RedrawPlayScreen();

                            /*// keep looping music. //alpha 10, not necessary
                            if (!m_MusicManager.IsPlaying(GameMusics.INTERLUDE))
                                m_MusicManager.Play(GameMusics.INTERLUDE);*/
                        }
#endregion

                        // aborted?
                        if (aborted)
                            break;

                        // check for abort.
#region
                        KeyEventArgs key = m_UI.UI_PeekKey();
                        if (key != null && key.KeyCode == Keys.Escape)
                        {
                            // jump in time for each map.
                            foreach (Map map in district.Maps)
                                map.LocalTime.TurnCounter = m_Session.WorldTime.TurnCounter;
                            // abort!
                            aborted = true;
                        }
#endregion

                        // if not aborted, simulate the district.
                        if (!aborted)
                        {
                            // sim the district.
                            SimulateDistrict(district);
                            ++turnsDone;
                        }
                    }

                    // show final result of sim    //@@MP (Release 7-3)
                    if (!aborted)
                    {
                        double timerComplete = DateTime.UtcNow.TimeOfDay.TotalMilliseconds;
                        ClearMessages();
                        AddMessage(new Message(String.Format("Simulating district complete ({0} turns)", cappedTurnsToCatchup), m_Session.WorldTime.TurnCounter, Color.White));

                        double turnsPerSecs = 1000.0f * (float)turnsDone / (1 + timerComplete - timerStart);
                        AddMessage(new Message(String.Format("Turns per second :  {0:F2}", turnsPerSecs), m_Session.WorldTime.TurnCounter, Color.White));

                        TimeSpan timeElapsed = new TimeSpan((long)(timerComplete - timerStart));
                        string formattedElapsed = "< 1 second";
                        if (timeElapsed.Seconds > 0)
                            formattedElapsed = String.Format("{0:00}m:{1:00}s.{2:0000}ms", (int)timeElapsed.Minutes, timeElapsed.Seconds, timeElapsed.Milliseconds);
                        AddMessage(new Message(String.Format("Time elasped :  {0}", formattedElapsed), m_Session.WorldTime.TurnCounter, Color.White));
                    }
                    else
                    {
                        RemoveLastMessage(); // remove "ESC" message.
                        AddMessage(new Message("Simulation aborted!", m_Session.WorldTime.TurnCounter, Color.Yellow));
                    }
#endregion

                    // alpha10 obsolete and fix
                    //// release mutex and restart sim thread.
                    //Monitor.Exit(m_SimMutex); // alpha10 obsolete
                    //RestartSimThread();  // alpha10 no no no! restart AFTER chaging the player district duh!

                    // Sim ends - either aborted or normal end.
#region
                    // since sim arbitrary messes with actor APs, we're not quite sure were they are now.
                    // so force them back to zero to have a clean start.
                    foreach (Map map in district.Maps)
                        foreach (Actor a in map.Actors)
                            if (!a.IsSleeping)
                                a.ActionPoints = 0;

                    // stop music.
                    m_MusicManager.StopAll();
#endregion
                }  // sim has catch-up to do
            } // sim on
            else
            {
                // jump in time for each map.
                foreach (Map map in district.Maps)
                    map.LocalTime.TurnCounter = m_Session.WorldTime.TurnCounter;
            }

            if (m_Session.WorldTime.TurnCounter > (s_Options.DaysBeforeDiscardedItemDespawns * WorldTime.TURNS_PER_DAY))
            {
                foreach (Map map in district.Maps)
                {
                    //empty player-dropped backpacks         //@@MP (Release 8-2)
                    //EmptyBackpacksSittingIdle(map, map.LocalTime.TurnCounter); //opted not to use this in the end

                    //NPC-discarded items cleanup          //@@MP (Release 7-6)
                    DeleteItemsSittingIdle(map, map.LocalTime.TurnCounter);
                }
            }
            #endregion
        }

        void OnPlayerChangeMap()
        {
            RefreshPlayer();
        }
#endregion

#region -Interface
        bool HandleQuitGame()
        {
            AddMessage(MakeYesNoMessage("REALLY QUIT GAME"));
            RedrawPlayScreen();

            bool answer = WaitYesOrNo();

            if (!answer)
                AddMessage(new Message("Good. Keep roguing!", m_Session.WorldTime.TurnCounter, Color.Yellow));
            else
                AddMessage(new Message("Bye!", m_Session.WorldTime.TurnCounter, Color.Yellow));

            return answer;
        }

        bool HandleAbandonGame()
        {
            AddMessage(MakeYesNoMessage("REALLY KILL YOURSELF"));
            RedrawPlayScreen();

            bool answer = WaitYesOrNo();

            if (!answer)
                AddMessage(new Message("Good. No reason to make the undeads life easier by removing yours!", m_Session.WorldTime.TurnCounter, Color.Yellow));
            else
                AddMessage(new Message("You can't bear the horror anymore...", m_Session.WorldTime.TurnCounter, Color.Yellow));

            return answer;
        }

        void HandleScreenshot()
        {
            // prepare.
            AddMessage(new Message("Taking screenshot...", m_Session.WorldTime.TurnCounter, Color.Yellow));
            RedrawPlayScreen();

            // shot it!
            string shotname = DoTakeScreenshot();
            if (shotname == null)
            {
                AddMessage(new Message("Could not save screenshot.", m_Session.WorldTime.TurnCounter, Color.Red));
            }
            else
            {
                AddMessage(new Message(String.Format("screenshot {0} saved.", shotname), m_Session.WorldTime.TurnCounter, Color.Yellow));
            }

            // refresh.
            RedrawPlayScreen();
        }

        string DoTakeScreenshot()        
        {
            string shotname = GetUserNewScreenshotName();
            if (m_UI.UI_SaveScreenshot(ScreenshotFilePath(shotname)) != null)
                return shotname;
            else
                return null;
        }

        void HandleHelpMode()
        {
            if (m_Manual == null)
            {
                m_UI.UI_Clear(Color.Black);
                int gy = 0;
                m_UI.UI_DrawStringBold(Color.Red, "Game manual not available (file missing?).", 0, gy);
                gy += BOLD_LINE_SPACING;
                DrawFootnote(Color.White, "press ENTER");
                m_UI.UI_Repaint();
                WaitEnter();
                return;
            }

            bool loop = true;
            List<string> lines = m_Manual.FormatedLines;
            do
            {
                // draw header.
                m_UI.UI_Clear(Color.Black);
                int gy = 0;
                DrawHeader(0);
                gy += BOLD_LINE_SPACING;
                m_UI.UI_DrawStringBold(Color.Yellow, "Game Manual", 0, gy);
                gy += BOLD_LINE_SPACING;
                m_UI.UI_DrawStringBold(Color.White, "---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+", 0, gy);
                gy += BOLD_LINE_SPACING;

                // draw manual.
                int iLine = m_ManualLine;
                do
                {
                    // ignore commands
                    bool ignore = (lines[iLine] == "<SECTION>");

                    if (!ignore)
                    {
                        m_UI.UI_DrawStringBold(Color.LightGray, lines[iLine], 0, gy);
                        gy += BOLD_LINE_SPACING;
                    }
                    ++iLine;
                }
                while (iLine < lines.Count && gy < CANVAS_HEIGHT - 2 * BOLD_LINE_SPACING);

                // draw foot.
                m_UI.UI_DrawStringBold(Color.White, "---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+", 0, gy);
                gy += BOLD_LINE_SPACING;
                DrawFootnote(Color.White, "cursor and PgUp/PgDn to move, numbers to jump to section, ESC to leave");

                m_UI.UI_Repaint();

                // get command.
                KeyEventArgs key = m_UI.UI_WaitKey();
                int choice = KeyToChoiceNumber(key.KeyCode);

                if (choice >= 0)
                {
                    if (choice == 0)
                    {
                        m_ManualLine = 0;
                    }
                    else
                    {
                        // jump to Nth section.
                        int prevLine = m_ManualLine;
                        int sectionCount = 0;
                        m_ManualLine = 0;
                        while (sectionCount < choice && m_ManualLine < lines.Count)
                        {
                            if (lines[m_ManualLine] == "<SECTION>")
                            {
                                ++sectionCount;
                            }
                            ++m_ManualLine;
                        }

                        // if section not found, don't move.
                        if (m_ManualLine >= lines.Count)
                        {
                            m_ManualLine = prevLine;
                        }
                    }
                }
                else
                {
                    switch (key.KeyCode)
                    {
                        case Keys.Escape:
                            loop = false;
                            break;

                        case Keys.Up:
                            --m_ManualLine;
                            break;
                        case Keys.Down:
                            ++m_ManualLine;
                            break;
                        case Keys.PageUp:
                            m_ManualLine -= TEXTFILE_LINES_PER_PAGE;
                            break;
                        case Keys.PageDown:
                            m_ManualLine += TEXTFILE_LINES_PER_PAGE;
                            break;
                    }
                }

                if (m_ManualLine < 0) m_ManualLine = 0;
                if (m_ManualLine + TEXTFILE_LINES_PER_PAGE >= lines.Count) m_ManualLine = Math.Max(0, lines.Count - TEXTFILE_LINES_PER_PAGE);
            }
            while (loop);
        }

        void HandleHintsScreen()
        {
            // draw header.
            m_UI.UI_Clear(Color.Black);
            int gy = 0;
            DrawHeader(0);
            gy += BOLD_LINE_SPACING;
            m_UI.UI_DrawStringBold(Color.Yellow, "Advisor Hints", 0, gy);
            gy += BOLD_LINE_SPACING;

            // prepare : get all the hints text into one huuuuuge list of line :D
            m_UI.UI_DrawStringBold(Color.White, "preparing...", 0, gy);
            gy += BOLD_LINE_SPACING;
            m_UI.UI_Repaint();
            List<string> lines = new List<string>();
            for (int i = (int)AdvisorHint._FIRST; i < (int)AdvisorHint._COUNT; i++)
            {
                string title;
                string[] body;
                GetAdvisorHintText((AdvisorHint)i, out title, out body);
                if (s_Hints.IsAdvisorHintGiven((AdvisorHint)i)) title += " (hint already given)"; // alpha10

                lines.Add(String.Format("HINT {0} : {1}", i, title));
                lines.AddRange(body);
                lines.Add("~~~~");
                lines.Add("");
            }

            // display & handle loop.
            int currentLine = 0;
            bool loop = true;
            do
            {
                // header.
                m_UI.UI_Clear(Color.Black);
                gy = 0;
                DrawHeader(0);
                gy += BOLD_LINE_SPACING;
                m_UI.UI_DrawStringBold(Color.Yellow, "Advisor Hints", 0, gy);
                gy += BOLD_LINE_SPACING;

                // display currently viewed lines.
                m_UI.UI_DrawStringBold(Color.White, "---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+", 0, gy);
                gy += BOLD_LINE_SPACING;
                int iLine = currentLine;
                do
                {
                    m_UI.UI_DrawStringBold(Color.LightGray, lines[iLine], 0, gy);
                    gy += BOLD_LINE_SPACING;
                    ++iLine;
                }
                while (iLine < lines.Count && gy < CANVAS_HEIGHT - 2 * BOLD_LINE_SPACING);

                // draw foot.
                m_UI.UI_DrawStringBold(Color.White, "---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+", 0, gy);
                gy += BOLD_LINE_SPACING;
                DrawFootnote(Color.White, "cursor and PgUp/PgDn to move, R to reset hints, ESC to leave");

                m_UI.UI_Repaint();

                // get command.
                KeyEventArgs key = m_UI.UI_WaitKey();
                switch (key.KeyCode)
                {
                    case Keys.Escape:
                        loop = false;
                        break;

                    case Keys.Up:
                        --currentLine;
                        break;
                    case Keys.Down:
                        ++currentLine;
                        break;
                    case Keys.PageUp:
                        currentLine -= TEXTFILE_LINES_PER_PAGE;
                        break;
                    case Keys.PageDown:
                        currentLine += TEXTFILE_LINES_PER_PAGE;
                        break;

                    case Keys.R:
                        // do it.
                        s_Hints.ResetAllHints();

                        // notify.
                        m_UI.UI_Clear(Color.Black);
                        gy = 0;
                        DrawHeader(0);
                        gy += BOLD_LINE_SPACING;
                        m_UI.UI_DrawStringBold(Color.Yellow, "Advisor Hints", 0, gy);
                        gy += BOLD_LINE_SPACING;
                        m_UI.UI_DrawStringBold(Color.White, "Hints reset done.", 0, gy);
                        m_UI.UI_Repaint();
                        m_UI.UI_Wait(DELAY_LONG);
                        break;
                }

                if (currentLine < 0) currentLine = 0;
                if (currentLine + TEXTFILE_LINES_PER_PAGE >= lines.Count) currentLine = Math.Max(0, lines.Count - TEXTFILE_LINES_PER_PAGE);
            }
            while (loop);

        }

        void HandleMessageLog()
        {
            // draw header.
            m_UI.UI_Clear(Color.Black);
            int gy = 0;
            DrawHeader(0);
            gy += BOLD_LINE_SPACING;
            m_UI.UI_DrawStringBold(Color.Yellow, "Message Log", 0, gy);
            gy += BOLD_LINE_SPACING;
            m_UI.UI_DrawStringBold(Color.White, "---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+", 0, gy);
            gy += BOLD_LINE_SPACING;

            // log.
            foreach (Message msg in m_MessageManager.History)
            {
                m_UI.UI_DrawString(msg.Color, msg.Text, 0, gy);
                gy += LINE_SPACING;
            }

            // foot.
            DrawFootnote(Color.White, "press ESC to leave");
            
            // wait.
            m_UI.UI_Repaint();
            WaitEscape();
        }

        void HandleCityInfo()
        {
            int gx, gy;

            gx = gy = 0;
            m_UI.UI_Clear(Color.Black);
            m_UI.UI_DrawStringBold(Color.White, "CITY INFORMATION", gy, gy);
            gy += 2 * BOLD_LINE_SPACING;

            /////////////////////
            // Undead : no info!
            // Living : normal.
            /////////////////////
            if (m_Player.Model.Abilities.IsUndead)
            {
#region Undead : no info
                m_UI.UI_DrawStringBold(Color.Red, "You can't remember where you are...", gx, gy);
                gy += BOLD_LINE_SPACING;
                m_UI.UI_DrawStringBold(Color.Red, "Must be that rotting brain of yours...", gx, gy);
                gy += 2 * BOLD_LINE_SPACING;
#endregion
            }
            else
            {
#region Living : show info
                ////////////
                // City map
                ////////////
#region
                m_UI.UI_DrawStringBold(Color.White, "> DISTRICTS LAYOUT", gx, gy);
                gy += BOLD_LINE_SPACING;

                // coordinates.
                gy += BOLD_LINE_SPACING;
                for (int y = 0; y < m_Session.World.Size; y++)
                {
                    Color color = (y == m_Player.Location.Map.District.WorldPosition.Y ? Color.LightGreen : Color.White);
                    m_UI.UI_DrawStringBold(color, y.ToString(), 20, gy + y * 3 * BOLD_LINE_SPACING + BOLD_LINE_SPACING);
                    m_UI.UI_DrawStringBold(color, ".", 20, gy + y * 3 * BOLD_LINE_SPACING);
                    m_UI.UI_DrawStringBold(color, ".", 20, gy + y * 3 * BOLD_LINE_SPACING + 2 * BOLD_LINE_SPACING);
                }
                gy -= BOLD_LINE_SPACING;
                for (int x = 0; x < m_Session.World.Size; x++)
                {
                    Color color = (x == m_Player.Location.Map.District.WorldPosition.X ? Color.LightGreen : Color.White);
                    m_UI.UI_DrawStringBold(color, String.Format("..{0}..", (char)('A'+x)), 32 + x * 48, gy);
                }
                // districts.
                gy += BOLD_LINE_SPACING;
                int mx = 32;
                int my = gy;
                for (int y = 0; y < m_Session.World.Size; y++)
                    for (int x = 0; x < m_Session.World.Size; x++)
                    {
                        District d = m_Session.World[x, y];
                        char dStatus = d == m_Session.CurrentMap.District ? '*' : m_Session.Scoring.HasVisited(d.EntryMap) ? '-' : '?';
                        Color dColor;
                        string dChar;
                        switch (d.Kind)
                        {
                            case DistrictKind.BUSINESS: dColor = Color.Red; dChar = "Bus"; break;
                            case DistrictKind.GENERAL: dColor = Color.Gray; dChar = "Gen"; break;
                            case DistrictKind.GREEN: dColor = Color.Green; dChar = "Gre"; break;
                            case DistrictKind.RESIDENTIAL: dColor = Color.Orange; dChar = "Res"; break;
                            case DistrictKind.SHOPPING: dColor = Color.White; dChar = "Sho"; break;
                            default:
                                throw new InvalidOperationException("unhandled district kind");
                        }

                        string lchar = "";
                        for (int i = 0; i < 5; i++)
                            lchar += dStatus;

                        Color lColor = (d == m_Player.Location.Map.District ? Color.Pink : dColor); //alpha 10
                        m_UI.UI_DrawStringBold(lColor, lchar, mx + x * 48, my + (y * 3) * BOLD_LINE_SPACING);
                        m_UI.UI_DrawStringBold(lColor, dStatus.ToString(), mx + x * 48, my + (y * 3 + 1) * BOLD_LINE_SPACING);
                        m_UI.UI_DrawStringBold(dColor, dChar, mx + x * 48 + 8, my + (y * 3 + 1) * BOLD_LINE_SPACING);
                        m_UI.UI_DrawStringBold(lColor, dStatus.ToString(), mx + x * 48 + 4 * 8, my + (y * 3 + 1) * BOLD_LINE_SPACING);
                        m_UI.UI_DrawStringBold(lColor, lchar, mx + x * 48, my + (y * 3 + 2) * BOLD_LINE_SPACING);
                    }
                // subway line.
                const string subwayChar = "=";
                int subwayY = m_Session.World.Size / 2;
                for (int x = 1; x < m_Session.World.Size; x++)
                {
                    m_UI.UI_DrawStringBold(Color.White, subwayChar, mx + x * 48 - 8, my + (subwayY * 3) * BOLD_LINE_SPACING + BOLD_LINE_SPACING);
                }

                gy += (m_Session.World.Size * 3 + 1) * BOLD_LINE_SPACING;
                m_UI.UI_DrawStringBold(Color.White, "Legend", gx, gy);
                gy += BOLD_LINE_SPACING;
                m_UI.UI_DrawString(Color.White, "  *   - current     ?   - unvisited", gx, gy);
                gy += LINE_SPACING;
                m_UI.UI_DrawString(Color.White, "  Bus - Business    Gen - General", gx, gy);
                gy += LINE_SPACING;
                m_UI.UI_DrawString(Color.White, "  Res - Residential Sho - Shopping", gx, gy);
                gy += LINE_SPACING;
                m_UI.UI_DrawString(Color.White, "  Gre - Green       =   - Subway Line", gx, gy);
                gy += LINE_SPACING;
#endregion

                /////////////////////
                // Notable locations
                /////////////////////
#region
                gy += BOLD_LINE_SPACING;
                m_UI.UI_DrawStringBold(Color.White, "> NOTABLE LOCATIONS", gx, gy);
                gy += BOLD_LINE_SPACING;
                int buildingsY = gy;
                for (int y = 0; y < m_Session.World.Size; y++)
                    for (int x = 0; x < m_Session.World.Size; x++)
                    {
                        District d = m_Session.World[x, y];
                        Map map = d.EntryMap;

                        // Subway station?
                        Zone subwayZone;
                        if ((subwayZone = map.GetZoneByPartialName(NAME_SUBWAY_STATION)) != null)
                        {
                            m_UI.UI_DrawStringBold(Color.Blue, String.Format(" at {0} : {1}", World.CoordToString(x, y), subwayZone.Name), gx, gy);
                            gy += BOLD_LINE_SPACING;
                            if (gy >= CANVAS_HEIGHT - 2 * BOLD_LINE_SPACING)
                            {
                                gy = buildingsY;
                                gx += 25 * BOLD_LINE_SPACING;
                            }

                        }

                        // Sewers maintenance? // alpha10 removed
                        /*Zone sewersZone;
                        if ((sewersZone = map.GetZoneByPartialName(NAME_SEWERS_MAINTENANCE)) != null)
                        {
                            m_UI.UI_DrawStringBold(Color.Green, String.Format(" at {0} : {1}", World.CoordToString(x, y), sewersZone.Name), gx, gy);
                            gy += BOLD_LINE_SPACING;
                            if (gy >= CANVAS_HEIGHT - 2 * BOLD_LINE_SPACING)
                            {
                                gy = buildingsY;
                                gx += 25 * BOLD_LINE_SPACING;
                            }
                        }*/

                        // Police station?
                        if (map == m_Session.UniqueMaps.PoliceStation_OfficesLevel.TheMap.District.EntryMap)
                        {
                            m_UI.UI_DrawStringBold(Color.CadetBlue, String.Format(" at {0} : Police Station", World.CoordToString(x, y)), gx, gy);
                            gy += BOLD_LINE_SPACING;
                            if (gy >= CANVAS_HEIGHT - 2 * BOLD_LINE_SPACING)
                            {
                                gy = buildingsY;
                                gx += 25 * BOLD_LINE_SPACING;
                            }
                        }

                        // Hospital?
                        if (map == m_Session.UniqueMaps.Hospital_Admissions.TheMap.District.EntryMap)
                        {
                            m_UI.UI_DrawStringBold(Color.White, String.Format(" at {0} : Hospital", World.CoordToString(x, y)), gx, gy);
                            gy += BOLD_LINE_SPACING;
                            if (gy >= CANVAS_HEIGHT - 2 * BOLD_LINE_SPACING)
                            {
                                gy = buildingsY;
                                gx += 25 * BOLD_LINE_SPACING;
                            }
                        }

                        // Shopping mall   //@@MP (Release 7-3)
                        if (map == m_Session.UniqueMaps.ShoppingMall_GroundFloor.TheMap.District.EntryMap)
                        {
                            m_UI.UI_DrawStringBold(Color.White, String.Format(" at {0} : Shopping mall", World.CoordToString(x, y)), gx, gy);
                            gy += BOLD_LINE_SPACING;
                            if (gy >= CANVAS_HEIGHT - 2 * BOLD_LINE_SPACING)
                            {
                                gy = buildingsY;
                                gx += 25 * BOLD_LINE_SPACING;
                            }
                        }

                        // Secrets
                        // - CHAR Underground Facility?
                        if (m_Session.PlayerKnows_CHARUndergroundFacilityLocation && map == m_Session.UniqueMaps.CHARUndergroundFacility.TheMap.District.EntryMap)
                        {
                            m_UI.UI_DrawStringBold(Color.Red, String.Format(" at {0} : {1}", World.CoordToString(x, y), m_Session.UniqueMaps.CHARUndergroundFacility.TheMap.Name), gx, gy);
                            gy += BOLD_LINE_SPACING;
                            if (gy >= CANVAS_HEIGHT - 2 * BOLD_LINE_SPACING)
                            {
                                gy = buildingsY;
                                gx += 25 * BOLD_LINE_SPACING;
                            }
                        }
                        // - The Sewers Thing?
                        if (m_Session.PlayerKnows_TheSewersThingLocation && 
                            map == m_Session.UniqueActors.TheSewersThing.TheActor.Location.Map.District.EntryMap &&
                            !m_Session.UniqueActors.TheSewersThing.TheActor.IsDead)
                        {
                            m_UI.UI_DrawStringBold(Color.Red, String.Format(" at {0} : The Sewers Thing lives down there.", World.CoordToString(x, y)), gx, gy);
                            gy += BOLD_LINE_SPACING;
                            if (gy >= CANVAS_HEIGHT - 2 * BOLD_LINE_SPACING)
                            {
                                gy = buildingsY;
                                gx += 25 * BOLD_LINE_SPACING;
                            }
                        }
                        //@@MP (Release 6-3)
                        // - Army base?
                        if (m_Session.PlayerKnows_ArmyBaseLocation && map == m_Session.UniqueMaps.ArmyBase.TheMap.District.EntryMap)
                        {
                            m_UI.UI_DrawStringBold(Color.Khaki, String.Format(" at {0} : {1}", World.CoordToString(x, y), m_Session.UniqueMaps.ArmyBase.TheMap.Name), gx, gy);
                            gy += BOLD_LINE_SPACING;
                            if (gy >= CANVAS_HEIGHT - 2 * BOLD_LINE_SPACING)
                            {
                                gy = buildingsY;
                                gx += 25 * BOLD_LINE_SPACING;
                            }
                        }
                        // Helicopter rescue location
                        if (m_Session.PlayerKnows_HelicopterArrivalDetails && map == m_Session.UniqueMaps.ArmyBase.TheMap.District.EntryMap)
                        {
                            m_UI.UI_DrawStringBold(Color.Khaki, String.Format(" at {0} : {1}{2} on day {3}", m_Session.ArmyHelicopterRescue_DistrictRef, "Helicopter rescue spot @", (m_Session.ArmyHelicopterRescue_Coordinates.X + "-" + m_Session.ArmyHelicopterRescue_Coordinates.Y), m_Session.ArmyHelicopterRescue_Day.ToString()), gx, gy);
                            gy += BOLD_LINE_SPACING;
                            if (gy >= CANVAS_HEIGHT - 2 * BOLD_LINE_SPACING)
                            {
                                gy = buildingsY;
                                gx += 25 * BOLD_LINE_SPACING;
                            }
                        }
                    }
#endregion

                /////////////////
                // Tag locations  //@@MP (Release 6-6)
                /////////////////
#region
                gx = 380;
                gy = 2 * BOLD_LINE_SPACING;
                m_UI.UI_DrawStringBold(Color.White, "> YOUR TAG LOCATIONS", gx, gy);
                gy += BOLD_LINE_SPACING;
                gx += 32;
                int tagsCount = 0;
                for (int dy = 0; dy < m_Session.World.Size; dy++)
                {
                    for (int dx = 0; dx < m_Session.World.Size; dx++)
                    {
                        District d = m_Session.World[dx, dy];
                        Map map = d.EntryMap;
                        if (m_Session.Scoring.HasVisited(map))
                        {
                            for (int ma = 0; ma < map.Width; ma++)
                            {
                                for (int mb = 0; mb < map.Height; mb++)
                                {
                                    Tile tile = map.GetTileAt(ma, mb);
                                    if (tile.IsVisited)
                                    {
                                        string colour = null;
                                        Color tagColor = Color.White;
                                        if (tile.HasDecoration(GameImages.DECO_PLAYER_TAG1))
                                        {
                                            colour = "yellow";
                                            tagColor = Color.Gold;
                                        }
                                        else if (tile.HasDecoration(GameImages.DECO_PLAYER_TAG2))
                                        {
                                            colour = "blue";
                                            tagColor = Color.Blue;
                                        }   
                                        else if (tile.HasDecoration(GameImages.DECO_PLAYER_TAG3))
                                        {
                                            colour = "green";
                                            tagColor = Color.LimeGreen;
                                        }   
                                        else if (tile.HasDecoration(GameImages.DECO_PLAYER_TAG4))
                                        {
                                            colour = "pink";
                                            tagColor = Color.HotPink;
                                        }   

                                        if (!String.IsNullOrEmpty(colour))
                                        {
                                            //get the name of the tag's location in-map
                                            string locName = "";
                                            List<Zone> zones = map.GetZonesAt(ma, mb);
                                            if (zones != null && zones.Count == 0)
                                            {
                                                foreach (Zone z in zones)
                                                {
                                                    int index = z.Name.IndexOf("@"); //eg "Subway Station@29-42"
                                                    string nameOnly = (index > 0 ? z.Name.Substring(0, index) : "");
                                                    locName += String.Format("{0} ", nameOnly); //eg "Subway Station"
                                                }
                                            }

                                            gy += BOLD_LINE_SPACING;
                                            m_UI.UI_DrawStringBold(tagColor, (colour + " at " + World.CoordToString(dx, dy) + " : " + locName + "(" + ma + "," + mb + ")"), gx, gy);
                                            ++tagsCount;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                if (tagsCount == 0)
                {
                    gy += BOLD_LINE_SPACING;
                    m_UI.UI_DrawStringBold(Color.White, "*no tags sprayed yet", gx, gy);
                    ++tagsCount;
                }
#endregion
#endregion
            }

            DrawFootnote(Color.White, "press ESC to leave");
            m_UI.UI_Repaint();
            WaitEscape();
        }

        void HandleIconsLegend() //@@MP (Release 6-1)
        {
            Point pos = new Point(0, 0);
            AddOverlay(new OverlayImage(pos, GameImages.ICONS_LEGEND));
            ClearMessages();
            AddMessagePressEnter();
            ClearOverlays();
        }

        void HandleInspectionMode() //@@MP (Release 7-1)
        {
            //starting on the player's tile each time
            m_PlayerInspectionModePt = m_Player.Location.Position;

            AddOverlay(new OverlayPopup(INSPECTION_MODE_TEXT, MODE_TEXTCOLOR, MODE_BORDERCOLOR, MODE_FILLCOLOR, Point.Empty));
            RedrawPlayScreen();

            bool loop = true;
            do
            {
                // Get input.
                Direction dir = WaitDirectionOrCancel();

                // Handle input
                if (dir == null)
                {
                    loop = false;
                }
                else if (dir != Direction.NEUTRAL)
                {
                    HandleInspection(dir);
                }
            }
            while (loop);
            
            ClearOverlays();
            RedrawPlayScreen();
        }

        void HandleInspection(Direction dir)
        {
            Point inspectPT = m_PlayerInspectionModePt + dir;

            // Ignore if out of view rect.
            if (!IsInViewRect(inspectPT))
                return;

            // Nothing to do if out of map.
            if (!m_Session.CurrentMap.IsInBounds(inspectPT))
                return;

            // Do look.
            ClearOverlays();
            if (IsVisibleToPlayer(m_Session.CurrentMap, inspectPT))
            {
                m_PlayerInspectionModePt = inspectPT;

                Point tileScreenPos = MapToScreen(inspectPT);
                string[] description = DescribeStuffAt(m_Session.CurrentMap, inspectPT);
                if (description != null)
                {
                    Point popupPos = new Point(tileScreenPos.X + TILE_SIZE, tileScreenPos.Y);
                    Actor actorThere = m_Session.CurrentMap.GetActorAt(inspectPT);

                    // prevent overlays being cut off at the bottom of the screen  //@@MP (Release 7-5)
                    Inventory invThere = m_Session.CurrentMap.GetItemsAt(inspectPT);
                    bool longInvList = (invThere != null && invThere.CountItems > 5);  //theres lots of items, which will make the popup large

                    if (actorThere != null || longInvList)
                    {
                        if (tileScreenPos.Y > 400)
                            popupPos.Y -= (6 * TILE_SIZE);
                    }

                    AddOverlay(new OverlayPopup(description, Color.White, Color.White, POPUP_FILLCOLOR, popupPos));
                    if (s_Options.ShowTargets)
                    {
                        if (actorThere != null)
                            DrawActorRelations(actorThere);
                    }
                }

                AddOverlay(new OverlayImage(MapToScreen(inspectPT), GameImages.INSPECTION_MODE_HIGHLIGHT));
                AddOverlay(new OverlayPopup(INSPECTION_MODE_TEXT, MODE_TEXTCOLOR, MODE_BORDERCOLOR, MODE_FILLCOLOR, Point.Empty));
                RedrawPlayScreen();
            }
        }
#endregion

#region -Translating commands
        public static Direction CommandToDirection(PlayerCommand cmd)
        {
            switch (cmd)
            {
                case PlayerCommand.MOVE_N:
                    return Direction.N;
                case PlayerCommand.MOVE_NE:
                    return Direction.NE;
                case PlayerCommand.MOVE_E:
                    return Direction.E;
                case PlayerCommand.MOVE_SE:
                    return Direction.SE;
                case PlayerCommand.MOVE_S:
                    return Direction.S;
                case PlayerCommand.MOVE_SW:
                    return Direction.SW;
                case PlayerCommand.MOVE_W:
                    return Direction.W;
                case PlayerCommand.MOVE_NW:
                    return Direction.NW;
                case PlayerCommand.WAIT_OR_SELF:
                    return Direction.NEUTRAL;

                default:
                    return null;
            }
        }
#endregion
#endregion

#region ACTIONS PRIMATIVES: DoXXX
#region -MOVEMENT
        public void DoMoveActor(Actor actor, Location newLocation)
        {
            Location oldLocation = actor.Location;

            // Try to leave tile.
            if (!TryActorLeaveTile(actor))
            {
                // waste ap.
                SpendActorActionPoints(actor, Rules.BASE_ACTION_COST);
                return;
            }

            // Do the move.
            if (oldLocation.Map == newLocation.Map)
                newLocation.Map.PlaceActorAt(actor, newLocation.Position);
            else
                throw new NotImplementedException("DoMoveActor : illegal to change map.");

            // If dragging corpse, move it along.
            Corpse draggedCorpse = actor.DraggedCorpse;
            if (draggedCorpse != null)
            {
                oldLocation.Map.MoveCorpseTo(draggedCorpse, newLocation.Position);
                if (IsVisibleToPlayer(newLocation) || IsVisibleToPlayer(oldLocation))
                    AddMessage(MakeMessage(actor, String.Format("{0} {1} corpse.", Conjugate(actor, VERB_DRAG), draggedCorpse.DeadGuy.TheName)));
            }

            // If fishing, force unequip fishing rod        //@@MP (Release 7-6)
            Item leftHandItem = actor.GetEquippedItem(DollPart.LEFT_HAND);
            if (leftHandItem != null && leftHandItem.Model == GameItems.FISHING_ROD)
                DoUnequipItem(actor, leftHandItem, false);

            // Spend AP & STA, check for running, jumping and dragging corpse.
#region
            int moveCost = Rules.BASE_ACTION_COST;

            //moving through water hurts STA //@@MP (Release 6-1)
            if (actor.IsInWater)
            {
                // x2 slower.
                moveCost *= 2;
                // cost STA.
                SpendActorStaminaPoints(actor, Rules.STAMINA_COST_RUNNING); //same as running
            }

            // running?
            if (actor.IsRunning)
            {
                // x2 faster.
                moveCost /= 2;
                // cost STA.
                SpendActorStaminaPoints(actor, Rules.STAMINA_COST_RUNNING);
            }

            bool isJump = false;
            MapObject mapObj = newLocation.Map.GetMapObjectAt(newLocation.Position.X, newLocation.Position.Y);
            if (mapObj != null && !mapObj.IsWalkable && mapObj.IsJumpable)
                isJump = true;

            // jumping?
            if (isJump)
            {
                // cost STA.
                SpendActorStaminaPoints(actor, Rules.STAMINA_COST_JUMP);

                // show.
                if (IsAudibleToPlayer(newLocation, Rules.QUIET_NOISE_RADIUS)) //@@MP - switched to IsVisible (Release 2), changed it back to audible now that it can be supplied a range (Release 5-4)
                {
                    //@@MP - order them by most common descending
                    if (mapObj.TheName == "the chain wire fence")
                    {
                        if (actor.IsPlayer)
                            m_SFXManager.Play(GameSounds.CLIMB_FENCE_PLAYER, AudioPriority.PRIORITY_BGM);
                        else
                            m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.CLIMB_FENCE_NEARBY, AudioPriority.PRIORITY_BGM);
                    }
                    else if (mapObj is Car) //@@MP - use Car type (Release 7-3)
                    {
                        if (actor.IsPlayer)
                            m_SFXManager.Play(GameSounds.CLIMB_CAR_PLAYER, AudioPriority.PRIORITY_BGM);
                        else
                            m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.CLIMB_CAR_NEARBY, AudioPriority.PRIORITY_BGM);
                    }
                }

                if (IsVisibleToPlayer(actor) && !actor.IsPlayer) //@@MP - moved out of the IsAudible check (Release 5-4)
                    AddMessage(MakeMessage(actor, Conjugate(actor, VERB_JUMP_ON), mapObj));

                // if CanJumpStumble ability, has a chance to stumble.
                if (actor.Model.Abilities.CanJumpStumble && m_Rules.RollChance(Rules.JUMP_STUMBLE_CHANCE))
                {
                    // stumble!
                    moveCost += Rules.JUMP_STUMBLE_ACTION_COST;

                    // show.
                    if (IsVisibleToPlayer(actor))
                        AddMessage(MakeMessage(actor, String.Format("{0}!", Conjugate(actor, VERB_STUMBLE))));
                }
            } 

            // dragging?
            if (draggedCorpse != null)
            {
                // cost STA.
                SpendActorStaminaPoints(actor, Rules.STAMINA_COST_MOVE_DRAGGED_CORPSE);
            }

            // spend move AP.
            SpendActorActionPoints(actor, moveCost);
#endregion

            // If actor can move again, make sure he drops his scent here. If we don't do this, since scents are dropped only in new turns,
            // there will be "holes" in the scent paths, and this is not fair for zombies who will loose track of running livings easily.
            if (actor.ActionPoints > 0) // alpha10 fix; was Rules.BASE_ACTION_COST
                DropActorScent(actor);

            // Screams of terror?
#region
            if (!actor.IsPlayer && actor.IsFleeing && !actor.Model.Abilities.IsUndead && actor.Model.Abilities.CanTalk)
            {
                // loud noise.
                OnLoudNoise(newLocation.Map, newLocation.Position, "A loud SCREAM");

                // player hears?
                DoScream(actor.Location, actor.Model.DollBody.IsMale, false, true); //@@MP - refactored to a separate method (Release 5-7)
            }
#endregion

            // Trigger stuff.
            OnActorEnterTile(actor);
        }

        public void DoMoveActor(Actor actor, Direction direction)
        {
            DoMoveActor(actor, actor.Location + direction);
        }

        public void OnActorEnterTile(Actor actor)
        {
            Map map = actor.Location.Map;
            Point pos = actor.Location.Position;

            // check ambient sound effects  //@@MP
            if (actor.IsPlayer) //@@MP - added check (Release 6-1)
            {
                CheckAmbientSFX(map); //@MP (Release 5-3)
                CheckLandedHelicopterSFX(map); //@@MP (Release 6-4)
            }

            if (map.GetTileAt(pos).Model.IsWater) //@@MP - added check (Release 6-1)
            {
                actor.IsInWater = true;
                ExtinguishOnFireActor(actor);
            }
            else
                actor.IsInWater = false;

            // Check traps.
            // Don't check if there is a covering mobj there.
            if (!m_Rules.IsTrapCoveringMapObjectThere(map,pos))
            {
                Inventory itemsThere = map.GetItemsAt(pos);
                if (itemsThere != null)
                {
                    List<Item> removeThem = null;
                    foreach (Item it in itemsThere.Items)
                    {
                        ItemTrap trap = it as ItemTrap;
                        if (trap == null || !trap.IsActivated)
                            continue;
                        if (TryTriggerTrap(trap, actor))
                        {
                            if (removeThem == null) removeThem = new List<Item>(itemsThere.CountItems);
                            removeThem.Add(it);
                        }
                    }
                    if (removeThem != null)
                    {
                        foreach (Item it in removeThem)
                            map.RemoveItemAt(it, pos);
                    }
                    // Kill actor?
                    if (actor.HitPoints <= 0)
                        KillActor(null, actor, "stepped on a trap");
                }
            }          
        }

        bool TryActorLeaveTile(Actor actor)
        {
            Map map = actor.Location.Map;
            Point pos = actor.Location.Position;
            bool canLeave = true;

            // Check traps.
            if (!m_Rules.IsTrapCoveringMapObjectThere(map, pos))
            {
                Inventory itemsThere = map.GetItemsAt(pos);
                if (itemsThere != null)
                {
                    List<Item> removeThem = null;
                    bool hasTriggeredTraps = false;
                    foreach (Item it in itemsThere.Items)
                    {
                        ItemTrap trap = it as ItemTrap;
                        if (trap == null || !trap.IsTriggered)
                            continue;
                        hasTriggeredTraps = true;
                        bool isDestroyed = false;
                        if (!TryEscapeTrap(trap, actor, out isDestroyed))
                        {
                            canLeave = false;
                            continue;
                        }
                        if (isDestroyed)
                        {
                            if (removeThem == null) removeThem = new List<Item>(itemsThere.CountItems);
                            removeThem.Add(it);
                        }
                    }
                    if (removeThem != null)
                    {
                        foreach (Item it in removeThem)
                            map.RemoveItemAt(it, pos);
                    }
                    // if can leave, force un-trigger all traps.
                    if (canLeave && hasTriggeredTraps)
                        UntriggerAllTrapsHere(actor.Location);
                }
            }

            // Check adjacent Z-Grabs
            bool visible = IsVisibleToPlayer(actor);
            map.ForEachAdjacentInMap(pos, (adj) =>
            {
                Actor grabber = map.GetActorAt(adj);
                if (grabber == null)
                    return;
                if (!grabber.Model.Abilities.IsUndead)
                    return;
                if (!m_Rules.AreEnemies(grabber, actor))
                    return;
                int chance = m_Rules.ZGrabChance(grabber); //@@MP - unused parameter (Release 5-7)
                if (chance == 0) 
                    return;
                if (m_Rules.RollChance(m_Rules.ZGrabChance(grabber))) //@@MP - unused parameter (Release 5-7)
                {
                    // grabbed!
                    if (visible)
                        AddMessage(MakeMessage(grabber, Conjugate(grabber, VERB_GRAB), actor));
                    // stuck there!
                    canLeave = false;
                }
            });

            return canLeave;
        }
#endregion

#region -TRAPS
        /// <summary>
        /// @return true if item must be removed (destroyed).
        /// </summary>
        /// <param name="trap"></param>
        /// <returns></returns>
        bool TryTriggerTrap(ItemTrap trap, Actor victim)
        {
            // check trigger chance.
            if (m_Rules.CheckTrapTriggers(trap, victim))
                DoTriggerTrap(trap, victim.Location.Map, victim.Location.Position, victim, null);
            else
            {
                if (IsVisibleToPlayer(victim))
                    AddMessage(MakeMessage(victim, String.Format("safely {0} {1}.", Conjugate(victim, VERB_AVOID), trap.TheName)));
            } 
            // destroy?
            return trap.Quantity == 0;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="trap"></param>
        /// <param name="victim"></param>
        /// <param name="isDestroyed"></param>
        /// <returns>true succesful escape</returns>
        bool TryEscapeTrap(ItemTrap trap, Actor victim, out bool isDestroyed)
        {
            isDestroyed = false;
            ItemTrapModel model = trap.TrapModel;

            // no brainer.
            if (model.BlockChance <= 0)
                return true;

            bool visible = IsVisibleToPlayer(victim);
            bool canEscape = false;

            // check escape chance.
            if (m_Rules.CheckTrapEscape(trap, victim))
            {
                // un-triggered and escape.
                trap.IsTriggered = false;
                canEscape = true;

                // tell
                if (visible)
                    AddMessage(MakeMessage(victim, String.Format("{0} {1}.", Conjugate(victim, VERB_ESCAPE), trap.TheName)));

                // then check break on escape chance.
                if (m_Rules.CheckTrapEscapeBreaks(trap)) //@@MP - unused parameter (Release 5-7)
                {
                    if (visible)
                        AddMessage(MakeMessage(victim, String.Format("{0} {1}.", Conjugate(victim, VERB_BREAK), trap.TheName)));
                    --trap.Quantity;
                    isDestroyed = trap.Quantity <= 0;
                }
            }
            else
            {
                // tell
                if (visible)
                    AddMessage(MakeMessage(victim, String.Format("is trapped by {0}!", trap.TheName)));
            }

            // escape?
            return canEscape;
        }

        static void UntriggerAllTrapsHere(Location loc) //@@MP - made static (Release 5-7)
        {
            Inventory itemsThere = loc.Map.GetItemsAt(loc.Position);
            if (itemsThere == null) return;
            foreach (Item it in itemsThere.Items)
            {
                ItemTrap trap = it as ItemTrap;
                if (trap == null || !trap.IsTriggered)
                    continue;
                trap.IsTriggered = false;
            }
        }

        /// <summary>
        /// Checks that there is a map object that triggers the traps there.
        /// If so, a map object triggers ALL activated the traps here.
        /// </summary>
        /// <param name="map"></param>
        /// <param name="pos"></param>
        void CheckMapObjectTriggersTraps(Map map, Point pos)
        {
            if (!m_Rules.IsTrapTriggeringMapObjectThere(map, pos))
                return;

            MapObject mobj = map.GetMapObjectAt(pos);

            Inventory itemsThere = map.GetItemsAt(pos);
            if (itemsThere == null) return;

            List<Item> removeThem = null;
            foreach (Item it in itemsThere.Items)
            {
                ItemTrap trap = it as ItemTrap;
                if (trap == null || !trap.IsActivated)
                    continue;
                DoTriggerTrap(trap, map, pos, null, mobj);
                if (trap.Quantity <= 0)
                {
                    if (removeThem == null) removeThem = new List<Item>(itemsThere.CountItems);
                    removeThem.Add(it);
                }
            }
            if (removeThem != null)
            {
                foreach (Item it in removeThem)
                    map.RemoveItemAt(it, pos);
            }
        }

        /// <summary>
        /// Trigger a trap by an actor or a map object.
        /// </summary>
        /// <param name="trap"></param>
        /// <param name="map"></param>
        /// <param name="pos"></param>
        /// <param name="victim"></param>
        /// <param name="mobj"></param>
        void DoTriggerTrap(ItemTrap trap, Map map, Point pos, Actor victim, MapObject mobj)
        {
            ItemTrapModel model = trap.TrapModel;
            bool visible = IsVisibleToPlayer(map, pos);

            // flag.
            trap.IsTriggered = true;

            // audio
            Location location = new Location(map, pos); //@@MP (Release 5-4)
            //@@MP - play sounds as relevant (Release 3)
            if (victim != null)
            {
                if (victim.IsPlayer)
                {
                    switch (trap.TheName.ToString())
                    {
                        case "the empty can":
                            m_SFXManager.Play(GameSounds.CAN_TRAP_PLAYER, AudioPriority.PRIORITY_BGM);
                            break;
                        case "the bear trap":
                            m_SFXManager.Play(GameSounds.BEAR_TRAP_PLAYER, AudioPriority.PRIORITY_EVENT);
                            break;
                        case "the spike":
                            m_SFXManager.Play(GameSounds.SPIKE_TRAP, AudioPriority.PRIORITY_EVENT);
                            break;
                        case "the barbed wire":
                            m_SFXManager.Play(GameSounds.BARBED_WIRE_TRAP_PLAYER, AudioPriority.PRIORITY_EVENT);
                            break;
                        default: break;
                    }
                }
                else if (IsAudibleToPlayer(location, Rules.QUIET_NOISE_RADIUS)) //@@MP - changed from visible to audible now that it can be supplied a range (Release 5-4)
                {
                    switch (trap.TheName.ToString())
                    {
                        case "the empty can":
                            m_SFXManager.Play(GameSounds.CAN_TRAP_NEARBY, AudioPriority.PRIORITY_BGM);
                            break;
                        case "the bear trap":
                            m_SFXManager.Play(GameSounds.BEAR_TRAP_NEARBY, AudioPriority.PRIORITY_BGM);
                            DoScream(victim.Location, victim.Model.DollBody.IsMale, false, false); //@@MP - refactored to a separate method (Release 5-7)
                            break;
                        case "the spike":
                            m_SFXManager.Play(GameSounds.SPIKE_TRAP, AudioPriority.PRIORITY_BGM);
                            DoScream(victim.Location, victim.Model.DollBody.IsMale, false, false); //@@MP - refactored to a separate method (Release 5-7)
                            break;
                        default: break;
                    }
                }
                else if (IsAudibleToPlayer(location, Rules.MODERATE_NOISE_RADIUS)) //@@MP - changed from IsAudibleToPlayer(victim.Location)) to audible with a supplied a range (Release 5-4)
                {
                    switch (trap.TheName.ToString())
                    {
                        case "the empty can":
                            m_SFXManager.Play(GameSounds.CAN_TRAP_FAR, AudioPriority.PRIORITY_BGM);
                            break;
                        case "the bear trap":
                            m_SFXManager.Play(GameSounds.BEAR_TRAP_FAR, AudioPriority.PRIORITY_BGM);
                            DoScream(victim.Location, victim.Model.DollBody.IsMale, false, false); //@@MP - refactored to a separate method (Release 5-7)
                            break;
                        case "the spike":
                            DoScream(victim.Location, victim.Model.DollBody.IsMale, false, false); //@@MP - refactored to a separate method (Release 5-7)
                            break;
                        default: break;
                    }
                }
            }

            // effect: damage on victim?  //@MP - moved to after the sfx to make them sync better (Release 5-4)
            int damage = model.Damage * trap.Quantity;
            if (damage > 0 && victim != null) //@@MP - victim can be null if an object (eg chair) is pushed onto the tile
            {
                InflictDamage(victim, damage, false, false);
                switch (trap.TheName.ToString()) //@@MP - ensure at least some blood is dropped for the nastier traps (Release 3)
                {
                    case "the barbed wire":
                    case "the bear trap":
                    case "the spike":
                        SplatterBlood(map, pos, true);
                        if (victim.IsPlayer) //@@MP (Release 6-6)
                        {
                            if (victim.Doll.Body.IsMale)
                                m_SFXManager.Play(GameSounds.MALE_HURT, AudioPriority.PRIORITY_EVENT);
                            else
                                m_SFXManager.Play(GameSounds.FEMALE_HURT, AudioPriority.PRIORITY_EVENT);
                        }
                        break;
                    default: break;
                }
                if (visible)
                {
                    AddMessage(MakeMessage(victim, String.Format("is hurt by {0} for {1} damage!", trap.AName, damage)));
                    AddOverlay(new OverlayImage(MapToScreen(victim.Location.Position), GameImages.ICON_MELEE_DAMAGE));
                    AddOverlay(new OverlayText(MapToScreen(victim.Location.Position).Add(DAMAGE_DX, DAMAGE_DY), Color.White, damage.ToString(), Color.Black));
                    RedrawPlayScreen();
                    if (victim.IsPlayer)
                        AnimDelay(DELAY_SHORT, true);
                    else
                        AnimDelay(DELAY_SHORT, false);
                    ClearOverlays();
                    RedrawPlayScreen();
                }
            }
            // effect: noise? (actor, mobj)  //@MP - moved to after the sfx to make them sync better (Release 5-4)
            if (model.IsNoisy)
            {
                if (visible)
                {
                    if (victim != null)
                        AddMessage(MakeMessage(victim, String.Format("stepping on {0} makes a bunch of noise!", trap.AName)));
                    else if (mobj != null)
                        AddMessage(new Message(String.Format("{0} makes a lot of noise!", Capitalize(trap.TheName)), map.LocalTime.TurnCounter));
                }
                OnLoudNoise(map, pos, model.NoiseName);
            }

            // if one time trigger = deactivate.
            if (model.IsOneTimeUse)
                trap.Deactivate();  //alpha10 //trap.IsActivated = false;

            // then check break chance (actor, mobj)
            if (m_Rules.CheckTrapStepOnBreaks(trap, mobj))
            {
                if (visible)
                {
                    if (victim != null)
                        AddMessage(MakeMessage(victim, String.Format("{0} {1}.", Conjugate(victim, VERB_CRUSH), trap.TheName)));
                    else if (mobj != null)
                        AddMessage(new Message(String.Format("{0} breaks the {1}.", Capitalize(mobj.TheName), trap.TheName), map.LocalTime.TurnCounter));
                }
                --trap.Quantity;
            }
        }
#endregion

#region -Leaving maps & Using exits
        public bool DoLeaveMap(Actor actor, Point exitPoint, bool askForConfirmation)
        {
            bool isPlayer = actor.IsPlayer;

            Map fromMap = actor.Location.Map;
            Point fromPos = actor.Location.Position;

            // get exit.
            Exit exit = fromMap.GetExitAt(exitPoint);
            if (exit == null)
            {
                if (isPlayer)
                {
                    AddMessage(MakeErrorMessage("There is nowhere to go there."));
                }
                return true;
            }

            // if player, ask for a confirmation.
            if (isPlayer && askForConfirmation)
            {
                ClearMessages();
                AddMessage(MakeYesNoMessage(String.Format("REALLY LEAVE {0}", fromMap.Name)));
                RedrawPlayScreen();
                bool confirm = WaitYesOrNo();
                if (!confirm)
                {
                    AddMessage(new Message("Let's stay here a bit longer...", m_Session.WorldTime.TurnCounter, Color.Yellow));
                    RedrawPlayScreen();
                    return false;
                }
            }

            // Try to leave tile.
            if (!TryActorLeaveTile(actor))
            {
                // waste ap.
                SpendActorActionPoints(actor, Rules.BASE_ACTION_COST);
                return false;
            }

            // spend AP **IF AI**
            if (!actor.IsPlayer)
                SpendActorActionPoints(actor, Rules.BASE_ACTION_COST);

            // if player is leaving and changing district, prepare district.
            bool playerChangedDistrict = false;  // alpha10
            if (isPlayer && !actor.IsBotPlayer && exit.ToMap.District != fromMap.District)// alpha10.1 disallow bots from leaving districts
            {
                playerChangedDistrict = true;  // alpha10
                BeforePlayerEnterDistrict(exit.ToMap.District);
            }


            /////////////////////////////////////
            // 1. If spot not available, cancel.
            // 2. Remove from previous map (+ corpse)
            // 3. Enter map (+corpse).
            // 4. Handle followers.
            /////////////////////////////////////

            // 1. If spot not available, cancel.
            MapObject blockingObj = exit.ToMap.GetMapObjectAt(exit.ToPosition);
            if (blockingObj != null)
            {
                bool canJump = blockingObj.IsJumpable && m_Rules.HasActorJumpAbility(actor);
                bool ignoreIt = blockingObj.IsCouch;
                if (!canJump && !ignoreIt)
                {
                    if (isPlayer)
                    {
                        AddMessage(MakeErrorMessage(String.Format("{0} is blocking your way.", blockingObj.AName)));
                        AddMessage(MakeErrorMessage(String.Format("Try using Break Mode (key: {0}) to demolish the {1}.", s_KeyBindings.GetFriendlyFormat(PlayerCommand.BREAK_MODE).ToString(), blockingObj.AName)));
                    }
                    return false;  //@@MP - this logic was wrong as of R6-5, because I prevented placing objects on exits. see Rules.CanPushObjectTo()    //@@MP (Release 7-5)
                }
            }
            Actor other = exit.ToMap.GetActorAt(exit.ToPosition);
            if (other != null)
            {
                //@@MP (Release 7-5)
                //take the NPC and move them to the nearest empty square. works around an issue that confused a lot of players

                bool spotFound = false;
                Point moveToSpot = other.Location.Position; //placeholder

                //check all the immediately adjacent squares
                Point p = new Point(other.Location.Position.X, other.Location.Position.Y);
                foreach (Direction d in Direction.COMPASS)
                {
                    Point adj = p + d;
                    if (m_Rules.IsSuitableForActorRelocate(other, exit.ToMap, adj.X, adj.Y) && exit.ToMap.GetExitAt(adj) == null)
                    {
                        moveToSpot = adj;
                        spotFound = true;
                        break;
                    }
                }

                //if no adjacent spots suitable, pick a spot at random. not ideal, because they could be warped a long way from their starting spot,
                //or they could be placed inside a locked building. but i'm too lazy to do any better
                if (!spotFound)
                {
                    // try <maxTries> times to find a walkable position.
                    Point pos = new Point();
                    int maxTries = 2500;
                    for (int i = 0; i < maxTries; i++)
                    {
                        DiceRoller roller = new DiceRoller();
                        int left = 0, top = 0; //0,0 coords are the top left square of the map
                        pos.X = roller.Roll(left, left + exit.ToMap.Width);
                        pos.Y = roller.Roll(top, top + exit.ToMap.Height);

                        if (m_Rules.IsSuitableForActorRelocate(other, exit.ToMap, pos.X, pos.Y) && exit.ToMap.GetExitAt(pos) == null)
                        {
                            moveToSpot = pos;
                            spotFound = true;
                            break;
                        }
                    }
                }

                if (spotFound == false)  //couldn't find a suitable spot
                {
                    if (isPlayer) //couldn't find a suitable spot to move the NPC, so the player will have to Break mode or wait a turn and try again
                    {
                        AddMessage(MakeErrorMessage(String.Format("{0} is blocking your way.", other.Name)));
                    }
                    //Logger.WriteLine(Logger.Stage.RUN_MAIN, String.Format("{0} can't use exit: can't relocate {1}", actor.Name, other.Name)); //DELETETHIS
                    return false;
                }
                else
                {
                    //now take the NPC from the exit square and put them on the empty square
                    if (other.DraggedCorpse != null)
                    {
                        exit.ToMap.RemoveCorpse(other.DraggedCorpse);
                        exit.ToMap.AddCorpseAt(other.DraggedCorpse, moveToSpot);
                    }
                    exit.ToMap.RemoveActor(other);
                    exit.ToMap.PlaceActorAt(other, moveToSpot);
                    exit.ToMap.MoveActorToFirstPosition(other);

                    //Logger.WriteLine(Logger.Stage.RUN_MAIN, String.Format("{0} forced {1} to relocate to {2}", actor.Name, other.Name, moveToSpot.ToString())); //DELETETHIS
                }
            }
 
            // 2. Remove from previous map (+corpse)
            if (IsVisibleToPlayer(actor))
            {
                AddMessage(MakeMessage(actor, String.Format("{0} {1}.", Conjugate(actor, VERB_LEAVE), fromMap.Name)));
            }
            fromMap.RemoveActor(actor);
            if (actor.DraggedCorpse != null)
                fromMap.RemoveCorpse(actor.DraggedCorpse);
            if (isPlayer && exit.ToMap.District != fromMap.District)
            {
                OnPlayerLeaveDistrict();
            }

            // 3. Enter map (+corpse)
            exit.ToMap.PlaceActorAt(actor, exit.ToPosition);
            exit.ToMap.MoveActorToFirstPosition(actor);
            if (actor.DraggedCorpse != null)
            {
                exit.ToMap.AddCorpseAt(actor.DraggedCorpse, exit.ToPosition);
            }
            if (IsVisibleToPlayer(actor) || isPlayer)
            {
                AddMessage(MakeMessage(actor, String.Format("{0} {1}.", Conjugate(actor, VERB_ENTER), exit.ToMap.Name)));
            }
            if (isPlayer)
            {
                // scoring event.
                if (fromMap.District != exit.ToMap.District)
                    m_Session.Scoring.AddEvent(m_Session.WorldTime.TurnCounter, String.Format("Entered district {0}.", exit.ToMap.District.Name));

                // change map.
                SetCurrentMap(exit.ToMap);

                // warning if using NVG in lit map
                WarnAboutNightVision(); //@@MP (Release 7-1)
            }
            // Trigger stuff.
            OnActorEnterTile(actor);

            // 4. Handle followers.
            if (actor.CountFollowers > 0)
            {
                DoFollowersEnterMap(actor, fromMap, fromPos, exit.ToMap, exit.ToPosition);
            }

            // handle after player changed district
            if (playerChangedDistrict) // alpha10
            {
                // restart sim thread if on
                if (s_Options.IsSimON && s_Options.SimThread)
                    StartSimThread();
            }

            // done.
            return true;
        }

        void DoFollowersEnterMap(Actor leader, Map fromMap, Point fromPos, Map toMap, Point toPos)
        {
            bool leavePeopleBehind = toMap.District != fromMap.District;
            bool isPlayer = m_Player == leader;
            List<Actor> leftBehind = null;

            foreach(Actor fo in leader.Followers)
            {
                // can follow only if was adj to leader and find free adj spot on the new map.
                bool canFollow = false;
                List<Point> adjList = null;

                if (m_Rules.IsAdjacent(fromPos, fo.Location.Position))
                {
                    adjList = toMap.FilterAdjacentInMap(toPos, (pt) => m_Rules.IsWalkableFor(fo, toMap, pt.X, pt.Y));
                    if (adjList == null || adjList.Count == 0)
                        canFollow = false;
                    else
                        canFollow = true;
                }

                if (!canFollow)
                {
                    // cannot follow.
                    if (leftBehind == null) leftBehind = new List<Actor>(3);
                    leftBehind.Add(fo);
                }
                else
                {
                    // can follow, do it now.
                    // Try to leave tile.
                    if (TryActorLeaveTile(fo))
                    {
                        Point spot = adjList[m_Rules.Roll(0, adjList.Count)];
                        fromMap.RemoveActor(fo);
                        toMap.PlaceActorAt(fo, spot);
                        toMap.MoveActorToFirstPosition(fo);
                        // Trigger stuff.
                        OnActorEnterTile(fo);
                    }
                }
            }

            // make followers left behind leave if must.
            if (leftBehind != null)
            {
                foreach (Actor leaveMe in leftBehind)
                {
                    if (leavePeopleBehind)
                    {
                        leader.RemoveFollower(leaveMe);
                        if (isPlayer)
                        {
                            // scoring.
                            m_Session.Scoring.AddEvent(m_Session.WorldTime.TurnCounter, String.Format("{0} was left behind.", leaveMe.TheName));

                            // message.
                            ClearMessages();
                            AddMessage(new Message(String.Format("{0} could not follow you out of the district and left you!", leaveMe.TheName), m_Session.WorldTime.TurnCounter, Color.Red));
                            if (!m_Player.IsBotPlayer)
                            {
                                AddMessagePressEnter();
                                ClearMessages();
                            }
                        }
                    }
                    else
                    {
                        if (leaveMe.Location.Map == fromMap)
                        {
                            if (isPlayer)
                            {
                                // message.
                                ClearMessages();
                                AddMessage(new Message(String.Format("{0} could not follow and is still in {1}.", leaveMe.TheName, fromMap.Name), m_Session.WorldTime.TurnCounter, Color.Yellow));
                                if (!m_Player.IsBotPlayer)
                                {
                                    AddMessagePressEnter();
                                    ClearMessages();
                                }
                            }
                        }
                    }
                }
            }
        }

        public bool DoUseExit(Actor actor, Point exitPoint)
        {
            // leave map.
            return DoLeaveMap(actor, exitPoint, false);
        }
#endregion

#region -LEADING
        public void DoSwitchPlace(Actor actor, Actor other)
        {
            // spend a bunch of ap.
            SpendActorActionPoints(actor, 2 * Rules.BASE_ACTION_COST);

            // swap positions.
            Map map = other.Location.Map;
            Point actorPos = actor.Location.Position;
            map.RemoveActor(other);
            map.PlaceActorAt(actor, other.Location.Position);
            map.PlaceActorAt(other, actorPos);

            // message.
            if (IsVisibleToPlayer(actor) || IsVisibleToPlayer(other))
            {
                AddMessage(MakeMessage(actor, Conjugate(actor, VERB_SWITCH_PLACE_WITH), other));
            }
        }

        public void DoTakeLead(Actor actor, Actor other)
        {
            // spend AP.
            SpendActorActionPoints(actor, Rules.BASE_ACTION_COST);

            // take lead.
            actor.AddFollower(other);

            // reset trust in leader.
            int prevTrust = other.GetTrustIn(actor);
            other.TrustInLeader = prevTrust;

            // message.
            if (IsVisibleToPlayer(actor) || IsVisibleToPlayer(other))
            {
                if (actor == m_Player)
                    ClearMessages();
                AddMessage(MakeMessage(actor, Conjugate(actor, VERB_PERSUADE), other, " to join."));
                if (prevTrust != 0)
                    DoSay(other, actor, "Ah yes I remember you.", Sayflags.IS_FREE_ACTION);
            }
        }

        public void DoCancelLead(Actor actor, Actor follower)
        {
            // spend AP.
            SpendActorActionPoints(actor, Rules.BASE_ACTION_COST);

            // remove lead.
            actor.RemoveFollower(follower);

            // reset trust in leader.
            follower.SetTrustIn(actor, follower.TrustInLeader);
            follower.TrustInLeader = Rules.TRUST_NEUTRAL;

            // message.
            if (IsVisibleToPlayer(actor) || IsVisibleToPlayer(follower))
            {
                if (actor == m_Player)
                    ClearMessages();
                AddMessage(MakeMessage(actor, Conjugate(actor, VERB_PERSUADE), follower, " to leave."));
            }
        }

        static bool AreLinkedByPhone(Actor speaker, Actor target) //@@MP - made static (Release 5-7)
        {
            // only leader-follower
            if (speaker.Leader != target && target.Leader != speaker)
                return false;

            // check if equipped phones.
            ItemTracker trSpeaker = speaker.GetEquippedItem(DollPart.LEFT_HAND) as ItemTracker;
            if (trSpeaker == null || !trSpeaker.CanTrackFollowersOrLeader)
                return false;
            ItemTracker trTarget = target.GetEquippedItem(DollPart.LEFT_HAND) as ItemTracker;
            if (trTarget == null || !trTarget.CanTrackFollowersOrLeader)
                return false;

            // yep!
            return true;
        }
#endregion

#region -MAKING ENEMIES
        public void DoMakeAggression(Actor aggressor, Actor target)
        {
            // no need if in enemy factions.
            if (aggressor.Faction.IsEnemyOf(target.Faction))
                return;

            bool alreadyEnemies = aggressor.IsAggressorOf(target) || target.IsAggressorOf(aggressor);

            // if target is AI, awake and has not aggressor as enemy, emote.
            if (!target.IsPlayer && !target.IsSleeping && !alreadyEnemies) //@@MP - used existing bool instead of checking again (Release 5-7)
            {
                if (!target.Model.Abilities.IsLivingAnimal)
                    DoSay(target, aggressor, "BASTARD! TRAITOR!", Sayflags.IS_FREE_ACTION | Sayflags.IS_DANGER);
                else if (target.Faction != m_GameFactions.TheUnintelligentAnimals)  //@@MP - updated to account for simple animals (Release 7-6)
                    DoSay(target, aggressor, "GRRRRRR!", Sayflags.IS_FREE_ACTION | Sayflags.IS_DANGER);
            }

            // aggressor and self-defence
            aggressor.MarkAsAgressorOf(target);
            target.MarkAsSelfDefenceFrom(aggressor);

            // then handle special cases.
            // make enemy of all faction actors on maps:
            // 1. Making an enemy of cops.
            // 2. Making an enemy of soldiers.
#region
            if (!target.IsSleeping)
            {
                Faction tFaction = target.Faction;
                // 1. Making an enemy of cops.
                if (tFaction == GameFactions.ThePolice)
                {
                    // only non-law enforcers or murderers make enemies of cops by attacking cops.
                    if (!aggressor.Model.Abilities.IsLawEnforcer || m_Rules.IsMurder(aggressor, target))
                        OnMakeEnemyOfCop(aggressor, target, alreadyEnemies);
                }
                // 2. Making an enemy of soldiers.
                else if (tFaction == GameFactions.TheArmy)
                {
                    OnMakeEnemyOfSoldier(aggressor, target, alreadyEnemies);
                }
            }
#endregion
        }

        // FIXME factorize common code with OnMakeEnemyOfSoldier
        void OnMakeEnemyOfCop(Actor aggressor, Actor cop, bool wasAlreadyEnemy)
        {
            // say.
            if (!wasAlreadyEnemy)
                DoSay(cop, aggressor, String.Format("TO DISTRICT PATROLS : SHOOT {0} ON SIGHT!", aggressor.TheName), Sayflags.IS_FREE_ACTION | Sayflags.IS_DANGER);

            // make enemy of all cops in the district.
            MakeEnemyOfTargetFactionInDistrict(aggressor, cop,
                (a) =>
                {
                    if (a.IsPlayer && a != cop && !a.IsSleeping && !m_Rules.AreEnemies(a,aggressor))
                    {
                        int turn = m_Session.WorldTime.TurnCounter;
                        ClearMessages();
                        AddMessage(new Message("You get a message from your police radio.", turn, Color.White));
                        AddMessage(new Message(String.Format("{0} is armed and dangerous. Shoot on sight!", aggressor.TheName), turn, Color.White));
                        AddMessage(new Message(String.Format("Current location : {0}@{1},{2}", aggressor.Location.Map.Name, aggressor.Location.Position.X, aggressor.Location.Position.Y), turn, Color.White));
                        if (!a.IsBotPlayer) //alpha 10.1
                            AddMessagePressEnter();
                    }
                });
        }

        // FIXME factorize common code with OnMakeEnemyOfCop
        void OnMakeEnemyOfSoldier(Actor aggressor, Actor soldier, bool wasAlreadyEnemy)
        {
            // say.
            if (!wasAlreadyEnemy)
                DoSay(soldier, aggressor, String.Format("TO DISTRICT SQUADS : SHOOT {0} ON SIGHT!", aggressor.TheName), Sayflags.IS_FREE_ACTION | Sayflags.IS_DANGER);

            // make enemy of all cops in the district.
            MakeEnemyOfTargetFactionInDistrict(aggressor, soldier,
                (a) =>
                {
                    if (a.IsPlayer && a != soldier && !a.IsSleeping && !m_Rules.AreEnemies(a, aggressor))
                    {
                        int turn = m_Session.WorldTime.TurnCounter;
                        ClearMessages();
                        AddMessage(new Message("You get a message from your army radio.", turn, Color.White));
                        AddMessage(new Message(String.Format("{0} is armed and dangerous. Shoot on sight!", aggressor.Name), turn, Color.White));
                        AddMessage(new Message(String.Format("Current location : {0}@{1},{2}", aggressor.Location.Map.Name, aggressor.Location.Position.X, aggressor.Location.Position.Y), turn, Color.White));
                        if (!a.IsBotPlayer) //alpha 10.1
                            AddMessagePressEnter();
                    }
                });
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="aggressor"></param>
        /// <param name="target"></param>
        /// <param name="fn">action to call on faction actor BEFORE making agressor an enemy.</param>
        static void MakeEnemyOfTargetFactionInDistrict(Actor aggressor, Actor target, Action<Actor> fn) //@@MP - made static (Release 5-7)
        {
            Faction tFaction = target.Faction;
            foreach (Map m in target.Location.Map.District.Maps)
            {
                foreach (Actor a in m.Actors)
                {
                    if (a == aggressor || a == target)
                        continue;
                    if (a.Faction != tFaction)
                        continue;
                    if (a.Leader == aggressor)
                        continue;

                    // perform additional action on actor.
                    if (fn != null)
                        fn(a);

                    // aggression & self defence.
                    aggressor.MarkAsAgressorOf(a);
                    a.MarkAsSelfDefenceFrom(aggressor);
                }
            }
        }

#if false
        obsolete Actor.HasActorAsPersonalEnemy checks for leaders & followers.
        void MakeEnemyOfGroup(Actor a, IEnumerable<Actor> group)
        {
            if (group == null || a == null)
                return;

            foreach (Actor member in group)
            {
                a.MarkAsPersonalEnemy(member);
                member.MarkAsPersonalEnemy(a);
            }
        }

        void MakeEnemiesGroupsSub(IEnumerable<Actor> groupA, IEnumerable<Actor> groupB)
        {
            if (groupA == null || groupB == null)
                return;

            // O(n^2) beauty
            foreach (Actor a in groupA)
                foreach (Actor b in groupB)
                {
                    a.MarkAsPersonalEnemy(b);
                    b.MarkAsPersonalEnemy(a);
                }
        }
#endif
#endregion

#region -ATTACKING
        public void DoMeleeAttack(Actor attacker, Actor defender)
        {
            // set activiy & target.
            attacker.Activity = Activity.FIGHTING;
            attacker.TargetActor = defender;

            // if not already enemies, attacker is aggressor.
            if (!m_Rules.AreEnemies(attacker, defender))
                DoMakeAggression(attacker, defender); 
            
            // get attack & defence.
            Attack attack = m_Rules.ActorMeleeAttack(attacker, attacker.CurrentMeleeAttack, defender);
            Defence defence = m_Rules.ActorDefence(defender, defender.CurrentDefence);

            // spend APs & STA.
            SpendActorActionPoints(attacker, Rules.BASE_ACTION_COST);
            SpendActorStaminaPoints(attacker, Rules.STAMINA_COST_MELEE_ATTACK + attack.StaminaPenalty);

            // loud noise.
            OnLoudNoise(attacker.Location.Map, attacker.Location.Position, "Nearby fighting");

            // if defender is long waiting player, force stop.
            if (m_IsPlayerLongWait && defender.IsPlayer)
                m_IsPlayerLongWaitForcedStop = true;

            // show
            bool isDefVisible = IsVisibleToPlayer(defender);
            bool isAttVisible = IsVisibleToPlayer(attacker);
            bool isPlayer = attacker.IsPlayer || defender.IsPlayer;

            //if (!isDefVisible && !isAttVisible && !isPlayer && m_Rules.RollChance(PLAYER_HEAR_FIGHT_CHANCE)) //@@MP (Release 2)
            if (IsAudibleToPlayer(attacker.Location, Rules.QUIET_NOISE_RADIUS))//(isDefVisible || isAttVisible) //@MP (Release 5-4)
            {
                if (!isPlayer)
                    AddMessageIfAudibleForPlayer(attacker.Location, MakePlayerCentricMessage("You hear fighting", attacker.Location.Position));
            }

            if (isAttVisible)
            {
                AddOverlay(new OverlayRect(Color.Yellow, new Rectangle(MapToScreen(attacker.Location.Position), new Size(TILE_SIZE, TILE_SIZE))));
                AddOverlay(new OverlayRect(Color.Red, new Rectangle(MapToScreen(defender.Location.Position), new Size(TILE_SIZE, TILE_SIZE))));
                AddOverlay(new OverlayImage(MapToScreen(attacker.Location.Position), GameImages.ICON_MELEE_ATTACK));
            }

            // item-specifics
            ItemMeleeWeapon meleeWeapon = attacker.GetEquippedWeapon() as ItemMeleeWeapon;
            if (meleeWeapon != null && meleeWeapon.Model == GameItems.CHAINSAW) //@@MP - chainsaw revving sfx even if it won't be a hit (Release 7-1)
            {
                if (isPlayer)
                    m_SFXManager.Play(GameSounds.CHAINSAW_PLAYER, AudioPriority.PRIORITY_EVENT);
                else if (IsAudibleToPlayer(attacker.Location, Rules.QUIET_NOISE_RADIUS))//(isDefVisible || isAttVisible)
                    m_SFXManager.Play(GameSounds.CHAINSAW_NEARBY, AudioPriority.PRIORITY_BGM);
                else if (IsAudibleToPlayer(attacker.Location, Rules.MODERATE_NOISE_RADIUS))//(isDefVisible || isAttVisible)
                    m_SFXManager.Play(GameSounds.CHAINSAW_FAR, AudioPriority.PRIORITY_BGM);
                SpendFuelAmmo(attacker);
            }

            // blocked by defender's shield?
            if (defender.GetEquippedShield() != null && m_Rules.RollChance(m_Rules.ActorShieldChanceToBlock(defender))) //@@MP (Release 7-2)
            {
                if (isPlayer)
                    m_SFXManager.Play(GameSounds.SHIELD_BLOCK_PLAYER, AudioPriority.PRIORITY_EVENT);
                else if (IsAudibleToPlayer(attacker.Location, Rules.QUIET_NOISE_RADIUS))//(isDefVisible || isAttVisible)
                    m_SFXManager.Play(GameSounds.SHIELD_BLOCK_NEARBY, AudioPriority.PRIORITY_BGM);

                if (isAttVisible || isDefVisible)
                {
                    AddMessage(MakeMessage(attacker, Conjugate(attacker, attack.Verb), defender, " but is blocked by a shield."));
                    AddOverlay(new OverlayImage(MapToScreen(defender.Location.Position), GameImages.ICON_MELEE_MISS));
                    RedrawPlayScreen();
                    AnimDelay(isPlayer ? DELAY_NORMAL : DELAY_SHORT, false);
                }

                if (attacker.Model.Abilities.CanDisarm && m_Rules.RollChance(attack.DisarmChance))
                {
                    Disarm(attacker, defender);
                }
            }
            // now the actual attack resolution
            else //not blocked by shield
            {
                // resolve attack.
                int hitRoll = m_Rules.RollSkill(attack.HitValue);
                int defRoll = m_Rules.RollSkill(defence.Value);

                // Hit vs Missed
                if (hitRoll > defRoll) //hit
                {
                    // chainsaw specifics  //@@MP (Release 7-2)
                    if (meleeWeapon != null && meleeWeapon.Model == GameItems.CHAINSAW && s_Options.IsSanityEnabled && !defender.Model.Abilities.IsUndead)
                    {
                        attacker.Sanity -= CAUSE_GRUESOME_DEATH_SANITY_PENALTY; //carving ppl up is warping
                        AddMessage(new Message("Carving people up is warping your sanity", m_Session.WorldTime.TurnCounter, Color.Yellow));
                    }

                    //hear  //@@MP (Release 2)
                    if (isPlayer)
                        m_SFXManager.Play(GameSounds.MELEE_ATTACK_PLAYER, AudioPriority.PRIORITY_EVENT);
                    else if (IsAudibleToPlayer(attacker.Location, Rules.QUIET_NOISE_RADIUS))//(isDefVisible || isAttVisible) //@MP (Release 5-4)
                        m_SFXManager.Play(GameSounds.MELEE_ATTACK_NEARBY, AudioPriority.PRIORITY_BGM);

                    // roll for attacker disarming defender  // alpha10
                    if (attacker.Model.Abilities.CanDisarm && m_Rules.RollChance(attack.DisarmChance))
                    {
                        Disarm(attacker, defender);
                    }

                    // roll damage - double potential if def is sleeping.
                    int dmgRoll = m_Rules.RollDamage(defender.IsSleeping ? attack.DamageValue * 2 : attack.DamageValue) - defence.Protection_Hit;
                    // damage?
                    if (dmgRoll > 0)
                    {
                        // inflict dmg.
                        InflictDamage(defender, dmgRoll, true, false, attacker); //@@MP - attacker param (Release 7-4)

                        // regen HP/Rot and infection?
                        if (attacker.Model.Abilities.CanZombifyKilled && !defender.Model.Abilities.IsUndead)
                        {
                            RegenActorHitPoints(attacker, Rules.ActorBiteHpRegen(attacker, dmgRoll));
                            attacker.FoodPoints = Math.Min(attacker.FoodPoints + m_Rules.ActorBiteNutritionValue(attacker, dmgRoll), m_Rules.ActorMaxRot(attacker));
                            if (isAttVisible)
                            {
                                AddMessage(MakeMessage(attacker, Conjugate(attacker, VERB_FEAST_ON), defender, " flesh!"));
                            }
                            if (Rules.HasInfection(m_Session.GameMode))
                            {
                                bool infectActor = true;
                                ItemBodyArmor armor = defender.GetEquippedArmor(); //wearing infection-resistant armor?
                                if (armor != null)
                                {
                                    if (m_Rules.RollChance(armor.Infection_Resistance)) //if there's no DMG there will be no INF, but even if there is DMG there may not be INF if armor blocks it        //@@MP - added (Release 7-6)
                                        infectActor = false;
                                }

                                if (infectActor)
                                    InfectActor(defender, Rules.InfectionForDamage(attacker, dmgRoll));
                            }
                        }

                        // Killed?
                        if (defender.HitPoints <= 0) // def killed!
                        {
                            // show.
                            if (isAttVisible || isDefVisible)
                            {
                                AddMessage(MakeMessage(attacker, Conjugate(attacker, defender.Model.Abilities.IsUndead ? VERB_DESTROY : m_Rules.IsMurder(attacker, defender) ? VERB_MURDER : VERB_KILL), defender, " !"));
                                AddOverlay(new OverlayImage(MapToScreen(defender.Location.Position), GameImages.ICON_KILLED));
                                RedrawPlayScreen();
                                if (attacker.IsPlayer)
                                    AnimDelay(DELAY_NORMAL, true);
                            }

                            // kill.
                            string cause = "hit";
                            if (attacker.Model.Abilities.IsUndead)
                                cause = "eaten alive";
                            else if (attacker.Model.Abilities.IsLivingAnimal || (meleeWeapon != null && meleeWeapon.Model == m_GameItems.CHAINSAW))
                                cause = "mauled";
                            else
                                cause = "bludgeoned";

                            KillActor(attacker, defender, cause);

                            // cause insanity?
                            if (attacker.Model.Abilities.IsUndead && !defender.Model.Abilities.IsUndead)
                                SeeingCauseInsanity(attacker.Location, Rules.SANITY_HIT_EATEN_ALIVE, String.Format("{0} eaten alive", defender.Name), attacker); //@@MP - updated for the change to this method (Release 5-2)

                            // turn victim into zombie?
                            if (Rules.HasImmediateZombification(m_Session.GameMode) || defender == m_Player)
                            {
                                // turn player into zombie now if killed by a zombifier?
                                if (attacker.Model.Abilities.CanZombifyKilled && !defender.Model.Abilities.IsUndead && !defender.Model.Abilities.IsLivingAnimal && m_Rules.RollChance(s_Options.ZombificationChance)) //@@MP - not animals (Release 7-6)
                                {
                                    /*if (defender.IsPlayer)
                                    {
                                        // remove player corpse.
                                        defender.Location.Map.TryRemoveCorpseOf(defender);
                                    }*/
                                    //@@MP - i assume was originally limited to the player because Std mode had no corpses (Release 7-6)
                                    defender.Location.Map.TryRemoveCorpseOf(defender);
                                    //Logger.WriteLine(Logger.Stage.RUN_MAIN, String.Format("{0} was insta-zombified", defender.Name)); //DELETETHIS

                                    // add new zombie.
                                    Zombify(attacker, defender, defender.Location.Map, defender.Location.Position, false);

                                    // show
                                    if (isDefVisible)
                                    {
                                        AddMessage(MakeMessage(attacker, Conjugate(attacker, "turn"), defender, " into a Zombie!"));
                                        RedrawPlayScreen();
                                        AnimDelay(DELAY_LONG, false);
                                    }
                                }
                                // always turn player into zombie if infected
                                else if (defender == m_Player && !defender.Model.Abilities.IsUndead && defender.Infection > 0)
                                {
                                    // remove player corpse.
                                    defender.Location.Map.TryRemoveCorpseOf(defender);

                                    // zombify player!
                                    Zombify(null, defender, defender.Location.Map, defender.Location.Position, false);

                                    // show
                                    AddMessage(MakeMessage(defender, Conjugate(defender, "turn") + " into a Zombie!"));
                                    RedrawPlayScreen();
                                    AnimDelay(DELAY_LONG, true);
                                }
                            }
                        }
                        else //defender is still alive
                        {
                            // show
                            if (isAttVisible || isDefVisible)
                            {
                                AddMessage(MakeMessage(attacker, Conjugate(attacker, attack.Verb), defender, String.Format(" for {0} damage.", dmgRoll)));
                                AddOverlay(new OverlayImage(MapToScreen(defender.Location.Position), GameImages.ICON_MELEE_DAMAGE));
                                AddOverlay(new OverlayText(MapToScreen(defender.Location.Position).Add(DAMAGE_DX, DAMAGE_DY), Color.White, dmgRoll.ToString(), Color.Black));
                                RedrawPlayScreen();
                                AnimDelay(isPlayer ? DELAY_NORMAL : DELAY_SHORT, false);
                            }
                        }
                    }
                    else  //no significant damage
                    {
                        if (isAttVisible || isDefVisible)
                        {
                            AddMessage(MakeMessage(attacker, Conjugate(attacker, attack.Verb), defender, " for no effect."));
                            AddOverlay(new OverlayImage(MapToScreen(defender.Location.Position), GameImages.ICON_MELEE_MISS));
                            RedrawPlayScreen();
                            AnimDelay(isPlayer ? DELAY_NORMAL : DELAY_SHORT, false);
                        }
                    }

                }   // end of hit
                else // miss
                {
                    if (isPlayer) //hear //@@MP (Release 2)
                        m_SFXManager.Play(GameSounds.MELEE_ATTACK_MISS_PLAYER, AudioPriority.PRIORITY_EVENT);
                    else if (IsAudibleToPlayer(attacker.Location, Rules.QUIET_NOISE_RADIUS)) //@@MP - added range (Release 5-4)
                        m_SFXManager.Play(GameSounds.MELEE_ATTACK_MISS_NEARBY, AudioPriority.PRIORITY_BGM);

                    if (isAttVisible || isDefVisible) //@@MP - moved isPlayer into this if (Release 3), undid (Release 5-4)
                    {
                        // show
                        AddMessage(MakeMessage(attacker, Conjugate(attacker, VERB_MISS), defender));
                        AddOverlay(new OverlayImage(MapToScreen(defender.Location.Position), GameImages.ICON_MELEE_MISS));
                        RedrawPlayScreen();
                        AnimDelay(isPlayer ? DELAY_NORMAL : DELAY_SHORT, false);
                    }
                } // end of miss
            }

            // weapon break?
            if (meleeWeapon != null && !(meleeWeapon.Model as ItemMeleeWeaponModel).IsUnbreakable)
            {
                if (m_Rules.RollChance(meleeWeapon.IsFragile ? Rules.MELEE_WEAPON_FRAGILE_BREAK_CHANCE : Rules.MELEE_WEAPON_BREAK_CHANCE))
                {
                    // do it.
                    // stackable weapons : only break ONE.
                    OnUnequipItem(attacker, meleeWeapon);
                    if (meleeWeapon.Quantity > 1)
                        --meleeWeapon.Quantity;
                    else
                        attacker.Inventory.RemoveAllQuantity(meleeWeapon);

                    // message.
                    if (isAttVisible)
                    {
                        AddMessage(MakeMessage(attacker, String.Format(": {0} breaks and is now useless!", meleeWeapon.TheName)));
                        RedrawPlayScreen();
                        if (attacker.IsPlayer && !attacker.IsBotPlayer)
                            AddMessagePressEnter();
                        else
                            AnimDelay(DELAY_SHORT,false);
                    }
                }
            }

            // alpha 10 bug fix; clear overlays only if action is visible, as they would have only been shown if visible
            if (isAttVisible || isDefVisible)
                ClearOverlays();
        }

        public void DoRangedAttack(Actor attacker, Actor defender, List<Point> LoF, FireMode mode)
        {
            // if not enemies, aggression.
            if (!m_Rules.AreEnemies(attacker, defender))
                DoMakeAggression(attacker, defender);

            // spend AP.
            SpendActorActionPoints(attacker, Rules.BASE_ACTION_COST);

            // resolve, depending on mode.
            switch (mode)
            {
                case FireMode.DEFAULT:
                case FireMode.FLAMING: //@@MP - flaming crossbow bolts. assumed single shot only (Release 7-2)
                    DoSingleRangedAttack(attacker, defender, LoF, 0, 1);
                    break;

                case FireMode.RAPID: //@@MP - re-wrote this case (Release 6-6)
                    // do we have enough ammo for rapid-fire?
                    ItemRangedWeapon w = attacker.GetEquippedWeapon() as ItemRangedWeapon;
                    bool secondShotPossible = false;
                    int soundEffect = 1;
                    if (w.Ammo >= 2)
                    {
                        soundEffect = 2;
                        secondShotPossible = true;
                    }

                    // 1st attack
                    DoSingleRangedAttack(attacker, defender, LoF, 1, soundEffect);

                    // 2nd attack, if possible
                    if (defender.IsDead)
                        --w.Ammo; //wasted shot
                    else if (secondShotPossible == true)
                        DoSingleRangedAttack(attacker, defender, LoF, 2, 0);

                    break;

                default:
                    throw new ArgumentOutOfRangeException("mode","unhandled ranged attack fire mode");
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="attacker"></param>
        /// <param name="defender"></param>
        /// <param name="LoF"></param>
        /// <param name="shotCounter">0 for normal shot, 1 for 1st rapid fire shot, 2 for 2nd rapid fire shot</param>
        /// <param name="soundEffectShots">0 for none, 1 for single-shot, 2 for rapid-fire</param>
        void DoSingleRangedAttack(Actor attacker, Actor defender, List<Point> LoF, int shotCounter, int soundEffectShots)
        {
            Map map = defender.Location.Map;
            ItemRangedWeapon weapon = attacker.GetEquippedWeapon() as ItemRangedWeapon;
            if (weapon == null)
                throw new InvalidOperationException("DoSingleRangedAttack but no equipped ranged weapon");
            ItemRangedWeaponModel rm = weapon.Model as ItemRangedWeaponModel;

            // set activiy & target.
            attacker.Activity = Activity.FIGHTING;
            attacker.TargetActor = defender;

            // get attack & defence.
            int targetDistance = m_Rules.GridDistance(attacker.Location.Position, defender.Location.Position);
            Attack attack = m_Rules.ActorRangedAttack(attacker, attacker.CurrentRangedAttack, targetDistance, defender);
            Defence defence = m_Rules.ActorDefence(defender, defender.CurrentDefence);

            // spend STA.
            SpendActorStaminaPoints(attacker, attack.StaminaPenalty);

            // Firearms weapon jam?  //@@MP - removed (Release 6-6)
#if false
            if (attack.Kind == AttackKind.FIREARM)
            {
                int jamChance = Rules.FIREARM_JAM_CHANCE_NO_RAIN;
                Tile tile = attacker.Location.Map.GetTileAt(attacker.Location.Position);
                if (m_Rules.IsWeatherRain(m_Session.World.Weather) && !tile.IsInside) //@@MP - now have to be outside (Release 6-6)
                        jamChance = Rules.FIREARM_JAM_CHANCE_RAIN;
                
                if (m_Rules.RollChance(jamChance))
                {
                    if (IsVisibleToPlayer(attacker))
                    {
                        AddMessage(MakeMessage(attacker, " : weapon jam!"));
                        return;
                    }
                }
            }
#endif

            // spend ammo.
            --weapon.Ammo;
            if (attacker.IsPlayer && m_Session.Player_CurrentFireMode == FireMode.FLAMING && rm.IsBow) //@@MP - flaming crossbow bolt (Release 7-2)
                SpendFuelAmmo(attacker);

            // show/hear.
            bool isDefVisible = IsVisibleToPlayer(defender.Location);
            bool isAttVisible = IsVisibleToPlayer(attacker.Location);
            bool isPlayer = attacker.IsPlayer || defender.IsPlayer;

            if (soundEffectShots > 0) //@@MP - added parameter for playing (or not) the desired SFX type for the firemode (Release 6-6)
                PlayRangedWeaponSFX(attacker.Location, weapon, soundEffectShots);

            if (isAttVisible)
            {
                AddOverlay(new OverlayRect(Color.Yellow, new Rectangle(MapToScreen(attacker.Location.Position), new Size(TILE_SIZE, TILE_SIZE))));
                AddOverlay(new OverlayRect(Color.Red, new Rectangle(MapToScreen(defender.Location.Position), new Size(TILE_SIZE, TILE_SIZE))));
                AddOverlay(new OverlayImage(MapToScreen(attacker.Location.Position), GameImages.ICON_RANGED_ATTACK));
            }
            else if (m_SFXManager.IsAudioEnabled == false) //@@MP - moved out of IsAudibleToPlayer:Far if to make it applicable for all (Release 5-4)
            {
                if ((weapon.Model as ItemRangedWeaponModel).IsFireArm) //@@MP - limited to only firearms, as bows are too quiet (Release 7-2)
                {
                    if (m_Rules.RollChance(PLAYER_HEAR_FIGHT_CHANCE)) //@@MP - lower chance to avoid message spam
                        AddMessageIfAudibleForPlayer(attacker.Location, MakePlayerCentricMessage("You hear weapons fire", attacker.Location.Position));
                }
            }

            // check if we are firing through something and it intercepts the attack.
            if (DoCheckFireThrough(attacker, LoF, rm))
                return;

            // if defender is long waiting player, force stop.
            if (m_IsPlayerLongWait && defender.IsPlayer)
                m_IsPlayerLongWaitForcedStop = true;

            // resolve attack.
            int hitValue = (shotCounter == 0 ? attack.HitValue : shotCounter == 1 ? attack.Hit2Value : attack.Hit3Value);
            int hitRoll = m_Rules.RollSkill(hitValue);
            int defRoll = m_Rules.RollSkill(defence.Value);

            // Hit vs Missed
#region
            if (hitRoll > defRoll) //hit
            {
                Point defpt = new Point(defender.Location.Position.X, defender.Location.Position.Y);

                // set on fire by flaming crossbow bolt?  //@@MP (Release 7-2)
                if (attacker.IsPlayer && m_Session.Player_CurrentFireMode == FireMode.FLAMING && defender.Model.Abilities.IsUndead && !GameActors.IsSkeletonBranch(defender.Model))
                {
                    if (m_Rules.RollChance(CATCH_ONFIRE_FROM_FLAMING_SHOT_CHANCE))
                        SetActorOnFire(defender);
                }

                // roll damage - double potential if def is sleeping.
                int dmgRoll = 0;
                if (rm.IsFlameWeapon)  // fires caused by flame weapons  //@@MP (Release 7-2)
                {
                    //special damage cases
                    if (GameActors.IsSkeletonBranch(defender.Model))
                        dmgRoll = 0;  //flames can't hurt skeletons
                    else //@@MP - fixed damage calculation (Release 8-1)
                    {
                        int dmg = m_Rules.RollDamage(defender.IsSleeping ? attack.DamageValue * 2 : attack.DamageValue);
                        dmgRoll = dmg;

                        //fire resistant armor?
                        Item torsoItem = defender.GetEquippedItem(DollPart.TORSO);
                        ItemBodyArmor armor = torsoItem as ItemBodyArmor;
                        if (torsoItem != null)
                        {
                            double dbl = armor.Fire_Resistance / 100.0f;
                            dmgRoll -= (int)(dbl * dmg);
                            //dmgRoll -= (dmg * (armor.Fire_Resistance / 100));
                        }
                    }

                    //random adjacent tile set on fire?
                    int maxFires = m_Rules.Roll(0, 2);
                    int firesCount = 0;
                    foreach (Direction dir in Direction.COMPASS)
                    {
                        Point pt = defpt + dir;
                        if (map.IsInBounds(pt) && pt != attacker.Location.Position && m_Rules.RollChance(RANDOM_TILE_FIRE_FROM_FLAME_WEAPON_CHANCE)) //don't set fire to the attacker's spot
                        {
                            SetTileOnFire(map, pt.X, pt.Y, true);
                            ++firesCount;
                            if (firesCount == maxFires) break; //that's enough
                        }
                    }

                    //splashback?
                    Point attpt = new Point(attacker.Location.Position.X, attacker.Location.Position.Y);
                    if (m_Rules.IsAdjacent(defpt, attpt) && m_Rules.RollChance(FLAME_WEAPON_SPLASHBACK_CHANCE))
                    {
                        SetActorOnFire(attacker); //chance for splashback
                        AddMessage(new Message("You're hit by splashback. It's safer to incinerate from a distance", m_Session.WorldTime.TurnCounter, Color.Red));
                    }
                }
                else
                    dmgRoll = m_Rules.RollDamage(defender.IsSleeping ? attack.DamageValue * 2 : attack.DamageValue) - defence.Protection_Shot;

                if (dmgRoll > 0)
                {
                    // inflict dmg.
                    InflictDamage(defender, dmgRoll, true, rm.IsFlameWeapon, attacker); //@@MP - attacker param (Release 7-4)

                    //@@MP - make bows more useful (Release 2)
                    // if crossbow shot, chance to dislodge an item from the living target (was chance to retrieve a bolt too prior to R7-5)
                    if (rm.IsBow)
                    {
                        Item crossbowBolt = new ItemAmmo(GameItems.AMMO_BOLTS);
                        crossbowBolt.Quantity = 1;
                        
                        if (defender.Model.Abilities.HasInventory && !defender.Inventory.IsEmpty) //undeads have no inventory
                        { //their invetory is not empty, chance to force them to 'drop' an equiped item. this makes bows more useful (or less useless)
                            if (m_Rules.RollChance(10)) //10% chance to force the defender to drop an item
                            {
                                //@@MP - crossbow attacks can now only disarm, not cause the target to drop any random item (Release 8-2)
                                Disarm(attacker, defender);
                                //@@MP - the following was disabled now that bows are more useful with the introduction of flaming shots (Release 7-5)
                                //map.DropItemAt(crossbowBolt, defender.Location.Position); //create a bolt on the ground
                                //DoTakeItem(defender, defender.Location.Position, crossbowBolt); //now put it into the inventory space we just vacated
                            }
                            //else if (randomDropChance == 1) //10% chance for it to penetrate the defender, or they've pulled it out and dropped it
                            //{
                            //    //@@MP - disabled due to the introduction of flaming arrows (Release 7-5)
                            //    map.DropItemAt(crossbowBolt, defender.Location.Position);
                            //}
                        }
                        //else   //@@MP - disabled due to the introduction of flaming arrows (Release 7-5)
                        //{
                        //    int randomRetrieveChance = m_Rules.Roll(0, 10);
                        //    if (randomRetrieveChance <= 1) //20%
                        //    {
                        //        map.DropItemAt(crossbowBolt, defender.Location.Position);  //create a bolt on the ground
                        //        if (defender.Model.Abilities.HasInventory) //the bolt will rip right through undead flesh, so only drop bolt on the ground. otherwise:
                        //            DoTakeItem(defender, defender.Location.Position, crossbowBolt); //add the bolt to their inventory, to simulate being stuck in their body
                        //    }
                        //}
                    }
                    // fires caused by flame weapons  //@@MP (Release 7-2)
                    else if (rm.IsFlameWeapon)
                    {
                        if (m_Rules.RollChance(CATCH_ONFIRE_FROM_FLAME_WEAPON_CHANCE))
                            SetActorOnFire(defender); //sets enemy on fire?

                        // sanity hit?
                        if (s_Options.IsSanityEnabled && !defender.Model.Abilities.IsUndead) //@@MP (Release 7-1)
                        {
                            attacker.Sanity -= CAUSE_GRUESOME_DEATH_SANITY_PENALTY; //burning ppl alive is warping
                            AddMessage(new Message("Torching people is warping your sanity", m_Session.WorldTime.TurnCounter, Color.Yellow));
                        }
                    }

                    // Killed?
                    if (defender.HitPoints <= 0) // def killed!
                    {
                        // show.
                        if (isDefVisible)
                        {
                            AddMessage(MakeMessage(attacker, Conjugate(attacker, defender.Model.Abilities.IsUndead ? VERB_DESTROY : m_Rules.IsMurder(attacker,defender) ? VERB_MURDER : VERB_KILL), defender, " !"));
                            AddOverlay(new OverlayImage(MapToScreen(defender.Location.Position), GameImages.ICON_KILLED));
                            RedrawPlayScreen();
                            bool forced = false;
                            if (attacker.IsPlayer)
                                forced = true;
                            AnimDelay(DELAY_NORMAL, forced);
                        }

                        // kill.
                        string cause = "shot";
                        switch (weapon.AmmoType)  //@@MP - added (Release 7-6)
                        {
                            case AmmoType.BOLT: cause = "shot by a crossbow"; break;
                            case AmmoType.CHARGE: cause = "electrified"; break;
                            case AmmoType.FUEL: cause = "incinerated"; break;
                            case AmmoType.LIGHT_PISTOL: 
                            case AmmoType.HEAVY_PISTOL: cause = "shot by a pistol"; break;
                            case AmmoType.LIGHT_RIFLE:
                            case AmmoType.PRECISION_RIFLE:
                            case AmmoType.HEAVY_RIFLE: cause = "shot by a rifle"; break;
                            case AmmoType.NAIL: cause = "shot by a nailgun"; break;
                            case AmmoType.SHOTGUN: cause = "shot by a shotgun"; break;
                            case AmmoType.GRENADES: cause = "hit by an explosive"; break;
                            case AmmoType.MINIGUN: cause = "shredded by bullets"; break;
                        };
                        KillActor(attacker, defender, cause, rm.IsFlameWeapon);
                    }
                    else //defender still alive
                    {
                        // show
                        if (isDefVisible)
                        {
                            AddMessage(MakeMessage(attacker, Conjugate(attacker, attack.Verb), defender, String.Format(" for {0} damage.", dmgRoll)));
                            AddOverlay(new OverlayImage(MapToScreen(defender.Location.Position), GameImages.ICON_RANGED_DAMAGE));
                            AddOverlay(new OverlayText(MapToScreen(defender.Location.Position).Add(DAMAGE_DX, DAMAGE_DY), Color.White, dmgRoll.ToString(), Color.Black));
                            RedrawPlayScreen();
                            AnimDelay(isPlayer ? DELAY_NORMAL : DELAY_SHORT,false);
                        }
                    }
                }
                else if (weapon.Model == GameItems.STUN_GUN && !defender.Model.Abilities.IsUndead) //@@MP (Release 7-2)
                {
                    defender.StunnedTurns += STUN_WEAPON_EFFECT_TURNS;
                    if (isDefVisible)
                    {
                        AddMessage(MakeMessage(attacker, Conjugate(attacker, attack.Verb), defender, " with a stun gun."));
                        AddOverlay(new OverlayImage(MapToScreen(defender.Location.Position), GameImages.ICON_RANGED_MISS));
                        RedrawPlayScreen();
                        AnimDelay(isPlayer ? DELAY_NORMAL : DELAY_SHORT, false);
                    }
                }
                else //no significant damage
                {
                    if (isDefVisible)
                    {
                        AddMessage(MakeMessage(attacker, Conjugate(attacker, attack.Verb), defender, " for no effect."));
                        AddOverlay(new OverlayImage(MapToScreen(defender.Location.Position), GameImages.ICON_RANGED_MISS));
                        RedrawPlayScreen();
                        AnimDelay(isPlayer ? DELAY_NORMAL : DELAY_SHORT,false);
                    }
                }

            }   // end of hit
            else // miss
            {
                //@@MP - make bows more useful (Release 2), disabled due to the introduction of flaming arrows (Release 7-5)
                ////if crossbow shot, chance to drop bolt on ground
                //if (rm.IsBow)
                //{
                //    int randomDropChance = m_Rules.Roll(0, 10);
                //    if (randomDropChance <= 1) //20% chance to drop bolt on ground, otherwise do nothing
                //    {
                //        Item crossbowBolt = new ItemAmmo(GameItems.AMMO_BOLTS);
                //        crossbowBolt.Quantity = 1;
                //        map.DropItemAt(crossbowBolt, defender.Location.Position);
                //    }
                //}

                // show
                if (isDefVisible)
                {
                    AddMessage(MakeMessage(attacker, Conjugate(attacker, VERB_MISS), defender));
                    AddOverlay(new OverlayImage(MapToScreen(defender.Location.Position), GameImages.ICON_RANGED_MISS));
                    RedrawPlayScreen();
                    AnimDelay(isPlayer ? DELAY_NORMAL : DELAY_SHORT, false);
                }
            }
#endregion

            // special cases       //@@MP (Release 7-6)
#region
            if (rm == GameItems.GRENADE_LAUNCHER) //the grenande launcher is a standard firearm, but it also drops a grenade on the defender's tile that immediately explodes
            {
                Item nade = new ItemGrenadePrimed(GameItems.GRENADE_PRIMED);
                ItemPrimedExplosive primed = nade as ItemPrimedExplosive;
                DoBlast(defender.Location, (primed.Model as ItemExplosiveModel).BlastAttack, nade.Model, attacker);
            }
            else if (rm == GameItems.BIO_FORCE_GUN) //the BFG is a standard firearm, but it also drops a grenade on the defender's tile that immediately explodes
            {
                Item plasmaBurst = new ItemGrenadePrimed(GameItems.PLASMA_CHARGE_PRIMED);
                ItemPrimedExplosive primed = plasmaBurst as ItemPrimedExplosive;
                DoBlast(defender.Location, (primed.Model as ItemExplosiveModel).BlastAttack, plasmaBurst.Model, attacker);
            }
#endregion

            //@@MP - missing this fix that was applied to melee attacks. impact is overlays being during the simulation of nearby districts (Release 7-1)
            // alpha 10 bug fix; clear overlays only if action is visible, as they would have only been shown if visible
            if (isAttVisible || isDefVisible)
                ClearOverlays();
        }

        bool DoCheckFireThrough(Actor attacker, List<Point> LoF, ItemRangedWeaponModel rm)
        {
            // check if we are firing through an object that blocks the LoF and breaks.
            foreach (Point pt in LoF)
            {
                MapObject mapObj = attacker.Location.Map.GetMapObjectAt(pt);
                if (mapObj == null)
                    continue;
                if (mapObj.BreaksWhenFiredThrough && 
                    mapObj.BreakState != MapObject.Break.BROKEN &&      // not if already broken.
                    !mapObj.IsWalkable)                                 // not if not blocking.
                {
                    if (rm.Attack.DamageValue > 0) //checkfirethru not applicable for zero-damage weapons eg stun guns  //@@MP (Release 7-3)
                    {
                        // message.
                        bool isAttVisible = IsVisibleToPlayer(attacker);
                        bool isObjVisible = IsVisibleToPlayer(mapObj);
                        if (isAttVisible || isObjVisible)
                        {
                            if (isAttVisible)
                            {
                                AddOverlay(new OverlayRect(Color.Yellow, new Rectangle(MapToScreen(attacker.Location.Position), new Size(TILE_SIZE, TILE_SIZE))));
                                AddOverlay(new OverlayImage(MapToScreen(attacker.Location.Position), GameImages.ICON_RANGED_ATTACK));
                            }
                            if (isObjVisible)
                                AddOverlay(new OverlayRect(Color.Red, new Rectangle(MapToScreen(pt), new Size(TILE_SIZE, TILE_SIZE))));

                            AnimDelay(DELAY_SHORT, false);
                        }

                        // special cases first   //@@MP (Release 7-3)
                        if (mapObj.ImageID == GameImages.OBJ_FUEL_PUMP)
                        {
                            if (rm.IsFireArm || rm.IsFlameWeapon)
                                ExplodeFuelPump(mapObj.Location);
                        }
                        else // destroy that object.
                            DoDestroyObject(mapObj);
                    }

                    // fire intercepted.
                    return true;
                }
            }

            // Line Of Fire completly clear, process normally.
            return false;
        }

        private void PlayRangedWeaponSFX(Location location, ItemRangedWeapon weapon, int shots) //@@MP (Release 7-1)
        {
            if (IsAudibleToPlayer(location, Rules.QUIET_NOISE_RADIUS)) //@@MP - the player is shot at or shoots, so play the CQC sound (Release 2), changed from isVisible to IsAudible with a supplied a range (Release 5-4)
            {
                switch (weapon.TheName.ToString())
                {
                    case "the pistol":
                    case "Hans von Hanz pistol":
                        if (shots == 1)
                            m_SFXManager.Play(GameSounds.PISTOL_SINGLE_SHOT_PLAYER, AudioPriority.PRIORITY_EVENT);
                        else
                            m_SFXManager.Play(GameSounds.PISTOL_RAPID_FIRE_PLAYER, AudioPriority.PRIORITY_EVENT);
                        break;
                    case "the hunting rifle":
                        m_SFXManager.Play(GameSounds.HUNTING_RIFLE_FIRE_PLAYER, AudioPriority.PRIORITY_EVENT);
                        break;
                    case "the precision rifle":
                    case "the army precision rifle":
                        m_SFXManager.Play(GameSounds.PRECISION_RIFLE_FIRE_PLAYER, AudioPriority.PRIORITY_EVENT);
                        break;
                    case "the army rifle":
                        if (shots == 1)
                            m_SFXManager.Play(GameSounds.ARMY_RIFLE_SINGLE_SHOT_PLAYER, AudioPriority.PRIORITY_EVENT);
                        else
                            m_SFXManager.Play(GameSounds.ARMY_RIFLE_RAPID_FIRE_PLAYER, AudioPriority.PRIORITY_EVENT);
                        break;
                    case "the shotgun":
                    case "the tactical shotgun":
                    case "the double barrel":
                    case "Santaman shotgun":
                        m_SFXManager.Play(GameSounds.SHOTGUN_FIRE_PLAYER, AudioPriority.PRIORITY_EVENT);
                        break;
                    case "the hunting crossbow":
                        m_SFXManager.Play(GameSounds.CROSSBOW_FIRE_PLAYER, AudioPriority.PRIORITY_EVENT);
                        break;
                    case "the nail gun":
                        m_SFXManager.Play(GameSounds.NAIL_GUN, AudioPriority.PRIORITY_EVENT);
                        break;
                    case "the revolver":
                    case "the army pistol":
                        if (shots == 1)
                            m_SFXManager.Play(GameSounds.REVOLVER_SINGLE_SHOT_PLAYER, AudioPriority.PRIORITY_EVENT);
                        else
                            m_SFXManager.Play(GameSounds.REVOLVER_RAPID_FIRE_PLAYER, AudioPriority.PRIORITY_EVENT);
                        break;
                    case "the flame thrower":
                        m_SFXManager.Play(GameSounds.FLAMETHROWER_VISIBLE, AudioPriority.PRIORITY_EVENT);
                        break;
                    case "the stun gun":
                        m_SFXManager.Play(GameSounds.STUN_GUN_PLAYER, AudioPriority.PRIORITY_EVENT);
                        break;
                    case "the SMG":
                        if (shots == 1)
                            m_SFXManager.Play(GameSounds.SMG_SINGLE_SHOT_PLAYER, AudioPriority.PRIORITY_EVENT);
                        else
                            m_SFXManager.Play(GameSounds.SMG_RAPID_FIRE_PLAYER, AudioPriority.PRIORITY_EVENT);
                        break;
                    case "the minigun":
                        m_SFXManager.Play(GameSounds.MINIGUN_RAPID_FIRE_PLAYER, AudioPriority.PRIORITY_EVENT);
                        break;
                    case "the grenade launcher":
                        m_SFXManager.Play(GameSounds.GRENADE_LAUNCHER_SINGLE_SHOT_PLAYER, AudioPriority.PRIORITY_EVENT);
                        break;
                    case "the bio force gun":
                        m_SFXManager.Play(GameSounds.BIO_FORCE_GUN_PLAYER, AudioPriority.PRIORITY_EVENT);
                        break;
                    default: break;
                }
            }
            else if (IsAudibleToPlayer(location, Rules.MODERATE_NOISE_RADIUS)) //@@MP - we see the shooter, so play the nearby sound (Release 2), changed from isVisible to IsAudible with a supplied a range (Release 5-4)
            {
                switch (weapon.TheName.ToString())
                {
                    case "the pistol":
                    case "Hans von Hanz pistol":
                        if (shots == 1)
                            m_SFXManager.Play(GameSounds.PISTOL_SINGLE_SHOT_NEARBY, AudioPriority.PRIORITY_EVENT);
                        else
                            m_SFXManager.Play(GameSounds.PISTOL_RAPID_FIRE_NEARBY, AudioPriority.PRIORITY_EVENT);
                        break;
                    case "the hunting rifle":
                        m_SFXManager.Play(GameSounds.HUNTING_RIFLE_FIRE_NEARBY, AudioPriority.PRIORITY_EVENT);
                        break;
                    case "the precision rifle":
                    case "the army precision rifle":
                        m_SFXManager.Play(GameSounds.PRECISION_RIFLE_FIRE_NEARBY, AudioPriority.PRIORITY_EVENT);
                        break;
                    case "the army rifle":
                        if (shots == 1)
                            m_SFXManager.Play(GameSounds.ARMY_RIFLE_SINGLE_SHOT_NEARBY, AudioPriority.PRIORITY_EVENT);
                        else
                            m_SFXManager.Play(GameSounds.ARMY_RIFLE_RAPID_FIRE_NEARBY, AudioPriority.PRIORITY_EVENT);
                        break;
                    case "the shotgun":
                    case "the tactical shotgun":
                    case "the double barrel":
                    case "Santaman shotgun":
                        m_SFXManager.Play(GameSounds.SHOTGUN_FIRE_NEARBY, AudioPriority.PRIORITY_EVENT);
                        break;
                    case "the hunting crossbow":
                        m_SFXManager.Play(GameSounds.CROSSBOW_FIRE_NEARBY, AudioPriority.PRIORITY_EVENT);
                        break;
                    case "the revolver":
                    case "the army pistol":
                        if (shots == 1)
                            m_SFXManager.Play(GameSounds.REVOLVER_SINGLE_SHOT_NEARBY, AudioPriority.PRIORITY_EVENT);
                        else
                            m_SFXManager.Play(GameSounds.REVOLVER_RAPID_FIRE_NEARBY, AudioPriority.PRIORITY_EVENT);
                        break;
                    case "the flame thrower":
                        m_SFXManager.Play(GameSounds.FLAMETHROWER_AUDIBLE, AudioPriority.PRIORITY_EVENT);
                        break;
                    case "the stun gun":
                        m_SFXManager.Play(GameSounds.STUN_GUN_NEARBY, AudioPriority.PRIORITY_EVENT);
                        break;
                    case "the SMG":
                        if (shots == 1)
                            m_SFXManager.Play(GameSounds.SMG_SINGLE_SHOT_NEARBY, AudioPriority.PRIORITY_EVENT);
                        else
                            m_SFXManager.Play(GameSounds.SMG_RAPID_FIRE_NEARBY, AudioPriority.PRIORITY_EVENT);
                        break;
                    case "the minigun":
                        m_SFXManager.Play(GameSounds.MINIGUN_RAPID_FIRE_NEARBY, AudioPriority.PRIORITY_EVENT);
                        break;
                    case "the grenade launcher":
                        m_SFXManager.Play(GameSounds.GRENADE_LAUNCHER_SINGLE_SHOT_NEARBY, AudioPriority.PRIORITY_EVENT);
                        break;
                    default: break;
                }
            }
            else if (IsAudibleToPlayer(location, Rules.LOUD_NOISE_RADIUS)) // && m_Rules.RollChance(PLAYER_HEAR_FIGHT_CHANCE)) //@@MP - the noise is within earshot somewhere, so play the far-off sound (Release 2), changed from isVisible to IsAudible with a supplied a range (Release 5-4)
            {
                switch (weapon.TheName.ToString())
                {
                    case "the pistol":
                    case "Hans von Hanz pistol":
                        if (shots == 1)
                            m_SFXManager.Play(GameSounds.PISTOL_SINGLE_SHOT_FAR, AudioPriority.PRIORITY_EVENT);
                        else
                            m_SFXManager.Play(GameSounds.PISTOL_RAPID_FIRE_FAR, AudioPriority.PRIORITY_EVENT);
                        break;
                    case "the hunting rifle":
                        m_SFXManager.Play(GameSounds.HUNTING_RIFLE_FIRE_FAR, AudioPriority.PRIORITY_BGM);
                        break;
                    case "the precision rifle":
                    case "the army precision rifle":
                        m_SFXManager.Play(GameSounds.PRECISION_RIFLE_FIRE_FAR, AudioPriority.PRIORITY_EVENT);
                        break;
                    case "the army rifle":
                        if (shots == 1)
                            m_SFXManager.Play(GameSounds.ARMY_RIFLE_SINGLE_SHOT_FAR, AudioPriority.PRIORITY_EVENT);
                        else
                            m_SFXManager.Play(GameSounds.ARMY_RIFLE_RAPID_FIRE_FAR, AudioPriority.PRIORITY_EVENT);
                        break;
                    case "the shotgun":
                    case "the tactical shotgun":
                    case "the double barrel":
                    case "Santaman shotgun":
                        m_SFXManager.Play(GameSounds.SHOTGUN_FIRE_FAR, AudioPriority.PRIORITY_BGM);
                        break;
                    case "the revolver":
                    case "the army pistol":
                        if (shots == 1)
                            m_SFXManager.Play(GameSounds.REVOLVER_SINGLE_SHOT_FAR, AudioPriority.PRIORITY_EVENT);
                        else
                            m_SFXManager.Play(GameSounds.REVOLVER_RAPID_FIRE_FAR, AudioPriority.PRIORITY_EVENT);
                        break;
                    case "the SMG":
                        if (shots == 1)
                            m_SFXManager.Play(GameSounds.SMG_SINGLE_SHOT_FAR, AudioPriority.PRIORITY_EVENT);
                        else
                            m_SFXManager.Play(GameSounds.SMG_RAPID_FIRE_FAR, AudioPriority.PRIORITY_EVENT);
                        break;
                    case "the minigun":
                        m_SFXManager.Play(GameSounds.MINIGUN_RAPID_FIRE_FAR, AudioPriority.PRIORITY_EVENT);
                        break;
                    default: break;
                }
            }
        }

        private void SpendFuelAmmo(Actor actor) //@@MP (Release 7-2)
        {
            ItemAmmo fuel = actor.Inventory.GetFirstByModel(GameItems.AMMO_FUEL) as ItemAmmo;
            actor.Inventory.Consume(fuel);  //@@MP - fixed (Release 7-5)
        }

        /// <summary>
        /// To shoot at fuel cans (ammo) and fuel pumps (mapobject)
        /// </summary>
        void DoRangedAttackAtFuelExplosives(Actor attacker, Point fuelThingPos, List<Point> LoF, FireMode mode, object target) //@@MP (Release 7-1)
        {
            // get weapon.
            ItemRangedWeapon weapon = attacker.GetEquippedWeapon() as ItemRangedWeapon;
            if (weapon == null)
                throw new InvalidOperationException("DoSingleRangedAttack but no equipped ranged weapon");
            ItemRangedWeaponModel rm = weapon.Model as ItemRangedWeaponModel;

            // get target type
            Item item = null; //placeholder
            bool isItem = false;
            item = target as Item;
            if (item != null)
                isItem = true;

            bool isMapObject = false;
            MapObject mapObj = target as MapObject;
            if (mapObj != null)
                isMapObject = true;

            if (isItem == false && isMapObject == false)
                return;

            //placeholder for determining SFX type
            int shotsFired = 0; //0 for none, 1 for single-shot, 2 for rapid-fire

            // resolve, depending on mode. spend ammo
            switch (mode)
            {
                case FireMode.DEFAULT:
                    shotsFired = 1; //single shot SFX
                    --weapon.Ammo;
                    break;

                case FireMode.RAPID:
                    // do we have enough ammo for rapid-fire?
                    if (weapon.Ammo >= 2)
                    {
                        shotsFired = 2; //rapid-fire SFX
                        weapon.Ammo -= 2;
                    }
                    else
                    {
                        shotsFired = 1;
                        --weapon.Ammo;
                    }
                    break;
                default:
                    throw new ArgumentOutOfRangeException("mode", "unhandled ranged attack fire mode");
            }

            // set activity.
            attacker.Activity = Activity.DESTROYING;

            // get attack & defence.
            Attack attack = attacker.CurrentRangedAttack;

            // spend AP and STA.
            SpendActorActionPoints(attacker, Rules.BASE_ACTION_COST);
            SpendActorStaminaPoints(attacker, attack.StaminaPenalty);

            // show/hear.
            bool isFuelThingVisible = IsVisibleToPlayer(attacker.Location.Map, fuelThingPos);
            bool isAttVisible = IsVisibleToPlayer(attacker.Location);
            bool isPlayer = attacker.IsPlayer;

            if (shotsFired > 0)
                PlayRangedWeaponSFX(attacker.Location, weapon, shotsFired);

            if (isAttVisible)
            {
                AddOverlay(new OverlayRect(Color.Yellow, new Rectangle(MapToScreen(attacker.Location.Position), new Size(TILE_SIZE, TILE_SIZE))));
                AddOverlay(new OverlayRect(Color.Red, new Rectangle(MapToScreen(fuelThingPos), new Size(TILE_SIZE, TILE_SIZE))));
                AddOverlay(new OverlayImage(MapToScreen(attacker.Location.Position), GameImages.ICON_RANGED_ATTACK));
            }
            else
            {
                if (m_SFXManager.IsAudioEnabled == false && !isPlayer)
                {
                    if (m_Rules.RollChance(PLAYER_HEAR_FIGHT_CHANCE)) //@@MP - lower chance to avoid message spam
                        AddMessageIfAudibleForPlayer(attacker.Location, MakePlayerCentricMessage("You hear weapons fire", attacker.Location.Position));
                }
            }

            // check we are firing through something and it intercepts the attack.
            if (DoCheckFireThrough(attacker, LoF, rm))
                return;

            //weapons that can't cause fuel explosives destruction  //@@MP (Release 7-2)
            if (rm.ID == (int)GameItems.IDs.RANGED_STUN_GUN || !rm.IsFireArm)
                return;

            // resolve attack.
            int hitChance = 100;
            if (mode == FireMode.RAPID)
            {
                int hit1Chance = m_Rules.ComputeChancesRangedHitOnItem(attacker, fuelThingPos, 1);
                int hit2Chance = m_Rules.ComputeChancesRangedHitOnItem(attacker, fuelThingPos, 2);
                hitChance = ((hit1Chance * hit2Chance) / 100);
            }
            else
                hitChance = m_Rules.ComputeChancesRangedHitOnItem(attacker, fuelThingPos, 0);

            // Hit vs Missed
#region
            DiceRoller roller = new DiceRoller();
            if (roller.RollChance(hitChance)) //hit
            {
                if (isItem)
                {
                    Inventory groundInv = attacker.Location.Map.GetItemsAt(fuelThingPos);
                    foreach (Item it in groundInv.Items.ToList())
                    {
                        if (it.Model == item.Model) //get rid of all instances of the fuel cans
                            attacker.Location.Map.RemoveItemAt(it, fuelThingPos);
                    }
                    ItemPrimedExplosive fuelThing = new ItemPrimedExplosive(GameItems.FUEL_CAN_PRIMED);
                    DoBlast(new Location(attacker.Location.Map, fuelThingPos), (fuelThing.Model as ItemExplosiveModel).BlastAttack, fuelThing.Model, attacker);
                }
                else if (isMapObject)
                {
                    ExplodeFuelPump(new Location(attacker.Location.Map, fuelThingPos));  //@@MP - fixed (Release 7-5)
                }
            }
            else // miss
            {
                // show
                if (isFuelThingVisible)
                {
                    if (isItem) //@@MP - originally only handled items (Release 7-3)
                        AddMessage(MakeMessage(attacker, Conjugate(attacker, VERB_MISS), item));
                    else if (isMapObject)
                        AddMessage(MakeMessage(attacker, Conjugate(attacker, VERB_MISS), mapObj));
                    AddOverlay(new OverlayImage(MapToScreen(fuelThingPos), GameImages.ICON_RANGED_MISS));
                    RedrawPlayScreen();
                    AnimDelay(isPlayer ? DELAY_NORMAL : DELAY_SHORT, false);
                }
            }
#endregion

            // make sure added overlays are cleared.
            if (isFuelThingVisible || isAttVisible)
                ClearOverlays();
        }

        public void DoThrowGrenadeUnprimed(Actor actor, Point targetPos)
        {
            // get grenade.
            ItemGrenade grenade = actor.GetEquippedWeapon() as ItemGrenade;
            if (grenade == null)
                throw new InvalidOperationException("throwing grenade but no grenade equipped ");

            Map map = actor.Location.Map;

            // spend AP.
            SpendActorActionPoints(actor, Rules.BASE_ACTION_COST);

            // consume grenade.
            actor.Inventory.Consume(grenade);

            // drop primed grenade at target position.
            ItemGrenadePrimed primedGrenade = new ItemGrenadePrimed(m_GameItems[grenade.PrimedModelID]);
            map.DropItemAt(primedGrenade, targetPos);
            primedGrenade.Owner = actor; //@@MP - so we can determine later if skills add extra damage to the blast (Release 6-6)

            // message about throwing.
            bool isVisible = IsVisibleToPlayer(actor) || IsVisibleToPlayer(actor.Location.Map, targetPos);
            if (isVisible)
            {
                AddOverlay(new OverlayRect(Color.Yellow, new Rectangle(MapToScreen(actor.Location.Position), new Size(TILE_SIZE, TILE_SIZE))));
                AddOverlay(new OverlayRect(Color.Red, new Rectangle(MapToScreen(targetPos), new Size(TILE_SIZE, TILE_SIZE))));
                AddMessage(MakeMessage(actor, String.Format("{0} a {1}!", Conjugate(actor, VERB_THROW), grenade.Model.SingleName)));
                RedrawPlayScreen();
                AnimDelay(DELAY_LONG,true);
                ClearOverlays();
                RedrawPlayScreen();
            }

            //@@MP - provoke those in blast radius (Release 5-7), (Release 6-6)
            if ((primedGrenade.Model as ItemExplosiveModel).BlastAttack.IsProvocative) //@@MP - allow for grenade-types that don't provoke eg smoke (Release 7-2)
            {
                //check for civilians within 2 tiles, or half the radius for bigger explosives. any larger is unreasonable to assume the thrower was targeting the victim
                int halfBlastRadius = Convert.ToInt32((primedGrenade.Model as ItemExplosiveModel).BlastAttack.Radius / 2);
                int provocationRadius = Math.Max(1, halfBlastRadius);
                // civilians in the blast radius will become aggrevated by the thrower
                List<Actor> actorsNearbyTargetPos = GetActorsInGivenRadius(map, targetPos, provocationRadius);
                if (actorsNearbyTargetPos != null && primedGrenade.Model != GameItems.DYNAMITE && primedGrenade.Model != GameItems.DYNAMITE_PRIMED) //dynamite is placed, not thrown, and huge radius, so we don't want to factor it in here
                {
                    HandleBlastRadiusActorsAggression(actor, actorsNearbyTargetPos); //actor (so we don't act upon the thrower), list of actors in radius
                }
            }
        }

        public void DoThrowGrenadePrimed(Actor actor, Point targetPos)
        {
            // get grenade.
            ItemGrenadePrimed primedGrenade = actor.GetEquippedWeapon() as ItemGrenadePrimed;
            if (primedGrenade == null)
                throw new InvalidOperationException("throwing primed grenade but no primed grenade equipped ");

            Map map = actor.Location.Map;

            // spend AP.
            SpendActorActionPoints(actor, Rules.BASE_ACTION_COST);

            // remove grenade from inventory.
            actor.Inventory.RemoveAllQuantity(primedGrenade);

            // drop primed grenade at target position.
            map.DropItemAt(primedGrenade, targetPos);
            primedGrenade.Owner = actor; //@@MP - so we can determine later if skills add extra damage to the blast (Release 6-6)

            // message about throwing.
            bool isVisible = IsVisibleToPlayer(actor) || IsVisibleToPlayer(actor.Location.Map, targetPos);
            if (isVisible)
            {
                AddOverlay(new OverlayRect(Color.Yellow, new Rectangle(MapToScreen(actor.Location.Position), new Size(TILE_SIZE, TILE_SIZE))));
                AddOverlay(new OverlayRect(Color.Red, new Rectangle(MapToScreen(targetPos), new Size(TILE_SIZE, TILE_SIZE))));
                AddMessage(MakeMessage(actor, String.Format("{0} back a {1}!", Conjugate(actor, VERB_THROW), primedGrenade.Model.SingleName)));
                RedrawPlayScreen();
                AnimDelay(DELAY_LONG,true);
                ClearOverlays();
                RedrawPlayScreen();
            }

            //@@MP - provoke those in blast radius (Release 5-7), (Release 6-6)
            if ((primedGrenade.Model as ItemExplosiveModel).BlastAttack.IsProvocative) //@@MP - allow for grenade-types that don't provoke eg smoke (Release 7-2)
            {
                // check for civilians within 2 tiles, or half the radius for bigger explosives. any larger is unreasonable to assume the thrower was targeting the victim
                int halfBlastRadius = Convert.ToInt32((primedGrenade.Model as ItemExplosiveModel).BlastAttack.Radius / 2);
                int provocationRadius = Math.Max(1, halfBlastRadius);
                List<Actor> actorsNearbyTargetPos = GetActorsInGivenRadius(map, targetPos, provocationRadius);
                // civilians in the blast radius will become aggrevated by the thrower
                if (actorsNearbyTargetPos != null && primedGrenade.Model != GameItems.DYNAMITE_PRIMED && primedGrenade.Model != GameItems.DYNAMITE) //dynamite is placed, not thrown, and huge radius, so we don't want to factor it in here
                {
                    HandleBlastRadiusActorsAggression(actor, actorsNearbyTargetPos); //actor (so we don't act upon the thrower), list of actors in radius
                }
            }
        }

        static List<Actor> GetActorsInGivenRadius(Map map, Point targetPos, int radius) //@@MP (Release 5-7)
        {
            Point pt = new Point();
            List<Actor> actorsNearbyTarget = new List<Actor>();
            // on the targetPos
            Actor foundActor = map.GetActorAt(targetPos);
            if (foundActor != null)
            {
                actorsNearbyTarget.Add(foundActor);
                foundActor = null;
            }

            for (int z = 1; z <= radius; z++) //@@MP - the code within only checks a particular distance, so if you need to check a radius of 2, it needs to check those at 1 first
            {
                int xmin = targetPos.X - z;
                int xmax = targetPos.X + z;
                int ymin = targetPos.Y - z;
                int ymax = targetPos.Y + z;

                // north of targetPos
                if (ymin >= 0)
                {
                    pt.Y = ymin;
                    for (int x = xmin; x <= xmax; x++)
                    {
                        pt.X = x;
                        foundActor = map.GetActorAt(pt);
                        if (foundActor != null)
                        {
                            actorsNearbyTarget.Add(foundActor);
                            foundActor = null;
                        }
                    }
                }

                // south of targetPos
                if (ymax < map.Height)
                {
                    pt.Y = ymax;
                    for (int x = xmin; x <= xmax; x++)
                    {
                        pt.X = x;
                        foundActor = map.GetActorAt(pt);
                        if (foundActor != null)
                        {
                            actorsNearbyTarget.Add(foundActor);
                            foundActor = null;
                        }
                    }
                }

                // west of targetPos
                // do dont west corners twice! hence the ymin + 1 and < ymax checks.
                if (xmin >= 0)
                {
                    pt.X = xmin;
                    for (int y = ymin + 1; y < ymax; y++)
                    {
                        pt.Y = y;
                        foundActor = map.GetActorAt(pt);
                        if (foundActor != null)
                        {
                            actorsNearbyTarget.Add(foundActor);
                            foundActor = null;
                        }
                    }
                }

                // east of targetPos
                // don't do east corners twice! hence the ymin + 1 and < ymax checks.
                if (xmax < map.Width)
                {
                    pt.X = xmax;
                    for (int y = ymin + 1; y < ymax; y++)
                    {
                        pt.Y = y;
                        foundActor = map.GetActorAt(pt);
                        if (foundActor != null)
                        {
                            actorsNearbyTarget.Add(foundActor);
                            foundActor = null;
                        }
                    }
                }
            }

            //remove duplicates
            List<Actor> uniqueActorsNearbyTarget = null; //only return each actor once
            if (actorsNearbyTarget != null)
                uniqueActorsNearbyTarget = new HashSet<Actor>(actorsNearbyTarget).ToList();

            return uniqueActorsNearbyTarget;
        }

        void HandleBlastRadiusActorsAggression(Actor thrower, List<Actor> actors) //@@MP (Release 5-7)
        {
            foreach (Actor victim in actors)
            {
                if (victim.Model.Abilities.IsUndead)
                    continue; //can't make enemies with undead, of course
                else if (victim == thrower)
                    continue; //can't make enemies with themself, of course
                else if (victim.HasLeader && victim.Leader == thrower) //the thrower was the leader of the victim
                    ModifyActorTrustInLeader(victim, Rules.TRUST_FRIENDLY_FIRE_PENALTY, true); //lose trust
                else if (thrower.HasLeader && thrower.Leader == victim) //the victim was the leader of the thrower
                    ModifyActorTrustInLeader(thrower, Rules.TRUST_FRIENDLY_FIRE_PENALTY, true); //lose trust
                else if (thrower.HasLeader && victim.HasLeader && thrower.Leader == victim.Leader) //the thrower and the victim are following the same leader
                    ModifyActorTrustInLeader(thrower, Rules.TRUST_FRIENDLY_FIRE_PENALTY, true); //lose trust
                else
                {
                    if (!m_Rules.AreEnemies(thrower, victim))
                        DoMakeAggression(thrower, victim); //make enemies
                }

                // if victim is long waiting player, force stop.
                if (m_IsPlayerLongWait && victim.IsPlayer)
                    m_IsPlayerLongWaitForcedStop = true;
            }
        }

        void ShowBlastImage(Point screenPos, BlastAttack attack, int damage, string blastImage = GameImages.ICON_BLAST) //@@MP - allowed the called to supply the blast image (Release 7-6)
        {
            float alpha = 0.1f + (float)damage / (float)attack.Damage[0];
            if (alpha > 1) alpha = 1;
            AddOverlay(new OverlayTransparentImage(alpha, screenPos, blastImage));
            if (blastImage != GameImages.ICON_PLASMA_BURST) //@@MP - special case for the BFG. the dmg is so huge it kills everything instantly (Release 7-6)
                AddOverlay(new OverlayText(screenPos, Color.Red, damage.ToString(), Color.Black));
        }

        void DoBlast(Location location, BlastAttack blastAttack, ItemModel itemModel, Actor thrower = null) //@@MP - added itemExplosiveModel to determine the relevant sfx (Release 4), added thrower (Release 6-6), thrower optional (Release 7-3)
        {
            // noise.
            OnLoudNoise(location.Map, location.Position, "An EXPLOSION");

            // blast icon vs audio.
            bool hugeExplosion = false; bool playerHearsExplosion = false; //@@MP (Release 7-1)
            bool isVisible = IsVisibleToPlayer(location);

#region SFX
            if (isVisible || IsAudibleToPlayer(location, Rules.LOUD_NOISE_RADIUS)) //@@MP - changed from isVisible to also IsAudible with a range (Release 5-4), was LOUD radius (Release 6-4)
            {
                playerHearsExplosion = true;
                switch (itemModel.ID) //@@MP - play the appropriate sfx for the explosive type (Release 4)
                {
                    case (int)GameItems.IDs.EXPLOSIVE_FUEL_CAN_PRIMED: //@@MP (Release 7-1)
                        if (isVisible)
                            m_SFXManager.Play(GameSounds.FUEL_CAN_VISIBLE, AudioPriority.PRIORITY_EVENT);
                        else
                            m_SFXManager.Play(GameSounds.FUEL_CAN_AUDIBLE, AudioPriority.PRIORITY_BGM);
                        AnimDelay(DELAY_SHORT, true);
                        break;
                    case (int)GameItems.IDs.EXPLOSIVE_GRENADE_PRIMED:
                    case (int)GameItems.IDs.EXPLOSIVE_HOLY_HAND_GRENADE_PRIMED: //@@MP (Release 7-6)
                        m_SFXManager.Play(GameSounds.GRENADE_VISIBLE, AudioPriority.PRIORITY_EVENT);
                        AnimDelay(DELAY_SHORT, true); //@@MP - the longer the delay the slower the explosion appers on screen
                        break;
                    case (int)GameItems.IDs.EXPLOSIVE_MOLOTOV_PRIMED:
                        if (isVisible)
                            m_SFXManager.Play(GameSounds.MOLOTOV_VISIBLE, AudioPriority.PRIORITY_EVENT);
                        else
                            m_SFXManager.Play(GameSounds.MOLOTOV_AUDIBLE, AudioPriority.PRIORITY_BGM); //@@MP - it's close enough that it would still be audible
                        AnimDelay(DELAY_LONG, true); //@MP - make it look like the fire spreads, also pads out to better match the sound
                        break;
                    case (int)GameItems.IDs.EXPLOSIVE_DYNAMITE_PRIMED:
                    case (int)GameItems.IDs.EXPLOSIVE_C4_PRIMED: //@@MP (Release 6-3)
                        m_SFXManager.Play(GameSounds.DYNAMITE_VISIBLE, AudioPriority.PRIORITY_EVENT);
                        hugeExplosion = true;
                        AnimDelay(DELAY_SHORT, true);
                        break;
                    case (int)GameItems.IDs.EXPLOSIVE_FUEL_PUMP_PRIMED: //@@MP (Release 7-1)
                        m_SFXManager.Play(GameSounds.FUEL_PUMP_VISIBLE, AudioPriority.PRIORITY_EVENT);
                        hugeExplosion = true;
                        AnimDelay(DELAY_SHORT, true);
                        break;
                    case (int)GameItems.IDs.EXPLOSIVE_SMOKE_GRENADE_PRIMED: //@@MP (Release 7-2)
                        m_SFXManager.Play(GameSounds.SMOKE_GRENADE, AudioPriority.PRIORITY_EVENT);
                        AnimDelay(DELAY_LONG, true);
                        break;
                    case (int)GameItems.IDs.EXPLOSIVE_FLASHBANG_PRIMED: //@@MP (Release 7-2)
                        if (isVisible)
                            m_SFXManager.Play(GameSounds.FLASHBANG_VISIBLE, AudioPriority.PRIORITY_EVENT);
                        else
                            m_SFXManager.Play(GameSounds.FLASHBANG_AUDIBLE, AudioPriority.PRIORITY_EVENT);
                        AnimDelay(DELAY_LONG, true);
                        break;
                    case (int)GameItems.IDs.EXPLOSIVE_PLASMA_CHARGE_PRIMED: //@@MP (Release 7-6)
                        if (isVisible)
                            m_SFXManager.Play(GameSounds.PLASMA_BURST_VISIBLE, AudioPriority.PRIORITY_EVENT);
                        else
                            m_SFXManager.Play(GameSounds.PLASMA_BURST_AUDIBLE, AudioPriority.PRIORITY_EVENT);
                        AnimDelay(DELAY_SHORT, true);
                        break;
                    default: throw new ArgumentOutOfRangeException("itemModel", "unhandled explosive type");
                }
            }
            else if (IsAudibleToPlayer(location, Rules.BOOMING_NOISE_RADIUS)) //(m_Rules.RollChance(PLAYER_HEAR_EXPLOSION_CHANCE)) //@@MP - explosions are rare, so no need to worry about message/sfx spam (Release 2), suppiled IsAudible with a range (Release 5-4), was LOUD radius (Release 6-4)
            {
                playerHearsExplosion = true;
                switch (itemModel.ID) //@@MP - play the appropriate sfx for the explosive type (Release 4)
                {
                    case (int)GameItems.IDs.EXPLOSIVE_FUEL_CAN_PRIMED:
                    case (int)GameItems.IDs.EXPLOSIVE_MOLOTOV_PRIMED:
                    case (int)GameItems.IDs.EXPLOSIVE_SMOKE_GRENADE_PRIMED: //@@MP (Release 7-2)
                    case (int)GameItems.IDs.EXPLOSIVE_FLASHBANG_PRIMED: //@@MP (Release 7-2)
                        break; //@@MP - out of range. explicitly handled to avoid forgetting SFX for new explosives (Release 7-1)
                    case (int)GameItems.IDs.EXPLOSIVE_PLASMA_CHARGE_PRIMED: //@@MP (Release 7-6)
                        m_SFXManager.Play(GameSounds.PLASMA_BURST_AUDIBLE, AudioPriority.PRIORITY_EVENT);
                        break;
                    case (int)GameItems.IDs.EXPLOSIVE_GRENADE_PRIMED:
                    case (int)GameItems.IDs.EXPLOSIVE_HOLY_HAND_GRENADE_PRIMED: //@@MP (Release 7-6)
                        m_SFXManager.Play(GameSounds.GRENADE_AUDIBLE, AudioPriority.PRIORITY_BGM);
                        break;
                    case (int)GameItems.IDs.EXPLOSIVE_FUEL_PUMP_PRIMED: //@@MP (Release 7-1)
                    case (int)GameItems.IDs.EXPLOSIVE_DYNAMITE_PRIMED:
                    case (int)GameItems.IDs.EXPLOSIVE_C4_PRIMED: //@@MP (Release 6-3)
                        m_SFXManager.Play(GameSounds.DYNAMITE_VISIBLE, AudioPriority.PRIORITY_EVENT);
                        hugeExplosion = true;
                        break;
                    default: throw new ArgumentOutOfRangeException("itemModel", "unhandled explosive type");
                }
            }
            else if (location.Map == m_Player.Location.Map) //only the really loud ones
            {
                playerHearsExplosion = true;
                switch (itemModel.ID)
                {
                    case (int)GameItems.IDs.EXPLOSIVE_FUEL_CAN_PRIMED:
                    case (int)GameItems.IDs.EXPLOSIVE_MOLOTOV_PRIMED:
                    case (int)GameItems.IDs.EXPLOSIVE_GRENADE_PRIMED:
                    case (int)GameItems.IDs.EXPLOSIVE_HOLY_HAND_GRENADE_PRIMED: //@@MP (Release 7-6)
                    case (int)GameItems.IDs.EXPLOSIVE_SMOKE_GRENADE_PRIMED: //@@MP (Release 7-2)
                    case (int)GameItems.IDs.EXPLOSIVE_FLASHBANG_PRIMED: //@@MP (Release 7-2)
                    case (int)GameItems.IDs.EXPLOSIVE_PLASMA_CHARGE_PRIMED: //@@MP (Release 7-6)
                        break; //@@MP - out of range. explicitly handled to avoid forgetting SFX for new explosives (Release 7-1)
                    case (int)GameItems.IDs.EXPLOSIVE_FUEL_PUMP_PRIMED: //@@MP (Release 7-1)
                    case (int)GameItems.IDs.EXPLOSIVE_DYNAMITE_PRIMED:
                    case (int)GameItems.IDs.EXPLOSIVE_C4_PRIMED: //@@MP (Release 6-3)
                        m_SFXManager.Play(GameSounds.DYNAMITE_AUDIBLE, AudioPriority.PRIORITY_EVENT);
                        break;
                    default: throw new ArgumentOutOfRangeException("itemModel", "unhandled explosive type");
                }
            }
#endregion

            // broader handling for messaging //@@MP (Release 7-1)
            string soundModifier = (hugeExplosion) ? "a huge" : "an";
            if (isVisible)
                AddMessage(MakeMessage(m_Player, MakePlayerCentricMessage("sees " + soundModifier + " EXPLOSION", location.Position).Text, Color.Yellow));
            else if (playerHearsExplosion)
                AddMessage(MakeMessage(m_Player, MakePlayerCentricMessage("hears " + soundModifier + " EXPLOSION", location.Position).Text, Color.Yellow));

            // special cases
            if (isVisible && blastAttack.Damage[0] > 0) //@@MP - >0 caters for non-damaging blasts like smoke grenades and flashbangs (Release 7-2)
            {
                string blastIcon = GameImages.ICON_BLAST;
                if (itemModel == m_GameItems.PLASMA_CHARGE_PRIMED)
                    blastIcon = GameImages.ICON_PLASMA_BURST;
                ShowBlastImage(MapToScreen(location.Position), blastAttack, blastAttack.Damage[0], blastIcon);
            }
            else if (itemModel.ID == (int)GameItems.IDs.EXPLOSIVE_SMOKE_GRENADE_PRIMED)
                DeploySmokeScreen(location.Map, location.Position);
            else if (itemModel.ID == (int)GameItems.IDs.EXPLOSIVE_FLASHBANG_PRIMED)
                DetonateFlashbang(location.Map, location.Position);

            if (location.Map == m_Player.Location.Map)
                RedrawPlayScreen();

            // ground zero explosion.
            ApplyExplosionDamage(location, 0, blastAttack, itemModel, thrower); //@@MP - added ItemModel argument for pass through to ApplyExplosionDamage (Release 4), added thrower (Release 6-6)

            // explosion wave.
            for (int waveDistance = 1; waveDistance <= blastAttack.Radius; waveDistance++)
            {
                // do it.
                bool anyVisible = ApplyExplosionWave(location, waveDistance, blastAttack, itemModel, thrower); //@@MP - added ItemModel argument for pass through to ApplyExplosionDamage (Release 4)

                // show.
                if (anyVisible)
                {
                    isVisible = true; // alpha10
                    RedrawPlayScreen();
                    AnimDelay(DELAY_NORMAL,true);
                }
            }

            // alpha10 bug fix; clear overlays only if action is visible
            if (isVisible)
                ClearOverlays();
        }

        bool ApplyExplosionWave(Location center, int waveDistance, BlastAttack blast, ItemModel itemModel, Actor thrower) //@@MP - added ItemModel argument for pass through to ApplyExplosionDamage (Release 4), added thrower (Release 6-6)
        {
            bool anyVisible = false;
            Map map = center.Map;

            Point pt = new Point();
            int xmin = center.Position.X - waveDistance;
            int xmax = center.Position.X + waveDistance;
            int ymin = center.Position.Y - waveDistance;
            int ymax = center.Position.Y + waveDistance;

            // north.
            if (ymin >= 0)
            {
                pt.Y = ymin;
                for (int x = xmin; x <= xmax; x++)
                {
                    pt.X = x;
                    anyVisible |= ApplyExplosionWaveSub(center, pt, waveDistance, blast, itemModel, thrower); //@@MP - added ItemModel argument for pass through to ApplyExplosionDamage (Release 4), added thrower (Release 6-6)
                }
            }

            // south.
            if (ymax < map.Height)
            {
                pt.Y = ymax;
                for (int x = xmin; x <= xmax; x++)
                {
                    pt.X = x;
                    anyVisible |= ApplyExplosionWaveSub(center, pt, waveDistance, blast, itemModel, thrower); //@@MP - added ItemModel argument for pass through to ApplyExplosionDamage (Release 4), added thrower (Release 6-6)
                }
            }

            // west.
            // do dont west corners twice!
            // hence the ymin + 1 and < ymax checks.
            if (xmin >= 0)
            {
                pt.X = xmin;
                for (int y = ymin + 1; y < ymax; y++)
                {
                    pt.Y = y;
                    anyVisible |= ApplyExplosionWaveSub(center, pt, waveDistance, blast, itemModel, thrower); //@@MP - added ItemModel argument for pass through to ApplyExplosionDamage (Release 4), added thrower (Release 6-6)
                }
            }

            // east.
            // don't do east corners twice!
            // hence the ymin + 1 and < ymax checks.
            if (xmax < map.Width)
            {
                pt.X = xmax;
                for (int y = ymin + 1; y < ymax; y++)
                {
                    pt.Y = y;
                    anyVisible |= ApplyExplosionWaveSub(center, pt, waveDistance, blast, itemModel, thrower); //@@MP - added ItemModel argument for pass through to ApplyExplosionDamage (Release 4), added thrower (Release 6-6)
                }
            }

            // return if any explosion was visible.
            return anyVisible;
        }

        bool ApplyExplosionWaveSub(Location blastCenter, Point pt, int waveDistance, BlastAttack blast, ItemModel itemModel, Actor thrower) //@@MP - added ItemModel argument for pass through to ApplyExplosionDamage (Release 4)
        {
            if (blastCenter.Map.IsInBounds(pt))
            {
                if (itemModel.ID == (int)GameItems.IDs.EXPLOSIVE_SMOKE_GRENADE_PRIMED) //@@MP - smoke grenade effect (Release 7-2)
                {
                    DeploySmokeScreen(blastCenter.Map, pt);
                    // show if visible.
                    if (IsVisibleToPlayer(blastCenter.Map, pt))
                        return true;
                }
                else if (itemModel.ID == (int)GameItems.IDs.EXPLOSIVE_FLASHBANG_PRIMED) //@@MP - flashbang effect (Release 7-2)
                {
                    DetonateFlashbang(blastCenter.Map, pt);
                    // show if visible.
                    if (IsVisibleToPlayer(blastCenter.Map, pt))
                        return true;
                }
                else if (LOS.CanTraceFireLine(blastCenter, pt, waveDistance, null)) // do damage.
                {
                    bool proceed = true;
                    if (itemModel == m_GameItems.PLASMA_CHARGE_PRIMED) //@@MP - special case for BFGs (Release 7-6)
                    {
                        Actor victim = blastCenter.Map.GetActorAt(pt);
                        if (victim == null || victim == thrower) //the BFG won't harm the firer, as the gun somehow protects the operator
                            proceed = false;
                    }

                    if (proceed)
                    {
                        int damage = ApplyExplosionDamage(new Location(blastCenter.Map, pt), waveDistance, blast, itemModel, thrower); //@@MP - added ItemModel argument for pass through to ApplyExplosionDamage (Release 4), added thrower (Release 6-6)

                        // show if visible.
                        if (IsVisibleToPlayer(blastCenter.Map, pt))
                        {
                            string blastIcon = GameImages.ICON_BLAST;
                            if (itemModel == m_GameItems.PLASMA_CHARGE_PRIMED) //@@MP - special case for BFGs (Release 7-6)
                                blastIcon = GameImages.ICON_PLASMA_BURST;
                            ShowBlastImage(MapToScreen(pt), blast, damage, blastIcon); //@@MP - not relevant for zero-damage explosions like smoke grenades
                            return true;
                        }
                    }
                }
            }

            return false;
        }

        int ApplyExplosionDamage(Location location, int distanceFromBlast, BlastAttack blast, ItemModel itemModel, Actor attacker = null) //@@MP - added ItemModel argument (Release 4), added attacker (Release 6-6), attacker now optional (Release 7-3)
        {
            Map map = location.Map;

            int modifiedDamage = m_Rules.BlastDamage(distanceFromBlast, blast);

            // if no damage, don't bother.
            if (modifiedDamage <= 0)
                return 0;

            // damage actor / carried explosives chain reaction.
#region
            Actor victim = map.GetActorAt(location.Position);
            if (victim != null)
            {
                // explosives chain reaction.
#region
                //@@MP - disabled because it's OP and didn’t increase the fun factor, especially given that mostly only the player is likely to use or even carry an explosive (Release 5-2)
                /*Inventory carriedItems = victim.Inventory;
                ExplosionChainReaction(carriedItems, location);*/
#endregion

                // damage.
#region
                if (attacker != null) //@@MP - added bonus from skill (Release 6-6)
                    modifiedDamage += (Rules.SKILL_EXPLOSIVES_DMG_BONUS * attacker.Sheet.SkillTable.GetSkillLevel((int)Skills.IDs.BOWS_EXPLOSIVES));

                int dmgToVicitim = modifiedDamage;
                bool fireCausedIt = false;
                bool splatterBlood = true;

                // inflict.       //@@MP - inflict section revived on rebase of R7-1 onto R6-6 (Release 7-1)
                if (itemModel.IsFlameWeapon) //@@MP - fire damage required something customised, as you'll see below and in 7.2 of NextMapTurn()
                {
                    SetActorOnFire(victim); //even if it's 0 damage they should still be set on fire (fire resistance of armor accounted for)
                    dmgToVicitim = Math.Max(0, (modifiedDamage - BASE_ISONFIRE_FIRE_DAMAGE)); //@@MP - NextMapTurn() will inflict base fire damage, so for this initial hit just include any damage over and above that. don't go below zero, which would add HP (Release 7-1)
                    fireCausedIt = true;
                    splatterBlood = false; //@@MP - now that InflictDamage doesn't have to cause blood splatter, don't for fires (Release 5-2)
                }
                else //normal firearm or crossbow
                {
                    dmgToVicitim = modifiedDamage - (victim.CurrentDefence.Protection_Hit + victim.CurrentDefence.Protection_Shot) / 2;
                }
                    
                if (dmgToVicitim > 0)
                {
                    // inflict.  //@@MP - inflict section revived on rebase of R7-1 onto R6-6 (Release 7-1)
                    // if it's a standard explosive (non flame wep) fireCausedIt is false, but we do want to splatter blood
                    InflictDamage(victim, dmgToVicitim, splatterBlood, fireCausedIt);

                    // message.
                    if (IsVisibleToPlayer(victim))
                    {
                        AddMessage(new Message(String.Format("{0} is hit for {1} damage!", victim.Name, dmgToVicitim), map.LocalTime.TurnCounter, Color.Crimson));
                    }

                    // die? do not kill someone who is already dead, this could happen because of multiple explosions in a single turn.
                    if (victim.HitPoints <= 0 && !victim.IsDead)
                    {
                        // kill him.
                        string cause = "explosion";
                        if (fireCausedIt)
                            cause = "incinerated";
                        else if (itemModel == m_GameItems.PLASMA_CHARGE_PRIMED) //@@MP - special case for BFGs (Release 7-6)
                            cause = "disintegrated";
                        KillActor(null, victim, cause, fireCausedIt);

                        // message?
                        if (IsVisibleToPlayer(victim))
                        {
                            AddMessage(new Message(String.Format("{0} dies in the explosion!", victim.Name), map.LocalTime.TurnCounter, Color.Crimson));
                        }
                    }
                }
                else
                    AddMessage(new Message(String.Format("{0} is hit but took no damage.", victim.Name), map.LocalTime.TurnCounter, Color.White));

#endregion
            }
#endregion

            // destroy items / ground explosives chain reaction.
#region
            if (itemModel != m_GameItems.PLASMA_CHARGE_PRIMED) //@@MP - special case for BFGs, as they only damage biomass and not objects nor items (Release 7-6)
            {
                Inventory groundInv = map.GetItemsAt(location.Position);
                if (groundInv != null)
                {
                    // ground explosives chain reaction.
                    ExplosionChainReactionInventory(groundInv, location);

                    // pick items to destroy - don't destroy explosives ready to go, we need them for the chain reaction.
                    #region
                    // the more damage, the more chance.
                    // never destroy uniques or unbreakables.
                    int destroyChance = modifiedDamage;
                    List<Item> destroyItems = new List<Item>(groundInv.CountItems);
                    ItemPrimedExplosive itemExplosive = null; //@@MP (Release 5-7)
                    foreach (Item it in groundInv.Items)
                    {
                        if (it.IsUnique || it.Model.IsUnbreakable)
                            continue;

                        itemExplosive = it as ItemPrimedExplosive;
                        if (itemExplosive != null)
                        {
                            if (itemExplosive.FuseTimeLeft <= 0)
                            {
                                itemExplosive = null;
                                continue;
                            }
                        }

                        if (!m_Rules.RollChance(destroyChance))
                            continue;
                        destroyItems.Add(it);
                    }

                    // do it.
                    foreach (Item it in destroyItems)
                        map.RemoveItemAt(it, location.Position);
                    destroyItems = null;
                    #endregion
                }
            }
#endregion

            // damage objects?
#region
            if (blast.CanDamageObjects)
            {
                MapObject obj = map.GetMapObjectAt(location.Position);
                if (obj != null)
                {
                    DoorWindow door = obj as DoorWindow;
                    // damage only breakables or barricaded door/windows.
                    if (obj.IsBreakable || (door != null && door.IsBarricaded))
                    {
                        int damageToObject = modifiedDamage;

                        // barricaded doors absorb part of the damage.
                        if (door != null && door.IsBarricaded)
                        {
                            int barricadeDamage = Math.Min(door.BarricadePoints, damageToObject);
                            door.BarricadePoints -= barricadeDamage;
                            damageToObject -= barricadeDamage;
                        }
                        
                        // then directly damage the object.
                        if (damageToObject >= 0)
                        {
                            obj.HitPoints -= damageToObject;
                            if (obj.HitPoints <= 0)
                            {
                                if (!ExplosionChainReactionMapObjects(location))  //because ExplosionChainReaction may have swapped a Breakable fuel pump for an Unbreakable damaged fuel pump
                                    DoDestroyObject(obj);
                            }
                                
                        }
                    }
                }
            }
#endregion

            // damage corpses?
#region
            List<Corpse> corpses = map.GetCorpsesAt(location.Position);
            if (corpses != null && itemModel != m_GameItems.PLASMA_CHARGE_PRIMED) //@@MP - special case for BFGs (Release 7-6))
            {
                foreach (Corpse c in corpses)
                    InflictDamageToCorpse(c, modifiedDamage);
            }
#endregion

            // destroy walls?
#region
            bool wallDestroyed = false;
            if (blast.CanDestroyWalls)
            {
                //@@MP (Release 3)
                if (map.IsDestructibleWallAt(this, location) && !map.AnyAdjacentOutOfBounds(location.Position)) //@@MP - don't destroy if next to out of bounds (Release 7-3)
                {
                    ReplaceDestroyedWall(location);
                    wallDestroyed = true;
                }
            }

            if (!wallDestroyed) //@@MP - add scorch sprite where ground or surviving wall was blasted (Release 2)
            {
                if (itemModel != m_GameItems.PLASMA_CHARGE_PRIMED) //@@MP - special case for the BFG, as it doesnt fire a standard explosive (Release 7-6)
                    ScorchBurntTile(map, location.Position.X, location.Position.Y, modifiedDamage);
            }
            #endregion

            // flame weapons start fires     //@@MP (Release 4)
#region
            if (itemModel.IsFlameWeapon || itemModel.CausesTileFires) //@@MP - switched to the new IsFlameWeapon property (Release 5-2), added CausesFires for explosion fires (Release 7-3)
                SetTileOnFire(map, location.Position.X, location.Position.Y, true);
#endregion

            // return damage done.
            return modifiedDamage;
        }

        void ExplosionChainReactionInventory(Inventory inv, Location location)
        {
            if (inv == null || inv.IsEmpty)
                return;

            // convert fuel cans into explosives to make them explode   //@@MP (Release 7-1)
            foreach (Item it in inv.Items.ToList())
            {
                ItemAmmo ammo = it as ItemAmmo;
                if (ammo != null && ammo.Model == GameItems.AMMO_FUEL)
                {
                    inv.RemoveAllQuantity(it);
                    ItemExplosive exp = new ItemExplosive(GameItems.FUEL_CAN, GameItems.FUEL_CAN_PRIMED);
                    inv.AddAsMuchAsPossible(exp, out int quantityAdded);
                    Logger.WriteLine(Logger.Stage.RUN_MAIN, "chain reaction fuel cans: " + quantityAdded.ToString());
                }
            }

            // set each explosive item ready to explode.
            List<ItemExplosive> removedExplosives = null;
            List<ItemPrimedExplosive> addedExplosives = null;
            foreach (Item it in inv.Items)
            {
                // explosive?
                ItemExplosive explosive = it as ItemExplosive;
                if (explosive == null)
                    continue;

                // if a primed explosive, just force fuse to zero.
                ItemPrimedExplosive primedExplosive = explosive as ItemPrimedExplosive;
                if (primedExplosive != null)
                {
                    primedExplosive.FuseTimeLeft = 0;
                    continue;
                }

                // unprimed explosive, prime it, force fuse to zero and drop it at location.
                if (removedExplosives == null)
                    removedExplosives = new List<ItemExplosive>();
                if (addedExplosives == null)
                    addedExplosives = new List<ItemPrimedExplosive>();

                removedExplosives.Add(explosive);
                // add as many primed explosives at explosive quantity (stackables explosives).
                for (int nbPrimedToDrop = 0; nbPrimedToDrop < it.Quantity; nbPrimedToDrop++)
                {
                    primedExplosive = new ItemPrimedExplosive(m_GameItems[explosive.PrimedModelID]);
                    primedExplosive.FuseTimeLeft = 0;
                    addedExplosives.Add(primedExplosive);
                }
            }

            // remove explosives from inventory.
            if (removedExplosives != null)
            {
                foreach (Item removeIt in removedExplosives)
                    inv.RemoveAllQuantity(removeIt);
            }

            // drop primed explosives.
            if (addedExplosives != null)
            {
                foreach(Item addIt in addedExplosives)
                    location.Map.DropItemAt(addIt, location.Position);
            }
        }

        private bool ExplosionChainReactionMapObjects(Location location) //@@MP - added (Release 7-3)
        {
            // convert fuel pumps into explosives to make them explode   //@@MP (Release 7-3)
            MapObject mapObj = location.Map.GetMapObjectAt(location.Position);
            if (mapObj != null && mapObj.ImageID == GameImages.OBJ_FUEL_PUMP)
            {
                ExplodeFuelPump(location);
                return true;
            }

            return false;
        }

        private void ExplodeFuelPump(Location location) //@@MP (Release 7-3)
        {
            location.Map.RemoveMapObjectAt(location.Position.X, location.Position.Y); //get rid of the intact pump
            ItemPrimedExplosive fuelPumpPrimed = new ItemPrimedExplosive(GameItems.FUEL_PUMP_PRIMED); //make the hidden explosive so we can cause a big boom
            DoBlast(new Location(location.Map, location.Position), (fuelPumpPrimed.Model as ItemExplosiveModel).BlastAttack, fuelPumpPrimed.Model, null);
            location.Map.PlaceMapObjectAt(m_TownGenerator.MakeObjFuelPumpBroken(GameImages.OBJ_FUEL_PUMP_BROKEN), location.Position); //what happens to the pump after it goes boom
        }

        /// <summary>
        /// Replaces the wall tile with the appropriate type of floor tile and damaged wall section
        /// </summary>
        private void ReplaceDestroyedWall(Location location)  //@@MP (Release 3), amde static (Release 5-7)
        {
            Map map = location.Map;

            map.GetTileAt(location.Position.X, location.Position.Y).RemoveAllDecorations(); //@@MP - remove any decorations eg shop signage (Release 4)

            //replace the wall tile with a decoration of a damaged image of the wall
            TileModel walltilemodel = map.GetTileAt(location.Position.X, location.Position.Y).Model;
            switch (walltilemodel.ImageID)
            {
                case @"Tiles\wall_brick":
                    map.GetTileAt(location.Position.X, location.Position.Y).AddDecoration(GameImages.DECO_WALL_BRICK_DAMAGED);
                    break;
                case @"Tiles\wall_char_office":
                    map.GetTileAt(location.Position.X, location.Position.Y).AddDecoration(GameImages.DECO_WALL_CHAR_OFFICE_DAMAGED);
                    break;
                case @"Tiles\wall_hospital":
                    map.GetTileAt(location.Position.X, location.Position.Y).AddDecoration(GameImages.DECO_WALL_HOSPITAL_DAMAGED);
                    break;
                case @"Tiles\wall_sewer":
                    map.GetTileAt(location.Position.X, location.Position.Y).AddDecoration(GameImages.DECO_WALL_SEWER_DAMAGED);
                    break;
                case @"Tiles\wall_stone":
                    map.GetTileAt(location.Position.X, location.Position.Y).AddDecoration(GameImages.DECO_WALL_STONE_DAMAGED);
                    break;
                case @"Tiles\wall_light_brown": //@@MP (Release 4)
                    map.GetTileAt(location.Position.X, location.Position.Y).AddDecoration(GameImages.DECO_WALL_LIGHT_BROWN_DAMAGED);
                    break;
                case @"Tiles\wall_army_base": //@@MP (Release 6-3)
                    map.GetTileAt(location.Position.X, location.Position.Y).AddDecoration(GameImages.DECO_WALL_ARMY_BASE_DAMAGED);
                    break;
                case @"Tiles\wall_wood_planks": //@@MP (Release 7-3)
                    map.DropItemAt(m_TownGenerator.MakeItemWoodenPlank(), location.Position.X, location.Position.Y);
                    break;
                case @"Tiles\wall_fuel_station": //@@MP (Release 7-3)
                    map.GetTileAt(location.Position.X, location.Position.Y).AddDecoration(GameImages.DECO_WALL_FUEL_STATION_DAMAGED);
                    break;
                case @"Tiles\wall_mall": //@@MP (Release 7-3)
                    map.GetTileAt(location.Position.X, location.Position.Y).AddDecoration(GameImages.DECO_WALL_MALL_DAMAGED);
                    break;
                case @"Tiles\wall_red_curtains": //@@MP (Release 7-3)
                    //leaves a whole gap
                    break;
                default:
                    throw new NotSupportedException("unexpected ImageID for TileModel of given wall");
            }

            //get an adjacent floor tile
            TileModel floortilemodel;
            if (map.IsBuildingFloorTileAt(location.Position.X, location.Position.Y + 1)) //north
                floortilemodel = map.GetTileAt(location.Position.X, location.Position.Y + 1).Model;
            else if (map.IsBuildingFloorTileAt(location.Position.X, location.Position.Y - 1)) //south
                floortilemodel = map.GetTileAt(location.Position.X, location.Position.Y - 1).Model;
            else if (map.IsBuildingFloorTileAt(location.Position.X + 1, location.Position.Y)) //east
                floortilemodel = map.GetTileAt(location.Position.X + 1, location.Position.Y).Model;
            else if (map.IsBuildingFloorTileAt(location.Position.X - 1, location.Position.Y)) //west
                floortilemodel = map.GetTileAt(location.Position.X - 1, location.Position.Y).Model;
            else
            {
                map.SetTileModelAt(location.Position.X, location.Position.Y, GameTiles.FLOOR_ASPHALT);
                return;
            }

            //use the adjacent floor tile as the tile underneath the new damaged wall decoration (to show the player it can be walked through)
            switch (floortilemodel.ImageID)
            {
                case @"Tiles\floor_office":
                    map.SetTileModelAt(location.Position.X, location.Position.Y, GameTiles.FLOOR_OFFICE);
                    break;
                case @"Tiles\floor_tiles":
                    map.SetTileModelAt(location.Position.X, location.Position.Y, GameTiles.FLOOR_TILES);
                    break;
                case @"Tiles\floor_concrete":
                    map.SetTileModelAt(location.Position.X, location.Position.Y, GameTiles.FLOOR_CONCRETE);
                    break;
                case @"Tiles\floor_walkway":
                    map.SetTileModelAt(location.Position.X, location.Position.Y, GameTiles.FLOOR_WALKWAY);
                    break;
                case @"Tiles\floor_planks":
                    map.SetTileModelAt(location.Position.X, location.Position.Y, GameTiles.FLOOR_PLANKS);
                    break;
                case @"Tiles\floor_food_court_pool":
                    map.SetTileModelAt(location.Position.X, location.Position.Y, GameTiles.FLOOR_FOOD_COURT_POOL);
                    break;
                case @"Tiles\floor_white_tile":
                    map.SetTileModelAt(location.Position.X, location.Position.Y, GameTiles.FLOOR_WHITE_TILE);
                    break;
                case @"Tiles\floor_sewer_water":
                case @"Tiles\floor_sewer_water_anim1":
                case @"Tiles\floor_sewer_water_anim2":
                case @"Tiles\floor_sewer_water_anim3":
                case @"Tiles\floor_sewer_water_cover":
                    map.SetTileModelAt(location.Position.X, location.Position.Y, GameTiles.FLOOR_SEWER_WATER);
                    break;
                default:
                    map.SetTileModelAt(location.Position.X, location.Position.Y, GameTiles.FLOOR_WALKWAY);
                    break;
            }
        }

        private void DeploySmokeScreen(Map map, Point pt) //@@MP (Release 7-2)
        {
            Tile tile = map.GetTileAt(pt);

            //put smoke down
            if (map.GetMapObjectAt(pt) == null)
            {
                if (map.GetTileAt(pt).Model.IsWalkable && map.GetExitAt(pt) == null)
                {
                    map.PlaceMapObjectAt(m_TownGenerator.MakeObjSmokeScreen(GameImages.EFFECT_SMOKE_SCREEN), pt);
                    map.AddTimer(new TaskRemoveMapObject(WorldTime.TURNS_PER_HOUR * 2, pt.X, pt.Y, GameImages.EFFECT_SMOKE_SCREEN));
                }
            }
            /*else
            {
                if (!tile.HasDecoration(GameImages.EFFECT_SMOKE_SCREEN))
                {
                    tile.AddDecoration(GameImages.EFFECT_SMOKE_SCREEN);
                    map.AddTimer(new TaskRemoveDecoration(WorldTime.TURNS_PER_HOUR * 2, pt.X, pt.Y, GameImages.EFFECT_SMOKE_SCREEN));
                }
            }*/

            //smother tile fires
            if (tile.IsOnFire)
                ExtinguishOnFireTile(tile);

            //clear any and all scents
            OdorScent living = map.GetScentByOdorAt(Odor.LIVING, pt);
            if (living != null)
                map.RemoveScent(living);
            OdorScent suppressor = map.GetScentByOdorAt(Odor.SUPPRESSOR, pt);
            if (suppressor != null)
                map.RemoveScent(suppressor);
            OdorScent undeadmaster = map.GetScentByOdorAt(Odor.UNDEAD_MASTER, pt);
            if (undeadmaster != null)
                map.RemoveScent(undeadmaster);
        }

        private void DetonateFlashbang(Map map, Point pt) //@@MP (Release 7-2)
        {
            Actor actor = map.GetActorAt(pt);
            if (actor != null && !actor.Model.Abilities.IsUndead)
            {
                actor.FlashbangedTurns += STUN_WEAPON_EFFECT_TURNS;
                if (IsVisibleToPlayer(actor))
                    AddMessage(MakeMessage(actor, "is stunned by a flashbang"));
            }
        }
#endregion

#region -CHATTING, TRADING, TALKING, SHOUTING
        public void DoChat(Actor speaker, Actor target)
        {
            // spend APs.
            SpendActorActionPoints(speaker, Rules.BASE_ACTION_COST);

            // message
            bool isVisible = IsVisibleToPlayer(speaker) || IsVisibleToPlayer(target);
            if (isVisible)
                AddMessage(MakeMessage(speaker, Conjugate(speaker, VERB_CHAT_WITH), target));

            // trade?
            if (m_Rules.CanActorInitiateTradeWith(speaker,target))
            {
                DoTrade(speaker, target);
            }
            else //SFX also played in DoTrade, so don't double up
            {
                if (speaker.IsPlayer || target.IsPlayer) //@@MP (Release 7-4)
                    m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.PSST_WHISPER, AudioPriority.PRIORITY_BGM);
            }
        }

        // alpha10 "fast" trade uses new trade mechanic of rating items and trades.
        // npcs will mostly only make mutually beneficial deals.
        // speaker and target are also somehow reversed from how they were in rs9(!?)
        // for the player should try to mimick most of trade results obtained by player negociating trade but not mandatory.
        public void DoTrade(Actor speaker, Actor target)
        {
            if (speaker.IsPlayer || target.IsPlayer) //@@MP (Release 7-4)
                m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.PSST_WHISPER, AudioPriority.PRIORITY_BGM);

            // clean up activities
            speaker.Activity = Activity.TRADING;
            target.Activity = Activity.TRADING;

            bool isVisible = IsVisibleToPlayer(speaker) || IsVisibleToPlayer(target);
            if (isVisible)
                AddMessage(MakeMessage(speaker, string.Format("wants to make a quick trade with {0}.", target.Name)));

            // the basic idea is to pick an item the speaker wants from target, 
            // and offer an item the speaker is willing to get rid of.
            BaseAI speakerAI = speaker.Controller as BaseAI;
            BaseAI targetAI = target.Controller as BaseAI;
            Item offered, asked;
            offered = asked = null;

            // target not willing to trade if is ordered not to
            if ((!targetAI.Directives.CanTrade) && (speaker != target.Leader))
            {
                if (isVisible)
                    AddMessage(MakeMessage(target, "is not willing to trade."));
                return;
            }

            // if speaker is the player, make the npc the speaker so the npc is the one offering an item.
            // alpha10.1 but not for bot
            if (speaker.IsPlayer)
            {
                // swap speaker and target so npc is always speaker in fast trade
                Actor swap = target;
                target = speaker;
                speaker = swap;
                targetAI = null;  // now player
                speakerAI = speaker.Controller as BaseAI;
            }

            // local lambdas just because -_-

            // get an item the speaker would like from target inventory.
            Item pickAskedItem(out ItemRating rating)
            {
                // pick an item in target inventory the speaker wants, or any item if target has only junk.
                List<Item> wants = target.Inventory.Filter((it) =>
                {
                    ItemRating r = speakerAI.RateItem(this, it, false);
                    // wants anything but junk. 
                    // don't limit to things speaker needs because the target ai is more likely to value the same item
                    // as being needed for himself! also makes for more varied deals.
                    return r != ItemRating.JUNK;
                });
                if (wants.Count == 0)
                {
                    // no non-junk items, extend to all items...
                    wants.AddRange(target.Inventory.Items);
                }

                // pick one from the wanted list.
                Item wantIt = wants[m_Rules.Roll(0, wants.Count)];
                rating = speakerAI.RateItem(this, wantIt, false);
                return wantIt;
            };

            // can return null 
            // get an item the speaker is willing to exhange for the target item it wants.
            Item pickOfferedItem(Item askedItem, ItemRating askedItemRating)
            {
                List<Item> offerables;

                // if target is npc: 
                //   - offer any item that could pass a trade deal with this npc (read their ai mind)
                // if target is player: 
                //   - cannot use rate trade offer on the npc itself...
                //   - so offer only items we rate less than the one we want (player should negotiate deal instead)
                //   - accepting equal item ratings lead to bad deals for the npc, offering a need for a need (eg: a rifle for bullets!)
                // in all offers, never offer the same item model as the one asked eg: a pistol for a pistol!
                if (target.IsPlayer)
                {
                    offerables = speaker.Inventory.Filter((it) =>
                    {
                        return it.Model != askedItem.Model && speakerAI.RateItem(this, it, true) < askedItemRating;
                    });
                }
                else
                {
                    offerables = speaker.Inventory.Filter((it) =>
                    {
                        if (it.Model == askedItem.Model)
                            return false;
                        // read target ai mind...
                        TradeRating tr = targetAI.RateTradeOffer(this, speaker, it, askedItem);
                        // accept "Maybe" items to be a bit more realistic in not always making perfect deals
                        // ("hey! the ai always accept ai trades! they are cheating!")
                        // and let charisma influence the final result.
                        return tr != TradeRating.REFUSE;
                    });
                }

                if (offerables.Count == 0)
                {
                    // all our items are more valuable than the one we want or only silly deals. no deal.
                    return null;
                }

                Item offerIt = offerables[m_Rules.Roll(0, offerables.Count)];
                return offerIt;
            }

            ItemRating askedRating;
            asked = pickAskedItem(out askedRating);
            offered = pickOfferedItem(asked, askedRating);

            // if no item pairs found, failed trade.
            // either the target has no interesting items for speaker,
            // or the speaker has items too valuable for a trade.
            if ((asked == null) || (offered == null))
            {
                if (asked == null)
                {
                    // speaker finds nothing interesting in target inventory
                    if (isVisible)
                        AddMessage(MakeMessage(speaker, "is not interested in any item of your items."));
                }
                else
                {
                    // speaker has no item to give away (should not happen if target is player)
                    if (isVisible)
                        AddMessage(MakeMessage(speaker, string.Format("would prefer to keep {0} items.", HisOrHer(speaker))));
                }
                if (target.IsPlayer)
                    // help confused players...
                    AddMessage(new Message(string.Format("(maybe try negociating a deal instead [key: {0}])", s_KeyBindings.GetFriendlyFormat(PlayerCommand.NEGOTIATE_TRADE).ToString()), m_Session.WorldTime.TurnCounter, Color.Yellow));
                return;
            }

            // propose.
            // if player, ask.
            // if target is ai, check for it.
            // alpha10.1 handle bot player
            bool acceptTrade;
            if (isVisible) AddMessage(MakeMessage(speaker, string.Format("{0} {1} for {2}.", Conjugate(speaker, VERB_OFFER), offered.AName, asked.AName)));
            if (target.IsPlayer && !target.IsBotPlayer)  // speaker always ai unless bot
            {
                // ask player.
                AddOverlay(new OverlayPopup(TRADE_MODE_TEXT, MODE_TEXTCOLOR, MODE_BORDERCOLOR, MODE_FILLCOLOR, Point.Empty));
                RedrawPlayScreen();
                acceptTrade = WaitYesOrNo();
                ClearOverlays();
                RedrawPlayScreen();
            }
            else
            {
                // ask target ai/bot
                BaseAI ai;
#if DEBUG
                ai = target.IsPlayer && target.IsBotPlayer ? m_botControl : targetAI;
#else
                ai = targetAI;
#endif

                TradeRating r = ai.RateTradeOffer(this, speaker, offered, asked);
                if (r == TradeRating.ACCEPT)
                    acceptTrade = true;
                else if (r == TradeRating.REFUSE)
                    acceptTrade = false;
                else
                {
                    // use charisma on "maybe" trades, similar to what we do for the player in the negociating command we the ai won't
                    // exploit the game by asking several times so its ok not to store the charisma roll -_-
                    // note that a duo of charismatic npcs could in theory trade back and forth ha!
                    if (m_Rules.RollChance(m_Rules.ActorCharismaticTradeChance(speaker)))
                    {
                        if (isVisible) DoEmote(target, "Okay you convinced me.");
                        acceptTrade = true;
                    }
                    else
                        acceptTrade = false;
                }
            }

            // so, deal or not?
            if (acceptTrade)
            {
                if (isVisible) AddMessage(MakeMessage(target, string.Format("{0}.", Conjugate(target, VERB_ACCEPT_THE_DEAL))));
                if (target.IsPlayer || speaker.IsPlayer)
                    RedrawPlayScreen();

                // do it
                SwapActorItems(speaker, offered, target, asked);
            }
            else
            {
                if (isVisible) AddMessage(MakeMessage(target, string.Format("{0}.", Conjugate(target, VERB_REFUSE_THE_DEAL))));
                if (target.IsPlayer || speaker.IsPlayer)
                    RedrawPlayScreen();
            }
        }

        /// <summary>
        /// Swap items after a succesful trade. Used in "fast" trades and player negociating trade.
        /// </summary>
        void SwapActorItems(Actor actorA, Item itA, Actor actorB, Item itB) //alpha 10
        {
            if (itA.IsEquipped)
                DoUnequipItem(actorA, itA);
            if (itB.IsEquipped)
                DoUnequipItem(actorB, itB);

            actorA.Inventory.RemoveAllQuantity(itA);
            actorB.Inventory.RemoveAllQuantity(itB);

            actorA.Inventory.AddAll(itB);
            actorB.Inventory.AddAll(itA);
        }

        [Flags]
        public enum Sayflags
        {
            NONE = 0,
            /// <summary>
            /// If told to the player and visible will highlight pause the game.
            /// </summary>
            IS_IMPORTANT = (1 << 0),

            /// <summary>
            /// Does not cost action points (emote).
            /// </summary>
            IS_FREE_ACTION = (1 << 1),

            /// <summary>
            /// A warning or menace, should be highlighted.
            /// </summary>
            IS_DANGER = (1 << 2) // alpha10
        }

        public void DoSay(Actor speaker, Actor target, string text, Sayflags flags)
        {
            Color sayColor = ((flags & Sayflags.IS_DANGER) != 0) ? SAYOREMOTE_DANGER_COLOR : SAYOREMOTE_NORMAL_COLOR; //alpha 10

            // spend APS?
            if ((flags & Sayflags.IS_FREE_ACTION) == 0)
                SpendActorActionPoints(speaker, Rules.BASE_ACTION_COST);

            // message.
            if (IsVisibleToPlayer(speaker) || (IsVisibleToPlayer(target) && !(m_Player.IsSleeping && target == m_Player)))
            {
                bool isPlayer = target.IsPlayer;
                bool isBot = target.IsBotPlayer; // alpha10.1 handle bot
                bool isImportant = (flags & Sayflags.IS_IMPORTANT) != 0;
                if (isPlayer && isImportant && !isBot)
                    ClearMessages();
                AddMessage(MakeMessage(speaker, String.Format("to {0} : ", target.TheName), sayColor));
                AddMessage(MakeMessage(speaker, String.Format("\"{0}\"", text), sayColor));
                if (isPlayer && isImportant && !isBot)
                {
                    AddOverlay(new OverlayRect(Color.Yellow, new Rectangle(MapToScreen(speaker.Location.Position), new Size(TILE_SIZE, TILE_SIZE))));
                    AddMessagePressEnter();
                    ClearOverlays();
                    RemoveLastMessage();
                    RedrawPlayScreen();
                }
            }

            //audio
            PlayNonHumanVocalAudio(speaker, text); //@@MP (Release 7-3)
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="speaker"></param>
        /// <param name="text">can be null</param>
        public void DoShout(Actor speaker, string text)
        {
            //@@MP (Release 7-4)
            if (!speaker.Model.Abilities.IsUndead && !speaker.Model.Abilities.IsLivingAnimal) //just in case
            {
                if (speaker.IsPlayer)
                    m_SFXManager.PlayIfNotAlreadyPlaying(speaker.Doll.Body.IsMale ? GameSounds.MALE_SHOUT_PLAYER : GameSounds.FEMALE_SHOUT_PLAYER, AudioPriority.PRIORITY_NULL);
                else if (IsAudibleToPlayer(speaker.Location, Rules.QUIET_NOISE_RADIUS))
                    m_SFXManager.PlayIfNotAlreadyPlaying(speaker.Doll.Body.IsMale ? GameSounds.MALE_SHOUT_NEARBY : GameSounds.FEMALE_SHOUT_NEARBY, AudioPriority.PRIORITY_NULL);
            }

            // spend APs.
            SpendActorActionPoints(speaker, Rules.BASE_ACTION_COST);

            // loud noise.
            OnLoudNoise(speaker.Location.Map, speaker.Location.Position, "A SHOUT");

            // message.
            if (IsVisibleToPlayer(speaker) || AreLinkedByPhone(speaker, m_Player))
            {
                // if player follower, alert!
                if (speaker.Leader == m_Player && !m_Player.IsBotPlayer)  // alpha10.1 handle bot
                {
                    ClearMessages();
                    AddOverlay(new OverlayRect(Color.Yellow, new Rectangle(MapToScreen(speaker.Location.Position), new Size(TILE_SIZE, TILE_SIZE))));
                    AddMessage(MakeMessage(speaker, String.Format("{0}!!", Conjugate(speaker, VERB_RAISE_ALARM))));
                    if (text != null)
                        DoEmote(speaker, text, true); //alpha 10 true
                    AddMessagePressEnter();
                    ClearOverlays();
                    RemoveLastMessage();
                }
                else
                {
                    if (text == null)
                        AddMessage(MakeMessage(speaker, String.Format("{0}!", Conjugate(speaker, VERB_SHOUT))));
                    else
                        DoEmote(speaker, String.Format("{0} \"{1}\"", Conjugate(speaker, VERB_SHOUT), text), true); //alpha 10 true
                }
            }
        }

        public void DoEmote(Actor actor, string text, bool isDanger = false) //alpha 10 isDanger
        {
            if (IsVisibleToPlayer(actor))
            {
                AddMessage(new Message(String.Format("{0} : {1}", actor.Name, text), actor.Location.Map.LocalTime.TurnCounter, isDanger ? SAYOREMOTE_DANGER_COLOR : SAYOREMOTE_NORMAL_COLOR));
            }
            PlayNonHumanVocalAudio(actor, text); //@@MP (Release 7-3)
        }

        /// <summary>
        /// Plays a scream sound effect
        /// </summary>
        /// <param name="location"></param>
        /// <param name="rollForIt">true if we want to diceroll to decide if it plays</param>
        public void DoScream(Location location, bool isMale, bool actorDied, bool rollForIt) //@@MP (Release 5-7), made more generic and flagged for gender and death-specific sound (7-6)
        {
            if (rollForIt && !m_Rules.RollChance(PLAYER_HEAR_SCREAMS_CHANCE))
                return;

            if (IsAudibleToPlayer(location, Rules.QUIET_NOISE_RADIUS)) //@@MP (Release 2), changed it to Audible now that it can be supplied a range (Release 5-4)
            {
                if (isMale)
                {
                    if (actorDied)
                    {
                        m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.SCREAM_NEARBY_09, AudioPriority.PRIORITY_NULL);
                        AddMessageIfAudibleForPlayer(location, MakePlayerCentricMessage("You hear screams of agony", location.Position));
                    }
                    else
                    {
                        int screamSelected = m_Rules.Roll(0, 3); // there are multiple screams, this will randomise which one is heard
                        switch (screamSelected)
                        {
                            case 0: m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.SCREAM_NEARBY_01, AudioPriority.PRIORITY_NULL); break;
                            case 1: m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.SCREAM_NEARBY_02, AudioPriority.PRIORITY_NULL); break;
                            case 2: m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.SCREAM_NEARBY_07, AudioPriority.PRIORITY_NULL); break;
                            default:
                                throw new ArgumentOutOfRangeException("unhandled nearby scream " + screamSelected);
                        }
                        AddMessageIfAudibleForPlayer(location, MakePlayerCentricMessage("You hear screams of terror", location.Position)); //@@MP - originally was either audio or message (Release 5-4)
                    }
                }
                else //female
                {
                    if (actorDied)
                    {
                        m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.SCREAM_NEARBY_04, AudioPriority.PRIORITY_NULL);
                        AddMessageIfAudibleForPlayer(location, MakePlayerCentricMessage("You hear screams of agony", location.Position));
                    }
                    else
                    {
                        int screamSelected = m_Rules.Roll(0, 3); // there are multiple screams, this will randomise which one is heard
                        switch (screamSelected)
                        {
                            case 0: m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.SCREAM_NEARBY_03, AudioPriority.PRIORITY_NULL); break;
                            case 1: m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.SCREAM_NEARBY_05, AudioPriority.PRIORITY_NULL); break;
                            case 2: m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.SCREAM_NEARBY_08, AudioPriority.PRIORITY_NULL); break;
                            default:
                                throw new ArgumentOutOfRangeException("unhandled nearby scream " + screamSelected);
                        }
                        AddMessageIfAudibleForPlayer(location, MakePlayerCentricMessage("You hear screams of terror", location.Position)); //@@MP - originally was either audio or message (Release 5-4)
                    }
                }
            }
            else if (IsAudibleToPlayer(location, Rules.MODERATE_NOISE_RADIUS)) //@@MP - people scream a lot, so I can see why it only had a 10% chance (n/a). Changed it to Audible now that it can be supplied a range (Release 5-4)
            {
                if (isMale)
                {
                    if (actorDied)
                    {
                        m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.SCREAM_FAR_09, AudioPriority.PRIORITY_NULL);
                        AddMessageIfAudibleForPlayer(location, MakePlayerCentricMessage("You hear screams of agony", location.Position));
                    }
                    else
                    {
                        int screamSelected = m_Rules.Roll(0, 3); // embedded the roll in each If statement as a micro-optimisation
                        switch (screamSelected)
                        {
                            case 0: m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.SCREAM_FAR_01, AudioPriority.PRIORITY_NULL); break;
                            case 1: m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.SCREAM_FAR_02, AudioPriority.PRIORITY_NULL); break;
                            case 2: m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.SCREAM_FAR_07, AudioPriority.PRIORITY_NULL); break;
                            default:
                                throw new ArgumentOutOfRangeException("unhandled nearby scream " + screamSelected);
                        }
                        AddMessageIfAudibleForPlayer(location, MakePlayerCentricMessage("You hear screams of terror", location.Position)); //@@MP - originally was either audio or message (Release 5-4)
                    }
                }
                else //female
                {
                    if (actorDied)
                    {
                        m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.SCREAM_FAR_04, AudioPriority.PRIORITY_NULL);
                        AddMessageIfAudibleForPlayer(location, MakePlayerCentricMessage("You hear screams of agony", location.Position));
                    }
                    else
                    {
                        int screamSelected = m_Rules.Roll(0, 3); // embedded the roll in each If statement as a micro-optimisation
                        switch (screamSelected)
                        {
                            case 0: m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.SCREAM_FAR_03, AudioPriority.PRIORITY_NULL); break;
                            case 1: m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.SCREAM_FAR_05, AudioPriority.PRIORITY_NULL); break;
                            case 2: m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.SCREAM_FAR_08, AudioPriority.PRIORITY_NULL); break;
                            default:
                                throw new ArgumentOutOfRangeException("unhandled nearby scream " + screamSelected);
                        }
                        AddMessageIfAudibleForPlayer(location, MakePlayerCentricMessage("You hear screams of terror", location.Position)); //@@MP - originally was either audio or message (Release 5-4)
                    }
                }
            }
        }

        /// <summary>
        /// Will only play if within appropriate range
        /// </summary>
        /// <param name="actor"></param>
        /// <param name="fightEmotes">used for some some actor types</param>
        public void PlayNonHumanVocalAudio(Actor actor, string fightEmotes = "") //@@MP (Release 7-3)
        {
            if (IsAudibleToPlayer((actor.Location), Rules.QUIET_NOISE_RADIUS)) //close nearby sounds
            {
                if (GameActors.IsDog(actor.Model))
                {
                    if (fightEmotes == FeralDogAI.FIGHT_EMOTES[0]) //flee
                        m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.DOG_FLEE, AudioPriority.PRIORITY_BGM);
                    else if (fightEmotes == FeralDogAI.FIGHT_EMOTES[1]) //trapped
                        m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.DOG_GROWL, AudioPriority.PRIORITY_BGM);
                    else //fight
                        m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.DOG_BARK_NEARBY, AudioPriority.PRIORITY_BGM);
                }
                else if (GameActors.IsSkeletonBranch(actor.Model))
                {
                    m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.SKELETON_GROWL, AudioPriority.PRIORITY_BGM);
                }
                else if (GameActors.IsShamblerBranch(actor.Model))
                {
                    m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.SHAMBLER_GROWL, AudioPriority.PRIORITY_BGM);
                }
                else if (GameActors.IsZMBranch(actor.Model))
                {
                    m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.ZOMBIE_MASTER_GROWL, AudioPriority.PRIORITY_BGM);
                }
                else if (GameActors.IsZombifiedBranch(actor.Model))
                {
                    //special case, as its much longer than the others and sounds silly when played too close together
                    if (m_Rules.RollChance(40))
                        m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.ZOMBIFIED_GROAN, AudioPriority.PRIORITY_BGM);
                }
                else if (GameActors.IsRatBranch(actor.Model))
                {
                    m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.RAT_SCREECH, AudioPriority.PRIORITY_BGM);
                }
                else if (actor.Model == GameActors.SewersThing)
                {
                    m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.SEWERS_THING_GROWL, AudioPriority.PRIORITY_BGM);
                }
            }
            else if (IsAudibleToPlayer((actor.Location), Rules.LOUD_NOISE_RADIUS))  //louder sounds
            {
                if (GameActors.IsDog(actor.Model))
                {
                    if (fightEmotes == FeralDogAI.FIGHT_EMOTES[2]) //fight
                        m_SFXManager.Play(GameSounds.DOG_BARK_FAR, AudioPriority.PRIORITY_BGM);
                }
            }
        }
#endregion

#region -ITEMS, EQUIPING AND USING
        public void DoTakeFromContainer(Actor actor, Point position)
        {
            Map map = actor.Location.Map;

            // get topmost item.
            Item it = map.GetItemsAt(position).TopItem;

            // take it.
            DoTakeItem(actor, position, it);
        }

        public void DoTakeItem(Actor actor, Point position, Item it)
        {
            Map map = actor.Location.Map;

            // spend APs.
            SpendActorActionPoints(actor, Rules.BASE_ACTION_COST);

            // special cases.
            ItemTrap trap = it as ItemTrap; //@@MP (Release 5-7)
            if (trap != null)
            {
                // taking a trap deactivates it.
                trap.Deactivate(); // alpha10 // trap.IsActivated = false;
            }
            else if (actor.IsPlayer)
            {
                if (it as ItemLight != null) //@@MP (Release 6-3)
                {
                    if (actor.IsPlayer && it.Model.IsThrowable) //@@MP - always enforce that burning flares or used glowsticks stay equipped (Release 7-1)
                        DoEquipItem(actor, it);
                }
                //when cooking raw meat, we marked the item as forbidden to stop NPCs from stealing it. that flag should now be reset      //@@MP - added (Release 7-6)
                else if (it is ItemFood && it.IsForbiddenToAI)
                    it.IsForbiddenToAI = false; //this allows it to be traded if the player so chooses
            }

            // add to inventory.
            int quantityAdded;
            int quantityBefore = it.Quantity;
            actor.Inventory.AddAsMuchAsPossible(it, out quantityAdded);

            // if added all, remove from map.
            if (quantityAdded == quantityBefore)
            {
                Inventory itemsThere = map.GetItemsAt(position);
                if (itemsThere != null)
                {
                    if (itemsThere.Contains(it))
                    {
                        map.RemoveItemAt(it, position);

                        //@@MP - if it was a 'locked safe' see if it's now empty (Release 6-5)
                        if (actor.IsPlayer) //AI don't get locked safes
                        {
                            MapObject mapObj = map.GetMapObjectAt(position);
                            if (mapObj != null && mapObj.ImageID == GameImages.OBJ_BANK_SAFE_OPEN_OWNED) //yup, its an owned safe
                            {
                                itemsThere = map.GetItemsAt(position);
                                if (itemsThere == null) //the player took the last item there, so it's no longer a 'locked' safe owned by them
                                {
                                    map.RemoveMapObjectAt(position.X, position.Y); //remove the existing object that signals it as belonging to the player
                                    map.PlaceMapObjectAt(m_TownGenerator.MakeObjOpenBankSafe(GameImages.OBJ_BANK_SAFE_OPEN), position); //replace it with an ordinary open one
                                }
                            }
                        }
                    }
                    else //@@MP - now caters for taking items from backpacks too (Release 8-2)
                    {
                        ItemBackpack backPack = itemsThere.GetFirstByType(typeof(ItemBackpack)) as ItemBackpack;
                        if (backPack != null && backPack.Inventory != null && backPack.Inventory.Contains(it))
                            backPack.Inventory.RemoveAllQuantity(it);
                    }
                }
            }

            // clear turn tracking
            it.DroppedOnTurnNumber = null;

            // message
            if (IsVisibleToPlayer(actor) || IsVisibleToPlayer(new Location(map, position)))
            AddMessage(MakeMessage(actor, Conjugate(actor, VERB_TAKE), it));

            // automatically equip item if flags set & possible, and not already equipped something.
            if (!it.Model.DontAutoEquip && m_Rules.CanActorEquipItem(actor, it) && actor.GetEquippedItem(it.Model.EquipmentPart) == null)
                DoEquipItem(actor, it);
        }

        public void DoGiveItemTo(Actor actor, Actor target, Item gift)
        {
            if (actor.IsPlayer || target.IsPlayer) //@@MP (Release 7-4)
                m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.PSST_WHISPER, AudioPriority.PRIORITY_BGM);

            // spend APs.
            SpendActorActionPoints(actor, Rules.BASE_ACTION_COST);

            // if leader give to follower, improve trust.
            if (target.Leader == actor)
            {
                // interesting item?
                BaseAI ai = target.Controller as BaseAI;
                bool isInterestingItem = (ai != null && ai.IsInterestingItemToOwn(this, gift, BaseAI.ItemSource.ANOTHER_ACTOR)); //alpha 10, was IsInterestingItem()

                // emote.
                if (isInterestingItem)
                    DoSay(target, actor, "Thank you, I really needed that!", Sayflags.IS_FREE_ACTION);
                else
                    DoSay(target, actor, "Thanks I guess...", Sayflags.IS_FREE_ACTION);

                // update trust.
                ModifyActorTrustInLeader(target, isInterestingItem ? Rules.TRUST_GOOD_GIFT_INCREASE : Rules.TRUST_MISC_GIFT_INCREASE, true);
            }
            // if follower give to leader, decrease trust.
            else if (actor.Leader == target)
            {
                // emote.
                DoSay(target, actor, "Well, here it is...", Sayflags.IS_FREE_ACTION);

                // update trust.
                ModifyActorTrustInLeader(actor, Rules.TRUST_GIVE_ITEM_ORDER_PENALTY, true);
            }

            // transfer item : drop then take (solves problem of partial quantities transfer). [quote from RS vanilla]
            //@@MP - workaround for a logic bug relating to dropping stackable items if the ground there already has some of that same item (Release 7-5)
            Point dropPos = DropItemForTransferBetweenActors(actor, gift);
            DoTakeItem(target, dropPos, gift);

            // message.
            if (IsVisibleToPlayer(actor) || IsVisibleToPlayer(target))
                AddMessage(MakeMessage(actor, String.Format("{0} {1} to", Conjugate(actor, VERB_GIVE), gift.TheName), target));
        }

        /// <summary>
        /// AP free
        /// </summary>
        /// <param name="actor"></param>
        /// <param name="it"></param>
        public void DoEquipItem(Actor actor, Item it, bool showMessage = false) //@@MP - showMessage based on alpha 10 (Release 6-1)
        {
            // unequip previous item first.
            Item previousItem = actor.GetEquippedItem(it.Model.EquipmentPart);
            if(previousItem != null)
                DoUnequipItem(actor, previousItem);

            // equip part.
            it.EquippedPart = it.Model.EquipmentPart;

            // update revelant datas.
            OnEquipItem(actor, it);

            // message
            if (showMessage && IsVisibleToPlayer(actor))
                AddMessage(MakeMessage(actor, Conjugate(actor, VERB_EQUIP), it));
        }

        /// <summary>
        /// AP free
        /// </summary>
        /// <param name="actor"></param>
        /// <param name="it"></param>
        public void DoUnequipItem(Actor actor, Item it, bool showMessage = false) //@@MP - showMessage based on alpha 10 (Release 6-1)
        {
            // unequip part.
            it.EquippedPart = DollPart.NONE;

            // throwable lights (flares, glowsticks) can't be turned off  //@@MP (Release 7-1)
            if (actor.IsPlayer && it.Model is ItemLightModel && it.Model.IsThrowable)
                DoDropItem(actor, it);

            // update revelant datas.
            OnUnequipItem(actor, it);

            // message.
            if (showMessage && IsVisibleToPlayer(actor))
                AddMessage(MakeMessage(actor, Conjugate(actor, VERB_UNEQUIP), it));
        }

        void OnEquipItem(Actor actor, Item it)
        {
#region Weapons
            if (it.Model is ItemWeaponModel)
            {
                bool isOneHanded = false;
                if (it.Model is ItemMeleeWeaponModel)
                {
                    ItemMeleeWeaponModel meleeModel = it.Model as ItemMeleeWeaponModel;
                    actor.CurrentMeleeAttack = Attack.MeleeAttack(meleeModel.Attack.Verb,
                        (meleeModel.Attack.HitValue + actor.Sheet.UnarmedAttack.HitValue),
                        (meleeModel.Attack.DamageValue + actor.Sheet.UnarmedAttack.DamageValue),
                        meleeModel.Attack.StaminaPenalty,
                        meleeModel.Attack.DisarmChance);
                    isOneHanded = meleeModel.IsOneHanded;
                }
                else if (it.Model is ItemRangedWeaponModel)
                {
                    ItemRangedWeaponModel rangedModel = it.Model as ItemRangedWeaponModel;
                    actor.CurrentRangedAttack = Attack.RangedAttack(rangedModel.Attack.Kind,
                        rangedModel.Attack.Verb,
                        rangedModel.Attack.HitValue, rangedModel.Attack.Hit2Value, rangedModel.Attack.Hit3Value,
                        rangedModel.Attack.DamageValue,
                        rangedModel.Attack.Range);
                    isOneHanded = rangedModel.IsOneHanded;

                    if (actor.IsPlayer)
                    {
                        if (rangedModel.IsSingleShot && m_Session.Player_CurrentFireMode == FireMode.RAPID) //@@MP - enforce single-shot weapon models (Release 6-6)
                        {
                            AddMessage(new Message(String.Format("{0} cannot rapid fire. Switched to single-shot", rangedModel.SingleName), m_Session.WorldTime.TurnCounter, Color.Red));
                            m_Session.Player_CurrentFireMode = FireMode.DEFAULT;
                        }

                        if (rangedModel.AmmoType == AmmoType.PLASMA) //@@MP - a special new gun was added (Release 7-6)
                            m_SFXManager.Play(GameSounds.EQUIP_BFG_PLAYER, AudioPriority.PRIORITY_EVENT);
                        else if (rangedModel.Attack.Kind == AttackKind.FIREARM) //@@MP (Release 2), now generically applies to all firearms (Release 6-6)
                            m_SFXManager.Play(GameSounds.EQUIP_GUN_PLAYER, AudioPriority.PRIORITY_EVENT);
                    }
                }

                if (!isOneHanded) //@@MP - can't use two-handed weapons with shields (Release 7-2)
                {
                    Item shield = actor.GetEquippedShield();
                    if (shield != null) //they have a shield equipped
                        DoUnequipItem(actor, shield);
                }
            }
#endregion
#region Armors
            else if (it.Model is ItemBodyArmorModel)
            {
                ItemBodyArmorModel armorModel = it.Model as ItemBodyArmorModel;
                actor.CurrentDefence += armorModel.ToDefence();
                if (actor.IsPlayer) //@@MP (Release 2)
                    m_SFXManager.Play(GameSounds.ARMOR_ZIPPER, AudioPriority.PRIORITY_EVENT);
            }
            else if (it.Model.EquipmentPart == DollPart.LEFT_ARM) //@@MP - it's a shield (Release 7-2)
            {
                // 4c. shield can't be used with a two-handed weapon  //@@MP (Release 7-2)
                ItemMeleeWeapon melee = actor.GetEquippedMeleeWeapon();
                if (melee != null && !melee.IsOneHanded)
                    DoUnequipItem(actor, melee);
                else
                {
                    ItemRangedWeapon ranged = actor.GetEquippedRangedWeapon();
                    if (ranged != null && !ranged.IsOneHanded)
                        DoUnequipItem(actor, ranged);
                }

                if (actor.IsPlayer) //@@MP (Release 2)
                    m_SFXManager.Play(GameSounds.EQUIP, AudioPriority.PRIORITY_EVENT);
            }
#endregion
#region Batteries
            else if (it.Model is ItemLightModel)
            {
                if (actor.IsPlayer) //@@MP (Release 2)
                {
                    //@@MP - NPCs get infinite batteries (Release 7-5)
                    ItemLight ltIt = it as ItemLight;
                    --ltIt.Batteries;

                    if (m_Rules.IsItemNightVision(it)) //@@MP (Release 6-3)
                        m_SFXManager.Play(GameSounds.NIGHT_VISION, AudioPriority.PRIORITY_BGM);
                    else if (m_Rules.IsItemBinoculars(it)) //@@MP (Release 7-1)
                        m_SFXManager.Play(GameSounds.EQUIP, AudioPriority.PRIORITY_BGM);
                    else //@@MP (Release 2)
                        m_SFXManager.Play(GameSounds.TORCH_CLICK_PLAYER, AudioPriority.PRIORITY_BGM);

                    UpdatePlayerFOV(m_Player); //@@MP - update FOV now, don't wait until the next turn (Release 6-2)
                }
                    
            }
            else if (it.Model is ItemTrackerModel)
            {
                if (actor.IsPlayer) //@@MP - NPCs get infinite batteries (Release 7-5)
                {
                    ItemTracker trIt = it as ItemTracker;
                    --trIt.Batteries;
                }
            }
            #endregion
            #region misc & other
            else if (it.Model is ItemBackpackModel)  //@@MP (Release 8-2)
            {
                if (actor.IsPlayer)
                    m_SFXManager.Play(GameSounds.ARMOR_ZIPPER, AudioPriority.PRIORITY_EVENT);
            }
            else if (it.Model == GameItems.FISHING_ROD)  //@@MP (Release 7-6)
            {
                DoUseFishingRodItem(actor);
            }
            #endregion
        }

        void OnUnequipItem(Actor actor, Item it)
        {
            if (it.Model is ItemWeaponModel)
            {
                if (it.Model is ItemMeleeWeaponModel)
                {
                    actor.CurrentMeleeAttack = actor.Sheet.UnarmedAttack;
                }
                else if (it.Model is ItemRangedWeaponModel)
                {
                    actor.CurrentRangedAttack = Attack.BLANK;
                }
            }
            else if (it.Model is ItemBodyArmorModel)
            {
                ItemBodyArmorModel armorModel = it.Model as ItemBodyArmorModel;
                actor.CurrentDefence -= armorModel.ToDefence();
                if (actor.IsPlayer) //@@MP (Release 2)
                    m_SFXManager.Play(GameSounds.ARMOR_ZIPPER, AudioPriority.PRIORITY_EVENT);
            }
            else if (actor.IsPlayer) //stuff that only applies when the player is unequipping something
            {
                if (it.Model is ItemLightModel) //@@MP (Release 2)
                {
                    if (m_Rules.IsItemBatteryPowered(it)) //@@MP - throwable lights (flares, glowsticks) don't need the SFX (Release 7-1)
                        m_SFXManager.Play(GameSounds.TORCH_CLICK_PLAYER, AudioPriority.PRIORITY_BGM);
                    UpdatePlayerFOV(m_Player); //@@MP - update FOV now, don't wait until the next turn (Release 6-2)
                    RedrawPlayScreen(); //@@MP - this reflects any change to FOV immediately on the player's screen (Release 7-6)
                }
                else if (it is ItemBackpack) //@@MP (Release 8-2)
                    m_SFXManager.Play(GameSounds.OPEN_BACKPACK, AudioPriority.PRIORITY_EVENT);
            }
        }

        public void DoDropItem(Actor actor, Item it)
        {
            bool spendAP = true; //@@MP (Release 7-5)

            // which item to drop (original or a clone)
            Item dropIt = it;
            // discard?
            bool discardMe = false;

            // special case for traps and discarded items.
            ItemTrap trap = it as ItemTrap; //@@MP (Release 5-7)
            if (trap != null)
            {
                if (actor.IsPlayer) //@@MP (Release 6-6)
                    m_SFXManager.Play(GameSounds.PLACE_TRAP, AudioPriority.PRIORITY_EVENT);

                // drop one at a time.
                ItemTrap clone = trap.Clone();
                //alpha10 clone.IsActivated = trap.IsActivated;
                if (trap.IsActivated) // alpha10
                    clone.Activate(actor);
                dropIt = clone;

                // trap activates when dropped?
                if (clone.TrapModel.ActivatesWhenDropped)
                    clone.Activate(actor);

                // make sure source stack is deactivated (activate only activate the stack top item).
                trap.Deactivate();
            }
            else if (it as ItemLight != null) //@@MP (Release 7-5)
            {
                if (actor.IsPlayer && it.Model.IsThrowable)
                    spendAP = false;  ///avoid the double-turn hit
            }
            // special cases for player-only specifics
            else if (actor.IsPlayer)
            {
                // fuel cans     //@@MP (Release 7-1)
                if (!actor.IsBotPlayer && it is ItemAmmo)
                {
                    ItemAmmo ammo = it as ItemAmmo;
                    if (ammo != null && ammo.Model == GameItems.AMMO_FUEL)
                    {
                        AddOverlay(new OverlayPopup(DROP_FUEL_TEXT, MODE_TEXTCOLOR, MODE_BORDERCOLOR, MODE_FILLCOLOR, Point.Empty));
                        RedrawPlayScreen();

                        KeyEventArgs inKey = m_UI.UI_WaitKey(); //  Read input
                        if (inKey.KeyCode == Keys.Escape) // Handle input
                        {
                            ClearOverlays();
                            RedrawPlayScreen();
                            return;
                        }
                        // get choice.
                        else if (inKey.KeyCode == Keys.O) //drop only one, probably because they want to use it as an explosive trap
                        {
                            actor.Inventory.Consume(it);

                            ItemAmmo cloneAmmo = new ItemAmmo(GameItems.AMMO_FUEL);
                            cloneAmmo.Quantity = 1;
                            DropItem(actor, cloneAmmo, true);
                            ClearOverlays();
                            RedrawPlayScreen();
                            return;
                        }
                        else if (inKey.KeyCode == Keys.A) //drop all
                            RedrawPlayScreen(); //nothing extra required, continue with normal drop
                        else
                        {
                            AddMessage(MakeErrorMessage("Unhandled key error when dropping fuel cans."));
                            AddMessage(MakeErrorMessage("Did you perhaps hit the wrong key?"));
                            ClearOverlays();
                            RedrawPlayScreen();
                            return;
                        }
                    }
                }
            }
            // special case for candles  //@@MP (Release 7-1)
            else if (it.Model == GameItems.CANDLES_BOX)
            {
                if (actor.IsPlayer)
                {
                    AddOverlay(new OverlayPopup(DROP_CANDLES_TEXT, MODE_TEXTCOLOR, MODE_BORDERCOLOR, MODE_FILLCOLOR, Point.Empty));
                    RedrawPlayScreen();

                    KeyEventArgs inKey = m_UI.UI_WaitKey(); //  Read input
                    if (inKey.KeyCode == Keys.Escape) // Handle input
                    {
                        ClearOverlays();
                        RedrawPlayScreen();
                        return;
                    }
                    // get choice.
                    else if (inKey.KeyCode == Keys.O) //drop only one
                    {
                        Point pt = new Point(actor.Location.Position.X, actor.Location.Position.Y);
                        Map map = actor.Location.Map;

                        //first check there isnt already candles there
                        if (map.GetTileAt(pt).HasDecoration(GameImages.DECO_LIT_CANDLE))
                        {
                            AddMessage(MakeErrorMessage("There's already a lit candle there."));
                            ClearOverlays();
                            RedrawPlayScreen();
                            return;
                        }
                        else if (!map.GetTileAt(pt).IsInside)
                        {
                            AddMessage(MakeErrorMessage("Candles are useless outside in the elements."));
                            ClearOverlays();
                            RedrawPlayScreen();
                            return;
                        }

                        //remove a candle from the box, and the whole box if it's now empty
                        actor.Inventory.Consume(it);

                        //place a lit candle on the ground, with a task to remove it when it runs out
                        map.AddTimer(new TaskRemoveDecoration(WorldTime.TURNS_PER_HOUR * 12, pt.X, pt.Y, GameImages.DECO_LIT_CANDLE));
                        if (!map.GetTileAt(pt).HasDecoration(GameImages.DECO_LIT_CANDLE))
                            map.GetTileAt(pt).AddDecoration(GameImages.DECO_LIT_CANDLE);

                        ClearOverlays();
                        RedrawPlayScreen();
                        return;
                    }
                    else if (inKey.KeyCode == Keys.A) //drop all
                        RedrawPlayScreen(); //nothing extra required, continue with normal drop
                    else
                    {
                        AddMessage(MakeErrorMessage("Unhandled key error when dropping candles."));
                        AddMessage(MakeErrorMessage("Did you perhaps hit the wrong key?"));
                        ClearOverlays();
                        RedrawPlayScreen();
                        return;
                    }
                }
            }
            else //discard
            {
                // drop or discard.
                /*if (it is ItemTracker)  //@@MP - don't, as they are still valuable and can be recharged (Release 6-5)
                {
                    discardMe = (it as ItemTracker).Batteries <= 0;
                }
                else if (it is ItemLight)
                {
                    discardMe = (it as ItemLight).Batteries <= 0;
                }*/
                if (it is ItemSprayPaint) //@@MP - was else if (Release 6-2)
                {
                    discardMe = (it as ItemSprayPaint).PaintQuantity <= 0;
                }
                else if (it is ItemSprayScent) //@@MP - reinstated (Release 6-5)
                {
                    discardMe = (it as ItemSprayScent).SprayQuantity <= 0;
                }
            }

            if (discardMe)
            {
                DiscardItem(actor, it);
                // message
                if (IsVisibleToPlayer(actor))
                    AddMessage(MakeMessage(actor, Conjugate(actor, VERB_DISCARD), it));
            }
            else
            {
                if (dropIt == it)
                    DropItem(actor, it, true);
                else
                    DropCloneItem(actor, it, dropIt);
                // message
                if (IsVisibleToPlayer(actor))
                    AddMessage(MakeMessage(actor, Conjugate(actor, VERB_DROP), dropIt));
            }

            // spend APs.
            if (spendAP)   //@@MP - tweaked to stop picking up flares/glowsticks from consuming two turns (Release 7-5)
                SpendActorActionPoints(actor, Rules.BASE_ACTION_COST);
        }

        static void DiscardItem(Actor actor, Item it) //@@MP - made static (Release 5-7)
        {
            // make sure it is unequipped.
            it.EquippedPart = DollPart.NONE;

            // remove from inventory.
            actor.Inventory.RemoveAllQuantity(it);
        }

        /// <summary>
        /// Place the item on the tile, or the nearest available tile if need be
        /// </summary>
        /// <param name="actor"></param>
        /// <param name="it"></param>
        /// <param name="dropNearbyIfNeeded">false forces the oldest item to be replaced if the inventory there is already full</param>
        public void DropItem(Actor actor, Item it, bool dropNearbyIfNeeded = false) //@@MP - made public for use by AI (Release 7-6)
        {
            // remove from inventory.
            actor.Inventory.RemoveAllQuantity(it);

            // add to ground.
            Map map = actor.Location.Map;
            Point position = actor.Location.Position;
            Point dropPos = position;

            //@@MP - if current spot is full, try adjacents (Release 6-2), made adjacent check optional (Release 7-5), corrected logic (Release 7-6)
            if (dropNearbyIfNeeded)
            {
                // try to drop it on the actor's spot first
                Inventory itemsThere = map.GetItemsAt(position);
                if (itemsThere != null && itemsThere.IsFull)
                {
                    Point testPos;
                    foreach (Direction d in Direction.COMPASS)
                    {
                        testPos = position + d;
                        MapObject obj = map.GetMapObjectAt(testPos);
                        if (map.IsWalkable(testPos) || (obj != null && (obj.IsJumpable || obj.IsContainer)))  //if its walkable or has a jumpable/container object its ok to put the item there
                        {
                            Inventory groundInv = map.GetItemsAt(testPos);
                            if (groundInv == null || !groundInv.IsFull)
                            {
                                dropPos = testPos; //this spot is the winner
                                break;
                            }
                        }
                    }
                }
            }

            // drop it
            actor.Location.Map.DropItemAt(it, dropPos);

            // make sure it is unequipped.
            it.EquippedPart = DollPart.NONE;


            if (actor.IsPlayer)
            {
                //special handling for bank safes
                MapObject obj = map.GetMapObjectAt(dropPos);
                if (obj != null)
                {
                    //@@MP - 'lock' it if it's the player and an open bank safe, they now "own" it (Release 6-5)
                    if (obj.ImageID == GameImages.OBJ_BANK_SAFE_OPEN)
                    {
                        //it doesn't already belong to the player, so "allocate" it now
                        //fyi: BaseAI.BehaviorGoGetInterestingItems() and BehaviorGoEatFoodOnGround() stops AI from taking items from this 'locked' safe
                        map.RemoveMapObjectAt(dropPos.X, dropPos.Y); //remove the existing safe
                        map.PlaceMapObjectAt(m_TownGenerator.MakeObjOwnedBankSafe(GameImages.OBJ_BANK_SAFE_OPEN_OWNED), dropPos); //replace it with one that flags it as belonging to the player
                        AddMessage(new Message(String.Format("You lock {0} away in the safe. No one else can get at it now", it.TheName), m_Session.WorldTime.TurnCounter, Color.Yellow));
                    }
                    else if (obj.ImageID == GameImages.OBJ_BANK_SAFE_OPEN_OWNED)
                        AddMessage(new Message(String.Format("You lock {0} away in the safe. No one else can get at it now", it.TheName), m_Session.WorldTime.TurnCounter, Color.Yellow));
                    /*else if (it is ItemBackpack) //@@MP - opted not to cleanup items from idle dropped backpacks (Release 8-2)
                        ApplyItemTurnTracker(it); //prevents the player from permanently storing in stashed backpacks, as that would be exploitable*/
                }
            }
            else if (actor.Leader != m_Player) //@@MP - items dropped by non-follower NPCs will be despawned if they sit idle for too long (Release 7-6)
                ApplyItemTurnTracker(it);
        }

        static Point DropItemForTransferBetweenActors(Actor actor, Item it)  //@@MP (Release 7-5)
        {
            // remove from inventory.
            actor.Inventory.RemoveAllQuantity(it);

            // add to ground.
            Map map = actor.Location.Map;
            Point position = actor.Location.Position;
            Point dropPos = position;
            bool searchElsewhere = false;

            // try to drop it on the actor's spot first
            if (map.HasItemsAt(position))
                searchElsewhere = true;

            // if current position's ground inventory has items keep searching for an empty one
            if (searchElsewhere)
            {
                // try <maxTries> times to find a walkable position.
                Point pos = new Point();
                int maxTries = 2500;
                for (int i = 0; i < maxTries; i++)
                {
                    DiceRoller roller = new DiceRoller();
                    int left = 0, top = 0; //0,0 coords are the top left square of the map
                    pos.X = roller.Roll(left, left + map.Width);
                    pos.Y = roller.Roll(top, top + map.Height);

                    if (!map.HasItemsAt(pos))
                    {
                        //we've found a suitable spot
                        dropPos = pos;
                        break;
                    }
                }
            }

            // drop it
            actor.Location.Map.DropItemAt(it, dropPos);

            // make sure it is unequipped.
            it.EquippedPart = DollPart.NONE;

            return dropPos;
        }

        static void DropCloneItem(Actor actor, Item it, Item clone) //@@MP - made static (Release 5-7)
        {
            // remove one quantity from inventory.
            if (--it.Quantity <= 0)
                actor.Inventory.RemoveAllQuantity(it);

            // add to ground.
            actor.Location.Map.DropItemAt(clone, actor.Location.Position);

            // make sure it is unequipped.
            clone.EquippedPart = DollPart.NONE;
        }

        /// <summary>
        /// Sets the turn number of when this item was dropped. This number is used to determine when an item should be cleaned up from the game when left idle for long enough
        /// </summary>
        void ApplyItemTurnTracker(Item it) //@@MP (Release 7-6)
        {
            //the types we'll always remove are weapons, lights, trackers, barricade materials, body armor, fuel cans, sprays
            //roughly ordered from most commonly dropped to least for best performance

            if (it is ItemMedicine && !it.Model.IsRecreational) //keep all medicine except booze. gangsters and bikers spawn with booze anyway
                return;

            if (it is ItemEntertainment && s_Options.IsSanityEnabled)
                return; //useful to the player

            if (it is ItemFood || it is ItemGrenade) //certain types that we simply don't want removed from the world
                return;

            if (it is ItemAmmo) //some ammo types can go, some must stay
            {
                //nails, crossbows and pistols are early-game weps, so by the time the item cleanup routine kicks in the player should have upgraded to better ones. thus, these are just clutter
                //TODO: cops and survivors are spawned with shotgun ammo, and they get spawned nightly, so should we delete those too?
                ItemAmmoModel ammo = it.Model as ItemAmmoModel;
                if (ammo.AmmoType != AmmoType.BOLT && ammo.AmmoType != AmmoType.LIGHT_PISTOL && ammo.AmmoType != AmmoType.NAIL && ammo.AmmoType != AmmoType.FUEL)
                    return;
            }

            if (it is ItemTrap && it.Model != m_GameItems.EMPTY_CAN)
                return;

            if (it.Model == m_GameItems.SLEEPING_BAG || it.Model == m_GameItems.FISHING_ROD) //rare items that aren't brought in with new refugee/survivor waves, so mustn't be deleted
                return;

            if (it.IsUnique || it.IsForbiddenToAI) //not that NPCs should have the latter anyway, but just in case
                return;

            //we've made it past all the exceptions, so this one gets marked for potential deletion
            it.DroppedOnTurnNumber = m_Session.WorldTime.TurnCounter;
        }

        public void DoUseItem(Actor actor, Item it)
        {
            // alpha10 defrag ai inventories
            bool defragInventory = false;//!actor.IsPlayer && it.Model.IsStackable; //@@MP - trade-off of performance vs AI realism (Release 6-1)

            // too dark to do certain actions? //@@MP (Release 6-2)
            bool absoluteDarkness = (m_Rules.ActorFOV(actor, actor.Location.Map.LocalTime, m_Session.World.Weather) == 0);

            // concrete use.
            if (it is ItemFood)
                DoUseFoodItem(actor, it as ItemFood);
            else if (it is ItemMedicine)
            {
                bool standingInLight = true;
                if (absoluteDarkness) //@@MP - it may be too dark to use meds (Release 6-2)
                {
                    standingInLight = false;
                    if (it.Model != GameItems.CIGARETTES && !m_Rules.IsItemAlcoholForDrinking(it))  //@@MP - these are the only exceptions (Release 7-5)
                        standingInLight = IsActorStandingInLight(actor); // check if next to any external light sources      //@@MP (Release 7-5)
                }

                if (standingInLight)
                    DoUseMedicineItem(actor, it as ItemMedicine);
                else if (actor.IsPlayer)
                    AddMessage(new Message("You can't do that, it's too dark here.", m_Session.WorldTime.TurnCounter, Color.Red));
            }
            else if (it is ItemAmmo)
                DoUseAmmoItem(actor, it as ItemAmmo);
            else if (it is ItemEntertainment)
            {
                bool standingInLight = true;
                if (absoluteDarkness) //@@MP - too dark to read? (Release 6-2), accounted for candles and such(Release 7-5)
                {
                    standingInLight = false;
                    standingInLight = IsActorStandingInLight(actor); // check if next to any external light sources      //@@MP (Release 7-5)
                }
                
                if (standingInLight)
                    DoUseEntertainmentItem(actor, it as ItemEntertainment);
                else if (actor.IsPlayer)
                    AddMessage(new Message("You can't do that, it's too dark here.", m_Session.WorldTime.TurnCounter, Color.Red));
            }
            else if (it is ItemTrap)
                DoUseTrapItem(actor, it as ItemTrap);
            else if (it.Model == GameItems.POLICE_RIOT_SHIELD) //@@MP (Release 7-2)
                DoUseShieldItem(actor, it);
            /*else if (it is ItemSprayScent) // alpha10 new way to use spray scent
                DoUseSprayScentItem(actor, it as ItemSprayScent);*/
            //@@MP - complex items
            else if (m_Rules.IsItemLiquorForMolotov(it))
                DoMakeMolotov(actor, it);
            else if (actor.IsPlayer && !actor.IsBotPlayer)
            {
                if (it.Model == GameItems.FLARES_KIT || it.Model == GameItems.GLOWSTICKS_BOX) //(Release 7-1)
                    HandlePlayerUseLightPackThrowable(actor, it);
                else if (it.Model.IsThrowable) //flares and glowsticks   //(Release 7-1)
                    HandlePlayerUseThrowableItem(actor, it); //TODO: allow AI to use throwables?
                else if (it.Model == GameItems.SIPHON_KIT) //(Release 7-1)
                    HandlePlayerSiphonFuel(); //TODO: allow AI to siphon fuel?
                else if (it.Model == GameItems.VEGETABLE_SEEDS) //TODD: make it possible for AI?   (Release 6-6)
                    HandlePlayerPlantSeeds(it); //TODO: allow AI to plant seeds?
                else if (it.Model == GameItems.CANDLES_BOX) //@@MP (Release 7-2)
                    DoDropItem(actor, it);
                else if (it.Model == GameItems.SLEEPING_BAG) //@@MP (Release 7-3)
                    HandlePlayerUseSleepingBag(actor, it); //TODO: allow AI to place sleeping bags?
            }

            // alpha10 defrag ai inventories
            if (defragInventory)
                actor.Inventory.Defrag();
        }

        public void DoEatFoodFromGround(Actor actor, Item it)
        {
            bool isVisible = IsVisibleToPlayer(actor);

            ItemFood food = it as ItemFood;

            // spend APs.
            SpendActorActionPoints(actor, Rules.BASE_ACTION_COST);

            // recover food points.
            int baseNutrition = m_Rules.FoodItemNutrition(food, actor.Location.Map.LocalTime.TurnCounter);
            actor.FoodPoints = Math.Min(actor.FoodPoints + m_Rules.ActorItemNutritionValue(actor, baseNutrition), m_Rules.ActorMaxFood(actor));

            // consume it.
            Inventory inv = actor.Location.Map.GetItemsAt(actor.Location.Position);
            inv.Consume(food);

            // message.
            if (isVisible)
                AddMessage(MakeMessage(actor, Conjugate(actor, VERB_EAT), food));

            // sound effects
            if (actor.IsPlayer) //@@MP (Release 2),(Release 3)
                m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.UNDEAD_EAT_PLAYER, AudioPriority.PRIORITY_EVENT); //@@MP reused the sound
            else if (IsAudibleToPlayer(actor.Location, Rules.QUIET_NOISE_RADIUS))//@@MP (Release 7-4)
                m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.UNDEAD_EAT_NEARBY, AudioPriority.PRIORITY_BGM); //@@MP reused the sound

            // vomit?
            if (m_Rules.IsFoodSpoiled(food, actor.Location.Map.LocalTime.TurnCounter))
            {
                if (m_Rules.RollChance(Rules.FOOD_EXPIRED_VOMIT_CHANCE))
                {
                    DoVomit(actor);
                    if (isVisible)
                    {
                        AddMessage(MakeMessage(actor, String.Format("{0} from eating spoiled food!", Conjugate(actor, VERB_VOMIT))));
                    }
                }
            }
        }

        void DoUseFoodItem(Actor actor, ItemFood food)
        {
            //@@MP - cannibalism = nasty stuff happens (Release 7-6)
            bool actorIsHuman = !actor.Model.Abilities.IsUndead && !actor.Model.Abilities.IsLivingAnimal;
            bool isCannibalism = food.Model == m_GameItems.RAW_HUMAN_FLESH || food.Model == m_GameItems.COOKED_HUMAN_FLESH;
            if (!actorIsHuman)
                isCannibalism = false;

            // run a few checks before we proceed
            if (actor == m_Player)
            {
                if (actor.FoodPoints >= m_Rules.ActorMaxFood(actor) - 1)
                {
                    AddMessage(MakeErrorMessage("Don't waste food!"));
                    return;
                }
                else if (isCannibalism) //@@MP - cannibalism is nasty, so check that we really want to do it (Release 7-6)
                {
                    bool performCannibalism = false;
                    AddMessage(MakeYesNoMessage(String.Format("{0} will have consequences. Eat it", food.TheName)));
                    RedrawPlayScreen();
                    performCannibalism = WaitYesOrNo();
                    ClearMessages();
                    RedrawPlayScreen();
                    if (!performCannibalism) return;
                }
                else if (food.CanCauseFoodPoisoning) //@@MP - raw meats may now cause food poisoning (Release 7-6)
                {
                    bool eatIt = false;
                    AddMessage(MakeYesNoMessage(String.Format("{0} may cause food poisoning. Eat it", food.TheName)));
                    RedrawPlayScreen();
                    eatIt = WaitYesOrNo();
                    ClearMessages();
                    RedrawPlayScreen();
                    if (!eatIt) return;
                }
            }

            // spend APs.
            SpendActorActionPoints(actor, Rules.BASE_ACTION_COST);

            // recover food points.
            int baseNutrition = m_Rules.FoodItemNutrition(food, actor.Location.Map.LocalTime.TurnCounter);
            actor.FoodPoints = Math.Min(actor.FoodPoints + m_Rules.ActorItemNutritionValue(actor, baseNutrition), m_Rules.ActorMaxFood(actor));

            // consume it.
            actor.Inventory.Consume(food);

            // canned food drops empty cans.
            if (food.Model == GameItems.CANNED_FOOD)
            {
                ItemTrap emptyCan = new ItemTrap(GameItems.EMPTY_CAN);// alpha10 { IsActivated = true };
                emptyCan.Activate(actor);  // alpha10
                actor.Location.Map.DropItemAt(emptyCan, actor.Location.Position);
            }

            // cannibalism has consequences          //@@MP (Release 7-6)
            if (isCannibalism)
                RepercussionsOfCannibalism(actor);
            // raw meats may cause food poisoning          //@@MP (Release 7-6)
            if (food.CanCauseFoodPoisoning)
                FoodPoisoning(actor, food, null);

            // message.
            bool isVisible = IsVisibleToPlayer(actor);
            if (actor.IsPlayer) //@@MP (Release 2)
                m_SFXManager.Play(GameSounds.EAT_FOOD, AudioPriority.PRIORITY_EVENT);
            else if (isVisible)
                AddMessage(MakeMessage(actor, Conjugate(actor, VERB_EAT), food));

            // vomit?
            if (m_Rules.IsFoodSpoiled(food, actor.Location.Map.LocalTime.TurnCounter))
            {
                if (m_Rules.RollChance(Rules.FOOD_EXPIRED_VOMIT_CHANCE))
                {
                    DoVomit(actor);

                    // message.
                    if (isVisible)
                    {
                        AddMessage(MakeMessage(actor, String.Format("{0} from eating spoiled food!", Conjugate(actor, VERB_VOMIT))));
                    }
                }
            }
        }

        /// <summary>
        /// Used by both NPCs and the player, with differing procedures
        /// </summary>
        /// <param name="actor"></param>
        /// <param name="food"></param>
        /// <param name="chosenFire">Only relevant if the player is the one cooking</param>
        public void DoCookFood(Actor actor, ItemFood food, Point chosenFire) //@@MP (Release 7-6)
        {
            // spend ap.
            SpendActorActionPoints(actor, Rules.BASE_ACTION_COST);

            bool meatFinishedCooking = false;
            if (!actor.IsPlayer || actor.IsBotPlayer) //meat cooks immediately for NPCs to keep their programming lite.
                meatFinishedCooking = true;
            else //for the player though, cooking takes 3 turns on the fire
            {
                ItemFood cookingPiece = new ItemFood(food.Model, food.BestBefore.TurnCounter, food.CanCauseFoodPoisoning, food.CanBeCooked); //make a new instance of it
                cookingPiece.Quantity = 1;
                actor.Location.Map.DropItemAt(cookingPiece, chosenFire);
                cookingPiece.IsForbiddenToAI = true; //stops NPCs from stealing it. this is a lazy workaround, but adding more AI around this isn't worth the cost
            }

            actor.Inventory.Consume(food); //remove one quantity of the raw food stack

            // food cooked.
            if (meatFinishedCooking)
            {
                // select the relevant food type
                ItemFood cookedFood;
                switch (food.AName)
                {
                    case "some raw fish":
                        cookedFood = new ItemFood(GameItems.COOKED_FISH, food.BestBefore.TurnCounter, false, false); break;
                    case "some raw rabbit":
                        cookedFood = new ItemFood(GameItems.COOKED_RABBIT, food.BestBefore.TurnCounter, false, false); break;
                    case "some raw chicken":
                        cookedFood = new ItemFood(GameItems.COOKED_CHICKEN, food.BestBefore.TurnCounter, false, false); break;
                    case "some raw dog meat":
                        cookedFood = new ItemFood(GameItems.COOKED_DOG_MEAT, food.BestBefore.TurnCounter, false, false); break;
                    case "some raw human flesh":
                        cookedFood = new ItemFood(GameItems.COOKED_HUMAN_FLESH, food.BestBefore.TurnCounter, false, false); break;
                    default:
                        throw new ArgumentException("unhandled raw food AName");
                }

                //try add to player inv, else put it on the ground here or nearby
                //this will suffice as we only ever cook one unit of quantity at a time
                if (!actor.Inventory.AddAll(cookedFood))
                    DropItem(actor, cookedFood, true);

                // in case it was the player's piece of meat (only going to trigger if it was .CookedDegree == 2 (ie. one less than max, which equates to "cooked")
                cookedFood.IsForbiddenToAI = false;

                // message.
                if (IsVisibleToPlayer(actor.Location))
                    AddMessage(MakeMessage(actor, String.Format("cooked {0}.", food.AName)));

                //feels good
                if (actor.Model.Abilities.HasSanity)
                    RegenActorSanity(actor, m_Rules.ActorSanRegenValue(actor, WorldTime.TURNS_PER_HOUR));
            }

            // SFX.
            if (actor.IsPlayer)
                m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.COOKING_SIZZLE_PLAYER, AudioPriority.PRIORITY_EVENT);
            else if (IsAudibleToPlayer(actor.Location, Rules.QUIET_NOISE_RADIUS))
                m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.COOKING_SIZZLE_NEARBY, AudioPriority.PRIORITY_BGM);
        }

        void DoVomit(Actor actor)
        {
            // beuargh.
            actor.StaminaPoints -= Rules.FOOD_VOMIT_STA_COST;
            actor.SleepPoints = Math.Max(0, actor.SleepPoints - (WorldTime.TURNS_PER_HOUR * 4)); //@@MP - made x4 (Release 7-6)
            actor.FoodPoints = Math.Max(0, actor.FoodPoints - (WorldTime.TURNS_PER_HOUR * 4)); //@@MP - made x4 (Release 7-6)

            // drop vomit
            Location loc = actor.Location;
            Map map = loc.Map;
            if (!map.GetTileAt(loc.Position.X, loc.Position.Y).HasDecoration(GameImages.DECO_VOMIT))
            {
                map.GetTileAt(loc.Position.X, loc.Position.Y).AddDecoration(GameImages.DECO_VOMIT);
                map.AddTimer(new TaskRemoveDecoration((WorldTime.TURNS_PER_DAY * 2), loc.Position.X, loc.Position.Y, GameImages.DECO_VOMIT)); //@@MP (Release 7-6)
            }

            //@@MP (Release 2)
            if (actor.IsPlayer)
                m_SFXManager.Play(GameSounds.VOMIT_PLAYER, AudioPriority.PRIORITY_BGM);
            else if (IsAudibleToPlayer(actor.Location)) //@@MP (Release 3), changed from IsVisible to IsAudible (Release 5-4)
                m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.VOMIT_NEARBY, AudioPriority.PRIORITY_EVENT);
        }

        void DoUseMedicineItem(Actor actor, ItemMedicine med)
        {
            //////////////////////////////////////
            // If player, prevent wasteful usage.
            //////////////////////////////////////
            if (actor == m_Player)
            {
                int HPneed = m_Rules.ActorMaxHPs(actor) - actor.HitPoints;
                int STAneed = m_Rules.ActorMaxSTA(actor) - actor.StaminaPoints;
                int SLPneed = m_Rules.ActorMaxSleep(actor) - 2 - actor.SleepPoints;
                int CureNeed = actor.Infection;
                int SanNeed = m_Rules.ActorMaxSanity(actor) - actor.Sanity;

                bool HPwaste = HPneed <= 0 || med.Healing <= 0;
                bool STAwaste = STAneed <= 0 || med.StaminaBoost <= 0;
                bool SLPwaste = SLPneed <= 0 || med.SleepBoost <= 0;
                bool CureWaste = ((CureNeed <= 0 || med.InfectionCure <= 0) && !actor.IsFoodPoisoned); //@@MP - antiviral pills cure food poisoning too now (Release 7-6)
                bool SanWaste = false; //@@MP - default false, which allows alcohol & cigarette consumption when sanity is disabled (Release 5-7)
                if (!med.Model.IsRecreational) //otherwise it's medicine, so check if it would be wasted
                    SanWaste = SanNeed <= 0 || med.SanityCure <= 0;

                if (HPwaste && STAwaste && SLPwaste && CureWaste && SanWaste)
                {
                    AddMessage(MakeErrorMessage("I shouldn't waste medicine!"));
                    return;
                }
            }

            // spend APs.
            SpendActorActionPoints(actor, Rules.BASE_ACTION_COST);

            // recover HPs, STA, SLP, INF, SAN.
            actor.HitPoints = Math.Min(actor.HitPoints + m_Rules.ActorMedicineEffect(actor, med.Healing), m_Rules.ActorMaxHPs(actor));
            actor.SleepPoints = Math.Min(actor.SleepPoints + m_Rules.ActorMedicineEffect(actor, med.SleepBoost), m_Rules.ActorMaxSleep(actor));
            actor.Infection = Math.Max(0, actor.Infection - m_Rules.ActorMedicineEffect(actor, med.InfectionCure));
            actor.Sanity = Math.Min(actor.Sanity + m_Rules.ActorMedicineEffect(actor, med.SanityCure), m_Rules.ActorMaxSanity(actor));
            if (med.Model == GameItems.CIGARETTES) //@@MP (Release 4)
                actor.StaminaPoints -= 6;
            else
                actor.StaminaPoints = Math.Min(actor.StaminaPoints + m_Rules.ActorMedicineEffect(actor, med.StaminaBoost), m_Rules.ActorMaxSTA(actor));

            // consume it.
            actor.Inventory.Consume(med);

            // canned drinks drops empty cans.
            if (med.Model == GameItems.ENERGY_DRINK || med.Model == GameItems.ALCOHOL_BEER_CAN_BLUE || med.Model == GameItems.ALCOHOL_BEER_CAN_RED)
            {
                ItemTrap emptyCan = new ItemTrap(GameItems.EMPTY_CAN);// alpha10 { IsActivated = true };
                emptyCan.Activate(actor);  // alpha10
                actor.Location.Map.DropItemAt(emptyCan, actor.Location.Position);
            }
            // smoking near fuel pumps will blow them up   //@MP (Release 7-3)
            else if (med.Model == GameItems.CIGARETTES)
            {
                bool oopsalready = false;
                actor.Location.Map.ForEachAdjacentAndCenterInMap(actor.Location.Position, (adj) =>
                {
                    MapObject mapObj = actor.Location.Map.GetMapObjectAt(adj);
                    if (mapObj != null && mapObj.ImageID == GameImages.OBJ_FUEL_PUMP)
                    {
                        if (!oopsalready)
                            AddMessage(MakeMessage(actor, String.Format("lit a cigarette next to a fuel pump...")));
                        ExplodeFuelPump(mapObj.Location);
                    }
                });   
            }
            // meds cure food poisoning after eating raw meat      //@@MP (Release 7-6)
            else if (med.Model == GameItems.SMALL_MEDIKIT || med.Model == GameItems.LARGE_MEDIKIT || med.Model == GameItems.PILLS_ANTIVIRAL)
            {
                if (actor.IsFoodPoisoned)
                {
                    actor.IsFoodPoisoned = false;
                    if (actor.IsPlayer || actor.Leader == m_Player)
                        AddMessage(MakeMessage(actor, "cures their food poisoning"));
                }
            }

            // message.
            if (actor.IsPlayer) //@@MP (Release 2)
            {
                if (med.Model == GameItems.SMALL_MEDIKIT || med.Model == GameItems.LARGE_MEDIKIT)
                {
                    m_SFXManager.Play(GameSounds.USE_MEDICINE, AudioPriority.PRIORITY_EVENT);
                }
                else if (med.Model == GameItems.PILLS_SAN || med.Model == GameItems.PILLS_SLP || med.Model == GameItems.PILLS_STA || med.Model == GameItems.PILLS_ANTIVIRAL)
                {
                    m_SFXManager.Play(GameSounds.USE_PILLS, AudioPriority.PRIORITY_EVENT);
                }
                else if (med.Model == GameItems.CIGARETTES) //@@MP (Release 4)
                {
                    m_SFXManager.Play(GameSounds.SMOKING, AudioPriority.PRIORITY_EVENT);
                }
                else if (med.Model == GameItems.ENERGY_DRINK || m_Rules.IsItemAlcoholForDrinking(med)) //@@MP (Release 6-6)(Release 7-1)
                {
                    m_SFXManager.Play(GameSounds.DRINK, AudioPriority.PRIORITY_EVENT);
                }
            }
            else if (IsVisibleToPlayer(actor))
            {
                AddMessage(MakeMessage(actor, Conjugate(actor, VERB_HEAL_WITH), med));
            }

            //alcohol effects   //@@MP (Release 7-1)
            if (m_Rules.IsItemAlcoholForDrinking(med))
            {
                bool wasDrunk = actor.IsDrunk;
                actor.BloodAlcohol += Rules.ALCOHOL_STANDARD_UNIT;
                if (actor.IsDrunk && !wasDrunk)
                    AddMessage(MakeMessage(actor, Conjugate(actor, VERB_BLACK_OUT), med));

                //vomit?
                if ((actor.PreviousBloodAlcohol < Rules.BLACKOUT_DRUNK_LEVEL * 0.8) && (actor.BloodAlcohol >= Rules.BLACKOUT_DRUNK_LEVEL * 0.8))
                    DoVomit(actor);

                //black out?
                if ((actor.PreviousBloodAlcohol < Rules.BLACKOUT_DRUNK_LEVEL) && (actor.BloodAlcohol >= Rules.BLACKOUT_DRUNK_LEVEL))
                {
                    DoVomit(actor);
                    DoStartSleeping(actor);

                    if (IsVisibleToPlayer(actor))
                        AddMessage(MakeMessage(actor, Conjugate(actor, VERB_BLACK_OUT), med));
                }
            }
        }

        void DoUseAmmoItem(Actor actor, ItemAmmo ammoItem)
        {
            // spend APs.
            SpendActorActionPoints(actor, Rules.BASE_ACTION_COST);

            // get weapon.
            ItemRangedWeapon ranged = actor.GetEquippedWeapon() as ItemRangedWeapon;
            ItemRangedWeaponModel model = ranged.Model as ItemRangedWeaponModel;

            // compute ammo spent.
            int ammoSpent = Math.Min(model.MaxAmmo - ranged.Ammo, ammoItem.Quantity);
            
            // reload.
            ranged.Ammo += ammoSpent;

            // spend ammo clip.
            ammoItem.Quantity -= ammoSpent;

            // if no ammo left, remove item.
            if (ammoItem.Quantity <= 0)
                actor.Inventory.RemoveAllQuantity(ammoItem);

            // message.
            if (IsVisibleToPlayer(actor))
                AddMessage(MakeMessage(actor, Conjugate(actor, VERB_RELOAD), ranged));

            //@@MP - play audio (Release 5-7)
            if (actor.IsPlayer)
            {
                if (ammoItem.AmmoType == AmmoType.PLASMA) //@@MP - a special new gun was added (Release 7-6)
                    m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.EQUIP_BFG_PLAYER, AudioPriority.PRIORITY_EVENT);
                else
                    m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.EQUIP_GUN_PLAYER, AudioPriority.PRIORITY_EVENT);
            }
        }

        void DoUseFishingRodItem(Actor actor) //@@MP (Release 7-6)
        {
            // unequip two-handed weapons
            Item rightHandItem = actor.GetEquippedItem(DollPart.RIGHT_HAND);
            if (rightHandItem != null)
            {
                if (rightHandItem.Model is ItemMeleeWeaponModel)
                {
                    ItemMeleeWeaponModel meleeModel = rightHandItem.Model as ItemMeleeWeaponModel;
                    if (!meleeModel.IsOneHanded)
                        DoUnequipItem(actor, rightHandItem, false);
                }
                else if(rightHandItem.Model is ItemRangedWeaponModel)
                {
                    ItemRangedWeaponModel rangedModel = rightHandItem.Model as ItemRangedWeaponModel;
                    if (!rangedModel.IsOneHanded)
                        DoUnequipItem(actor, rightHandItem, false);
                }
            }

            //now fish
            if (actor.IsPlayer)
                m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.FISHING_CAST_PLAYER, AudioPriority.PRIORITY_EVENT);
            else if (IsAudibleToPlayer(actor.Location, Rules.QUIET_NOISE_RADIUS))
                m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.FISHING_CAST_NEARBY, AudioPriority.PRIORITY_EVENT);

            if (actor.IsPlayer)
                AddMessage(new Message(String.Format("Now press Wait <{0}> or Long-Wait <{1}> until a fish is hooked.",
                    s_KeyBindings.GetFriendlyFormat(PlayerCommand.WAIT_OR_SELF).ToString(), s_KeyBindings.GetFriendlyFormat(PlayerCommand.WAIT_LONG).ToString()),
                    actor.Location.Map.LocalTime.TurnCounter, Color.Yellow));

            return;
        }

        void DoUseShieldItem(Actor actor, Item shield) //@@MP (Release 7-2)
        {
            // equip or unequip
            Item leftArmItem = actor.GetEquippedItem(DollPart.LEFT_ARM);
            if (leftArmItem == null) //equip
                DoEquipItem(actor, shield, true);
            else
                DoUnequipItem(actor, shield, true);
        }

        /*void DoUseSprayScentItem(Actor actor, ItemSprayScent spray)  // alpha10 obsolete, see DoSprayOdorSuppressor
        {
            // spend APs.
            SpendActorActionPoints(actor, Rules.BASE_ACTION_COST);

            // consume spray.
            --spray.SprayQuantity;

            // add odor.
            Map map = actor.Location.Map;
            ItemSprayScentModel model = spray.Model as ItemSprayScentModel;
            map.ModifyScentAt(model.Odor, model.Strength, actor.Location.Position);

            // message.
            if (actor.IsPlayer) //@@MP (Release 2)
                m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.SPRAY_SCENT);
            else if (IsVisibleToPlayer(actor))
                AddMessage(MakeMessage(actor, Conjugate(actor, VERB_SPRAY), spray));
        }*/

        void DoUseTrapItem(Actor actor, ItemTrap trap)
        {
            // spend APs.
            SpendActorActionPoints(actor, Rules.BASE_ACTION_COST);

            // toggle activation.
            if (trap.IsActivated) // alpha10 //trap.IsActivated = !trap.IsActivated;
                trap.Deactivate();
            else
                trap.Activate(actor);

            // message.
            if (IsVisibleToPlayer(actor))
                AddMessage(MakeMessage(actor, Conjugate(actor, (trap.IsActivated ? VERB_ACTIVATE : VERB_DEACTIVATE)), trap));
        }

        void DoUseEntertainmentItem(Actor actor, ItemEntertainment ent)
        {
            //play sound
            if (actor.IsPlayer) //@@MP (Release 3)
                m_SFXManager.Play(GameSounds.TURN_PAGE, AudioPriority.PRIORITY_EVENT);

            bool visible = IsVisibleToPlayer(actor);

            // spend APs.
            SpendActorActionPoints(actor, Rules.BASE_ACTION_COST);

            // recover san.
            RegenActorSanity(actor, Rules.ActorSanRegenValue(actor, ent.EntertainmentModel.Value));

            // check boring chance. 100% means discard it.
            int boreChance = ent.EntertainmentModel.BoreChance;
            bool bored = false;
            bool discarded = false;
            if (boreChance == 100)
            {
                actor.Inventory.Consume(ent);
                discarded = true;
            }
            else if (boreChance > 0)
            {
                if (m_Rules.RollChance(boreChance))
                    bored = true;
            }
            if (bored)
                ent.AddBoringFor(actor); // alpha10 boring items item-centric

            // messages.
            if (visible)
            {
                AddMessage(MakeMessage(actor, Conjugate(actor, VERB_ENJOY), ent));
                if (bored)
                    AddMessage(MakeMessage(actor, String.Format("{0} now bored of {1}.", Conjugate(actor, VERB_BE), ent.TheName)));
                if (discarded)
                    AddMessage(MakeMessage(actor, Conjugate(actor, VERB_DISCARD), ent));
            }
        }

        public void DoRechargeItemBattery(Actor actor, Item it)
        {
            // spend APs.
            SpendActorActionPoints(actor, Rules.BASE_ACTION_COST);
            
            // recharge.
            if (it is ItemLight)
            {
                ItemLight light = it as ItemLight;
                light.Batteries += WorldTime.TURNS_PER_HOUR;
            }
            else if (it is ItemTracker)
            {
                ItemTracker track = it as ItemTracker;
                track.Batteries += WorldTime.TURNS_PER_HOUR;
            }
            else if (it is ItemRangedWeapon) //@@MP (Release 7-2)
            {
                ItemRangedWeapon ranged = it as ItemRangedWeapon;
                ranged.Ammo = Math.Min((ranged.Model as ItemRangedWeaponModel).MaxAmmo, ++ranged.Ammo);
            }

            // message.
            if (IsVisibleToPlayer(actor))
            {
                AddMessage(MakeMessage(actor, Conjugate(actor, VERB_RECHARGE), it, " batteries."));
            }

        }

        void DoMakeMolotov(Actor actor, Item it) //@@MP (Release 7-1)
        {
            if (m_Rules.IsItemLiquorForMolotov(it))
            {
                // spend ap.
                SpendActorActionPoints(actor, Rules.BASE_ACTION_COST); //@@MP - added (Release 7-6)

                actor.Inventory.RemoveAllQuantity(it); //remove the liquor

                //add as many molotovs as possible to actor inventory
                int liquorQuantity = it.Quantity;
                int molotovsAdded = 0;
                for (int i = 0; i != liquorQuantity; i++)
                {
                    Item molotov = new ItemGrenade(GameItems.MOLOTOV, GameItems.MOLOTOV_PRIMED);
                    int quantityAdded;
                    actor.Inventory.AddAsMuchAsPossible(molotov, out quantityAdded);
                    molotovsAdded += quantityAdded;     //@@MP (Release 7-5)
                }
                
                //add any molotovs that couldn't fit in actor's inventory to the ground    //@@MP (Release 7-5)
                int overflowMolotovs = liquorQuantity - molotovsAdded;
                if (overflowMolotovs > 0)
                {
                    for (int i = 0; i != overflowMolotovs; i++)
                    {
                        Item molotov = new ItemGrenade(GameItems.MOLOTOV, GameItems.MOLOTOV_PRIMED);
                        DropItem(actor, molotov, true);
                    }
                }

                if (actor.IsPlayer)
                    m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.MAKE_MOLOTOV, AudioPriority.PRIORITY_EVENT); //@@MP (Release 6-6)

                if (IsVisibleToPlayer(actor.Location))
                    AddMessage(MakeMessage(actor, String.Format("crafted a molotov from liquor.")));
            }
        }

        void DoUnloadAmmoFromGun(Actor actor, ItemRangedWeapon weapon) //@@MP (Release 7-6)
        {
            // spend APs.
            SpendActorActionPoints(actor, Rules.BASE_ACTION_COST);

            int ammoCount = weapon.Ammo;

            // work out the type of ammo to unload
            ItemAmmoModel ammoModel;
            switch (weapon.AmmoType)
            {
                case AmmoType.BOLT: ammoModel = m_GameItems.AMMO_BOLTS; break;
                case AmmoType.FUEL: ammoModel = m_GameItems.AMMO_FUEL; break;
                case AmmoType.GRENADES: ammoModel = m_GameItems.AMMO_GRENADES; break;
                case AmmoType.HEAVY_PISTOL: ammoModel = m_GameItems.AMMO_HEAVY_PISTOL; break;
                case AmmoType.HEAVY_RIFLE: ammoModel = m_GameItems.AMMO_HEAVY_RIFLE; break;
                case AmmoType.LIGHT_PISTOL: ammoModel = m_GameItems.AMMO_LIGHT_PISTOL; break;
                case AmmoType.LIGHT_RIFLE: ammoModel = m_GameItems.AMMO_LIGHT_RIFLE; break;
                case AmmoType.MINIGUN: ammoModel = m_GameItems.AMMO_MINIGUN; break;
                case AmmoType.NAIL: ammoModel = m_GameItems.AMMO_NAILS; break;
                case AmmoType.PRECISION_RIFLE: ammoModel = m_GameItems.AMMO_PRECISION_RIFLE; break;
                case AmmoType.SHOTGUN: ammoModel = m_GameItems.AMMO_SHOTGUN; break;
                default:
                    throw new InvalidOperationException("unhandled ammo type");
            }

            // create a new ammo instance
            ItemAmmo newAmmo = new ItemAmmo(ammoModel);
            newAmmo.Quantity = ammoCount;

            // remove the ammo from the gun
            weapon.Ammo = 0;

            // add to inventory (or drop on ground if inv is full)
            if (!actor.Inventory.AddAll(newAmmo))
            {
                //add as much ammo as possible to actor inventory
                int totalAmmo = ammoCount;
                int ammoAdded = 0;
                for (int i = 0; i != ammoCount; i++)
                {
                    ItemAmmo singleAmmo = new ItemAmmo(ammoModel);
                    singleAmmo.Quantity = 1;
                    int quantityAdded;
                    actor.Inventory.AddAsMuchAsPossible(singleAmmo, out quantityAdded);
                    ammoAdded += quantityAdded;
                }

                //add any ammo that couldn't fit in actor's inventory to the ground
                int overflowAmmo = totalAmmo - ammoAdded;
                if (overflowAmmo > 0)
                {
                    ItemAmmo overflowAmmoItem = new ItemAmmo(ammoModel);
                    overflowAmmoItem.Quantity = overflowAmmo;
                    DropItem(actor, overflowAmmoItem, true);
                }
            }

            // SFX & msg
            if (actor.IsPlayer)
            {
                m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.EQUIP_GUN_PLAYER, AudioPriority.PRIORITY_EVENT);
                AddMessage(MakeMessage(actor, Conjugate(actor, VERB_UNLOAD), weapon));
            }
        }
#endregion

#region -Doors
        public void DoOpenDoor(Actor actor, DoorWindow door)
        {
            // Do it.
            door.SetState(DoorWindow.STATE_OPEN);

            // Message.
            if (actor.IsPlayer || IsAudibleToPlayer(door.Location, Rules.QUIET_NOISE_RADIUS)) //@@MP - changed from visible to audible (Release 7-4)
            {
                if (door.GivesWood)
                    m_SFXManager.Play(GameSounds.WOODEN_DOOR_OPEN, AudioPriority.PRIORITY_EVENT);
                else if (door.IsMetal) //@@MP (Release 7-4)
                    m_SFXManager.Play(GameSounds.METAL_DOOR_OPEN, AudioPriority.PRIORITY_EVENT);
                else if (door.TheName == "the roller door") //@@MP (Release 4)
                    m_SFXManager.Play(GameSounds.ROLLER_DOOR, AudioPriority.PRIORITY_EVENT);
                else
                    m_SFXManager.Play(GameSounds.GLASS_DOOR, AudioPriority.PRIORITY_EVENT);

                if (!actor.IsPlayer)
                {
                    AddMessage(MakeMessage(actor, Conjugate(actor, VERB_OPEN), door));
                }
                RedrawPlayScreen();
            }

            // Spend APs.
            int openCost = Rules.BASE_ACTION_COST;
            SpendActorActionPoints(actor, openCost);
        }

        public void DoCloseDoor(Actor actor, DoorWindow door)
        {
            // Do it.
            door.SetState(DoorWindow.STATE_CLOSED);

            // Message.
            if (actor.IsPlayer || IsAudibleToPlayer(door.Location, Rules.QUIET_NOISE_RADIUS)) //@@MP - changed from visible to audible (Release 7-4)
            {
                if (door.GivesWood)
                    m_SFXManager.Play(GameSounds.WOODEN_DOOR_CLOSE, AudioPriority.PRIORITY_EVENT);
                else if (door.IsMetal) //@@MP (Release 7-4)
                    m_SFXManager.Play(GameSounds.METAL_DOOR_CLOSE, AudioPriority.PRIORITY_EVENT);
                else if (door.TheName == "the roller door") //@@MP (Release 4)
                    m_SFXManager.Play(GameSounds.ROLLER_DOOR, AudioPriority.PRIORITY_EVENT);
                else
                    m_SFXManager.Play(GameSounds.GLASS_DOOR, AudioPriority.PRIORITY_EVENT);
                if (!actor.IsPlayer)
                {
                    AddMessage(MakeMessage(actor, Conjugate(actor, VERB_CLOSE), door));
                }
                RedrawPlayScreen();
            }

            // Spend APs.
            int closeCost = Rules.BASE_ACTION_COST;
            SpendActorActionPoints(actor, closeCost);
        }

        public void DoBarricadeDoor(Actor actor, DoorWindow door)
        {
            // get barricading item.
            ItemBarricadeMaterial it = actor.Inventory.GetSmallestStackByType(typeof(ItemBarricadeMaterial)) as ItemBarricadeMaterial; // alpha10, smallest stack first
            ItemBarricadeMaterialModel m = it.Model as ItemBarricadeMaterialModel;

            // do it.
            actor.Inventory.Consume(it);
            door.BarricadePoints = Math.Min(door.BarricadePoints + m_Rules.ActorBarricadingPoints(actor, m.BarricadingValue), Rules.BARRICADING_MAX);

            // message.
            bool isVisible = IsVisibleToPlayer(actor) || IsVisibleToPlayer(door);
            if (isVisible)
            {
                m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.BUILDING_PLAYER, AudioPriority.PRIORITY_EVENT); //@@MP (Release 3)
                AddMessage(MakeMessage(actor, Conjugate(actor, VERB_BARRICADE), door));
            }
            else if (IsAudibleToPlayer(door.Location, Rules.MODERATE_NOISE_RADIUS)) //@@MP (Release 7-4)
            {
                m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.BUILDING_NEARBY, AudioPriority.PRIORITY_EVENT);
                AddMessage(MakePlayerCentricMessage("You hear some sort of construction work", door.Location.Position));
            }

            // spend AP.
            int barricadingCost = Rules.BASE_ACTION_COST;
            SpendActorActionPoints(actor, barricadingCost);
        }

        public void DoRepairDoor(Actor actor, DoorWindow door) //@@MP (Release 8-1)
        {
            // consume barricading material
            int consumed = 0;
            int materialBarricadingValue = 0;
            while (consumed < 2)
            {
                // get barricading item.
                ItemBarricadeMaterial it = actor.Inventory.GetSmallestStackByType(typeof(ItemBarricadeMaterial)) as ItemBarricadeMaterial; // alpha10, smallest stack first
                ItemBarricadeMaterialModel m = it.Model as ItemBarricadeMaterialModel;
                materialBarricadingValue = m.BarricadingValue;
                actor.Inventory.Consume(it);
                ++consumed;
            }

            // do it.
            if (door.State != DoorWindow.STATE_BROKEN)
                door.HitPoints = Math.Min(door.HitPoints + m_Rules.ActorBarricadingPoints(actor, materialBarricadingValue), Rules.BARRICADING_MAX);
            else
            {
                Map map = door.Location.Map;
                Point doorPT = door.Location.Position;
                map.RemoveMapObjectAt(doorPT.X, doorPT.Y);
                DoorWindow newDoor = m_TownGenerator.MakeObjWoodenDoor();
                actor.Location.Map.PlaceMapObjectAt(newDoor, doorPT);
                newDoor.HitPoints = Math.Min(m_Rules.ActorBarricadingPoints(actor, materialBarricadingValue), Rules.BARRICADING_MAX);
            }

            // message.
            bool isVisible = IsVisibleToPlayer(actor) || IsVisibleToPlayer(door);
            if (isVisible)
            {
                m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.BUILDING_PLAYER, AudioPriority.PRIORITY_EVENT);
                AddMessage(MakeMessage(actor, Conjugate(actor, VERB_BARRICADE), door));
            }
            else if (IsAudibleToPlayer(door.Location, Rules.MODERATE_NOISE_RADIUS))
            {
                m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.BUILDING_NEARBY, AudioPriority.PRIORITY_EVENT);
                AddMessage(MakePlayerCentricMessage("You hear some sort of construction work", door.Location.Position));
            }

            // spend AP.
            int repairingCost = Rules.BASE_ACTION_COST;
            SpendActorActionPoints(actor, repairingCost);
        }
#endregion

#region -Building & Repairing
        public void DoBuildFortification(Actor actor, Point buildPos, bool isLarge)
        {
            // spend AP.
            SpendActorActionPoints(actor, Rules.BASE_ACTION_COST);

            // consume material.
            int need = m_Rules.ActorBarricadingMaterialNeedForFortification(actor, isLarge);
            for (int i = 0; i < need; i++)
            {
                Item it = actor.Inventory.GetFirstByType(typeof(ItemBarricadeMaterial));
                actor.Inventory.Consume(it);
            }

            // add object.
            Fortification fortObj = isLarge ? m_TownGenerator.MakeObjLargeFortification(GameImages.OBJ_LARGE_WOODEN_FORTIFICATION) : m_TownGenerator.MakeObjSmallFortification(GameImages.OBJ_SMALL_WOODEN_FORTIFICATION);
            actor.Location.Map.PlaceMapObjectAt(fortObj, buildPos);

            // message.
            if (IsVisibleToPlayer(actor) || IsVisibleToPlayer(new Location(actor.Location.Map, buildPos)))
            {
                m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.BUILDING_PLAYER, AudioPriority.PRIORITY_EVENT); //@@MP (Release 3)
                AddMessage(MakeMessage(actor, String.Format("{0} a {1} fortification.", Conjugate(actor, VERB_BUILD), isLarge ? "large" : "small")));
            }
            else if (IsAudibleToPlayer(new Location(actor.Location.Map, buildPos), Rules.MODERATE_NOISE_RADIUS)) //@@MP (Release 7-4)
            {
                m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.BUILDING_NEARBY, AudioPriority.PRIORITY_EVENT);
                AddMessage(MakePlayerCentricMessage("You hear some sort of construction work", buildPos));
            }

            // check traps.
            CheckMapObjectTriggersTraps(actor.Location.Map, buildPos);
        }

        public void DoRepairFortification(Actor actor, Fortification fort)
        {
            // spend AP.
            SpendActorActionPoints(actor, Rules.BASE_ACTION_COST);

            // spend material.
            ItemBarricadeMaterial material = actor.Inventory.GetSmallestStackByType(typeof(ItemBarricadeMaterial)) as ItemBarricadeMaterial; // alpha10 get smallest stack first
            if (material == null)
                throw new InvalidOperationException("no material");
            actor.Inventory.Consume(material);

            // repair HP.
            fort.HitPoints = Math.Min(fort.MaxHitPoints,
                fort.HitPoints + m_Rules.ActorBarricadingPoints(actor, (material.Model as ItemBarricadeMaterialModel).BarricadingValue));

            // message.
            if (IsVisibleToPlayer(actor) || IsVisibleToPlayer(fort))
            {
                m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.BUILDING_PLAYER, AudioPriority.PRIORITY_EVENT); //@@MP (Release 3)
                AddMessage(MakeMessage(actor, Conjugate(actor, VERB_REPAIR), fort));
            }
            else if (IsAudibleToPlayer(fort.Location, Rules.MODERATE_NOISE_RADIUS)) //@@MP (Release 7-4)
            {
                m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.BUILDING_NEARBY, AudioPriority.PRIORITY_EVENT);
                AddMessage(MakePlayerCentricMessage("You hear some sort of construction work", fort.Location.Position));
            }
        }
#endregion

#region -Breaking stuff
        void DoDestroyObject(MapObject mapObj)
        {
            //bool isWindow = (door != null && door.IsWindow); //@@MP - unused (Release 5-7)
            Point pt = mapObj.Location.Position;
            Map map = mapObj.Location.Map;

            // force HP to zero.
            mapObj.HitPoints = 0;

            // drop plank and improvised weapons?
            if (mapObj.GivesWood)
            {
                // drop planks.
                int nbPlanks = 1 + mapObj.MaxHitPoints / DoorWindow.BASE_HITPOINTS;
                while (nbPlanks > 0)
                {
                    Item planks = new ItemBarricadeMaterial(m_GameItems.WOODENPLANK)
                    {
                        Quantity = Math.Min(m_GameItems.WOODENPLANK.StackingLimit, nbPlanks)
                    };
                    if (planks.Quantity < 1) planks.Quantity = 1;
                    mapObj.Location.Map.DropItemAt(planks, mapObj.Location.Position);
                    nbPlanks -= planks.Quantity;
                }

                // drop improvised weapons?
                if (m_Rules.RollChance(Rules.IMPROVED_WEAPONS_FROM_BROKEN_WOOD_CHANCE))
                {
                    // improvised club, improvised spear.
                    ItemMeleeWeapon impWpn;
                    if (m_Rules.RollChance(50))
                        impWpn = new ItemMeleeWeapon(m_GameItems.IMPROVISED_CLUB);
                    else
                        impWpn = new ItemMeleeWeapon(m_GameItems.IMPROVISED_SPEAR);

                    // drop it.
                    mapObj.Location.Map.DropItemAt(impWpn, mapObj.Location.Position);
                }
            }

            PlayBashOrBreakSFX(mapObj, true); //@@MP - added (Release 5-3), refactored (Release 5-4)

            // remove object - but not doors and windows.
            DoorWindow door = mapObj as DoorWindow;
            if (door != null) //@@MP (Release 5-4)
                door.SetState(DoorWindow.STATE_BROKEN);
            else
                mapObj.Location.Map.RemoveMapObjectAt(mapObj.Location.Position.X, mapObj.Location.Position.Y);

            #region trees
            //@@MP - added (Release 7-6)
            if (mapObj.AName == "a tree")
            {
                MapObject treeStump = BaseMapGenerator.MakeObjTreeStump(GameImages.OBJ_TREE_STUMP);
                map.PlaceMapObjectAt(treeStump, pt);
            }
#if false
                //@@MP - opted not to use the below. left in for reference or potential reuse elsewhere (Release 7-6)
                // if it was a tree, plant a seed
                // the new idle items housekeeping routine removes planks. after some time a lot of the wooden stuff is destroyed and the planks have been used or deleted
                // this planting ensures there will always be a source of wood, in a thematic way
                if (mapObj.AName == "a tree")
                {
                    Point pt = mapObj.Location.Position;
                    MapObject tree = BaseMapGenerator.MakeObjParkTree(m_Rules.DiceRoller);
                    mapObj.Location.Map.AddTimer(new TaskAddMapObject(WorldTime.TURNS_PER_HOUR * 1, pt.X, pt.Y, tree, false)); //false because there's lots of trees
                }
#endif
            #endregion

            // loud noise.
            OnLoudNoise(mapObj.Location.Map, mapObj.Location.Position, "A loud *CRASH*");
        }

        public void DoBreak(Actor actor, MapObject mapObj)
        {
            Attack bashAttack = m_Rules.ActorMeleeAttack(actor, actor.CurrentMeleeAttack, null, mapObj);
            
#region Attacking a barricaded door.
            DoorWindow door = mapObj as DoorWindow;
            if (door != null && door.IsBarricaded)
            {
                PlayBashOrBreakSFX(mapObj, false); //@@MP - play the appropriate sfx (Release 3), moved/copied from the very start of the method (Release 5-3), refactored (Release 5-4)

                // Spend APs & STA.
                int bashCost = Rules.BASE_ACTION_COST;
                SpendActorActionPoints(actor, bashCost);
                SpendActorStaminaPoints(actor, Rules.STAMINA_COST_MELEE_ATTACK);

                // Bash.
                door.BarricadePoints -= bashAttack.DamageValue;

                // loud noise.
                OnLoudNoise(door.Location.Map, door.Location.Position, "A loud *BASH*");

                // message.
                if (IsVisibleToPlayer(door))
                {
                    // alpha10 tell & show damage
                    Point screenPos = MapToScreen(mapObj.Location.Position);
                    AddOverlay(new OverlayImage(screenPos, GameImages.ICON_MELEE_DAMAGE));
                    AddOverlay(new OverlayText(screenPos.Add(DAMAGE_DX, DAMAGE_DY), Color.White, bashAttack.DamageValue.ToString(), Color.Black)); // alpha10
                    AddMessage(MakeMessage(actor, string.Format("{0} the barricade for {1} damage.", Conjugate(actor, VERB_BASH), bashAttack.DamageValue))); // alpha10
                    RedrawPlayScreen();
                    AnimDelay(DELAY_SHORT,false);
                    ClearOverlays();
                }
                else if (IsVisibleToPlayer(actor))
                    AddMessage(MakeMessage(actor, string.Format("{0} the barricade.", Conjugate(actor, VERB_BASH)))); // alpha10
                else if (m_Rules.RollChance(PLAYER_HEAR_BASH_CHANCE)) //@@MP (Release 3)
                    AddMessageIfAudibleForPlayer(door.Location, MakePlayerCentricMessage("You hear someone bashing barricades", door.Location.Position));

                // done.
                return;
            }
#endregion
#region Attacking an un-barricaded door or a normal object
            else
            {
                // Always hit.
                mapObj.HitPoints -= bashAttack.DamageValue;

                // Spend APs & STA.
                int bashCost = Rules.BASE_ACTION_COST;
                SpendActorActionPoints(actor, bashCost);
                SpendActorStaminaPoints(actor, Rules.STAMINA_COST_MELEE_ATTACK);

                // Broken?
                bool isBroken = false;
                if (mapObj.HitPoints <= 0)
                {
                    if (mapObj.ImageID == GameImages.OBJ_FUEL_PUMP) //@@MP - special cases first (Release 7-3)
                        ExplodeFuelPump(mapObj.Location);
                    else // breaks.
                        DoDestroyObject(mapObj);
                    isBroken = true;
                }

                // loud noise.
                OnLoudNoise(mapObj.Location.Map, mapObj.Location.Position, "A loud *CRASH*");

                // Message.
                bool isActorVisible = IsVisibleToPlayer(actor);
                bool isObjectVisible = IsVisibleToPlayer(mapObj); //@@MP - renamed from Door to Object to better represent whatever it could be (Release 6-2)

                if (isActorVisible || isObjectVisible)
                {
                    if (isActorVisible)
                        AddOverlay(new OverlayRect(Color.Yellow, new Rectangle(MapToScreen(actor.Location.Position), new Size(TILE_SIZE, TILE_SIZE))));
                    if (isObjectVisible)
                        AddOverlay(new OverlayRect(Color.Red, new Rectangle(MapToScreen(mapObj.Location.Position), new Size(TILE_SIZE, TILE_SIZE))));

                    if (isBroken)
                    { //@@MP - sound effect for this can be found in DoDestroyObject()
                        AddMessage(MakeMessage(actor, Conjugate(actor, VERB_BREAK), mapObj));
                        if (isActorVisible)
                            AddOverlay(new OverlayImage(MapToScreen(actor.Location.Position), GameImages.ICON_MELEE_ATTACK));
                        if (isObjectVisible)
                            AddOverlay(new OverlayImage(MapToScreen(mapObj.Location.Position), GameImages.ICON_KILLED));
                        RedrawPlayScreen();
                        AnimDelay(DELAY_NORMAL,false);
                    }
                    else
                    {
                        PlayBashOrBreakSFX(mapObj, isBroken); //@@MP - play the appropriate sfx (Release 3), moved/copied from the very start of the method (Release 5-3), refactored (Release 5-4)
                        if (isObjectVisible)
                        {
                            AddOverlay(new OverlayImage(MapToScreen(mapObj.Location.Position), GameImages.ICON_MELEE_DAMAGE));
                            AddOverlay(new OverlayText(MapToScreen(mapObj.Location.Position).Add(DAMAGE_DX, DAMAGE_DY), Color.White, bashAttack.DamageValue.ToString(), Color.Black)); // alpha10
                            AddMessage(MakeMessage(actor, string.Format("{0} {1} for {2} damage.", Conjugate(actor, VERB_BASH), mapObj.TheName, bashAttack.DamageValue))); // alpha10
                        }
                        else if (isActorVisible)
                            AddMessage(MakeMessage(actor, string.Format("{0} {1}.", Conjugate(actor, VERB_BASH), mapObj.TheName))); // alpha10

                        if (isActorVisible)
                            AddOverlay(new OverlayImage(MapToScreen(actor.Location.Position), GameImages.ICON_MELEE_ATTACK));

                        RedrawPlayScreen();
                        AnimDelay(DELAY_SHORT,false);
                    }

                    // alpha10 bug fix; clear overlays only if action is visible
                    ClearOverlays(); // was in the wrong place!
                }
                else  // any is visible
                {
                    if (isBroken)
                    { //@@MP - sound effect for this can be found in DoDestroyObject()
                        if (IsAudibleToPlayer(mapObj.Location, Rules.LOUD_NOISE_RADIUS)) //(m_Rules.RollChance(PLAYER_HEAR_BREAK_CHANCE)) //@@MP - have built the checks in individually below instead (Release 5-3)
                            AddMessageIfAudibleForPlayer(mapObj.Location, MakePlayerCentricMessage("You hear someone breaking something", mapObj.Location.Position));
                    }
                    else
                    {
                        PlayBashOrBreakSFX(mapObj, isBroken); //@@MP - play the appropriate sfx (Release 3), moved/copied from the very start of the method (Release 5-3), refactored (Release 5-4)
                        if (m_Rules.RollChance(PLAYER_HEAR_BASH_CHANCE))
                            AddMessageIfAudibleForPlayer(mapObj.Location, MakePlayerCentricMessage("You hear someone bashing something", mapObj.Location.Position));
                    }
                }
            }
#endregion
        }

        void PlayBashOrBreakSFX(MapObject mapObj, bool isBroken) //@@MP (Release 5-4)
        {
            DoorWindow door = mapObj as DoorWindow;
            string objectMaterial = "other"; //need to know what sfx to play
            if (mapObj != null)
            {
                if (mapObj.GivesWood && mapObj.AName != "a tree")
                    objectMaterial = "wood";
                else if (mapObj.AName == "a chain wire fence")
                    objectMaterial = "chain fence"; //chain fences must get checked before metal, because they are metal
                else if (mapObj.IsMetal)
                    objectMaterial = "metal";
                else if (door != null && door.IsBarricaded) //wooden barricades
                    objectMaterial = "wood";
                else if (door != null && (door.IsWindow || door.IsTransparent)) //wood and metal must get checked first because open doors are true for IsTransparent
                    objectMaterial = "glass"; //all glass doors are transparent, wood and iron are not. iron gates, like in subways, are not DoorWindow objects so don't count
                else if (mapObj.AName == "a potted plant")
                    objectMaterial = "ceramic";
                //@@MP - FIXME: need sounds for other materials i've missed. might need to add more flags and properties to Data\MapObjects
            }

            if (isBroken)
            {
                if (IsVisibleToPlayer(mapObj))
                {
                    switch (objectMaterial)
                    {
                        case "glass": m_SFXManager.Play(GameSounds.BREAK_GLASSDOOR_PLAYER, AudioPriority.PRIORITY_EVENT); break;
                        case "metal": m_SFXManager.Play(GameSounds.BREAK_METALDOOR_PLAYER, AudioPriority.PRIORITY_EVENT); break;
                        case "chain fence": m_SFXManager.Play(GameSounds.CLIMB_FENCE_PLAYER, AudioPriority.PRIORITY_BGM); break;
                        case "ceramic": m_SFXManager.Play(GameSounds.BREAK_CERAMIC_VISIBLE, AudioPriority.PRIORITY_BGM); break;
                        case "wood":
                        default: m_SFXManager.Play(GameSounds.BREAK_WOODENDOOR_PLAYER, AudioPriority.PRIORITY_EVENT); break;
                    }
                }
                else if (IsAudibleToPlayer(mapObj.Location, Rules.MODERATE_NOISE_RADIUS))
                {
                    switch (objectMaterial)
                    {
                        case "glass": m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.BREAK_GLASSDOOR_NEARBY, AudioPriority.PRIORITY_EVENT); break;
                        case "metal": m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.BREAK_METALDOOR_NEARBY, AudioPriority.PRIORITY_EVENT); break;
                        case "chain fence": m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.CLIMB_FENCE_NEARBY, AudioPriority.PRIORITY_BGM); break;
                        case "ceramic": m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.BREAK_CERAMIC_VISIBLE, AudioPriority.PRIORITY_BGM); break;
                        case "wood":
                        default: m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.BREAK_WOODENDOOR_NEARBY, AudioPriority.PRIORITY_EVENT); break;
                    }
                }
            }
            else
            {
                if (IsVisibleToPlayer(mapObj))
                {
                    switch (objectMaterial)
                    {
                        case "metal": m_SFXManager.Play(GameSounds.BASH_METALDOOR_PLAYER, AudioPriority.PRIORITY_EVENT); break;
                        case "chain fence": m_SFXManager.Play(GameSounds.CLIMB_FENCE_PLAYER, AudioPriority.PRIORITY_EVENT); break;
                        case "ceramic": m_SFXManager.Play(GameSounds.BASH_CERAMIC_VISIBLE, AudioPriority.PRIORITY_EVENT); break;
                        case "wood": m_SFXManager.Play(GameSounds.BASH_WOOD_PLAYER, AudioPriority.PRIORITY_EVENT); break;
                        case "glass":
                        default: m_SFXManager.Play(GameSounds.BASH_OTHER_OBJECTS_PLAYER, AudioPriority.PRIORITY_EVENT); break;
                    }
                }
                else if (IsAudibleToPlayer(mapObj.Location, Rules.MODERATE_NOISE_RADIUS))
                {
                    switch (objectMaterial)
                    {
                        case "metal": m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.BASH_METALDOOR_NEARBY, AudioPriority.PRIORITY_EVENT); break;
                        case "chain fence": m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.CLIMB_FENCE_NEARBY, AudioPriority.PRIORITY_BGM); break;
                        case "ceramic": m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.BASH_CERAMIC_VISIBLE, AudioPriority.PRIORITY_EVENT); break;
                        case "wood": m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.BASH_WOOD_NEARBY, AudioPriority.PRIORITY_EVENT); break;
                        case "glass":
                        default: m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.BASH_OTHER_OBJECTS_NEARBY, AudioPriority.PRIORITY_EVENT); break;
                    }
                }
            }
        }
#endregion

#region -Pushing, Pulling & Shoving
        void DoPushPullFollowersHelp(Actor actor, MapObject mapObj, bool isPulling, ref int staCost) //alpha 10
        {
            bool isVisibleMobj = IsVisibleToPlayer(mapObj);

            Location objLoc = new Location(actor.Location.Map, mapObj.Location.Position);
            List<Actor> helpers = null;
            foreach (Actor fo in actor.Followers)
            {
                // follower can help if: not sleeping, idle and adj to map object.
                if (!fo.IsSleeping && (!fo.IsFightingOrFleeing) && m_Rules.IsAdjacent(fo.Location, mapObj.Location)) //@@MP (Release 6-6)
                {
                    if (helpers == null) helpers = new List<Actor>(actor.CountFollowers);
                    helpers.Add(fo);
                }
            }
            if (helpers != null)
            {
                // share the sta cost.
                staCost = mapObj.Weight / (1 + helpers.Count);
                foreach (Actor h in helpers)
                {
                    // spend fo AP & STA.
                    SpendActorActionPoints(h, Rules.BASE_ACTION_COST);
                    SpendActorStaminaPoints(h, staCost);
                    // message.
                    if (isVisibleMobj || IsVisibleToPlayer(h))
                        AddMessage(MakeMessage(h, String.Format("{0} {1} {2} {3}.", Conjugate(h, VERB_HELP), actor.Name, (isPulling ? "pulling" : "pushing"), mapObj.TheName)));
                }
            }
        }

        public void DoPush(Actor actor, MapObject mapObj, Point toPos)
        {
            bool isVisible = IsVisibleToPlayer(actor) || IsVisibleToPlayer(mapObj);
            int staCost = mapObj.Weight;

            // followers help?
            if (actor.CountFollowers > 0)
                DoPushPullFollowersHelp(actor, mapObj, false, ref staCost); // alpha10

            // spend AP & STA.
            SpendActorActionPoints(actor, Rules.BASE_ACTION_COST);
            SpendActorStaminaPoints(actor, staCost);

            // do it : move object, then move actor if he is pushing it away and can enter the tile.
            Map map = mapObj.Location.Map;
            Point prevObjPos = mapObj.Location.Position;
            map.RemoveMapObjectAt(mapObj.Location.Position.X, mapObj.Location.Position.Y);
            map.PlaceMapObjectAt(mapObj, toPos);
            if (!m_Rules.IsAdjacent(toPos, actor.Location.Position) && m_Rules.IsWalkableFor(actor, map, prevObjPos.X,prevObjPos.Y))
            {
                // pushing away, need to follow.
                if (TryActorLeaveTile(actor))  // alpha10
                {
                    map.RemoveActor(actor);
                    map.PlaceActorAt(actor, prevObjPos);
                    OnActorEnterTile(actor);  // alpha10
                }
            }

            // noise/message.
            if (IsAudibleToPlayer(mapObj.Location, Rules.QUIET_NOISE_RADIUS)) //@@MP - changed from isVisible, because if it's that close we'd hear it as loud (Release 5-4)
            {
                if (mapObj.IsMetal) //@@MP - added sound for wooden items (Release 5-4)
                    m_SFXManager.Play(GameSounds.PUSH_METAL_OBJECT_VISIBLE, AudioPriority.PRIORITY_EVENT); //@@MP (Release 3)
                else
                    m_SFXManager.Play(GameSounds.PUSH_WOODEN_OBJECT_VISIBLE, AudioPriority.PRIORITY_EVENT);

                AddMessage(MakeMessage(actor, Conjugate(actor, VERB_PUSH), mapObj));
                RedrawPlayScreen();
            }
            else if (!isVisible)
            {
                // loud noise.
                OnLoudNoise(map, toPos, "Something being pushed");
                // player hears?  //@@MP - added a distance check, because the default audible range is big (Release 5-3)
                if (IsAudibleToPlayer(mapObj.Location, Rules.MODERATE_NOISE_RADIUS))// && m_Rules.RollChance(PLAYER_HEAR_PUSH_CHANCE)) //@@MP - to ease up on sfx spam, and chance can be used to reduce it even more (Release 5-3), changed to MODERATE from LOUD (Release 5-4)
                {
                    if (mapObj.IsMetal) //@@MP - added sound for wooden items (Release 5-4)
                        m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.PUSH_METAL_OBJECT_AUDIBLE, AudioPriority.PRIORITY_BGM); //@@MP (Release 3)
                    else
                        m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.PUSH_WOODEN_OBJECT_AUDIBLE, AudioPriority.PRIORITY_BGM);

                    AddMessageIfAudibleForPlayer(mapObj.Location, MakePlayerCentricMessage("You hear something being pushed", toPos));
                } 
            }

            // check traps.
            CheckMapObjectTriggersTraps(map, toPos);
        }

        public void DoShove(Actor actor, Actor target, Point toPos)
        {
            // Target try to leave tile.
            if (!TryActorLeaveTile(target))
            {
                // waste ap.
                SpendActorActionPoints(actor, Rules.BASE_ACTION_COST);
                return;
            }

            // spend AP & STA.
            SpendActorActionPoints(actor, Rules.BASE_ACTION_COST);
            SpendActorStaminaPoints(actor, Rules.DEFAULT_ACTOR_WEIGHT);

            // force target to stop dragging corpses.
            DoStopDraggingCorpses(target);

            // do it : move target, then move actor if he is pushing it away and can enter the tile.
            Map map = target.Location.Map;
            Point prevTargetPos = target.Location.Position;
            map.PlaceActorAt(target, toPos);
            if (!m_Rules.IsAdjacent(toPos, actor.Location.Position) && m_Rules.IsWalkableFor(actor, map, prevTargetPos.X, prevTargetPos.Y))
            {
                // shoving away, need to follow.
                // Try to leave tile.
                if (TryActorLeaveTile(actor))  // alpha10
                {
                    map.RemoveActor(actor);
                    map.PlaceActorAt(actor, prevTargetPos);
                    // Trigger stuff.
                    OnActorEnterTile(actor);
                }
            }

            //hear?
            if (IsAudibleToPlayer(actor.Location, Rules.QUIET_NOISE_RADIUS)) //@@MP - changed from isVisible, because if it's that close we'd hear it even if not seen (Release 5-4)
            {
                if (actor.IsPlayer) //@@MP (Release 3)
                    m_SFXManager.Play(GameSounds.SHOVE_PLAYER, AudioPriority.PRIORITY_EVENT);
                else //@@MP - if it's too far away we'd see it but not hear it. another reason for the change to IsAudibleToPlayer
                    m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.SHOVE_NEARBY, AudioPriority.PRIORITY_BGM);
            }

            // message. //@@MP - separated from hear (Release 5-4)
            bool isVisible = IsVisibleToPlayer(actor) || IsVisibleToPlayer(target) || IsVisibleToPlayer(map, toPos);
            if (isVisible)
            {
                AddMessage(MakeMessage(actor, Conjugate(actor, VERB_SHOVE), target));
                RedrawPlayScreen();
            }

            // if target is sleeping, wakes him up!
            if (target.IsSleeping)
                DoWakeUp(target);

            // Trigger stuff.
            OnActorEnterTile(target);
        }

        public void DoPull(Actor actor, MapObject mapObj, Point moveActorToPos) // alpha10
        {
            bool isVisible = IsVisibleToPlayer(actor) || IsVisibleToPlayer(mapObj);
            int staCost = mapObj.Weight;

            // try leaving tile
            if (!TryActorLeaveTile(actor))
            {
                // waste ap.
                SpendActorActionPoints(actor, Rules.BASE_ACTION_COST);
                return;
            }

            // followers help?
            if (actor.CountFollowers > 0)
                DoPushPullFollowersHelp(actor, mapObj, true, ref staCost);

            // spend AP & STA.
            SpendActorActionPoints(actor, Rules.BASE_ACTION_COST);
            SpendActorStaminaPoints(actor, staCost);

            // do it : move actor then move object
            Map map = mapObj.Location.Map;
            // actor...
            Point pullObjectTo = actor.Location.Position;
            map.RemoveActor(actor);
            map.PlaceActorAt(actor, moveActorToPos);  // assumed to be walkable, checked by rules
            // ...object
            map.RemoveMapObjectAt(mapObj.Location.Position.X, mapObj.Location.Position.Y);
            map.PlaceMapObjectAt(mapObj, pullObjectTo);

            // noise/message.
            if (isVisible)
            {
                AddMessage(MakeMessage(actor, Conjugate(actor, VERB_PULL), mapObj));
                RedrawPlayScreen();
            }
            else
            {
                // loud noise.
                OnLoudNoise(map, mapObj.Location.Position, "Something being pushed");

                // player hears?
                if (m_Rules.RollChance(PLAYER_HEAR_PUSHPULL_CHANCE))
                {
                    AddMessageIfAudibleForPlayer(mapObj.Location, MakePlayerCentricMessage("You hear something being pushed", mapObj.Location.Position));
                }
            }

            // check triggers
            OnActorEnterTile(actor);
            CheckMapObjectTriggersTraps(map, mapObj.Location.Position);
        }

        public void DoPullActor(Actor actor, Actor target, Point moveActorToPos) // alpha10
        {
            bool isVisible = IsVisibleToPlayer(actor) || IsVisibleToPlayer(target);

            // try leaving tile, both actors and target
            if (!TryActorLeaveTile(actor))
            {
                // waste ap.
                SpendActorActionPoints(actor, Rules.BASE_ACTION_COST);
                return;
            }
            if (!TryActorLeaveTile(target))
            {
                // waste ap.
                SpendActorActionPoints(actor, Rules.BASE_ACTION_COST);
                return;
            }

            // spend AP & STA.
            SpendActorActionPoints(actor, Rules.BASE_ACTION_COST);
            SpendActorStaminaPoints(actor, Rules.DEFAULT_ACTOR_WEIGHT);

            // force target to stop dragging corpses.
            DoStopDraggingCorpses(target);

            // do it : move actor then move target
            Map map = target.Location.Map;
            // move actor...
            Point pullTargetTo = actor.Location.Position;
            map.RemoveActor(actor);
            map.PlaceActorAt(actor, moveActorToPos);
            // ...move target
            map.RemoveActor(target);
            map.PlaceActorAt(target, pullTargetTo);

            // if target is sleeping, wakes him up!
            if (target.IsSleeping)
                DoWakeUp(target);

            // message
            if (isVisible)
            {
                AddMessage(MakeMessage(actor, Conjugate(actor, VERB_PULL), target));
                RedrawPlayScreen();
            }

            // Trigger stuff.
            OnActorEnterTile(actor);
            OnActorEnterTile(target);
        }
#endregion

#region -Sleeping & Waking up
        public void DoStartSleeping(Actor actor)
        {
            // spend AP.
            SpendActorActionPoints(actor, Rules.BASE_ACTION_COST);

            // force actor to stop dragging corpses.
            DoStopDraggingCorpses(actor);

            // set activity & state.
            actor.Activity = Activity.SLEEPING;
            actor.IsSleeping = true;
        }

        public void DoWakeUp(Actor actor)
        {
            // set activity & state.
            actor.Activity = Activity.IDLE;
            actor.IsSleeping = false;

            // message.
            if (IsVisibleToPlayer(actor))
            {
                AddMessage(MakeMessage(actor, String.Format("{0}.", Conjugate(actor, VERB_WAKE_UP))));
            }

            // stop sleep music if player.
            if (actor.IsPlayer && m_MusicManager.Track == GameMusics.SLEEP) //alpha 10 added check for specific track
            {
                m_MusicManager.Stop(GameMusics.SLEEP); //@@MP - specified track in response to alpha 10 (Release 6-1)
                CheckAmbientSFX(actor.Location.Map); //@@MP - restart the rain sound if required (Release 5-3)
            }
        }
#endregion

#region -Ordering
        void DoGiveOrderTo(Actor master, Actor slave, ActorOrder order)
        {
            if (master.IsPlayer || slave.IsPlayer) //@@MP (Release 7-4)
                m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.PSST_WHISPER, AudioPriority.PRIORITY_BGM);

            // master spend AP.
            SpendActorActionPoints(master, Rules.BASE_ACTION_COST);

            // refuse if :
            // - master is not slave leader.
            // - slave is not trusting leader.
            if (master != slave.Leader)
            {
                DoSay(slave, master, "Who are you to give me orders?", Sayflags.IS_FREE_ACTION);
                return;
            }
            if (!m_Rules.IsActorTrustingLeader(slave))
            {
                DoSay(slave, master, "Sorry, I don't trust you enough yet.", Sayflags.IS_FREE_ACTION | Sayflags.IS_IMPORTANT);
                return;
            }

            // get AI.
            AIController ai = slave.Controller as AIController;
            if (ai == null)
                return;

            // give order.
            ai.SetOrder(order);

            // message.
            if (IsVisibleToPlayer(master) || IsVisibleToPlayer(slave))
            {
                AddMessage(MakeMessage(master, Conjugate(master, VERB_ORDER), slave, String.Format(" to {0}.", order.ToString())));
            }
        }

        void DoCancelOrder(Actor master, Actor slave)
        {
            // master spend AP.
            SpendActorActionPoints(master, Rules.BASE_ACTION_COST);

            // get AI.
            AIController ai = slave.Controller as AIController;
            if (ai == null)
                return;

            // cancel order.
            ai.SetOrder(null);

            // message.
            if (IsVisibleToPlayer(master) || IsVisibleToPlayer(slave))
            {
                AddMessage(MakeMessage(master, Conjugate(master, VERB_ORDER), slave, " to forget its orders."));
            }
        }
        #endregion

        #region -Misc
        public void DoWait(Actor actor, bool isFishing = false)
        {
#if DEBUG
            /*if (actor.IsPlayer)
            {
                AddMessage(new Message(String.Format("walls = {0}", MapGenerator.CountAdjWalls(actor.Location.Map, actor.Location.Position.X, actor.Location.Position.Y).ToString()),
                    actor.Location.Map.LocalTime.TurnCounter));
                //HandlePlayerDecideUpgrade(m_Player); //@@MP - grant a skill upgrade, for testing only
            }*/
            /*Point mousePos = new Point(-1, -1);
            mousePos = m_UI.UI_GetMousePosition();
            MessageBox.Show(mousePos.X.ToString() + " " + mousePos.Y.ToString());
            MessageBox.Show(m_UI.UI_GetCanvasScaleX().ToString() + " " + m_UI.UI_GetCanvasScaleY().ToString());
            Inventory inv;
            Point itemPos;
            Item it = MouseToInventoryItem(mousePos, out inv, out itemPos);
            MessageBox.Show(it.TheName.ToString());*/
#endif

            // spend AP.
            SpendActorActionPoints(actor, Rules.BASE_ACTION_COST);

            // player is fishing?       //@@MP (Release 7-6)
            if (actor.IsPlayer)// && !actor.IsBotPlayer)
            {
                Item fishingRod = actor.GetEquippedItem(DollPart.LEFT_HAND);
                if (fishingRod != null && fishingRod.Model == GameItems.FISHING_ROD)
                    isFishing = true; //centrally handles the different ways a player can trigger a wait (eg. long and single)
            }

            // message.
            if (IsVisibleToPlayer(actor))
            {
                if (actor.IsOnFire) //@@MP (Release 7-6)
                {
                    if (actor.IsPlayer)
                        AddMessage(MakePlayerCentricMessage("You stop-drop-and-roll to try to extinguish yourself.", actor.Location.Position));
                    else
                        AddMessage(MakeMessage(actor, String.Format("stop-drops-and-rolls to try to extinguish {0}.", HimselfOrHerself(actor))));
                }
                else if (isFishing) //@@MP (Release 7-6)
                    AddMessage(MakeMessage(actor, "is waiting for a fish to bite."));
                else if (actor.StaminaPoints < m_Rules.ActorMaxSTA(actor))
                    AddMessage(MakeMessage(actor, String.Format("{0} {1} breath.", Conjugate(actor, VERB_CATCH), HisOrHer(actor))));
                else if (actor.IsPlayer || (actor.HasLeader && actor.Leader.IsPlayer)) //@@MP - don't tell us unless we may actually care (Release 7-6)
                    AddMessage(MakeMessage(actor, String.Format("{0}.", Conjugate(actor, VERB_WAIT))));
            }

            // regen STA?
            if (!actor.IsOnFire)             //@@MP - added IsOnFire prerequisite (Release 7-6)
                RegenActorStaminaPoints(actor, Rules.STAMINA_REGEN_WAIT);
            // extinguish fire on actor?     //@@MP (Release 7-6)
            else if (m_Rules.RollChance(ON_WAIT_EXTINGUISH_FIRE_CHANCE))
                ExtinguishOnFireActor(actor);

            // caught a fish?           //@@MP (Release 7-6)
            #region
            if (isFishing)
            {
                bool caughtFish = true;
                if (actor.IsPlayer && !actor.IsBotPlayer)
                {
                    //calculate chance based on Options.ResourcesAvailability
                    int catchFishChance = CATCHING_FISH_BASE_CHANCE;
                    if (s_Options.ResourcesAvailability == GameOptions.Resources.HIGH)
                        catchFishChance = CATCHING_FISH_BASE_CHANCE * 2;
                    else if (s_Options.ResourcesAvailability == GameOptions.Resources.LOW)
                        catchFishChance = (int)(CATCHING_FISH_BASE_CHANCE * 0.5);
                    //further boost to chances from any levels in Unsuspicious skill
                    catchFishChance = Math.Max(catchFishChance, (catchFishChance + m_Rules.ActorFishingChanceFromUnsuspiciousSkill(actor)));

                    if (!m_Rules.RollChance(catchFishChance))
                        caughtFish = false;
                }

                if (caughtFish)
                {
                    //SFX & msg
                    if (actor.IsPlayer)
                    {
                        if (m_SFXManager.IsPlaying(GameSounds.FISHING_CAST_PLAYER)) //if the player is quick, this may not finish playing before the reeling SFX starts
                            m_SFXManager.Stop(GameSounds.FISHING_CAST_PLAYER);
                        m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.FISHING_REEL_PLAYER, AudioPriority.PRIORITY_EVENT);

                        AddMessageIfAudibleForPlayer(actor.Location, MakeMessage(actor, "caught a fish!"));  //this particular message function interrupts long-waiting - perfect for fishing
                    }
                    else if (IsAudibleToPlayer(actor.Location, Rules.QUIET_NOISE_RADIUS))
                    {
                        if (m_SFXManager.IsPlaying(GameSounds.FISHING_CAST_NEARBY)) //NPCs only have to wait 1 turn before they "land" a fish, so this may not finish playing before the reeling SFX starts
                            m_SFXManager.Stop(GameSounds.FISHING_CAST_NEARBY);
                        m_SFXManager.PlayIfNotAlreadyPlaying(GameSounds.FISHING_REEL_NEARBY, AudioPriority.PRIORITY_BGM);

                        if (IsVisibleToPlayer(actor))
                            AddMessage(MakeMessage(actor, "caught a fish."));
                    }

                    //fish
                    Item fish = new ItemFood(GameItems.RAW_FISH, actor.Location.Map.LocalTime.TurnCounter + (WorldTime.TURNS_PER_DAY * GameItems.RAW_FISH.BestBeforeDays), true, true);
                    if (actor.Inventory.CanAddAtLeastOne(fish))
                        actor.Inventory.AddAll(fish);
                    else
                        DropItem(actor, fish, true);

                    //feels good
                    if (actor.Model.Abilities.HasSanity)
                        RegenActorSanity(actor, m_Rules.ActorSanRegenValue(actor, Rules.SANITY_RECOVER_CHAT_OR_TRADE));

                    //Logger.WriteLine(Logger.Stage.RUN_MAIN, String.Format("{0}: {1} caught a fish!", m_Session.WorldTime.TurnCounter.ToString(), actor.Name));

                    //finish fishing
                    if (actor.GetEquippedItem(DollPart.LEFT_HAND) != null) //handles simulated AI in other districts
                        DoUnequipItem(actor, actor.GetEquippedItem(DollPart.LEFT_HAND), false);
                }
            }
#endregion
        }

        public bool DoPlayerBump(Actor player, Direction direction)
        {
            ActionBump bump = new ActionBump(player, this, direction);

            if (bump == null)
                return false;

            if (bump.IsLegal())
            {
                ClearOverlays(); //@@MP - workaround for some overlays that get stuck eg Tip of Day, RIP (Release 7-2)
                bump.Perform();
                return true;
            }

            #region DoorWindow special cases
            DoorWindow door = player.Location.Map.GetMapObjectAt(player.Location.Position + direction) as DoorWindow;

            //1. unopenable ('locked') doors
            if (door != null && door.IsLocked) //@@MP - moved this check from Engine\Rules : CanActorGetItemFromContainer() (Release 5-3)
            {
                if (IsInArmyOffice(door.Location)) //@@MP - added check for army office pass card (Release 6-3)
                {
                    //if (player.Inventory.HasItemMatching((it) => it.Model == GameItems.UNIQUE_ARMY_ACCESS_BADGE))
                    if (player.Inventory.Contains(m_Session.UniqueItems.TheArmyOfficePass.TheItem))
                    {
                        Map map = door.Location.Map;
                        Point pt = new Point(door.Location.Position.X, door.Location.Position.Y);
                        //remove the current door
                        map.RemoveMapObjectAt(pt.X, pt.Y);
                        //replace it with the standard, unlocked iron door. it's replaced rather than SetState to reset the hitpoints to standard
                        map.PlaceMapObjectAt(m_TownGenerator.MakeObjIronDoor(DoorWindow.STATE_CLOSED), pt);
                        m_SFXManager.Play(GameSounds.ACCESS_GRANTED, AudioPriority.PRIORITY_EVENT);
                        AddMessage(new Message("You've unlocked the door with the army access card.", m_Session.WorldTime.TurnCounter, Color.Yellow));
                        return true;
                    }
                    else
                    {
                        m_SFXManager.Play(GameSounds.ACCESS_DENIED, AudioPriority.PRIORITY_EVENT);
                        AddMessage(MakeErrorMessage("This door is locked. Looks like it needs an access card."));
                        RedrawPlayScreen();
                        return false;
                    }
                }
                else
                {
                    m_SFXManager.Play(GameSounds.BASH_OTHER_OBJECTS_NEARBY, AudioPriority.PRIORITY_EVENT); //@@MP (Release 6-3)
                    AddMessage(MakeErrorMessage("This door cannot be opened."));
                    RedrawPlayScreen();
                    return false;
                }
            }

            //2. tearing down barricades as living
            if (door != null && door.IsBarricaded && !player.Model.Abilities.IsUndead) //barricaded doors
            {
                if (!m_Rules.IsActorTired(player))
                {
                    // ask for confirmation.
                    AddMessage(MakeYesNoMessage("Really tear down the barricade"));
                    RedrawPlayScreen();
                    bool confirm = WaitYesOrNo();

                    if (confirm)
                    {
                        DoBreak(player, door);
                        return true;
                    }
                    else
                    {
                        AddMessage(new Message("Good, keep everything secure.", m_Session.WorldTime.TurnCounter, Color.Yellow));
                        return false;
                    }
                }
                else
                {
                    AddMessage(MakeErrorMessage("Too tired to tear down the barricade."));
                    RedrawPlayScreen();
                    return false;
                }
            }
            #endregion

            #region MapObject special cases
            MapObject mapObj = player.Location.Map.GetMapObjectAt(player.Location.Position + direction);
            if (mapObj != null)
            {
                // 3. change clothes and hair (wigs)   //@@MP (Release 7-6)
                if (mapObj.ImageID == GameImages.OBJ_CLOTHES_WALL1)
                {
                    AddMessage(MakeYesNoMessage("Do you want to change your shirt"));
                    RedrawPlayScreen();
                    if (WaitYesOrNo())
                    {
                        BaseTownGenerator.RandomiseTorsoClothing(new DiceRoller(), player);
                    }
                    ClearMessages();
                    RedrawPlayScreen();
                    return true;
                }
                else if (mapObj.ImageID == GameImages.OBJ_CLOTHES_WALL2)
                {
                    AddMessage(MakeYesNoMessage("Do you want to change your pants/skirt"));
                    RedrawPlayScreen();
                    if (WaitYesOrNo())
                    {
                        BaseTownGenerator.RandomiseLegsClothing(new DiceRoller(), player);
                    }
                    ClearMessages();
                    RedrawPlayScreen();
                    return true;
                }
                else if (mapObj.ImageID == GameImages.OBJ_SHOES_WALL)
                {
                    AddMessage(MakeYesNoMessage("Do you want to change your shoes"));
                    RedrawPlayScreen();
                    if (WaitYesOrNo())
                    {
                        BaseTownGenerator.RandomiseShoes(new DiceRoller(), player);
                    }
                    ClearMessages();
                    RedrawPlayScreen();
                    return true;
                }
                else if (mapObj.ImageID == GameImages.OBJ_WIGS_DISPLAY1 || mapObj.ImageID == GameImages.OBJ_WIGS_DISPLAY2 || mapObj.ImageID == GameImages.OBJ_WIGS_DISPLAY3)
                {
                    AddMessage(MakeYesNoMessage("Do you want to change your hairstyle"));
                    RedrawPlayScreen();
                    if (WaitYesOrNo())
                    {
                        BaseTownGenerator.RandomiseHair(new DiceRoller(), player);
                    }
                    ClearMessages();
                    RedrawPlayScreen();
                    return true;
                }

                // 4. cooking fires   //@@MP (Release 7-6)
                if (mapObj.IsOnFire && ((mapObj is Campfire) || (mapObj is Barrel)))
                {
                    if (player.Inventory.HasItemOfType(typeof(ItemBarricadeMaterial)))
                    {
                        AddMessage(MakeYesNoMessage(String.Format("Add more wood to {0}", mapObj.TheName)));
                        RedrawPlayScreen();
                        if (WaitYesOrNo())
                        {
                            ClearMessages();
                            AddMessage(MakeMessage(player, String.Format("adds more wood to {0}.", mapObj.TheName)));
                            IncreaseCookingFireFuel(player, mapObj);
                            RedrawPlayScreen();
                            return true;
                        }
                        ClearMessages();
                        RedrawPlayScreen();
                        //continue on, as there may be items there to pick up (OnFire Barrels and Campfires act as containers)
                    }
                }

                // 5. army rescue helicopter (endgame) //@@MP (Release 6-4)
                if (mapObj.AName == "a helicopter")
                {
                    // ask for confirmation.
                    AddMessage(MakeYesNoMessage("Really escape on the helicopter and finish the game"));
                    RedrawPlayScreen();
                    bool confirm = WaitYesOrNo();

                    if (confirm)
                    {
                        // completed achievement!
                        m_Session.Scoring.SetCompletedAchievement(Achievement.IDs.RESCUED_BY_HELICOPTER);
                        ShowNewAchievement(Achievement.IDs.RESCUED_BY_HELICOPTER);

                        // now rescue
                        ClearMessages();
                        RedrawPlayScreen();
                        PlayerWasRescued();
                        return true;
                    }
                    else
                    {
                        ClearMessages();
                        AddMessage(new Message("Ok, but remember, it won't wait for long...", m_Session.WorldTime.TurnCounter, Color.Yellow));
                        RedrawPlayScreen();
                        return false;
                    }
                }

                // 6. Non-special checks         @@MP - moved the from Engine\Rules : CanActorGetItemFromContainer() (Release 5-3), moved below doors (Release 6-3)
                if (mapObj.IsJumpable && player.StaminaPoints < Rules.STAMINA_MIN_FOR_ACTIVITY)
                {
                    AddMessage(MakeErrorMessage("Not enough stamina to climb on that"));
                    RedrawPlayScreen();
                    return false;
                }
                else if (!mapObj.IsContainer) //@@MP - swapped the if and else ifs (Release 6-2)
                {
                    if (mapObj.ImageID == GameImages.OBJ_BANK_SAFE_CLOSED) //@@MP - custom message to help the player understand that they can only use open safes (Release 6-5)
                        AddMessage(MakeErrorMessage("That safe is locked by someone else"));
                    else
                        AddMessage(MakeErrorMessage("Cannot climb on that"));

                    RedrawPlayScreen();
                    return false;
                }
            }
            #endregion

            AddMessage(MakeErrorMessage(String.Format("Cannot do that : {0}.", bump.FailReason)));
            return false;
        }

        void OnLoudNoise(Map map, Point noisePosition, string noiseName)
        {
            ////////////////////////////////////////////
            // Check if nearby sleeping actors wake up.
            // Check long wait interruption.
            ////////////////////////////////////////////
            int xmin = noisePosition.X - Rules.LOUD_NOISE_RADIUS;
            int xmax = noisePosition.X + Rules.LOUD_NOISE_RADIUS;
            int ymin = noisePosition.Y - Rules.LOUD_NOISE_RADIUS;
            int ymax = noisePosition.Y + Rules.LOUD_NOISE_RADIUS;
            map.TrimToBounds(ref xmin, ref ymin);
            map.TrimToBounds(ref xmax, ref ymax);

            ///////////////////////////
            // Waking up nearby actors.
            ///////////////////////////
            for (int x = xmin; x <= xmax; x++)
            {
                for (int y = ymin; y <= ymax; y++)
                {
                    // sleeping actor?
                    Actor actor = map.GetActorAt(x, y);
                    if (actor == null || !actor.IsSleeping)
                        continue;

                    // ignore if too far.
                    int noiseDistance = m_Rules.GridDistance(noisePosition, x, y);
                    if (noiseDistance > Rules.LOUD_NOISE_RADIUS)
                        continue;

                    // roll chance of waking up.
                    int wakeupChance = m_Rules.ActorLoudNoiseWakeupChance(actor, noiseDistance);
                    if (!m_Rules.RollChance(wakeupChance))
                        continue;

                    // wake up!
                    if (actor.BloodAlcohol < Rules.BLACKOUT_DRUNK_LEVEL) //@@MP - can't wake up if passed out (Release 7-1)
                        DoWakeUp(actor);

                    if (IsVisibleToPlayer(actor))
                    {
                        AddMessage(new Message(String.Format("{0} wakes {1} up!", noiseName, actor.TheName), map.LocalTime.TurnCounter, actor == m_Player ? Color.Red : Color.White));
                        RedrawPlayScreen();
                    }
#if DEBUGAILOOPING
                    if (actor.IsLooping) //(map.District == m_Player.Location.Map.District)
                        Logger.WriteLine(Logger.Stage.RUN_MAIN, String.Format("[#{0}] {1} woken up by loud noise: {2}", map.LocalTime.TurnCounter.ToString(), actor.Name, noiseName));
#endif
                }
            }

            ///////////////////////////
            // Interrupting long wait.
            ///////////////////////////
            if (m_IsPlayerLongWait && map == m_Player.Location.Map && IsVisibleToPlayer(map,noisePosition))
                m_IsPlayerLongWaitForcedStop = true;
        }

        void DoUsePaintThinner(Actor actor, ItemSprayPaint thinner, Point pos) //@@MP - added (Release 7-6)
        {
            // spend AP.
            SpendActorActionPoints(actor, Rules.BASE_ACTION_COST);

            // spend paint.
            --thinner.PaintQuantity;

            // add tag decoration.
            Map map = actor.Location.Map;
            map.GetTileAt(pos.X, pos.Y).RemoveAllDecorations();

            // message.
            if (actor.IsPlayer)
                m_SFXManager.Play(GameSounds.SPRAY_TAG, AudioPriority.PRIORITY_EVENT);
            if (IsVisibleToPlayer(actor))
                AddMessage(MakeMessage(actor, String.Format("{0} removes a spray tag.", Conjugate(actor, VERB_REMOVE))));

            // discard empty spray   ///@@MP (Release 7-5)
            if (thinner.PaintQuantity <= 0)
            {
                DiscardItem(actor, thinner);
                if (actor.IsPlayer)
                    AddMessage(new Message("Paint thinner can is now empty and has been discarded.", map.LocalTime.TurnCounter));
            }
        }

        void DoUseFireExtinguisher(Actor sprayer, ItemSprayPaint extinguisher, Location loc) //@@MP - added (Release 7-6)
        {
            // spend AP.
            SpendActorActionPoints(sprayer, Rules.BASE_ACTION_COST);

            // spend paint.
            --extinguisher.PaintQuantity;

            // extinguish ALL fires there.
            MapObject mapObj = sprayer.Location.Map.GetMapObjectAt(loc.Position);
            if (mapObj != null && mapObj.IsOnFire)
                UnapplyOnFire(mapObj);
            Actor target = sprayer.Location.Map.GetActorAt(loc.Position);
            if (target != null && target.IsOnFire)
                ExtinguishOnFireActor(target);
            Tile tile = sprayer.Location.Map.GetTileAt(loc.Position);
            if (tile != null && tile.IsOnFire)
                ExtinguishOnFireTile(tile);

            // message.
            if (sprayer.IsPlayer)
                m_SFXManager.Play(GameSounds.FIRE_EXTINGUISHER_PLAYER, AudioPriority.PRIORITY_EVENT);
            else if (IsAudibleToPlayer(loc, Rules.QUIET_NOISE_RADIUS))
                m_SFXManager.Play(GameSounds.FIRE_EXTINGUISHER_NEARBY, AudioPriority.PRIORITY_BGM);
            if (IsVisibleToPlayer(loc))
                AddMessage(MakeMessage(sprayer, String.Format("{0} extinguishes the fire.", Conjugate(sprayer, VERB_REMOVE))));

            // discard empty spray   ///@@MP (Release 7-5)
            if (extinguisher.PaintQuantity <= 0)
            {
                DiscardItem(sprayer, extinguisher);
                if (sprayer.IsPlayer)
                    AddMessage(new Message("Fire extinguisher is now empty and has been discarded.", sprayer.Location.Map.LocalTime.TurnCounter));
            }
        }

        void DoTag(Actor actor, ItemSprayPaint spray, Point pos)
        {
            // spend AP.
            SpendActorActionPoints(actor, Rules.BASE_ACTION_COST);

            // spend paint.
            --spray.PaintQuantity;

            // add tag decoration.
            Map map = actor.Location.Map;
            map.GetTileAt(pos.X, pos.Y).AddDecoration((spray.Model as ItemSprayPaintModel).TagImageID);

            // message.
            if (actor.IsPlayer) //@@MP (Release 2)
                m_SFXManager.Play(GameSounds.SPRAY_TAG, AudioPriority.PRIORITY_EVENT);
            if (IsVisibleToPlayer(actor))
                AddMessage(MakeMessage(actor, String.Format("{0} a tag.", Conjugate(actor, VERB_SPRAY))));

            // discard empty spray   ///@@MP (Release 7-5)
            if (spray.PaintQuantity <= 0)
            {
                DiscardItem(actor, spray);
                if (actor.IsPlayer)
                    AddMessage(new Message("Spray can is now empty and has been discarded.", map.LocalTime.TurnCounter));
            }
        }

        public void DoSprayOdorSuppressor(Actor actor, ItemSprayScent suppressor, Actor sprayOn) // alpha10 new way to use spray scent
        {
            // spend AP.
            SpendActorActionPoints(actor, Rules.BASE_ACTION_COST);

            // spend spray.
            --suppressor.SprayQuantity;

            // add odor suppressor on spray target
            sprayOn.OdorSuppressorCounter += suppressor.Strength;

            // message.
            if (actor.IsPlayer) //@@MP (Release 7-4)
                m_SFXManager.Play(GameSounds.SPRAY_SCENT, AudioPriority.PRIORITY_EVENT);
            if (IsVisibleToPlayer(actor))
                AddMessage(MakeMessage(actor, string.Format("{0} {1}.", Conjugate(actor, VERB_SPRAY), (sprayOn == actor ? HimselfOrHerself(actor) : sprayOn.Name))));

            // discard empty spray   ///@@MP (Release 7-5)
            if (suppressor.SprayQuantity <= 0)
            {
                DiscardItem(actor, suppressor);
                if (actor.IsPlayer)
                    AddMessage(new Message("Spray bottle is now empty and has been discarded.", actor.Location.Map.LocalTime.TurnCounter));
            }
        }

        public void DoSwitchPowerGenerator(Actor actor, PowerGenerator powGen)
        {
            // spend AP.
            SpendActorActionPoints(actor, Rules.BASE_ACTION_COST);

            // switch it.
            powGen.TogglePower();

            // message.
            if (actor.IsPlayer) //@@MP (Release 2)
            {
                m_SFXManager.Play(GameSounds.TORCH_CLICK_PLAYER, AudioPriority.PRIORITY_EVENT); //@@MP reuse the sound
            }
            else if (IsVisibleToPlayer(actor) || IsVisibleToPlayer(powGen))
            {
                AddMessage(MakeMessage(actor, Conjugate(actor, VERB_SWITCH), powGen, powGen.IsOn ? " on." : " off."));
            }

            // check for special effects.
            OnMapPowerGeneratorSwitch(actor.Location); //@@MP - unused parameter (Release 5-7)
        }

        public void DoMakeFireForCooking(Actor actor, Point firePos) //@@MP - added (Release 7-6)
        {
            bool usedWood = false;

            MapObject mapObj = actor.Location.Map.GetMapObjectAt(firePos);
            if (mapObj != null) //there's an empty barrel or unlit campfire there
            {
                Barrel barrel = mapObj as Barrel;
                if (barrel != null)
                {
                    if (barrel.FuelUnits <= 0)
                    {
                        usedWood = true;
                        IncreaseCookingFireFuel(actor, barrel);
                    }
                    ApplyOnFire(barrel); // now light it
                }
                Campfire campfire = mapObj as Campfire;
                if (campfire != null)
                {
                    if (campfire.FuelUnits <= 0)
                    {
                        usedWood = true;
                        IncreaseCookingFireFuel(actor, campfire);
                    }
                    ApplyOnFire(campfire); // now light it
                }
            }
            else //need to make a campfire
            {
                usedWood = true;
                MapObject newCampfire = BaseMapGenerator.MakeObjCampfire(GameImages.OBJ_CAMPFIRE);
                actor.Location.Map.PlaceMapObjectAt(newCampfire, firePos);
                IncreaseCookingFireFuel(actor, newCampfire);
                ApplyOnFire(newCampfire); // now light it
            }

            //use up a match
            Item matches = actor.Inventory.GetSmallestStackByModel(GameItems.MATCHES);
            actor.Inventory.Consume(matches);

            // message.
            if (actor.IsPlayer)
                m_SFXManager.Play(GameSounds.MATCH_STRIKE_START_FIRE_PLAYER, AudioPriority.PRIORITY_EVENT);
            if (IsVisibleToPlayer(actor) || IsVisibleToPlayer(mapObj))
            {
                if (usedWood)
                    AddMessage(MakeMessage(actor, "starts a fire with some wood."));
                else
                    AddMessage(MakeMessage(actor, "reignites a fire."));
            }
        }

        static void IncreaseCookingFireFuel(Actor actor, MapObject mapObj) //@@MP - added (Release 7-6)
        {
            ItemBarricadeMaterial wood = actor.Inventory.GetSmallestStackByType(typeof(ItemBarricadeMaterial)) as ItemBarricadeMaterial; // smallest stack first
            actor.Inventory.Consume(wood);

            Barrel barrel = mapObj as Barrel;
            if (barrel != null)
            {
                barrel.FuelUnits = Math.Min(barrel.FuelUnits += (FIRE_FUEL_PER_WOOD_PLANK * 4), barrel.MaxFuelUnits);
                return;
            }
            Campfire campfire = mapObj as Campfire;
            if (campfire != null)
            {
                campfire.FuelUnits = Math.Min(campfire.FuelUnits += FIRE_FUEL_PER_WOOD_PLANK, campfire.MaxFuelUnits);
                return;
            }
        }
#endregion
#endregion

#region IMPARTED ON ACTORS
#region -Damaging, Killing and Disarming actors **
        /// <summary>
        /// 
        /// </summary>
        /// <param name="victim">the one receiving the damage</param>
        /// <param name="dmg"></param>
        /// <param name="splatterBlood">Should the damage splatter blood?</param>
        /// <param name="fireCaused">Was the damage caused by fire?</param>
        /// <param name="attacker"></param>
        void InflictDamage(Actor victim, int dmg, bool splatterBlood, bool fireCausedIt, Actor attacker = null)
        {
            //@@MP - made blood splatter optional, for times where it doesn't make sense eg fires (Release 5-2)
            //@@MP - added flag to differentiate fire as the damage source (Release 7-1)
            //@@MP - added Attacker for the new damage options (Release 7-4)

            // Damage option modifier
            double dmgTmp = dmg;
            if (attacker != null) //it's damage directly caused by an attacker
            {
                dmgTmp = attacker.Model.Abilities.IsUndead ? dmgTmp * s_Options.UndeadDamagePercent : dmgTmp * s_Options.LivingDamagePercent;
                dmg = (int)Math.Round(dmgTmp / 100, 0, MidpointRounding.AwayFromZero); //divide by 100 because its a percentage
            }

            // Stamina.
            if (victim.Model.Abilities.CanTire)
                victim.StaminaPoints -= dmg;

            // Armor.
            Item torsoItem = victim.GetEquippedItem(DollPart.TORSO);
            if (torsoItem != null)
            {
                ItemBodyArmor armor = torsoItem as ItemBodyArmor;
                if (armor != null)
                {
                    //Is it fire resistant? //@@MP - added (Release 7-1)
                    if (fireCausedIt)
                    {
                        // wearing a fire hazard suit blocks fire damage

                        dmg -= (dmg * (armor.Fire_Resistance / 100));
                    }

                    //Body armor breaks?
                    if (m_Rules.RollChance(Rules.BODY_ARMOR_BREAK_CHANCE))
                    {
                        // do it.
                        OnUnequipItem(victim, torsoItem);
                        victim.Inventory.RemoveAllQuantity(torsoItem);

                        // message.
                        if (IsVisibleToPlayer(victim))
                        {
                            AddMessage(MakeMessage(victim, String.Format(": {0} breaks and is now useless!", torsoItem.TheName)));
                            RedrawPlayScreen();
                            if (victim.IsPlayer)
                                AnimDelay(DELAY_NORMAL, true);
                        }
                    }
                }
            }

            // HP.
            if (!fireCausedIt || !GameActors.IsSkeletonBranch(victim.Model)) //@@MP - flame weapons don't hurt skeletons (Release 7-2)
            {
                victim.HitPoints -= dmg;
            }

            //@@MP - splatter bood (Release 2)
            if (splatterBlood && (!victim.Model.Abilities.IsUndead) && (victim.HitPoints > 0)) //@@MP - added check whether we even want to splatter blood (Release 5-2)
            {
                /*if (actor.Location.Map.District != m_Player.Location.Map.District)
                {
                    if (m_Rules.RollChance(60)) //60% chance to generate a splatter, because simulations only create minor amounts of attacks, so beef up the splatter rate
                        SplatterBlood(actor.Location.Map, actor.Location.Position, true);
                }
                else
                {*/
                if (m_Rules.RollChance(30)) //30% chance to generate a splatter
                    SplatterBlood(victim.Location.Map, victim.Location.Position, true);
            }

            // If fishing, force unequip fishing rod        //@@MP (Release 7-6)
            if (victim.GetEquippedItem(DollPart.LEFT_HAND) != null && victim.GetEquippedItem(DollPart.LEFT_HAND).Model == GameItems.FISHING_ROD)
                DoUnequipItem(victim, victim.GetEquippedItem(DollPart.LEFT_HAND), false);

            // If sleeping, wake up dude!
            if (victim.IsSleeping)
                DoWakeUp(victim);
        }

        public void KillActor(Actor killer, Actor deadGuy, string reason, bool causedByFire = false, bool canDropCorpse = true) // alpha10, drop corpse optional. //@@MP- added causedByFire (Release 8-1)
        {
            /*// Sanity check.
#if false
            for some reason, this can happen with starved actors. no f*****g idea why since this is the only place where we set the dead flag.
            if (deadGuy.IsDead)
                throw new InvalidOperationException(String.Format("killing deadGuy that is already dead : killer={0} deadGuy={1} reason={2}", (
                    killer == null ? "N/A" : killer.TheName), deadGuy.TheName, reason));
#endif*/

            // Set dead flag.
            deadGuy.IsDead = true;

            // force to stop dragging corpses.
            DoStopDraggingCorpses(deadGuy);

            // put them out if on fire             //@@MP (Release 7-6)
            ExtinguishOnFireActor(deadGuy); //remove the flames from the corpse

            // untrigger all traps here.
            UntriggerAllTrapsHere(deadGuy.Location);

            // living killing an undead = restore sanity. 
            if (killer != null && !killer.Model.Abilities.IsUndead && killer.Model.Abilities.HasSanity)
            {
                if (deadGuy.Model.Abilities.IsUndead)
                    RegenActorSanity(killer, m_Rules.ActorSanRegenValue(killer, Rules.SANITY_RECOVER_KILL_UNDEAD));
                else if (deadGuy.Model.Abilities.IsLivingAnimal)    //@@MP - added (Release 7-6)
                    RegenActorSanity(killer, m_Rules.ActorSanRegenValue(killer, WorldTime.TURNS_PER_HOUR)); //a successful hunt for meat
            }

            // death of bonded leader/follower hits sanity.
            if (deadGuy.HasLeader)
            {
                if (m_Rules.HasActorBondWith(deadGuy.Leader, deadGuy))
                {
                    SpendActorSanity(deadGuy.Leader, Rules.SANITY_HIT_BOND_DEATH);
                    if (IsVisibleToPlayer(deadGuy.Leader))
                    {
                        if (deadGuy.Leader.IsPlayer && !deadGuy.Leader.IsBotPlayer)
                            ClearMessages();
                        AddMessage(MakeMessage(deadGuy.Leader, String.Format("{0} deeply disturbed by {1} sudden death!", Conjugate(deadGuy.Leader, VERB_BE), deadGuy.Name)));
                        if (deadGuy.Leader.IsPlayer && !deadGuy.Leader.IsBotPlayer)
                            AddMessagePressEnter();
                    }
                }
            }
            else if (deadGuy.CountFollowers > 0)
            {
                foreach (Actor fo in deadGuy.Followers)
                {
                    if (m_Rules.HasActorBondWith(fo, deadGuy))
                    {
                        SpendActorSanity(fo, Rules.SANITY_HIT_BOND_DEATH);
                        if (IsVisibleToPlayer(fo))
                        {
                            if (fo.IsPlayer && !fo.IsBotPlayer)
                                ClearMessages();
                            AddMessage(MakeMessage(fo, String.Format("{0} deeply disturbed by {1} sudden death!", Conjugate(fo, VERB_BE), deadGuy.Name)));
                            if (fo.IsPlayer && !fo.IsBotPlayer)
                                AddMessagePressEnter();
                        }
                    }
                }
            }

            // Unique actor?
            if (deadGuy.IsUnique)
            {
                if (killer != null)
                    m_Session.Scoring.AddEvent(deadGuy.Location.Map.LocalTime.TurnCounter, String.Format("* {0} was killed by {1} {2}! *", deadGuy.TheName, killer.Model.Name, killer.TheName));
                else
                    m_Session.Scoring.AddEvent(deadGuy.Location.Map.LocalTime.TurnCounter, String.Format("* {0} died, reason: {1}! *", deadGuy.TheName, reason));
            }

            // Player dead?
            // BEFORE removing followers & dropping items.
            if (deadGuy == m_Player)
                PlayerDied(killer, reason);
            else
                deadGuy.CauseOfDeath = reason; //@@MP (Release 7-6)

            // Remove aggressor & self defence relations.
            bool wasMurder = (killer != null && m_Rules.IsMurder(killer, deadGuy));
            deadGuy.RemoveAllAgressorSelfDefenceRelations();

            // Remove followers.
            deadGuy.RemoveAllFollowers();

            // Remove from leader.
#region
            if (deadGuy.Leader != null)
            {
                // player's follower killed : scoring and message.
                if (deadGuy.Leader.IsPlayer)
                {
                    string deathEvent;
                    if (killer != null)
                        deathEvent = String.Format("Follower {0} was killed by {1} {2}!", deadGuy.TheName, killer.Model.Name, killer.TheName);
                    else
                        deathEvent = String.Format("Follower {0} died by {1}!", deadGuy.TheName, reason);
                    m_Session.Scoring.AddEvent(deadGuy.Location.Map.LocalTime.TurnCounter, deathEvent);
                }

                deadGuy.Leader.RemoveFollower(deadGuy);
            }
#endregion

            // Remove from map.
            deadGuy.Location.Map.RemoveActor(deadGuy);

            // Drop inventory items.
#region
            if (deadGuy.Inventory != null && !deadGuy.Inventory.IsEmpty)
            {
                int deadItemsCount = deadGuy.Inventory.CountItems;
                Item[] dropThem = new Item[deadItemsCount];
                for (int i = 0; i < dropThem.Length; i++)
                    dropThem[i] = deadGuy.Inventory[i];
                for (int i = 0; i < dropThem.Length; i++)
                {
                    Item it = dropThem[i];
                    int chance = (it is ItemAmmo || it is ItemFood) ? Rules.VICTIM_DROP_AMMOFOOD_ITEM_CHANCE : Rules.VICTIM_DROP_GENERIC_ITEM_CHANCE;
                    if (it.Model.IsUnbreakable || it.IsUnique || m_Rules.RollChance(chance))
                        DropItem(deadGuy, it, true);
                }
            }
            #endregion

            // See and hear?              //@@MP (Release 7-6)
#region
            // blood splat
            if (!deadGuy.Model.Abilities.IsUndead && !deadGuy.Model.Abilities.IsLivingAnimal)
                SplatterBlood(deadGuy.Location.Map, deadGuy.Location.Position, false);

            // Remains
            // note: corpses cause larger saved games and slow turn processing
            if (deadGuy.Model.Abilities.IsUndead)
                UndeadRemains(deadGuy.Location.Map, deadGuy.Location.Position, deadGuy.TheName, causedByFire);
            else if (canDropCorpse)
                DropCorpse(deadGuy);

            if (!deadGuy.Model.Abilities.IsUndead && !deadGuy.Model.Abilities.IsLivingAnimal && !deadGuy.IsSleeping && killer != null && killer.Model.Abilities.IsUndead)
            {
                // loud noise.
                OnLoudNoise(deadGuy.Location.Map, deadGuy.Location.Position, "A loud SCREAM");
                // player hears?
                DoScream(deadGuy.Location, deadGuy.Model.DollBody.IsMale, true, false);
            }
#endregion

            // One more kill
            if (killer != null)
                ++killer.KillsCount;

            // Player scoring
            if (killer == m_Player)
                PlayerKill(deadGuy);

            // Undead level up?
#region
            if (killer != null && Rules.HasEvolution(m_Session.GameMode))
            {
                if (killer.Model.Abilities.IsUndead)
                {
#region
                    // check for evolution.
                    ActorModel levelUpModel = CheckUndeadEvolution(killer);
                    if (levelUpModel != null)
                    {
                        // Remember skills if any.
                        SkillTable savedSkills = null;
                        if (killer.Sheet.SkillTable != null && killer.Sheet.SkillTable.Skills != null)
                            savedSkills = new SkillTable(killer.Sheet.SkillTable.Skills);

                        // Do the transformation.
                        killer.Model = levelUpModel;

                        // If player, make sure it is setup properly.
                        if (killer.IsPlayer)
                            PrepareActorForPlayerControl(killer);

                        // If had skills, give them back.
                        if (savedSkills != null)
                        {
                            foreach (Skill s in savedSkills.Skills)
                                for (int i = 0; i < s.Level; i++)
                                {
                                    killer.Sheet.SkillTable.AddOrIncreaseSkill(s.ID);
                                    OnSkillUpgrade(killer, (Skills.IDs)s.ID);
                                }
                            m_TownGenerator.RecomputeActorStartingStats(killer);
                        }

                        // Message.
                        if (IsVisibleToPlayer(killer))
                        {
                            AddOverlay(new OverlayRect(Color.Yellow, new Rectangle(MapToScreen(killer.Location.Position), new Size(TILE_SIZE, TILE_SIZE))));
                            AddMessage(MakeMessage(killer, String.Format("{0} a {1} horror!", Conjugate(killer, VERB_TRANSFORM_INTO), levelUpModel.Name)));
                            RedrawPlayScreen();
                            AnimDelay(DELAY_NORMAL,false);
                            ClearOverlays();
                        }
                    }
#endregion
                }
            }
#endregion

            // Trust : leader killing a follower target or adjacent enemy.
            if (killer != null && killer.CountFollowers > 0)
            {
                foreach (Actor fo in killer.Followers)
                {
                    bool gainTrust = false;
                    if (fo.TargetActor == deadGuy || (m_Rules.AreEnemies(fo, deadGuy) && m_Rules.IsAdjacent(fo.Location, deadGuy.Location)))
                        gainTrust = true;

                    if (gainTrust)
                    {
                        DoSay(fo, killer, "That was close! Thanks for the help!!", Sayflags.IS_FREE_ACTION);
                        ModifyActorTrustInLeader(fo, Rules.TRUST_LEADER_KILL_ENEMY, true);
                    }
                }
            }

            // Murder?
#region
            if (wasMurder)
            {
                // one more murder.
                ++killer.MurdersCounter;

                // if player, log.
                if (killer.IsPlayer)
                    m_Session.Scoring.AddEvent(m_Session.WorldTime.TurnCounter, String.Format("Murdered {0} a {1}!", deadGuy.TheName, deadGuy.Model.Name));
                // message.
                if (IsVisibleToPlayer(killer))
                    AddMessage(MakeMessage(killer, String.Format("murdered {0}!!", deadGuy.Name)));

                // check for npcs law enforcers witnessing the murder.
                Map map = killer.Location.Map;
                Point killerPos = killer.Location.Position;
                foreach (Actor a in map.Actors)
                {
                    // check ability and state/relationship
                    if (!a.Model.Abilities.IsLawEnforcer || a.IsDead || a.IsSleeping || a.IsPlayer || 
                        a == killer || a == deadGuy || a.Leader == killer || killer.Leader == a)
                        continue;

                    // do as less computations as possible : we don't need all the actor fucking fov, just the line to the murderer.

                    // fov range check. 
                    if (m_Rules.GridDistance(a.Location.Position, killerPos) > m_Rules.ActorFOV(a, map.LocalTime, m_Session.World.Weather))
                        continue;

                    // LOS check.
                    if (!LOS.CanTraceViewLine(a.Location, killerPos))
                        continue;

                    // we see the murderer!
                    // make enemy and emote.
                    DoSay(a, killer, String.Format("MURDER! {0} HAS KILLED {1}!", killer.TheName, deadGuy.TheName), Sayflags.IS_FREE_ACTION | Sayflags.IS_IMPORTANT);
                    DoMakeAggression(a, killer);
                }
            }
#endregion

            // Emote: a law enforcer killing a murderer feels warm and fuzzy inside.
#region
            if (killer != null && deadGuy.MurdersCounter > 0 && killer.Model.Abilities.IsLawEnforcer && !killer.Faction.IsEnemyOf(deadGuy.Faction))
            {
                if (killer.IsPlayer)
                    AddMessage(new Message("You feel like you did your duty with killing a murderer.", m_Session.WorldTime.TurnCounter, Color.White));
                else
                    DoSay(killer, deadGuy, "Good riddance, murderer!", Sayflags.IS_FREE_ACTION | Sayflags.IS_DANGER);
            }
#endregion

            //////////////////////////////////////////////
            // Player or Player Followers Killing Uniques
            //////////////////////////////////////////////
#region
            // The Sewers Thing
            if (deadGuy == m_Session.UniqueActors.TheSewersThing.TheActor)
            {
                if (killer == m_Player || killer.Leader == m_Player)
                {
                    // scoring.
                    m_Session.Scoring.SetCompletedAchievement(Achievement.IDs.KILLED_THE_SEWERS_THING);

                    // achievement!
                    ShowNewAchievement(Achievement.IDs.KILLED_THE_SEWERS_THING);
                }
            }
#endregion
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="attacker">the actor doing the disarming</param>
        /// <param name="defender">the actor being disarmed</param>
        /// <returns>the disarmed item or null if actor had no equipped item</returns>
        Item Disarm(Actor attacker, Actor defender) // alpha10
        {
            Item disarmIt = null;

            // pick equipped item to disarm : prefer weapon, then any right handed item(?), then left handed.
            disarmIt = defender.GetEquippedWeapon();
            if (disarmIt == null)
            {
                disarmIt = defender.GetEquippedItem(DollPart.RIGHT_HAND);
                if (disarmIt == null)
                {
                    disarmIt = defender.GetEquippedItem(DollPart.LEFT_HAND);
                }
            }

            if (disarmIt == null)
                return null;

            // unequip, remove from inv and drop item in a random adjacent tile
            // if none possible, will drop on same tile (which then has no almost no gameplay effect 
            // because the actor can take it back asap at no ap cost... unless he dies)
            DoUnequipItem(defender, disarmIt, false);
            defender.Inventory.RemoveAllQuantity(disarmIt);
            List<Point> dropTiles = new List<Point>(8);
            defender.Location.Map.ForEachAdjacentInMap(defender.Location.Position,
                (pt) =>
                {
                    // checking if can drop there is eq to checking if can throw it there
                    if (!defender.Location.Map.IsBlockingThrow(pt.X, pt.Y))
                        dropTiles.Add(pt);
                });
            Point dropOnTile;
            if (dropTiles.Count > 0)
                dropOnTile = dropTiles[m_Rules.Roll(0, dropTiles.Count)];
            else
                dropOnTile = defender.Location.Position;
            defender.Location.Map.DropItemAt(disarmIt, dropOnTile);

            //show? //@@MP (Release 7-2)
            if (disarmIt != null)
            {
                if (IsVisibleToPlayer(defender))
                {
                    bool isPlayer = attacker.IsPlayer || defender.IsPlayer;
                    bool isBot = attacker.IsBotPlayer || defender.IsBotPlayer;
                    if (isPlayer)
                        ClearMessages();
                    AddMessage(MakeMessage(attacker, Conjugate(attacker, VERB_DISARM), defender));
                    AddMessage(new Message(string.Format("{0} is sent flying!", disarmIt.TheName), attacker.Location.Map.LocalTime.TurnCounter));
                    if (attacker.IsPlayer && !isBot)
                        AddMessagePressEnter();
                    else
                    {
                        RedrawPlayScreen();
                        AnimDelay(DELAY_SHORT, false);
                    }
                }
            }

            // done
            return disarmIt;
        }

        /// <summary>
        /// Add kill to scoring record.
        /// </summary>
        void PlayerKill(Actor victim)
        {
            // scoring.
            m_Session.Scoring.AddKill(victim, m_Session.WorldTime.TurnCounter); //@@MP - unused parameter (Release 5-7)
        }

        bool TryPlayerInsanity()
        {
            if (!m_Rules.IsActorInsane(m_Player))
                return false;
            if (!m_Rules.RollChance(Rules.SANITY_INSANE_ACTION_CHANCE))
                return false;

            ActorAction insaneAction = GenerateInsaneAction(m_Player);
            if (insaneAction == null)
                return false;
            if (!insaneAction.IsLegal())
                return false;

            ClearMessages();
            AddMessage(new Message("(your insanity takes over. you lost control for a moment)", m_Player.Location.Map.LocalTime.TurnCounter, Color.Orange));

            insaneAction.Perform();

            return true;
        }

        bool TryPlayerControlAlteringEffects() //@@MP (Release 7-1), added stunned (Release 7-2), added food poisoning (Release 7-6)
        {
            if (TryPlayerIncapacitated())
                return true;

            if (TryPlayerInsanity())
                return true;

            if (TryPlayerDrunkenness())
                return true;

            if (TryPlayerFoodPoisoningEffects())
                return true;

            return false;
        }

        bool TryPlayerDrunkenness() //@@MP (Release 7-1)
        {
            if (!m_Player.IsDrunk)
                return false;
            if (!m_Rules.RollChance(Rules.DRUNK_AFFECTED_ACTION_CHANCE))
                return false;

            ActorAction drunkAction = GenerateDrunkAction(m_Player);
            if (drunkAction == null)
                return false;
            if (!drunkAction.IsLegal())
                return false;

            ClearMessages();
            AddMessage(new Message("(you're quite drunk. you lost control for a moment)", m_Player.Location.Map.LocalTime.TurnCounter, Color.Orange));

            drunkAction.Perform();

            return true;
        }

        /// <summary>
        /// Flashbanged or stun gunned
        /// </summary>
        /// <returns></returns>
        bool TryPlayerIncapacitated() //@@MP (Release 7-2)
        {
            if (!m_Player.IsIncapacitated)
                return false;

            ActorAction incapactitatedAction = GenerateIncapacitatedAction(m_Player);
            if (incapactitatedAction == null)
                return false;
            if (!incapactitatedAction.IsLegal())
                return false;

            ClearMessages();
            AddMessage(new Message("(you were stunned/flashbanged. you lose control for a moment)", m_Player.Location.Map.LocalTime.TurnCounter, Color.Orange));

            incapactitatedAction.Perform();
            return true;
        }

        bool TryPlayerFoodPoisoningEffects() //@@MP (Release 7-6)
        {
            if (!m_Player.IsFoodPoisoned)
                return false;
            if (!m_Rules.RollChance(Rules.FOOD_POISONING_AFFECTED_ACTION_CHANCE))
                return false;

            ActorAction unwellAction = GenerateFoodPoisonedAction(m_Player);
            if (unwellAction == null)
                return false;
            if (!unwellAction.IsLegal())
                return false;

            ClearMessages();
            AddMessage(new Message("(you're quite unwell. you lost control for a moment)", m_Player.Location.Map.LocalTime.TurnCounter, Color.Orange));

            unwellAction.Perform();

            return true;
        }
#endregion

#region -Undeads leveling up
        ActorModel CheckUndeadEvolution(Actor undead)
        {
            // check option & game mode.
            if (!s_Options.AllowUndeadsEvolution || !Rules.HasEvolution(m_Session.GameMode))
                return null;

            // evolve?
            bool evolve = false;
            switch (undead.Model.ID)
            {
                // zombie master 4 kills & Day > X -> zombie lord
                case (int)GameActors.IDs.UNDEAD_ZOMBIE_MASTER:
                    {
                        if (undead.KillsCount < 4)
                            return null;
                        if (undead.Location.Map.LocalTime.Day < UNDEAD_STAGE2_SLOW_EVOLUTION_MIN_DAY && !undead.IsPlayer)
                            return null;
                        evolve = true;
                        break;
                    }

                 // zombie lord 8 kills -> zombie prince.
                case (int)GameActors.IDs.UNDEAD_ZOMBIE_LORD:
                    {
                        if (undead.KillsCount < 8)
                            return null;
                        if (undead.Location.Map.LocalTime.Day < UNDEAD_STAGE3_SLOW_EVOLUTION_MIN_DAY && !undead.IsPlayer) //@@MP (Release 5-6)
                            return null;
                        evolve = true;
                        break;
                    }

                // skeleton 2 kills -> red eyed skeleton
                case (int)GameActors.IDs.UNDEAD_SKELETON:
                    {
                        if (undead.KillsCount < 2)
                            return null;
                        if (undead.Location.Map.LocalTime.Day < UNDEAD_STAGE2_SLOW_EVOLUTION_MIN_DAY && !undead.IsPlayer) //@@MP (Release 5-7)
                            return null;
                        evolve = true;
                        break;
                    }
                // red eye skeleton 4 kills -> red skeleton
                case (int)GameActors.IDs.UNDEAD_RED_EYED_SKELETON:
                    {
                        if (undead.KillsCount < 4)
                            return null;
                        if (undead.Location.Map.LocalTime.Day < UNDEAD_STAGE3_SLOW_EVOLUTION_MIN_DAY && !undead.IsPlayer) //@@MP (Release 5-7)
                            return null;
                        evolve = true;
                        break;
                    }

                // zombie shambler -> dark eyed zombie shambler
                case (int)GameActors.IDs.UNDEAD_ZOMBIE:
                    { //@@MP (Release 5-6)
                        if (undead.KillsCount < 2)
                            return null;
                        if (undead.Location.Map.LocalTime.Day < UNDEAD_STAGE2_SLOW_EVOLUTION_MIN_DAY && !undead.IsPlayer) //@@MP (Release 5-7)
                            return null;
                        evolve = true;
                        break;
                    }

                // dark eyed zombie shambler -> dark zombie shambler
                case (int)GameActors.IDs.UNDEAD_DARK_EYED_ZOMBIE:
                    { //@@MP (Release 5-6)
                        if (undead.KillsCount < 4)
                            return null;
                        if (undead.Location.Map.LocalTime.Day < UNDEAD_STAGE3_SLOW_EVOLUTION_MIN_DAY && !undead.IsPlayer) //@@MP (Release 5-7)
                            return null;
                        evolve = true;
                        break;
                    }

                // zombified 2 kills -> neophyte
                case (int)GameActors.IDs.UNDEAD_MALE_ZOMBIFIED:
                case (int)GameActors.IDs.UNDEAD_FEMALE_ZOMBIFIED:
                    {
                        if (undead.KillsCount < 4) //@@MP (Release 5-6)
                            return null;
                        if (undead.Location.Map.LocalTime.Day < UNDEAD_STAGE2_SLOW_EVOLUTION_MIN_DAY && !undead.IsPlayer) //@@MP (Release 5-6)
                            return null;
                        evolve = true;
                        break;
                    }

                // neophyte 4 kills & Day > X -> disciple
                case (int)GameActors.IDs.UNDEAD_MALE_NEOPHYTE:
                case (int)GameActors.IDs.UNDEAD_FEMALE_NEOPHYTE:
                    {
                        if (undead.KillsCount < 8) //@@MP (Release 5-6)
                            return null;
                        if (undead.Location.Map.LocalTime.Day < UNDEAD_STAGE3_SLOW_EVOLUTION_MIN_DAY && !undead.IsPlayer)
                            return null;
                        evolve = true;
                        break;
                    }

                default:
                    evolve = false;
                    break;
            }

            // evolve vs no evolution.
            if (evolve)
            {
                GameActors.IDs evolutionID = NextUndeadEvolution((GameActors.IDs)undead.Model.ID);
                if (evolutionID == (GameActors.IDs)undead.Model.ID)
                    return null;
                else
                    return GameActors[evolutionID];
            }
            else
                return null;
        }

        public GameActors.IDs NextUndeadEvolution(GameActors.IDs fromModelID) //@@MP - can't be made static
        {
            switch (fromModelID)
            {
                case GameActors.IDs.UNDEAD_SKELETON: return GameActors.IDs.UNDEAD_RED_EYED_SKELETON;
                case GameActors.IDs.UNDEAD_RED_EYED_SKELETON: return GameActors.IDs.UNDEAD_RED_SKELETON;

                case GameActors.IDs.UNDEAD_ZOMBIE: return GameActors.IDs.UNDEAD_DARK_EYED_ZOMBIE;
                case GameActors.IDs.UNDEAD_DARK_EYED_ZOMBIE: return GameActors.IDs.UNDEAD_DARK_ZOMBIE;

                case GameActors.IDs.UNDEAD_FEMALE_ZOMBIFIED: return GameActors.IDs.UNDEAD_FEMALE_NEOPHYTE;
                case GameActors.IDs.UNDEAD_MALE_ZOMBIFIED: return GameActors.IDs.UNDEAD_MALE_NEOPHYTE;
                case GameActors.IDs.UNDEAD_FEMALE_NEOPHYTE: return GameActors.IDs.UNDEAD_FEMALE_DISCIPLE;
                case GameActors.IDs.UNDEAD_MALE_NEOPHYTE: return GameActors.IDs.UNDEAD_MALE_DISCIPLE;

                case GameActors.IDs.UNDEAD_ZOMBIE_MASTER: return GameActors.IDs.UNDEAD_ZOMBIE_LORD;
                case GameActors.IDs.UNDEAD_ZOMBIE_LORD: return GameActors.IDs.UNDEAD_ZOMBIE_PRINCE;

                default: return fromModelID;
            }
        }
#endregion

#region -Blood, Remains & Scent
        public void SplatterBlood(Map map, Point position, bool actorStillAlive = false)
        {
            // splatter floor there.
            Tile tile = map.GetTileAt(position.X,position.Y);
            switch (actorStillAlive) //@@MP (Release 2)
            {
                case false:
                    if (map.IsWalkable(position.X, position.Y) && !tile.HasDecoration(GameImages.DECO_BLOODIED_FLOOR))
                    {
                        tile.AddDecoration(GameImages.DECO_BLOODIED_FLOOR);
                        map.AddTimer(new TaskRemoveDecoration((WorldTime.TURNS_PER_DAY * 3), position.X, position.Y, GameImages.DECO_BLOODIED_FLOOR)); //@@MP - restored after removing in R1 (Release 5-7)
                    }
                    break;
                case true:
                    if (map.IsWalkable(position.X, position.Y) && !tile.HasDecoration(GameImages.DECO_BLOODIED_FLOOR_SMALL))
                    {
                        tile.AddDecoration(GameImages.DECO_BLOODIED_FLOOR_SMALL);
                        map.AddTimer(new TaskRemoveDecoration((WorldTime.TURNS_PER_DAY * 3), position.X, position.Y, GameImages.DECO_BLOODIED_FLOOR_SMALL)); //@@MP restored after removing in R1 (Release 5-7)
                    }
                    break;
            }

            // splatter adjacent walls.
            foreach (Direction d in Direction.COMPASS)
            {
                if (!m_Rules.RollChance(BLOOD_WALL_SPLAT_CHANCE))
                    continue;
                Point next = position + d;
                if (!map.IsInBounds(next))
                    continue;
                Tile tileNext = map.GetTileAt(next.X, next.Y);
                if (tileNext.Model.IsWalkable)
                    continue;
                if (tileNext.HasDecoration(GameImages.DECO_BLOODIED_WALL)) //@@MP - already has maximum blood
                    continue;
                if (tileNext.HasDecoration(GameImages.DECO_BLOODIED_WALL_SMALL) && actorStillAlive) //@@MP - already has enough blood considering it was only a wound (Release 2)
                    continue;

                if (actorStillAlive) //@@MP (Release 2)
                {
                    tileNext.AddDecoration(GameImages.DECO_BLOODIED_WALL_SMALL);
                    map.AddTimer(new TaskRemoveDecoration((WorldTime.TURNS_PER_DAY * 3), next.X, next.Y, GameImages.DECO_BLOODIED_WALL_SMALL)); //@@MP restored after removing in R1 (Release 5-7)
                }
                else
                {
                    if (tileNext.HasDecoration(GameImages.DECO_BLOODIED_WALL_SMALL))
                        tileNext.RemoveDecoration(GameImages.DECO_BLOODIED_WALL_SMALL); //@@MP - replace the small blood splatter with the big one
                    tileNext.AddDecoration(GameImages.DECO_BLOODIED_WALL);
                    map.AddTimer(new TaskRemoveDecoration((WorldTime.TURNS_PER_DAY * 3), next.X, next.Y, GameImages.DECO_BLOODIED_WALL)); //@@MP restored after removing in R1 (Release 5-7)
                }
            }
        }

        /// <summary>
        /// drop remains for a destroyed undead
        /// </summary>
        public static void UndeadRemains(Map map, Point position, string thename, bool causedByFire) //@@MP - made static (Release 5-7), distinct sprite when the death came by fire (Release 8-1)
        {
            thename = thename.ToLower();
            Tile tile = map.GetTileAt(position.X,position.Y);
            if (map.IsWalkable(position.X, position.Y))
            { //@@MP - work out the appropriate remains for the type of undead (Release 2)
                if (thename.Contains("skeleton")) //@@MP - order by most to least common type
                {
                    if (!tile.HasDecoration(GameImages.DECO_SKELETON_REMAINS))
                    {
                        tile.AddDecoration(GameImages.DECO_SKELETON_REMAINS);
                        map.AddTimer(new TaskRemoveDecoration((WorldTime.TURNS_PER_DAY * 4), position.X, position.Y, GameImages.DECO_SKELETON_REMAINS)); //@@MP (Release 5-7)
                    }
                }
                else if (thename.Contains("rat")) //@@MP - added rat corpses (Release 5-4)
                {
                    if (!tile.HasDecoration(GameImages.DECO_RAT_ZOMBIE_REMAINS))
                    {
                        tile.AddDecoration(GameImages.DECO_RAT_ZOMBIE_REMAINS);
                        map.AddTimer(new TaskRemoveDecoration((WorldTime.TURNS_PER_DAY * 4), position.X, position.Y, GameImages.DECO_RAT_ZOMBIE_REMAINS)); //@@MP (Release 5-7)
                    }
                }
                else if (causedByFire) //@@MP (Release 8-1)
                {
                    if (!tile.HasDecoration(GameImages.DECO_ZOMBIE_REMAINS_BURNED))
                    {
                        tile.AddDecoration(GameImages.DECO_ZOMBIE_REMAINS_BURNED);
                        map.AddTimer(new TaskRemoveDecoration((WorldTime.TURNS_PER_DAY * 4), position.X, position.Y, GameImages.DECO_ZOMBIE_REMAINS_BURNED));
                    }
                }
                else
                {
                    if (!tile.HasDecoration(GameImages.DECO_ZOMBIE_REMAINS_RAW))
                    {
                        tile.AddDecoration(GameImages.DECO_ZOMBIE_REMAINS_RAW);
                        map.AddTimer(new TaskRemoveDecoration((WorldTime.TURNS_PER_DAY * 4), position.X, position.Y, GameImages.DECO_ZOMBIE_REMAINS_RAW)); //@@MP (Release 5-7)
                    }
                }
            }
        }

        public void DropCorpse(Actor deadGuy)
        {
            // add blood to deadguy.
            deadGuy.Doll.AddDecoration(DollPart.TORSO, GameImages.BLOODIED);

            // make and add corpse.
            int corpseHp = m_Rules.ActorMaxHPs(deadGuy);
            float rotation = m_Rules.Roll(30, 60); //@MP - which compass direction the body is aligned to
            if (m_Rules.RollChance(50)) rotation = -rotation;
            float scale = 1.0f;
            deadGuy.Location.Map.AddCorpseAt(new Corpse(deadGuy, corpseHp, corpseHp, deadGuy.Location.Map.LocalTime.TurnCounter, rotation, scale), deadGuy.Location.Position);
        }

        static void DropActorScent(Actor actor) //@@MP - made static (Release 5-7)
        {
            // alpha10 dont drop if odor suppressed
            if (actor.OdorSuppressorCounter > 0)
                return;

            if (!actor.IsInWater) //@@MP - water hides their tracks (Release 6-1)
            {
                Location loc = actor.Location;
                //@@MP - so does smoke (Release 7-2)
                MapObject mapObj = loc.Map.GetMapObjectAt(loc.Position);
                if (mapObj != null && mapObj.ImageID == GameImages.EFFECT_SMOKE_SCREEN)
                    return;

                if (actor.Model.Abilities.IsUndead)
                {
                    // ZM scent?
                    if (actor.Model.Abilities.IsUndeadMaster)
                        loc.Map.RefreshScentAt(Odor.UNDEAD_MASTER, Rules.UNDEAD_MASTER_SCENT_DROP, loc.Position);
                }
                else
                {
                    // Living scent.
                    loc.Map.RefreshScentAt(Odor.LIVING, Rules.LIVING_SCENT_DROP, loc.Position);
                }
            }
        }

        void DecayActorScents(Actor actor)   // alpha10
        {
            // decay suppressor
            if (actor.OdorSuppressorCounter > 0)
            {
                int decay = m_Rules.OdorsDecay(actor.Location.Map, actor.Location.Position, m_Session.World.Weather);
                actor.OdorSuppressorCounter -= decay;
                if (actor.OdorSuppressorCounter < 0) actor.OdorSuppressorCounter = 0;
            }
        }
#endregion

#region -INFECTION & ZOMBIFICATION ***
        void InfectActor(Actor actor, int addInfection)
        {
            actor.Infection = Math.Min(m_Rules.ActorInfectionHPs(actor), actor.Infection + addInfection);
        }

        /// <summary>
        /// Zombify an actor during the game or zombify the player at game start.
        /// </summary>
        Actor Zombify(Actor zombifier, Actor deadVictim, Map map, Point pos, bool isStartingGame)
        {
            //@@MP - added map and pos for fixing a bug when zombifying corpses on NextMapTurn() (Release 7-5)
            //see: https://gitlab.com/RogueSurvivor-StillAlive/StillAlive/-/issues/56

            Actor newZombie = m_TownGenerator.MakeZombified(zombifier, deadVictim, isStartingGame ? 0 : deadVictim.Location.Map.LocalTime.TurnCounter);

            // reset AP - dont act this turn.
            newZombie.ActionPoints = 0;

            // if zombifying player, remember it!
            if (deadVictim == m_Player || deadVictim.IsPlayer)
                m_Session.Scoring.SetZombifiedPlayer(newZombie);

            // keep half of the skills from living form at random.
            SkillTable livingSkills = deadVictim.Sheet.SkillTable;
            if (livingSkills != null && livingSkills.CountSkills > 0)
            {
                if (newZombie.Sheet.SkillTable == null)
                    newZombie.Sheet.SkillTable = new SkillTable();
                int nbLivingSkills = livingSkills.CountSkills;
                int nbSkillsToKeep = livingSkills.CountTotalSkillLevels / 2;
                for (int i = 0; i < nbSkillsToKeep; i++)
                {
                    Skills.IDs keepSkill = (Skills.IDs)livingSkills.SkillsList[m_Rules.Roll(0, nbLivingSkills)];
                    Skills.IDs? zombiefiedSkill = ZombifySkill(keepSkill);
                    if (zombiefiedSkill.HasValue)
                        SkillUpgrade(newZombie, zombiefiedSkill.Value);
                }
                m_TownGenerator.RecomputeActorStartingStats(newZombie);
            }
            
            if (!isStartingGame)  //when actors are spawned at game start, those functions handle their placement
            {
                // add zombified to map.
                map.PlaceActorAt(newZombie, pos);

                // cause insanity if the actor sees a zombie rise
                SeeingCauseInsanity(newZombie.Location, Rules.SANITY_HIT_ZOMBIFY, String.Format("{0} turning into a zombie", deadVictim.Name), newZombie); //@@MP - updated for the change to this method (Release 5-2)
            }

            // done.
            return newZombie;
        }

        public Skills.IDs? ZombifySkill(Skills.IDs skill) //@@MP - can't be made static
        {
            switch (skill)
            {
                case Skills.IDs.AGILE: return Skills.IDs.Z_AGILE;
                case Skills.IDs.LIGHT_EATER: return Skills.IDs.Z_LIGHT_EATER;
                case Skills.IDs.LIGHT_FEET: return Skills.IDs.Z_LIGHT_FEET;
                case Skills.IDs.MEDIC: return Skills.IDs.Z_INFECTOR;                    
                case Skills.IDs.STRONG: return Skills.IDs.Z_STRONG;
                case Skills.IDs.TOUGH: return Skills.IDs.Z_TOUGH;
                default: return null;
            }
        }
#endregion

#region -Applying/Unapplying effects: ApplyXXX/UnapplyXXX
        void ScorchBurntTile(Map map, int x, int y, int damage) //@@MP - add a burn mark sprite to the ground (Release 2), cater for the new explosives with damage ranges (Release 4)
        {
            if (map.GetExitAt(x, y) != null) //skip if it's stairs
                return;

            Tile tile = map.GetTileAt(x, y);
            if (tile.HasDecorations) //@@MP - added (Release 7-6)
            {
                foreach (string deco in tile.Decorations)
                {
                    //don't apply to damaged walls, as the scorch sprite hides the opening in damaged walls
                    if (deco.Contains("_damaged"))
                        return;
                }
            }

            if (damage > 0 && !map.TileAlreadyHasScorchDecoration(x, y)) //@@MP - so that we don't try to add a new scorch over an existing scorch (Release 5-2)
            {
                tile.IsScorched = true; //indicates that it has been burnt, so there is no fuel to burn it again if this is a spreading tile fire rather than a flameweapon

                if (damage <= 40) //@@MP FIXME - a lazy way of doing it. should go back and calculate based on radius from the center of the blast...
                {
                    if (m_GameTiles.IsWallModel(tile.Model)) //@@MP - now a scorch for walls and floor each (Release 6-3)
                    {
                        tile.AddDecoration(GameImages.DECO_SCORCH_MARK_OUTER_WALL);
                        map.AddTimer(new TaskRemoveDecoration((WorldTime.TURNS_PER_DAY * 3), x, y, GameImages.DECO_SCORCH_MARK_OUTER_WALL)); //@@MP - cleanup (Release 7-6)
                    }
                    else
                    {
                        tile.AddDecoration(GameImages.DECO_SCORCH_MARK_OUTER_FLOOR);
                        map.AddTimer(new TaskRemoveDecoration((WorldTime.TURNS_PER_DAY * 3), x, y, GameImages.DECO_SCORCH_MARK_OUTER_FLOOR)); //@@MP - cleanup (Release 7-6)
                    }
                }
                else if (damage > 40 && damage <= 120)
                {
                    if (m_GameTiles.IsWallModel(tile.Model)) //@@MP - now a scorch for walls and floor each (Release 6-3)
                    {
                        tile.AddDecoration(GameImages.DECO_SCORCH_MARK_INNER_WALL);
                        map.AddTimer(new TaskRemoveDecoration((WorldTime.TURNS_PER_DAY * 3), x, y, GameImages.DECO_SCORCH_MARK_INNER_WALL)); //@@MP - cleanup (Release 7-6)
                    }
                    else
                    {
                        tile.AddDecoration(GameImages.DECO_SCORCH_MARK_INNER_FLOOR);
                        map.AddTimer(new TaskRemoveDecoration((WorldTime.TURNS_PER_DAY * 3), x, y, GameImages.DECO_SCORCH_MARK_INNER_FLOOR)); //@@MP - cleanup (Release 7-6)
                    }
                }
                else if (damage > 120) //@@MP - now a scorch for walls and floor each (Release 6-3)
                {
                    tile.AddDecoration(GameImages.DECO_SCORCH_MARK_CENTER_FLOOR);
                    map.AddTimer(new TaskRemoveDecoration((WorldTime.TURNS_PER_DAY * 3), x, y, GameImages.DECO_SCORCH_MARK_CENTER_FLOOR)); //@@MP - cleanup (Release 7-6)
                }
            }
        }

        /// <summary>
        /// Different to mapobj.IsOnFire as it can be used for just empty tiles
        /// </summary>
        void SetTileOnFire(Map map, int x, int y, bool wasFlameWeapon) //@@MP - new method (Release 4), checks for flameweapon (Release 7-6)
        {
            Point pt = new Point(x, y);
            Tile targetTile = map.GetTileAt(pt);

            if (targetTile == null || targetTile.IsOnFire || map.IsAnyTileWaterThere(map, pt)) //@@MP - added check for water tiles (Release 6-1)
                return;
            else
            {
                bool scorchTheTile = false; //tile fires don't spread to walls - only flameweapons and explosions can scorch or ignite those  //@@MP (Release 7-6)
                if (targetTile.Model.IsWalkable) //@@MP - don't ignite walls, otherwise fires can pass through them (from outside to inside, or vice versa) (Release 7-6)
                {
                    targetTile.IsOnFire = true;
                    targetTile.AddDecoration(GameImages.EFFECT_ONFIRE);
                    scorchTheTile = true;
                }

                if (wasFlameWeapon || scorchTheTile)
                    ScorchBurntTile(map, x, y, BASE_TILE_FIRE_DAMAGE); //@@MP - FIXME?: replace hard-coded damage value with a relevant variable? not that it matters (Release 5-2)

                //@@MP - fires blow up adjacent fuel pumps (Release 7-3)
                map.ForEachAdjacentAndCenterInMap(pt, (adj) =>
                {
                    MapObject mapObj = map.GetMapObjectAt(adj);
                    if (mapObj != null && mapObj.ImageID == GameImages.OBJ_FUEL_PUMP)
                    {
                        ExplodeFuelPump(mapObj.Location);
                        return;
                    }
                });
            }
        }

        static void ExtinguishOnFireTile(Tile targetTile) //@@MP (Release 6-1)
        {
            if (targetTile == null)
                return;

            targetTile.IsOnFire = false;
            targetTile.RemoveDecoration(GameImages.EFFECT_ONFIRE);
        }

        /// <summary>
        /// Applies damage when the actor IsOnFire. Distinct from damage caused by standing on a tile where there is fire
        /// </summary>
        void ApplyBurnDamageToOnFireActor(Actor actor) //@@MP (Release 5-7)
        {
            /*Flame weapons like molotovs have their own damage values for initial impact (like any other explosion), but NextMapTurn() actually handles all fire damage, so to prevent
            duplicating damage in NextMapTurn() the difference between base FIRE_DAMAGE and weapon initial impact DMG calculates damage is taken into account by ApplyExplosionDamage().
            The weapon's damage comes from the relevant CSV file, and this technique (whilst janky) allows players to still mod those values.*/

            if (actor == null)
                throw new ArgumentNullException("actor", "null actor");

            if (actor.HitPoints > 0) // added hitpoints check (Release 6-1)
                InflictDamage(actor, BASE_ISONFIRE_FIRE_DAMAGE, false, true);

            if (actor.HitPoints <= 0)
            {
                // show.
                if (IsVisibleToPlayer(actor))
                {
                    AddMessage(new Message(actor.Name + " died in flames!", m_Session.WorldTime.TurnCounter, OTHER_ACTION_COLOR));
                    AddOverlay(new OverlayImage(MapToScreen(actor.Location.Position), GameImages.ICON_KILLED));
                    RedrawPlayScreen();
                    AnimDelay(DELAY_SHORT, false);
                }
                KillActor(null, actor, "burned alive", true);
                
                if (!actor.Model.Abilities.IsUndead)
                    SeeingCauseInsanity(actor.Location, Rules.SANITY_HIT_EATEN_ALIVE, String.Format("{0} burnt alive", actor.Name));
            }
        }

        /// <summary>
        /// Applies damage to any actor standing on a tile where there is fire. Distinct from the actor actually being IsOnFire
        /// </summary>
        void ApplyBurnDamageFromTileFire(Map map, Point point, List<Actor> exemptFromTileFireDMGThisTurn) //@@MP (Release 5-2), renamed (Release 5-7), added exempt parameter (Release 6-6)
        {
            /*flame weapons like molotovs have their own damage values for initial impact (like any other explosion), but NextMapTurn() actually handles all fire damage, so to prevent
            duplicating damage in NextMapTurn() the difference between base FIRE_DAMAGE and weapon initial impact dmg calculates damage is taken into account by ApplyExplosionDamage().
            The weapons damage comes from the relevant csv, and this technique (whilst janky) allows players to still mod those values.*/

            //damage actor if present
            Actor actor = map.GetActorAt(point);
            if (actor != null && !GameActors.IsSkeletonBranch(actor.Model) && actor.HitPoints > 0) //skeletons are invulnerable to fire // added hitpoints check (Release 6-1)
            {
                if (!exemptFromTileFireDMGThisTurn.Contains(actor)) //@@MP - they're exempt, probably because they already took fire damage this turn from actually being on fire (Release 6-6)
                {
                    InflictDamage(actor, BASE_TILE_FIRE_DAMAGE, false, true);
                    if (actor.HitPoints <= 0)
                    {
                        // show.
                        if (IsVisibleToPlayer(actor))
                        {
                            AddMessage(new Message(actor.Name + " died in flames!", m_Session.WorldTime.TurnCounter, OTHER_ACTION_COLOR));
                            AddOverlay(new OverlayImage(MapToScreen(actor.Location.Position), GameImages.ICON_KILLED));
                            RedrawPlayScreen();
                            AnimDelay(DELAY_SHORT, false);
                        }
                        KillActor(null, actor, "died in flames", true);
                        
                        if (!actor.Model.Abilities.IsUndead) //@@MP - had this check in the wrong spot in R5-3 (Release 5-7)
                            SeeingCauseInsanity(actor.Location, Rules.SANITY_HIT_EATEN_ALIVE, String.Format("{0} burnt alive", actor.Name));
                    }
                    else if (m_Rules.RollChance(CATCH_ONFIRE_FROM_TILE_CHANCE)) //@@MP - small chance of being set on fire (Release 6-6)
                        SetActorOnFire(actor);
                }
            }

            //damage corpses if present
            List<Corpse> corpses = map.GetCorpsesAt(point);
            if (corpses != null)
            {
                foreach (Corpse c in corpses)
                    InflictDamageToCorpse(c, (float)BASE_TILE_FIRE_DAMAGE);
            }

            //damage crops if present (Release 5-5)
            Tile tile = map.GetTileAt(point);
            if (tile.Model == GameTiles.FLOOR_PLANTED)
                map.SetTileModelAt(point.X, point.Y, GameTiles.FLOOR_GRASS);
        }

        private void SetActorOnFire(Actor actor) //@@MP (Release 5-7)
        {
            if (actor != null && !GameActors.IsSkeletonBranch(actor.Model) && !actor.IsInWater) //@@MP - added water check (Release 6-1)
            {
                bool wasOnFire = actor.IsOnFire; //@@MP (Release 7-6)

                actor.IsOnFire = true;

                //undead
                #region
                if (actor.Model.Abilities.IsUndead)
                {
                    if (actor.Model == GameActors.Zombie || actor.Model == GameActors.DarkZombie || actor.Model == GameActors.DarkEyedZombie)
                    {
                        if (actor.Doll.GetDecorations(DollPart.TORSO) == null || (!actor.Doll.GetDecorations(DollPart.TORSO).Contains(GameImages.ZOMBIE_ON_FIRE))) //@@MP - added check (Release 6-1)
                            actor.Doll.AddDecoration(DollPart.TORSO, GameImages.ZOMBIE_ON_FIRE);
                    }
                    else if (actor.Model != GameActors.RatZombie)
                    {
                        if (actor.Doll.GetDecorations(DollPart.TORSO) == null || (!actor.Doll.GetDecorations(DollPart.TORSO).Contains(GameImages.OTHER_UNDEAD_ON_FIRE))) //@@MP - added check (Release 6-1)
                            actor.Doll.AddDecoration(DollPart.TORSO, GameImages.OTHER_UNDEAD_ON_FIRE);
                    }
                    return;
                }
                #endregion

                //livings
                #region
                //-wearing armor?
                Item torsoItem = actor.GetEquippedItem(DollPart.TORSO);
                if (torsoItem != null)   //@@MP - wearing a fire-resistant armor? (Release 7-1)
                {
                    ItemBodyArmor armor = torsoItem as ItemBodyArmor;
                    if (armor != null)
                    {
                        if (m_Rules.RollChance(armor.Fire_Resistance))
                        {
                            actor.IsOnFire = false;
                            return;
                        }
                    }
                }

                //they're definitely on fire, so draw the relevant effect
                if (actor.Model.DollBody.IsMale)
                {
                    if (actor.Doll.GetDecorations(DollPart.TORSO) == null || (!actor.Doll.GetDecorations(DollPart.TORSO).Contains(GameImages.MALE_ON_FIRE))) //@@MP - added check (Release 6-1)
                        actor.Doll.AddDecoration(DollPart.TORSO, GameImages.MALE_ON_FIRE);
                }
                else if (!actor.Model.DollBody.IsMale)
                {
                    if (actor.Doll.GetDecorations(DollPart.TORSO) == null || (!actor.Doll.GetDecorations(DollPart.TORSO).Contains(GameImages.FEMALE_ON_FIRE))) //@@MP - added check (Release 6-1)
                        actor.Doll.AddDecoration(DollPart.TORSO, GameImages.FEMALE_ON_FIRE);
                }

                // loud noise.
                OnLoudNoise(actor.Location.Map, actor.Location.Position, "A loud SCREAM");
                // player hears?
                DoScream(actor.Location, actor.Model.DollBody.IsMale, false, false);

                // message to player        //@@MP (Release 7-6)
                if (actor.IsPlayer && !wasOnFire)
                {
                    AddMessage(new Message("You are literally on fire! You should try to extinguish yourself.", m_Session.WorldTime.TurnCounter, Color.Red));
                    AddMessage(new Message(String.Format("Walk in the rain or a pond, or try Waiting (<{0}>) to stop-drop-and-roll", s_KeyBindings.GetFriendlyFormat(PlayerCommand.WAIT_OR_SELF).ToString()), m_Session.WorldTime.TurnCounter, Color.Red));
                    if (!actor.IsBotPlayer)
                        AddMessagePressEnter();
                }
                #endregion
            }
        }

        static void ExtinguishOnFireActor(Actor actor) //@@MP (Release 5-7)
        {
            if (actor != null)// && actor.HitPoints > 0)
            {
                actor.IsOnFire = false;
                if (actor.Doll.GetDecorations(DollPart.TORSO) == null) //@@MP - added null check (Release 6-1)
                    return;
                else if (actor.Doll.GetDecorations(DollPart.TORSO).Contains(GameImages.ZOMBIE_ON_FIRE))
                    actor.Doll.RemoveDecoration(GameImages.ZOMBIE_ON_FIRE);
                else if (actor.Doll.GetDecorations(DollPart.TORSO).Contains(GameImages.OTHER_UNDEAD_ON_FIRE))
                    actor.Doll.RemoveDecoration(GameImages.OTHER_UNDEAD_ON_FIRE);
                else if (actor.Doll.GetDecorations(DollPart.TORSO).Contains(GameImages.MALE_ON_FIRE))
                    actor.Doll.RemoveDecoration(GameImages.MALE_ON_FIRE);
                else if (actor.Doll.GetDecorations(DollPart.TORSO).Contains(GameImages.FEMALE_ON_FIRE))
                    actor.Doll.RemoveDecoration(GameImages.FEMALE_ON_FIRE);
            }
        }

        /// <summary>
        /// Put the object on fire : firestate = onfire, jump -1.
        /// </summary>
        /// <param name="mapObj"></param>
        public void ApplyOnFire(MapObject mapObj) //@@MP - can't be made static
        {
            // put object on fire.
            mapObj.FireState = MapObject.Fire.ONFIRE;
            /*
            // can't jump on it.
            --mapObj.JumpLevel;
            */
            // can't move it
            mapObj.IsMovable = false;
            mapObj.IsContainer = true; //in case items were dropped there when it was unlit    

            //special cases        //@@MP (Release 7-6)
            if (mapObj is Barrel || mapObj is Campfire)
            {
                mapObj.IsWalkable = false;
            }
            else
            {
                Car car = mapObj as Car;
                if (car != null)
                {
                    car.FuelUnits = 0; //@@MP - if car, fuel has burned off (Release 7-1)
                    // restore jumpability.
                    --mapObj.JumpLevel;
                }
            }
        }

        /// <summary>
        /// Unapply fire effects. FIXME: need to distinguish Unapply (burnable again) vs PutOutFire (ashes)?
        /// </summary>
        /// <param name="mapObj"></param>
        public static void UnapplyOnFire(MapObject mapObj) //@@MP - made static (Release 5-7)
        {
            // extinguish fire, burnable again.
            mapObj.FireState = MapObject.Fire.BURNABLE;
            // can move it again
            if (!(mapObj is Campfire)) //only campfires can't be moved as of now
                mapObj.IsMovable = true; //@@MP (Release 7-6)
            mapObj.IsContainer = false; //can now be moved and jumped on again      //@@MP (Release 7-6)

            //special cases       //@@MP (Release 7-6)
            if (mapObj is Barrel || mapObj is Campfire)
            {
                mapObj.IsWalkable = true;
            }
            else
            {
                Car car = mapObj as Car;
                if (car != null)
                {
                    car.FuelUnits = 0; //@@MP - if car, fuel has burned off (Release 7-1)
                    // restore jumpability.
                    ++mapObj.JumpLevel;
                }
            }
        }
#endregion

#region -Insanity, drunkeness, food poisoning and incapacitated
        ActorAction GenerateInsaneAction(Actor actor)
        {
            // Do a random, uncontrolled action as a manifestation of going insane
            int roll = m_Rules.Roll(0, 5);
            switch (roll)
            {
                // shout
                case 0: return new ActionShout(actor, this, "AAAAAAAAAAA!!!");

                // random bump (movement)
                case 1: return new ActionBump(actor, this, m_Rules.RollDirection());

                // random bash.
                case 2:
                    Direction d = m_Rules.RollDirection();
                    MapObject mobj = actor.Location.Map.GetMapObjectAt(actor.Location.Position + d);
                    if (mobj != null)
                        return new ActionBreak(actor, this, mobj);
                    return new ActionShout(actor, this, "MMMMYYYYAAAAARRRRR!!!");

                // random use/unequip-drop
                case 3:
                    Inventory inv = actor.Inventory;
                    if (inv == null || inv.CountItems == 0) return null;
                    Item it = inv[m_Rules.Roll(0, inv.CountItems)];
                    ActionUseItem useIt = new ActionUseItem(actor, this, it);
                    if (useIt.IsLegal())
                        return useIt;
                    if (it.IsEquipped)
                        return new ActionUnequipItem(actor, this, it);
                    return new ActionDropItem(actor, this, it);

                // random aggression.
                case 4:
                    int fov = m_Rules.ActorFOV(actor, actor.Location.Map.LocalTime, m_Session.World.Weather);
                    foreach (Actor mapActor in actor.Location.Map.Actors)
                    {
                        if (mapActor == actor) continue;
                        if (m_Rules.AreEnemies(actor, mapActor)) continue;
                        if (!LOS.CanTraceViewLine(actor.Location, mapActor.Location.Position, fov)) continue;
                        if (m_Rules.RollChance(50))
                        {
                            // force leaving of leader.
                            if (actor.HasLeader)
                            {
                                actor.Leader.RemoveFollower(actor);
                                actor.TrustInLeader = Rules.TRUST_NEUTRAL;
                            }
                            // agress.
                            DoMakeAggression(actor, mapActor);
                            return new ActionSay(actor, this, mapActor, "YOU ARE ONE OF THEM!!", Sayflags.IS_IMPORTANT | Sayflags.IS_DANGER); //alpha 10 added  | Sayflags.IS_DANGER
                        }
                    }
                    return null;

                default:
                    return null;
            }
        }

        void SeeingCauseInsanity(Location loc, int sanCost, string what, Actor whoDoesTheAction = null) //@@MP - made whoDoesTheAction optional (Release 5-2)
        {
            foreach (Actor a in loc.Map.Actors)
            {
                if (!a.Model.Abilities.HasSanity) continue;

                // can't see if sleeping or out of fov.
                if (a.IsSleeping) continue;
                int fov = m_Rules.ActorFOV(a, loc.Map.LocalTime, m_Session.World.Weather);
                if (!LOS.CanTraceViewLine(loc, a.Location.Position, fov)) continue;

                // san hit.
                SpendActorSanity(a, sanCost);

                // msg.
                if (whoDoesTheAction != null && whoDoesTheAction == a) //@@MP - allowed for cases where whoDoesTheAction was not provided eg deaths in fires (Release 5-2)
                {
                    if (a.IsPlayer)
                        AddMessage(new Message("That was a very disturbing thing to do...", loc.Map.LocalTime.TurnCounter, Color.Orange));
                    else if (IsVisibleToPlayer(a))
                        AddMessage(MakeMessage(a, String.Format("{0} done something very disturbing...", Conjugate(a, VERB_HAVE))));
                }
                else
                {
                    if (a.IsPlayer)
                        AddMessage(new Message(String.Format("Seeing {0} is very disturbing...", what), loc.Map.LocalTime.TurnCounter, Color.Orange));
                    else if (IsVisibleToPlayer(a))
                        AddMessage(MakeMessage(a, String.Format("{0} something very disturbing...", Conjugate(a, VERB_SEE))));
                }
            }
        }

        ActorAction GenerateDrunkAction(Actor actor) //@@MP (Release 7-1)
        {
            // Do a random, uncontrolled action as a manifestation of heavy intoxication
            int roll = m_Rules.Roll(0, 6);
            switch (roll)
            {
                // vomit
                case 0:
                case 1:
                    DoVomit(actor);
                    return new ActionWait(actor, this);

                // random bump (movement)
                case 2:
                case 3:
                    return new ActionBump(actor, this, m_Rules.RollDirection());

                // random unequip/drop
                case 4:
                    Inventory inv = actor.Inventory;
                    if (inv == null || inv.CountItems == 0) return null;
                    Item it = inv[m_Rules.Roll(0, inv.CountItems)];
                    if (it.IsEquipped)
                        return new ActionUnequipItem(actor, this, it);
                    else if (it.Model != GameItems.CANDLES_BOX && it.Model != GameItems.FLARES_KIT && it.Model != GameItems.GLOWSTICKS_BOX) //these prompt to drop one or all
                        return new ActionDropItem(actor, this, it);
                    else
                        return new ActionShout(actor, this, "DAMN IT!!!");

                // random aggression.
                case 5:
                    int fov = m_Rules.ActorFOV(actor, actor.Location.Map.LocalTime, m_Session.World.Weather);
                    foreach (Actor mapActor in actor.Location.Map.Actors)
                    {
                        if (mapActor == actor) continue;
                        if (m_Rules.AreEnemies(actor, mapActor)) continue;
                        if (!LOS.CanTraceViewLine(actor.Location, mapActor.Location.Position, fov)) continue;
                        if (actor.Doll.Body.IsMale != mapActor.Doll.Body.IsMale) continue; //must be same gender
                        if (m_Rules.RollChance(50))
                        {
                            // force leaving of leader.
                            if (actor.HasLeader)
                            {
                                actor.Leader.RemoveFollower(actor);
                                actor.TrustInLeader = Rules.TRUST_NEUTRAL;
                            }
                            // agress.
                            DoMakeAggression(actor, mapActor);
                            return new ActionSay(actor, this, mapActor, "WHAT ARE YOU LOOKING AT!", Sayflags.IS_IMPORTANT | Sayflags.IS_DANGER);
                        }
                    }
                    return null;

                default:
                    return null;
            }
        }

        ActorAction GenerateIncapacitatedAction(Actor actor) //@@MP (Release 7-2)
        {
            // Do a random, uncontrolled action as a manifestation of being stunned/flashbanged
            int roll = m_Rules.Roll(0, 3);
            switch (roll)
            {
                // shout
                case 0: return new ActionShout(actor, this, "GAAHHH!!!");

                // random bash.
                case 1:
                    foreach (Direction d in Direction.COMPASS)
                    {
                        MapObject mobj = actor.Location.Map.GetMapObjectAt(actor.Location.Position + d);
                        if (mobj != null)
                            return new ActionBreak(actor, this, mobj);
                    }
                    return new ActionShout(actor, this, "OWWWWW!!!");

                // random unequip-drop
                case 2:
                    Inventory inv = actor.Inventory;
                    if (inv == null || inv.CountItems == 0) return null;
                    Item it = inv[m_Rules.Roll(0, inv.CountItems)];
                    if (it.IsEquipped)
                        return new ActionUnequipItem(actor, this, it);
                    else if (it.Model != GameItems.CANDLES_BOX && it.Model != GameItems.FLARES_KIT && it.Model != GameItems.GLOWSTICKS_BOX) //these prompt to drop one or all
                        return new ActionDropItem(actor, this, it);
                    else
                        return new ActionShout(actor, this, "DAMN IT!!!");

                default:
                    return new ActionShout(actor, this, "DAMN IT!!!");
            }
        }

        ActorAction GenerateFoodPoisonedAction(Actor actor) //@@MP (Release 7-6)
        {
            //a manifestation of being horribly unwell
            if (actor.IsPlayer || IsVisibleToPlayer(actor))
                AddMessage(MakeMessage(actor, "feels unwell and vomits"));
            DoVomit(actor);
            return new ActionWait(actor, this);
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2208:InstantiateArgumentExceptionsCorrectly")]
        void FoodPoisoning(Actor actor, ItemFood food = null, Corpse corpse = null) //@@MP (Release 7-6)
        {
            // we factor the rot level into how much best before turns is remaining in the meat
            int perishingFactor = 1; //placeholder
            if (food != null)
            {
                if (m_Rules.IsFoodStillFresh(food, actor.Location.Map.LocalTime.TurnCounter))
                    perishingFactor = 1; //fresh
                else if (m_Rules.IsFoodExpired(food, actor.Location.Map.LocalTime.TurnCounter))
                    perishingFactor = 3; //spoiled
                else if (m_Rules.IsFoodSpoiled(food, actor.Location.Map.LocalTime.TurnCounter))
                    perishingFactor = 5; //rotten
            }
            else if (corpse != null)
            {
                perishingFactor = Rules.CorpseRotLevel(corpse);
                /*
                    level 5: "The corpse is about to crumble to dust."
                    level 4: "The corpse is almost entirely rotten."
                    level 3: "The corpse is badly damaged."
                    level 2: "The corpse is damaged."
                    level 1: "The corpse is bruised and smells."
                    level 0: "The corpse looks fresh."
                */
            }
            else
                throw new ArgumentNullException("either one of ItemFood or Corpse arguments cannot be null");

            int baseChance = Rules.BASE_FOOD_POISONING_INFECTION_CHANCE;
            int poisoningChance = Math.Max(baseChance, (baseChance * perishingFactor)); //avoids a case of multiplying by zero, because the corpse rot levels start at 0:
            if (m_Rules.RollChance(poisoningChance - m_Rules.ActorRecoverFromFoodPoisoningChanceBonus(actor)))
            {
                actor.IsFoodPoisoned = true;
                if (actor.IsPlayer || actor.Leader == m_Player)
                    AddMessage(MakeMessage(actor, "contracted food poisoning"));
            }
        }

        void RepercussionsOfCannibalism(Actor cannibal) //@@MP (Release 7-6)
        {
            if (cannibal.Model.Abilities.IsUndead && cannibal.Model.Abilities.IsLivingAnimal) //shouldn't get to this point if true, but just in case
                return;

            if (cannibal.Model.Abilities.HasSanity)
                cannibal.Sanity = cannibal.Sanity / 2;

            //followers lose trust, and one may abandon
            IEnumerable<Actor> followers = cannibal.Followers;
            int followersCount = cannibal.CountFollowers;
            Actor abandoningFollower = null;
            if (followersCount > 0)
            {
                foreach (Actor follower in cannibal.Followers)
                {
                    if (follower.IsSleeping) continue;
                    int fov = m_Rules.ActorFOV(follower, follower.Location.Map.LocalTime, m_Session.World.Weather);
                    if (!LOS.CanTraceViewLine(follower.Location, cannibal.Location.Position, fov)) continue;

                    if (abandoningFollower == null && !Rules.IsActorInsane(follower))
                        abandoningFollower = follower;

                    follower.SetTrustIn(cannibal, Rules.TRUST_MIN);
                }
            }
            //selected follower will abandon the cannibal
            if (abandoningFollower != null)
            {
                Sayflags sayType;
                if (abandoningFollower.Leader.IsPlayer)
                    sayType = Sayflags.IS_IMPORTANT;
                else
                    sayType = Sayflags.IS_FREE_ACTION;

                abandoningFollower.SetTrustIn(cannibal, Rules.TRUST_DESPISED);
                cannibal.RemoveFollower(abandoningFollower);

                //remove a Leadership skill level
                cannibal.Sheet.SkillTable.DecOrRemoveSkill((int)Skills.IDs.LEADERSHIP); //remove one level
                DoSay(abandoningFollower, cannibal, String.Format("{0}, you monster! Get away from me!", cannibal.TheName), sayType);
            }

            // any non-follower witnesses may attack the cannibal
            bool spotted = false;
            foreach (Actor npc in cannibal.Location.Map.Actors)
            {
                if (npc.Model.Abilities.IsUndead || npc.Model.Abilities.IsLivingAnimal)
                    continue;

                if (npc.IsSleeping || npc == cannibal)
                    continue;

                if (followers != null && followers.Contains(npc)) //a friend
                    continue;

                if (Rules.IsActorInsane(npc) || Rules.IsActorStarving(npc)) //not fussed or understanding, respectively
                    continue;

                int fov = m_Rules.ActorFOV(npc, npc.Location.Map.LocalTime, m_Session.World.Weather);
                if (!LOS.CanTraceViewLine(npc.Location, cannibal.Location.Position, fov)) //can see the cannibal
                    continue;

                spotted = true;
                cannibal.MarkAsAgressorOf(npc);
                DoShout(npc, String.Format("{0} is a cannibal! Get {1}!", cannibal.Name, HimOrHer(cannibal)));
            }

            if (!spotted)  //lucky actor. well they need some sort of roughly equivalent penalty instead
            {
                //remove an skill level
                int skill = Rules.DiceRoller.Roll(0, 4);
                switch (skill)
                {
                    case 0: cannibal.Sheet.SkillTable.DecOrRemoveSkill((int)Skills.IDs.CHARISMATIC); break;
                    case 1: cannibal.Sheet.SkillTable.DecOrRemoveSkill((int)Skills.IDs.AWAKE); break;
                    case 2: cannibal.Sheet.SkillTable.DecOrRemoveSkill((int)Skills.IDs.LIGHT_EATER); break;
                    case 3: cannibal.Sheet.SkillTable.DecOrRemoveSkill((int)Skills.IDs.UNSUSPICIOUS); break;
                    default: throw new InvalidOperationException("roll for skill outside of range");
                }
            }
        }
#endregion
#endregion

#region VIEW & DRAWING
#region -VIEW ***
        void UpdatePlayerFOV(Actor player)
        {
            if (player == null)
                return;

            m_PlayerFOV = LOS.ComputeFOVFor(this, player, m_Session.WorldTime, m_Session.World.Weather, true);//, MAX_ITEMLIGHT_TINT_RANGE); //@@MP - added that other tiles light up by other light sources outside FoV (Release 6-5), added max tint range (Relese 7-1)
            player.Location.Map.SetViewAndMarkVisited(m_PlayerFOV);
        }

        public void ComputeViewRect(Point mapCenter)
        {
            int left = mapCenter.X - HALF_VIEW_WIDTH;
            int right = mapCenter.X + HALF_VIEW_WIDTH;

            int top = mapCenter.Y - HALF_VIEW_HEIGHT;
            int bottom = mapCenter.Y + HALF_VIEW_HEIGHT;

            m_MapViewRect = new Rectangle(left, top, 1 + right - left, 1 + bottom - top);
        }

        public bool IsInViewRect(Point mapPosition)
        {
            return m_MapViewRect.Contains(mapPosition);
        }
#endregion

        public void RedrawPlayScreen()
        {
            //shared variables
            bool canKnowTime = m_Rules.CanActorKnowTime(m_Player); // alpha10 dont display some infos
            bool isNight = m_Session.WorldTime.IsNight; //@@MP (Release 6-2)
            bool canActorSeeSky = m_Rules.CanActorSeeSky(m_Player);//@@MP (Release 6-2)
            bool hasLitTorch = m_Rules.HasLightOnEquipped(m_Player); //@@MP (Release 6-2)
            Weather currentWeather = m_Session.World.Weather; //@@MP (Release 6-2)

            // get mutex.
            Monitor.Enter(m_UI);

            m_UI.UI_Clear(Color.Black);
            {
                // map
                //// determine tint to apply
                Color mapTint = TINT_MIDNIGHT;
                if (hasLitTorch && (!canActorSeeSky || isNight)) //@@MP - change tint during night if torch on (Release 6-2)
                    mapTint = TINT_SUNSET; //it's a good colour for a torch too
                else if (canActorSeeSky) //@@MP - added check in case they're undergound (Release 6-1)
                    mapTint = TintForDayPhase(m_Session.WorldTime.Phase); //@@MP - restored (Release 5-7)

                //// determine graylevel for tiles and objects visited but not visible //@@MP (Release 6-2)
                string grayLevelType = "daytime"; //outside, day (default)
                if (!canActorSeeSky && m_Session.CurrentMap.Lighting != Lighting.LIT)  //@@MP - added lit check, as underground areas can be lit (Release 6-3)
                {
                    if (hasLitTorch)
                        grayLevelType = "underground_littorch"; //sky not visible, carrying lit torch
                    else
                        grayLevelType = "underground_notorch"; //sky not visible, not carrying a lit torch
                }
                else if (isNight && canActorSeeSky) //night, outside. //@@MP - added canseesky check, because it could be both night and player is underground (Release 6-3)
                {
                    if (currentWeather == Weather.CLEAR)
                        grayLevelType = "nighttime_clear";
                    else
                        grayLevelType = "nighttime_clouded";
                }

                m_UI.UI_DrawLine(Color.DarkGray, RIGHTPANEL_X, 0, RIGHTPANEL_X, MESSAGES_Y);
                DrawMap(m_Session.CurrentMap, mapTint, grayLevelType); //@@MP - added parameter for grayLevelType (Release 6-2)

                // minimap
                m_UI.UI_DrawLine(Color.DarkGray, RIGHTPANEL_X, MINIMAP_Y - 4, CANVAS_WIDTH, MINIMAP_Y - 4);
                DrawMiniMap(m_Session.CurrentMap);

                // messages   //@@ MP - bottom left section of the UI
                m_UI.UI_DrawLine(Color.DarkGray, MESSAGES_X, MESSAGES_Y - 1, CANVAS_WIDTH, MESSAGES_Y - 1);
                DrawMessages();

                // location info.  //@@MP - bottom right section of the UI
#region
                //    x0            x1 
                // y0 <map name>
                // y1 <zone name>
                // y2 <day>        <dayphase>
                // y3 <hour>       <weather>/<lighting>
                // y4 <turn>       <scoring>@<difficulty> <mode>
                // y5 <life>/<lives>   <murders>
                const int X0 = LOCATIONPANEL_TEXT_X;
                const int X1 = LOCATIONPANEL_TEXT_X + 100; //@@MP - moved inward to avoid Score running off the screen (Release 7-4)
                const int Y0 = LOCATIONPANEL_TEXT_Y;
                const int Y1 = Y0 + LINE_SPACING;
                const int Y2 = Y1 + LINE_SPACING;
                const int Y3 = Y2 + LINE_SPACING;
                const int Y4 = Y3 + LINE_SPACING;
                const int Y5 = Y4 + LINE_SPACING;
                m_UI.UI_DrawLine(Color.DarkGray, LOCATIONPANEL_X, LOCATIONPANEL_Y, LOCATIONPANEL_X, CANVAS_HEIGHT);
                m_UI.UI_DrawString(Color.White, m_Session.CurrentMap.Name, X0, Y0);
                m_UI.UI_DrawString(Color.White, LocationText(m_Session.CurrentMap, m_Player), X0, Y1);
                m_UI.UI_DrawString(Color.White, String.Format("Day  {0}", m_Session.WorldTime.Day), X0, Y2);
                if (canKnowTime)
                    m_UI.UI_DrawString(Color.White, String.Format("Hour {0}", m_Session.WorldTime.Hour), X0, Y3);
                else
                    m_UI.UI_DrawString(Color.White, "Hour ??", X0, Y3);

                // alpha10 desc day fov effect, not if cant know time
                string dayPhaseString;
                Color timeColor = Color.Gray; //@@MP - handled a bit differently from alpha 10 (Release 6-1)
                if (canKnowTime)
                {
                    dayPhaseString = DescribeDayPhase(m_Session.WorldTime.Phase);
                    int timeFovPenalty = m_Rules.NightFovPenalty(m_Player, m_Session.WorldTime);
                    if (timeFovPenalty != 0)
                        dayPhaseString += " [fov -" + timeFovPenalty + "]";
                    timeColor = m_Session.WorldTime.IsNight ? NIGHT_COLOR : DAY_COLOR; //@@MP - handled a bit differently from alpha 10 (Release 6-1)
                }
                else
                {
                    dayPhaseString = "[don't know the time]";
                    //keep the gray color
                }
                m_UI.UI_DrawString(timeColor, dayPhaseString, X1, Y2);

                Color weatherOrLightingColor;
                string weatherOrLightingString;
                switch(m_Session.CurrentMap.Lighting)
                {
                    case Lighting.OUTSIDE:
                        weatherOrLightingColor = WeatherColor(currentWeather);
                        // alpha10 only show weather if can see it
                        /*if (m_Rules.CanActorSeeSky(m_Player)) //@@MP - handled a bit differently from alpha 10 (Release 6-1)
                        {*/
                        weatherOrLightingString = DescribeWeather(currentWeather);
                            // alpha10 desc weather fov effect
                            int fovPenalty = m_Rules.WeatherFovPenalty(m_Player, currentWeather);
                            if (fovPenalty != 0)
                                weatherOrLightingString += " [fov -" + fovPenalty + "]";
                        /*}
                        else
                            weatherOrLightingString = "[can't see the sky]";*/
                        break;
                    case Lighting.DARKNESS:
                        weatherOrLightingColor = Color.Blue;
                        weatherOrLightingString = "Darkness";
                        int FOV = m_Rules.ActorFOV(m_Player, m_Session.WorldTime, m_Session.World.Weather); //@@MP (Release 6-6)
                        if (FOV == 0) //@@MP (Release 6-5)
                            weatherOrLightingString += " (CAN'T SEE!)";
                        else if (FOV != m_Player.Sheet.BaseViewRange)
                            weatherOrLightingString += "  fov " + FOV;
                        break;
                    case Lighting.LIT:
                        weatherOrLightingColor = Color.Yellow;
                        weatherOrLightingString = "Lit";
                        break;
                    default:
                        throw new InvalidOperationException("unhandled lighting type");
                }
                if (canActorSeeSky) //@@MP - handled a bit differently from alpha 10 (Release 6-1), switched to variable (Release 6-2)
                    m_UI.UI_DrawString(weatherOrLightingColor, weatherOrLightingString, X1, Y3);
                else if (m_Session.CurrentMap.Lighting == Lighting.DARKNESS && m_Rules.DarknessFov(m_Player) == 0) //@@MP (Release 6-5)
                    m_UI.UI_DrawString(Color.Red, weatherOrLightingString, X1, Y3);
                else
                    m_UI.UI_DrawString(Color.Gray, "[can't see the sky]", X1, Y3);
                m_UI.UI_DrawString(Color.White, String.Format("Reinc  {0}/{1}", (m_Session.Scoring.ReincarnationNumber), (s_Options.MaxReincarnations)), X0, Y4); //@@MP (Release 6-1)
                m_UI.UI_DrawString(Color.White, String.Format("Murders {0}", m_Player.MurdersCounter), X0, Y5); //@@MP (Release 6-1)
                m_UI.UI_DrawString(Color.White, String.Format("Score  {0} @{1}% {2}", m_Session.Scoring.TotalPoints, (int)(100*Scoring.ComputeDifficultyRating(s_Options, m_Session.Scoring.Side, m_Session.Scoring.ReincarnationNumber, m_Session.GameMode)), Session.DescShortGameMode(m_Session.GameMode)), X1, Y4);
                m_UI.UI_DrawString(Color.White, String.Format("Turn  {0}", m_Session.WorldTime.TurnCounter), X1, Y5);
#endregion

                //player status, inventory, ground and skills //@@MP
#region
                // character status.
                if (m_Player != null)
                    DrawActorStatus(m_Player, RIGHTPANEL_TEXT_X, RIGHTPANEL_TEXT_Y);
                
                // inventories.
                if (m_Player != null)
                {
                    bool hideGroundInv = false;
                    if (m_Player.Inventory != null && m_Player.Model.Abilities.HasInventory)
                    {
                        DrawInventory(m_Player.Inventory, "Inventory", true, INVENTORY_SLOTS_PER_LINE, m_Player.Inventory.MaxCapacity, INVENTORYPANEL_X, INVENTORYPANEL_Y);

                        ItemBackpack pack = m_Player.Inventory.GetFirstByType(typeof(ItemBackpack)) as ItemBackpack; //@@MP (Release 8-2)
                        if (pack != null && !pack.IsEquipped) //can only ever have one backpack in one's inventory
                        {
                            hideGroundInv = true; //hides the ground inventory, only when the backpack's inventory is open
                            DrawBackpackInventory(pack.Inventory, "Backpack", true, INVENTORY_SLOTS_PER_LINE, pack.Inventory.MaxCapacity, INVENTORYPANEL_X, BACKPACKPANEL_Y);
                        }
                    }
                    if (!hideGroundInv)
                        DrawInventory(m_Player.Location.Map.GetItemsAt(m_Player.Location.Position), "Items on ground", true, INVENTORY_SLOTS_PER_LINE, Map.GROUND_INVENTORY_SLOTS, INVENTORYPANEL_X, GROUNDINVENTORYPANEL_Y);
                    DrawCorpsesList(m_Player.Location.Map.GetCorpsesAt(m_Player.Location.Position), "Corpses on ground", INVENTORY_SLOTS_PER_LINE, INVENTORYPANEL_X, CORPSESPANEL_Y);
                }

                // character skills.
                if (m_Player != null && m_Player.Sheet.SkillTable != null && m_Player.Sheet.SkillTable.CountSkills > 0)
                    DrawActorSkillTable(m_Player, RIGHTPANEL_TEXT_X, SKILLTABLE_Y);

                // overlays
                Monitor.Enter(m_Overlays);
                foreach (Overlay o in m_Overlays)
                    o.Draw(m_UI);
                Monitor.Exit(m_Overlays);
#endregion

                // DEV STATS
#if DEBUG
                if (s_Options.DEV_ShowActorsStats)
                {
                    int countLiving, countUndead, countSimpleAnimals, countDogs;
                    countLiving = m_Session.CurrentMap.CountLivings();
                    countUndead = m_Session.CurrentMap.CountUndeads();
                    countSimpleAnimals = m_Session.CurrentMap.CountFaction(m_GameFactions.TheUnintelligentAnimals);
                    countDogs = m_Session.CurrentMap.CountFaction(m_GameFactions.TheFerals);
                    m_UI.UI_DrawString(Color.White, String.Format("Living {0}. {1} Undead. {2} Dumb animals. {3} Dogs", countLiving, countUndead, countSimpleAnimals, countDogs), RIGHTPANEL_TEXT_X, SKILLTABLE_Y - 32);
                }
#endif
            }

            m_UI.UI_Repaint();

            // release mutex.
            Monitor.Exit(m_UI);

            
            UpdatePlayerFOV(m_Player);    // make sure LOS is up to date.
        }

        static string LocationText(Map map, Actor actor) //@@MP - made static (Release 5-7)
        {
            if (map == null || actor == null)
                return "";

            StringBuilder sb = new StringBuilder(String.Format("({0},{1}) ", actor.Location.Position.X, actor.Location.Position.Y));

            List<Zone> zones = map.GetZonesAt(actor.Location.Position.X, actor.Location.Position.Y);
            if (zones == null || zones.Count == 0)
                return sb.ToString();

            foreach (Zone z in zones)
            {
                //@@MP - removed the unecessary coordinates (Release 6-6)
                int index = z.Name.IndexOf("@"); //eg "Subway Station@29-42"
                string nameOnly = (index > 0 ? z.Name.Substring(0, index) : "");
                sb.Append(String.Format("{0} ", nameOnly));//eg "Subway Station"
            }
                

            return sb.ToString();
        }

        Color TintForDayPhase(DayPhase phase)
        {
            switch (phase)
            {
                case DayPhase.MORNING:
                case DayPhase.MIDDAY:
                case DayPhase.AFTERNOON:
                    return TINT_DAY;

                case DayPhase.SUNRISE:
                    return TINT_SUNRISE;

                case DayPhase.SUNSET:
                    return TINT_SUNSET;

                case DayPhase.MIDNIGHT:
                    return TINT_MIDNIGHT;

                case DayPhase.DEEP_NIGHT:
                    return TINT_NIGHT;

                case DayPhase.EVENING:
                    return TINT_EVENING;
                default:
                    throw new ArgumentOutOfRangeException("phase","unhandled dayphase");
            }
        }

#region DRAWING ELEMENTS
        /// <summary>
        /// Draws the image (tile or object) with the appropriate gray level according to the time of day and location
        /// </summary>
        /// <param name="grayLevelType">For day, night or underground</param>
        private void DrawGrayLevelHandler(string imageID, int gx, int gy, string grayLevelType) //@@MP (Release 6-2)
        {
            m_UI.UI_DrawGrayLevelImage(imageID, gx, gy, grayLevelType); //@@MP - simplified method (Release 6-3)
        }

        public void DrawMap(Map map, Color tint, string grayLevelType) //@@MP - added distinctions for different times and locations. makes the visited but not-in-FOV tiles darker accordingly (Release 6-2)
        {
            // trim to outer map bounds.
            int left = Math.Max(-1, m_MapViewRect.Left);
            int right = Math.Min(map.Width + 1, m_MapViewRect.Right);
            int top = Math.Max(-1, m_MapViewRect.Top);
            int bottom = Math.Min(map.Height + 1, m_MapViewRect.Bottom);

            // get weather image.
            string weatherImage;
            switch (m_Session.World.Weather)
            {
                case Weather.RAIN:
                    weatherImage = (m_Session.WorldTime.TurnCounter % 2 == 0 ? GameImages.EFFECT_WEATHER_RAIN1 : GameImages.EFFECT_WEATHER_RAIN2);
                    break;
                case Weather.HEAVY_RAIN:
                    weatherImage = (m_Session.WorldTime.TurnCounter % 2 == 0 ? GameImages.EFFECT_WEATHER_HEAVY_RAIN1 : GameImages.EFFECT_WEATHER_HEAVY_RAIN2);
                    break;
                default:
                    weatherImage = null;
                    break;
            }

            ///////////////////////////////////////////
            // Layered draw:
            // 1. Tiles.
            // 2. Corpses.
            // 3. (Target statut), Map objects.
            // 4. Fires (if visible)
            // 5. Scents.
            // 6. Items, Actors (if visible).
            // 7. Water cover.
            // 8. Weather (if visible and not inside).
            // 9. Screen effects
            ///////////////////////////////////////////
            Point position = new Point();
            bool isUndead = m_Player.Model.Abilities.IsUndead;
            bool hasSmell = m_Player.Model.StartingSheet.BaseSmellRating > 0;
            int playerSmellTheshold = m_Rules.ActorSmellThreshold(m_Player);

            for (int x = left; x < right; x++)
            {
                position.X = x;
                for (int y = top; y < bottom; y++)
                {
                    position.Y = y;
                    Point toScreen = MapToScreen(x, y);
                    bool isVisible = IsVisibleToPlayer(map, position);
                    bool drawWater = false;
                    Tile tile = map.IsInBounds(x, y) ? map.GetTileAt(x, y) : null;

                    // 1. Tile
                    if (map.IsInBounds(x, y))
                        DrawTile(tile, toScreen, tint, grayLevelType); //@@MP - added parameter for grayLevelType (Release 6-1)
                    else if (map.IsMapBoundary(x, y))
                    {
                        if(map.GetExitAt(position) != null)
                            DrawExit(toScreen, tint);
                    }

                    // 2. Corpses
                    if (isVisible)
                    {
                        List<Corpse> corpses = map.GetCorpsesAt(x, y);
                        if (corpses != null)
                        {
                            foreach (Corpse c in corpses)
                                DrawCorpse(c, toScreen.X, toScreen.Y, tint); //@@MP - unused parameter (Release 5-7), added tint (Release 7-2)
                        }
                    }

                    // 3. (TargetStatus), Map objects
                    if (s_Options.ShowPlayerTargets && !m_Player.IsSleeping && m_Player.Location.Position == position)
                        DrawPlayerActorTargets(m_Player);
                    MapObject mapObj = map.GetMapObjectAt(x, y);
                    if (mapObj != null)
                    {
                        DrawMapObject(mapObj, toScreen, tint, grayLevelType); //@@MP - added parameter for grayLevelType (Release 6-2)
                        drawWater = true;
                    }

                    // 4. Fires (if visible)                     //@@MP - added (Release 7-4)
                    // draw these after mapbojects to ensure they are brought to the front (avoid fires hiding behind say benches)
                    if (map.IsInBounds(x, y) && tile.HasDecorations && isVisible)
                    {
                        foreach (string deco in tile.Decorations)
                        {
                            if (deco == @"Effects\onFire")
                                m_UI.UI_DrawImage(deco, toScreen.X, toScreen.Y, tint);
                        }
                    }

                    // 5. Scents
#region
                    if (!m_Player.IsSleeping && map.IsInBounds(x, y) && m_Rules.GridDistance(m_Player.Location.Position, position) <= 1)
                    {
                        // scents alpha is low to be able to see objects behind them (eg: scent on a door)
                        // squaring alpha helps increase discrimination for player.

                        if (isUndead)
                        {
                            // Undead can see living & zm scents.
                            if (hasSmell)
                            {
                                // living scent?
                                int livingScent = map.GetScentStrengthByOdorAt(Odor.LIVING, position);
                                if (livingScent >= playerSmellTheshold)
                                {
                                    float alpha = 0.90f * (float)livingScent / (float)OdorScent.MAX_STRENGTH;
                                    alpha *= alpha;
                                    m_UI.UI_DrawTransparentImage(alpha, GameImages.ICON_SCENT_LIVING, toScreen.X, toScreen.Y);
                                }

                                // zombie master scent?
                                int masterScent = map.GetScentStrengthByOdorAt(Odor.UNDEAD_MASTER, position);
                                if (masterScent >= playerSmellTheshold)
                                {
                                    float alpha = 0.90f * (float)masterScent / (float)OdorScent.MAX_STRENGTH;
                                    alpha *= alpha;
                                    m_UI.UI_DrawTransparentImage(alpha, GameImages.ICON_SCENT_ZOMBIEMASTER, toScreen.X, toScreen.Y);
                                }
                            }
                        }
                        /*else // alpha10 obsolete
                        {
                            // Living can see some perfumes.
                            // perfume: living suppressor?
                            int livingSupr = map.GetScentByOdorAt(Odor.PERFUME_LIVING_SUPRESSOR, position);
                            if (livingSupr > 0)
                            {
                                float alpha = 0.90f * (float)livingSupr / (float)OdorScent.MAX_STRENGTH;
                                //alpha *= alpha;
                                m_UI.UI_DrawTransparentImage(alpha, GameImages.ICON_SCENT_LIVING_SUPRESSOR, toScreen.X, toScreen.Y);
                            }
                        }*/
                    }
#endregion

                    // 6. Items and Actors (if visible)
                    if (isVisible)
                    {
                        // Items
                        Inventory inv = map.GetItemsAt(x, y);
                        if (inv != null)
                        {
                            DrawItemsStack(inv, toScreen.X, toScreen.Y, tint);
                            drawWater = true;
                        }

                        // Actors
                        Actor actor = map.GetActorAt(x, y);
                        if (actor != null)
                        {
                            DrawActorSprite(actor, toScreen, tint);
                            drawWater = true;
                        }
                    }

                    // 7. Water cover.
                    if (tile != null && tile.HasDecorations)
                        drawWater = true;
                    if (drawWater && tile.Model.IsWater)
                        DrawTileWaterCover(tile, toScreen, tint, grayLevelType); //@@MP - added parameter for grayLevelType (Release 6-2)

                    // 8. Weather (if visible and not inside).
                    if (isVisible && weatherImage != null && tile != null && !tile.IsInside)
                        m_UI.UI_DrawImage(weatherImage, toScreen.X, toScreen.Y);

                    // 9. screen effects (applied last because they must overlay everything else)   //@@MP (Release 7-2)
                    if (isVisible)
                    {
                        if (m_Player.IsFlashbanged) // flashbang-affected
                        {
                            switch (m_Player.FlashbangedTurns)
                            {
                                case 1: m_UI.UI_DrawImage(GameImages.EFFECT_FLASHBANG_020, toScreen.X, toScreen.Y); break;
                                case 2: m_UI.UI_DrawImage(GameImages.EFFECT_FLASHBANG_040, toScreen.X, toScreen.Y); break;
                                case 3: m_UI.UI_DrawImage(GameImages.EFFECT_FLASHBANG_060, toScreen.X, toScreen.Y); break;
                                case 4: m_UI.UI_DrawImage(GameImages.EFFECT_FLASHBANG_080, toScreen.X, toScreen.Y); break;
                                case 5: m_UI.UI_DrawImage(GameImages.EFFECT_FLASHBANG_100, toScreen.X, toScreen.Y); break;
                                default: throw new InvalidOperationException("unexpected FlashbangedTurns value (probably 6+)");
                            }
                        }
                        else if (m_Player.Model.Abilities.HasSanity && m_Rules.IsActorDisturbed(m_Player)) //@@MP (Release 7-3)
                        {
                            //warning colour as you get really low on sanity
                            if (m_Player.Sanity < 50) //very disturbed
                                m_UI.UI_DrawImage(GameImages.EFFECT_DISTURBED_HIGH, toScreen.X, toScreen.Y);
                            else if (m_Player.Sanity < 100) //quite disturbed
                                m_UI.UI_DrawImage(GameImages.EFFECT_DISTURBED_MED, toScreen.X, toScreen.Y);
                            else if (m_Player.Sanity < 150) //a little bit disturbed
                                m_UI.UI_DrawImage(GameImages.EFFECT_DISTURBED_LOW, toScreen.X, toScreen.Y);
                        }
                        else if (m_Player.IsDrunk) //@@MP (Release 7-3)
                        {
                            switch (m_Player.GetIntoxicationDescription())
                            {
                                case "tipsy": //40-59%
                                    m_UI.UI_DrawImage(GameImages.EFFECT_TIPSY, toScreen.X, toScreen.Y); break;
                                case "drunk": //60-79%
                                    m_UI.UI_DrawImage(GameImages.EFFECT_DRUNK, toScreen.X, toScreen.Y); break;
                                case "hammered": //80-99%
                                    m_UI.UI_DrawImage(GameImages.EFFECT_HAMMERED, toScreen.X, toScreen.Y); break;
                            }
                        }
                        else //wearing NVGs?
                        {
                            ItemLight eyesLight = m_Player.GetEquippedItem(DollPart.EYES) as ItemLight; //@@MP (Release 6-3)
                            if (eyesLight != null && m_Rules.IsItemNightVision(eyesLight) && eyesLight.Batteries > 0) //@@MP - night vision are the only ItemLights on the head dollpart
                                m_UI.UI_DrawImage(GameImages.EFFECT_NIGHTVISION, toScreen.X, toScreen.Y);
                        }
                    }
                }
            }

            // DEV: scents
#if false
            for (int x = left; x < right; x++)
                for (int y = top; y < bottom; y++)
                {
                    if (map.IsInBounds(x, y))
                    {
                        int scent = map.GetScentByOdorAt(Odor.LIVING, new Point(x, y));
                        if (scent > 0)
                        {
                            m_UI.UI_DrawString(Color.White, String.Format("{0}", scent), MapToScreen(x, y).X, MapToScreen(x, y).Y);
                        }
                    }
                }
#endif
        }

        string MovingWaterImage(TileModel model, int turnCount)
        {
            if (model == m_GameTiles.FLOOR_SEWER_WATER)
            {
                int i = turnCount % 3;
                switch (i)
                {
                    case 0: return GameImages.TILE_FLOOR_SEWER_WATER_ANIM1;
                    case 1: return GameImages.TILE_FLOOR_SEWER_WATER_ANIM2;
                    default: return GameImages.TILE_FLOOR_SEWER_WATER_ANIM3;
                }
            }

            return null;
        }

        public void DrawTile(Tile tile, Point screen, Color tint, string grayLevelType) //@@MP - added grayLevel for environment-specific 'fog of war' tuning (Release 6-2)
        {
            if (tile.IsInView)  // visible
            {
                // tile.
                m_UI.UI_DrawImage(tile.Model.ImageID, screen.X, screen.Y, tint);

                // animation layer.
                string movingWater = MovingWaterImage(tile.Model, m_Session.WorldTime.TurnCounter);
                if (movingWater != null)
                    m_UI.UI_DrawImage(movingWater, screen.X, screen.Y, tint);

                // decorations.
                if (tile.HasDecorations)
                {
                    foreach (string deco in tile.Decorations)
                    {
                        if (deco != @"Effects\onFire") //@@MP - handled as a separate step in DrawMap() (Release 7-4)
                            m_UI.UI_DrawImage(deco, screen.X, screen.Y, tint);
                    }
                }
            }
            else if (tile.IsVisited && !IsPlayerSleeping()) // memorized
            {
                //@@MP - added distinctions for different times and locations (grayLevelType). makes the visited but not-in-FOV tiles darker accordingly (Release 6-2)

                // tile.
                DrawGrayLevelHandler(tile.Model.ImageID, screen.X, screen.Y, grayLevelType);

                // animation layer.
                string movingWater = MovingWaterImage(tile.Model, m_Session.WorldTime.TurnCounter);
                if (movingWater != null)
                    DrawGrayLevelHandler(movingWater, screen.X, screen.Y, grayLevelType);

                // decorations.
                if (tile.HasDecorations)
                    foreach (string deco in tile.Decorations)
                    {
                        List<string> donotrenderthese = new List<string> { GameImages.DECO_ZOMBIE_REMAINS_RAW, GameImages.DECO_ZOMBIE_REMAINS_BURNED, GameImages.DECO_SKELETON_REMAINS,
                            GameImages.DECO_RAT_ZOMBIE_REMAINS, GameImages.DECO_LIT_CANDLE, GameImages.DECO_VOMIT, GameImages.DECO_BLOODIED_FLOOR, GameImages.DECO_BLOODIED_FLOOR_SMALL,
                            GameImages.DECO_BLOODIED_WALL, GameImages.DECO_BLOODIED_WALL_SMALL } ;
                        if (!donotrenderthese.Contains(deco)) //@@MP - added a filter for perishable stuff (Release 7-6)
                            DrawGrayLevelHandler(deco, screen.X, screen.Y, grayLevelType);
                    }
            }
        }

        public void DrawTileWaterCover(Tile tile, Point screen, Color tint, string grayLevelType) //@@MP - added parameter to allow graylevels for different times of day/location (Release 6-2)
        {
            if (tile.IsInView)  // visible
            {
                // tile.
                m_UI.UI_DrawImage(tile.Model.WaterCoverImageID, screen.X, screen.Y, tint);
            }
            else if (tile.IsVisited && !IsPlayerSleeping()) // memorized
            {
                // tile.
                DrawGrayLevelHandler(tile.Model.WaterCoverImageID, screen.X, screen.Y, grayLevelType);
            }
        }

        public void DrawExit(Point screen, Color tint) //@@MP - added tint (Release 7-2)
        {
            m_UI.UI_DrawImage(GameImages.MAP_EXIT, screen.X, screen.Y, tint);
        }

        public void DrawTileRectangle(Point mapPosition, Color color)
        {
            m_UI.UI_DrawRect(color, new Rectangle(MapToScreen(mapPosition), new Size(TILE_SIZE, TILE_SIZE)));
        }

        public void DrawMapObject(MapObject mapObj, Point screen, Color tint, string grayLevelType) //@@MP - added parameter to allow graylevels for different times of day/location (Release 6-2)
        {
            // pushables objects in water floating animation.
            if (mapObj.IsMovable && mapObj.Location.Map.GetTileAt(mapObj.Location.Position.X, mapObj.Location.Position.Y).Model.IsWater)
            {
                int yDrift = (mapObj.Location.Position.X + m_Session.WorldTime.TurnCounter) % 2 == 0 ? -2 : 0;
                screen.Y -= yDrift;
            }

            if (IsVisibleToPlayer(mapObj))
            {
                DrawMapObject(mapObj, screen, mapObj.ImageID, (imageID, gx, gy) => m_UI.UI_DrawImage(imageID, gx, gy, tint));

                if (mapObj.HitPoints < mapObj.MaxHitPoints && mapObj.HitPoints > 0)
                    DrawMapHealthBar(mapObj.HitPoints, mapObj.MaxHitPoints, screen.X, screen.Y);

                DoorWindow door = mapObj as DoorWindow;
                if (door != null && door.BarricadePoints > 0)
                {
                    DrawMapHealthBar(door.BarricadePoints, Rules.BARRICADING_MAX, screen.X, screen.Y, Color.Green);
                    m_UI.UI_DrawImage(GameImages.EFFECT_BARRICADED, screen.X, screen.Y, tint);
                }

                Car car = mapObj as Car; //@@MP (Release 7-1)
                if (car != null && !car.IsOnFire)
                {
                    DrawMapFuelBar(car.FuelUnits, car.MaxFuelUnits, screen.X, screen.Y); //@@MP - added MaxFuelUnits property (Release 7-6)
                }
                Barrel barrel = mapObj as Barrel; //@@MP (Release 7-6)
                if (barrel != null && barrel.IsOnFire)
                {
                    DrawMapFuelBar(barrel.FuelUnits, barrel.MaxFuelUnits, screen.X, screen.Y);
                }
                Campfire campfire = mapObj as Campfire; //@@MP (Release 7-6)
                if (campfire != null && campfire.IsOnFire)
                {
                    DrawMapFuelBar(campfire.FuelUnits, campfire.MaxFuelUnits, screen.X, screen.Y);
                }
            }
            else if (IsKnownToPlayer(mapObj) && !IsPlayerSleeping())
            {
                DrawMapObject(mapObj, screen, mapObj.HiddenImageID, (imageID, gx, gy) => m_UI.UI_DrawGrayLevelImage(imageID, gx, gy, grayLevelType)); //@@MP - added grayLevelType (Release 6-2)
            }
        }

        static void DrawMapObject(MapObject mapObj, Point screen, string imageID, Action<string, int, int> drawFn) //@@MP - made static (Release 5-7)
        {
            // draw image.
            drawFn(imageID, screen.X, screen.Y);

            // draw effects.
            //@@MP: so far EFFECT_ONFIRE is only for cars. RJ drafted it for other mapobj (eg doors) but never implemented them, and that's why I haven't used
            //      the MapObject.Car class as the filter here.
            //TODO: this really needs a better overall implementation
            if (mapObj.IsOnFire)
            {
                if (mapObj is Car)
                    drawFn(GameImages.EFFECT_ONFIRE, screen.X, screen.Y);
                else if (mapObj is Barrel)  //@@MP - added (Release 7-6)
                    drawFn(GameImages.EFFECT_BARREL_ONFIRE, screen.X, screen.Y);
                else if (mapObj is Campfire)  //@@MP - added (Release 7-6)
                    drawFn(GameImages.EFFECT_CAMPFIRE_ONFIRE, screen.X, screen.Y);
            }
        }

        public void DrawActorSprite(Actor actor, Point screen, Color tint)
        {
            int gx = screen.X;
            int gy = screen.Y;

            // player follower?
            if (actor.Leader != null && actor.Leader == m_Player)
            {
                if (m_Rules.HasActorBondWith(actor, m_Player))
                    m_UI.UI_DrawImage(GameImages.PLAYER_FOLLOWER_BOND, gx, gy, tint);
                else if (m_Rules.IsActorTrustingLeader(actor))
                    m_UI.UI_DrawImage(GameImages.PLAYER_FOLLOWER_TRUST, gx, gy, tint);
                else
                    m_UI.UI_DrawImage(GameImages.PLAYER_FOLLOWER, gx, gy, tint);
            }

            gx += ACTOR_OFFSET;
            gy += ACTOR_OFFSET;

            // rotation for various states //@@MP (Release 7-2)
            float rotation = 0;
            float scale = 1.0f;
            if (actor.IsSleeping)  //@@MP (Release 7-3)
                rotation = 90;  //degrees
            else if (actor.IsIncapacitated) //@@MP (Release 7-2)
                rotation = 45;

            // model
            if (actor.Model.ImageID != null)
                m_UI.UI_DrawImage(actor.Model.ImageID, gx, gy, tint);

            // skin/clothing
            DrawActorDecoration(actor, gx, gy, DollPart.SKIN, tint, rotation, scale);
            DrawActorDecoration(actor, gx, gy, DollPart.FEET, tint, rotation, scale);
            DrawActorDecoration(actor, gx, gy, DollPart.LEGS, tint, rotation, scale);
            DrawActorDecoration(actor, gx, gy, DollPart.EYES, tint, rotation, scale);
            DrawActorDecoration(actor, gx, gy, DollPart.HEAD, tint, rotation, scale);
            DrawActorDecoration(actor, gx, gy, DollPart.TORSO, tint, rotation, scale);

            // equipment
            DrawActorEquipment(actor, gx - ACTOR_OFFSET, gy - ACTOR_OFFSET, DollPart.TORSO, tint, rotation, scale);
            DrawActorEquipment(actor, gx - ACTOR_OFFSET, gy - ACTOR_OFFSET, DollPart.RIGHT_HAND, tint, rotation, scale);
            DrawActorEquipment(actor, gx - ACTOR_OFFSET, gy - ACTOR_OFFSET, DollPart.LEFT_HAND, tint, rotation, scale); //@@MP (Release 6-2) swapped to 2nd so torches appear over guns
            DrawActorEquipment(actor, gx - ACTOR_OFFSET, gy - ACTOR_OFFSET, DollPart.EYES, tint, rotation, scale); //@@MP - for night vision goggles (Release 6-3)
            DrawActorEquipment(actor, gx - ACTOR_OFFSET, gy - ACTOR_OFFSET, DollPart.LEFT_ARM, tint, rotation, scale); //@@MP - left arm drawn last so that shield can go over the rest (Release 7-2)

            gx -= ACTOR_OFFSET;
            gy -= ACTOR_OFFSET;

            // personal enemy?
            if (m_Player != null)
            {
                if (m_Player.IsSelfDefenceFrom(actor)) //in self defence
                    m_UI.UI_DrawImage(GameImages.ICON_SELF_DEFENCE, gx, gy, tint);
                else if (m_Player.IsAggressorOf(actor)) //i'm the aggressor
                    m_UI.UI_DrawImage(GameImages.ICON_AGGRESSOR, gx, gy, tint);
                else if (!m_Player.Faction.IsEnemyOf(actor.Faction) && m_Rules.AreGroupEnemies(m_Player, actor)) // alpha10, modified //indirect enemies
                    m_UI.UI_DrawImage(GameImages.ICON_INDIRECT_ENEMIES, gx, gy, tint);
            }

            // activity
#region
            switch (actor.Activity)
            {
                case Activity.IDLE:
                case Activity.EATING:
                case Activity.EXPLORING:
                case Activity.WANDERING:
                case Activity.FINDING_EXIT:
                case Activity.HEALING:
                case Activity.WAITING:
                case Activity.PATROLLING:
                case Activity.CHATTING:
                case Activity.REVIVING:
                case Activity.BUILDING:
                case Activity.MANAGING_INVENTORY:
                case Activity.TRADING:
                case Activity.SEARCHING:
                case Activity.SHOUTING:
                case Activity.DESTROYING:
                case Activity.RESTING:
                case Activity.FISHING:
                case Activity.COOKING:
                    break;

                case Activity.CHASING:
                case Activity.FIGHTING:
                case Activity.HUNTING:
                    if (actor.IsPlayer)
                        break;
                    if (actor.TargetActor == null)
                        break;

                    if (actor.TargetActor != null && actor.TargetActor == m_Player)
                        m_UI.UI_DrawImage(GameImages.ACTIVITY_CHASING_PLAYER, gx, gy, tint);
                    else
                        m_UI.UI_DrawImage(GameImages.ACTIVITY_CHASING, gx, gy, tint);
                    break;

                case Activity.TRACKING:
                    if (actor.IsPlayer)
                        break;

                    m_UI.UI_DrawImage(GameImages.ACTIVITY_TRACKING, gx, gy, tint);
                    break;

                case Activity.FLEEING:
                    if (actor.IsPlayer)
                        break;

                    m_UI.UI_DrawImage(GameImages.ACTIVITY_FLEEING, gx, gy, tint);
                    break;

                case Activity.FLEEING_FROM_EXPLOSIVE:
                    if (actor.IsPlayer)
                        break;

                    m_UI.UI_DrawImage(GameImages.ACTIVITY_FLEEING_FROM_EXPLOSIVE, gx, gy, tint);
                    break;

                case Activity.FOLLOWING:
                    if (actor.IsPlayer)
                        break;
                    if (actor.TargetActor == null)
                        break;

                    if (actor.TargetActor.IsPlayer)
                        m_UI.UI_DrawImage(GameImages.ACTIVITY_FOLLOWING_PLAYER, gx, gy);
                    else if (actor.TargetActor == actor.Leader) // alpha10
                        m_UI.UI_DrawImage(GameImages.ACTIVITY_FOLLOWING_LEADER, gx, gy);
                    else
                        m_UI.UI_DrawImage(GameImages.ACTIVITY_FOLLOWING, gx, gy);
                    break;

                case Activity.FOLLOWING_ORDER:
                    m_UI.UI_DrawImage(GameImages.ACTIVITY_FOLLOWING_ORDER, gx, gy);
                    break;

                case Activity.SLEEPING:
                    m_UI.UI_DrawImage(GameImages.ACTIVITY_SLEEPING, gx, gy);
                    break;

                default:
                    throw new InvalidOperationException("unhandled activity " + actor.Activity);
            }
#endregion

            // health bar.
            int maxHP = m_Rules.ActorMaxHPs(actor);
            if (actor.HitPoints < maxHP)
            {
                DrawMapHealthBar(actor.HitPoints, maxHP, gx, gy);
            }

            // run/tired icon.
#region
            if (actor.IsRunning)
                m_UI.UI_DrawImage(GameImages.ICON_RUNNING, gx, gy, tint);
            else if (actor.Model.Abilities.CanRun && !m_Rules.CanActorRun(actor))
                m_UI.UI_DrawImage(GameImages.ICON_CANT_RUN, gx, gy, tint);
#endregion

            // sleepy, hungry & insane icons.
#region
            if (actor.Model.Abilities.HasToSleep)
            {
                if (actor.IsIncapacitated) //@@MP - added incapacitated (Release 7-2)
                    m_UI.UI_DrawImage(GameImages.ICON_INCAPACITATED, gx, gy, tint);
                else if (m_Rules.IsActorExhausted(actor))
                    m_UI.UI_DrawImage(GameImages.ICON_SLEEP_EXHAUSTED, gx, gy, tint);
                else if (m_Rules.IsActorSleepy(actor))
                    m_UI.UI_DrawImage(GameImages.ICON_SLEEP_SLEEPY, gx, gy, tint);
                else if (m_Rules.IsAlmostSleepy(actor))
                    m_UI.UI_DrawImage(GameImages.ICON_SLEEP_ALMOST_SLEEPY, gx, gy, tint);
            }

            if (actor.Model.Abilities.HasToEat)
            {
                if (m_Rules.IsActorStarving(actor))
                    m_UI.UI_DrawImage(GameImages.ICON_FOOD_STARVING, gx, gy, tint);
                else if (m_Rules.IsActorHungry(actor))
                    m_UI.UI_DrawImage(GameImages.ICON_FOOD_HUNGRY, gx, gy, tint);
                else if (IsAlmostHungry(actor))
                    m_UI.UI_DrawImage(GameImages.ICON_FOOD_ALMOST_HUNGRY, gx, gy, tint);
            }
            else if (actor.Model.Abilities.IsRotting)
            {
                if (m_Rules.IsRottingActorStarving(actor))
                    m_UI.UI_DrawImage(GameImages.ICON_ROT_STARVING, gx, gy, tint);
                else if (m_Rules.IsRottingActorHungry(actor))
                    m_UI.UI_DrawImage(GameImages.ICON_ROT_HUNGRY, gx, gy, tint);
                else if (IsAlmostRotHungry(actor))
                    m_UI.UI_DrawImage(GameImages.ICON_ROT_ALMOST_HUNGRY, gx, gy, tint);
            }

            if (actor.Model.Abilities.HasSanity)
            {
                if (m_Rules.IsActorInsane(actor))
                    m_UI.UI_DrawImage(GameImages.ICON_SANITY_INSANE, gx, gy, tint);
                else if (m_Rules.IsActorDisturbed(actor))
                    m_UI.UI_DrawImage(GameImages.ICON_SANITY_DISTURBED, gx, gy, tint);
            }

            if (actor.IsDrunk) //@@MP (Release 7-1)
                m_UI.UI_DrawImage(GameImages.ICON_DRUNK, gx, gy, tint);
#endregion

            // can trade with player icon.
            if (m_Player != null && m_Rules.CanActorInitiateTradeWith(m_Player, actor))
                m_UI.UI_DrawImage(GameImages.ICON_CAN_TRADE, gx, gy, tint);

            // alpha10 odor suppressed icon (FIXME: will overlap with sleep healing, but not a big deal)
            if (actor.OdorSuppressorCounter > 0)
                m_UI.UI_DrawImage(GameImages.ICON_ODOR_SUPPRESSED, gx, gy, tint);

            // sleep-healing icon.
            if (actor.IsSleeping && (m_Rules.IsOnCouch(actor) || m_Rules.ActorHealChanceBonus(actor) > 0))
                m_UI.UI_DrawImage(GameImages.ICON_HEALING, gx, gy, tint);

            // is a leader icon.
            if (actor.CountFollowers > 0)
                m_UI.UI_DrawImage(GameImages.ICON_LEADER, gx, gy, tint);

            // z-grab skill warning icon   // alpha10
            if (actor.Sheet.SkillTable.GetSkillLevel((int)Skills.IDs.Z_GRAB) > 0)
                m_UI.UI_DrawImage(GameImages.ICON_ZGRAB, gx, gy, tint);

            // combat assitant helper.
            if (s_Options.IsCombatAssistantOn)
            {
                if (actor != m_Player && m_Player != null && m_Rules.AreEnemies(actor, m_Player))
                {
                    if (m_Rules.WillActorActAgainBefore(m_Player, actor))
                        m_UI.UI_DrawImage(GameImages.ICON_THREAT_SAFE, gx, gy, tint);
                    else if (m_Rules.WillOtherActTwiceBefore(m_Player, actor))
                        m_UI.UI_DrawImage(GameImages.ICON_THREAT_HIGH_DANGER, gx, gy, tint);
                    else
                        m_UI.UI_DrawImage(GameImages.ICON_THREAT_DANGER, gx, gy, tint);
                }
            }
        }

        public void DrawActorDecoration(Actor actor, int gx, int gy, DollPart part, Color tint)
        {
            List<string> decos = actor.Doll.GetDecorations(part);
            if (decos == null)
                return;

            foreach (string imageID in decos)
                m_UI.UI_DrawImage(imageID, gx, gy, tint);
        }

        public void DrawActorDecoration(Actor actor, int gx, int gy, DollPart part, Color tint, float rotation, float scale)
        {
            List<string> decos = actor.Doll.GetDecorations(part);
            if (decos == null)
                return;

            foreach (string imageID in decos)
                m_UI.UI_DrawImageTransform(imageID, gx, gy, tint, rotation, scale);
        }

        public void DrawActorEquipment(Actor actor, int gx, int gy, DollPart part, Color tint)
        {
            Item it = actor.GetEquippedItem(part);
            if (it == null)
                return;

            m_UI.UI_DrawImage(it.ImageID, gx, gy, tint);
        }

        public void DrawActorEquipment(Actor actor, int gx, int gy, DollPart part, Color tint, float rotation, float scale) //@@MP (Release 7-2)
        {
            Item it = actor.GetEquippedItem(part);
            if (it == null)
                return;

            m_UI.UI_DrawImageTransform(it.ImageID, gx, gy, tint, rotation, scale);
        }

        public void DrawCorpse(Corpse c, int gx, int gy, Color tint) //@@MP - unused parameter (Release 5-7)
        {
            float rotation = c.Rotation;
            float scale = c.Scale;
            int offset = 0;// TILE_SIZE / 2;

            Actor actor = c.DeadGuy;

            gx += ACTOR_OFFSET + offset;
            gy += ACTOR_OFFSET + offset;
            
            // model.
            if (actor.Model.ImageID != null)
                m_UI.UI_DrawImageTransform(actor.Model.ImageID, gx, gy, tint, rotation, scale);

            // skinning/clothing.
            DrawActorDecoration(actor, gx, gy, DollPart.SKIN, tint, rotation, scale);
            DrawActorDecoration(actor, gx, gy, DollPart.FEET, tint, rotation, scale);
            DrawActorDecoration(actor, gx, gy, DollPart.LEGS, tint, rotation, scale);
            //DrawActorDecoration(actor, gx, gy, DollPart.TORSO, tint, rotation, scale); //@@MP - not sure why it was always drawn twice... (Release 2)
            DrawActorDecoration(actor, gx, gy, DollPart.TORSO, tint, rotation, scale);
            DrawActorDecoration(actor, gx, gy, DollPart.EYES, tint, rotation, scale);
            DrawActorDecoration(actor, gx, gy, DollPart.HEAD, tint, rotation, scale);

            gx -= ACTOR_OFFSET + offset;
            gy -= ACTOR_OFFSET + offset;

            // rotting.
            int rotLevel = Rules.CorpseRotLevel(c);
            string img = null;
            switch (rotLevel)
            {
                case 5: 
                case 4: 
                case 3: 
                case 2:
                case 1: img = @"Effects\rot" + rotLevel + "_"; break;
                case 0: break;
                default: throw new ArgumentException("unhandled rot level","c");
            }
            if (img != null)
            {
                // anim frame.
                img += 1 + (m_Session.WorldTime.TurnCounter % 2);
                // a bit of offset for a nice flies movement effect.
                int rotdx = (m_Session.WorldTime.TurnCounter % 5) - 2;
                int rotdy = ((m_Session.WorldTime.TurnCounter / 3) % 5) - 2;
                m_UI.UI_DrawImage(img, gx + rotdx, gy + rotdy);
            }
        }

        public void DrawCorpsesList(List<Corpse> list, string title, int slots, int gx, int gy)
        {
            int x, y;
            int slot = 0;

            // Draw title.
            int n = (list == null ? 0 : list.Count);
            if (n > 0) title += " : " + n;
            gy -= BOLD_LINE_SPACING;
            m_UI.UI_DrawStringBold(Color.White, title, gx, gy);
            gy += BOLD_LINE_SPACING;

            // Draw slots.
            x = gx; y = gy; slot = 0;
            for (int i = 0; i < slots; i++)
            {
                m_UI.UI_DrawImage(GameImages.ITEM_SLOT, x, y);
                x += TILE_SIZE;
            }

            // Draw corpses.
            if (list == null)
                return;

            x = gx; y = gy; slot = 0;
            foreach (Corpse c in list)
            {
                if (c.IsDragged)
                    m_UI.UI_DrawImage(GameImages.CORPSE_DRAGGED, x, y);
                DrawCorpse(c, x, y, Color.White); //@@MP - unused parameter (Release 5-7), added tint [though not appplicable] (Release 7-2)
                if (++slot >= slots)
                    break;
                else
                    x += TILE_SIZE;
            }
        }

        /// <summary>
        /// Highlight with overlays which visible actors are
        /// - are the target of this actor 
        /// - targeting this actor
        /// - in group with this actor
        /// </summary>
        /// <param name="actor"></param>
        public void DrawActorRelations(Actor actor) //alpha 10, was DrawActorTargets()
        {
            Point offset = new Point(TILE_SIZE / 2, TILE_SIZE / 2);

            // target of this actor
            if (actor.TargetActor != null && !actor.TargetActor.IsDead && IsVisibleToPlayer(actor.TargetActor))
                AddOverlay(new OverlayImage(MapToScreen(actor.TargetActor.Location.Position), GameImages.ICON_IS_TARGET));

            // actors targeting this actor or in same group
            bool isTargettedHighlighted = false;
            foreach (Actor other in actor.Location.Map.Actors)
            {
                if (!IsVisibleToPlayer(other) || other == actor || other.IsDead)
                    continue;

                // targetting this actor
                if (other.TargetActor == actor && (other.Activity == Activity.CHASING || other.Activity == Activity.FIGHTING))
                {
                    if (!isTargettedHighlighted)
                    {
                        AddOverlay(new OverlayImage(MapToScreen(actor.Location.Position), GameImages.ICON_IS_TARGETTED));
                        isTargettedHighlighted = true;
                    }
                    AddOverlay(new OverlayImage(MapToScreen(other.Location.Position), GameImages.ICON_IS_TARGETING));
                }

                // in group with actor
                if (other.IsInGroupWith(actor))
                    AddOverlay(new OverlayImage(MapToScreen(other.Location.Position), GameImages.ICON_IS_IN_GROUP));
            }
        }

        /// <summary>
        /// immediate mode
        /// </summary>
        /// <param name="player"></param>
        public void DrawPlayerActorTargets(Actor player)
        {
            Point offset = new Point(TILE_SIZE / 2, TILE_SIZE / 2);

            if (player.TargetActor != null && !player.TargetActor.IsDead && IsVisibleToPlayer(player.TargetActor))
            {
                Point gpos = MapToScreen(player.TargetActor.Location.Position);
                m_UI.UI_DrawImage(GameImages.ICON_IS_TARGET, gpos.X, gpos.Y);
            }
            foreach (Actor a in player.Location.Map.Actors)
            {
                if (a == player || a.IsDead || !IsVisibleToPlayer(a))
                    continue;
                if (a.TargetActor == player && (a.Activity == Activity.CHASING || a.Activity == Activity.FIGHTING))
                {
                    Point gpos = MapToScreen(player.Location.Position);
                    m_UI.UI_DrawImage(GameImages.ICON_IS_TARGETTED, gpos.X, gpos.Y);
                    break;
                }
            }
        }

        public void DrawItemsStack(Inventory inventory, int gx, int gy, Color tint)
        {
            if (inventory == null)
                return;

            foreach (Item it in inventory.Items)
                DrawItem(it, gx, gy, tint);
        }

        public void DrawMapIcon(Point position, string imageID)
        {
            m_UI.UI_DrawImage(imageID, position.X * RogueGame.TILE_SIZE, position.Y * RogueGame.TILE_SIZE);
        }

        public void DrawMapHealthBar(int hitPoints, int maxHitPoints, int gx, int gy)
        {
            DrawMapHealthBar(hitPoints, maxHitPoints, gx, gy, Color.Red);
        }

        public void DrawMapHealthBar(int hitPoints, int maxHitPoints, int gx, int gy, Color barColor) //@@MP - the health bar layed over each character model when wounded (hidden at full HP)
        {
            int hpX = gx + 4;
            int hpY = gy + TILE_SIZE - 4;
            int barLength = (int)(20 * (float)hitPoints / (float)maxHitPoints);
            m_UI.UI_FillRect(Color.Black, new Rectangle(hpX, hpY, 20, 4)); //@@MP - the black bar demonstrating max HP
            if (barLength > 0) //@@MP - this IF exists to handle when something dies and becomes a corpse
                m_UI.UI_FillRect(barColor, new Rectangle(hpX + 1, hpY + 1, barLength, 2)); //@@MP - the red bar demonstrating current HP as a proportion of max HP (black bar)
        }

        public void DrawMapFuelBar(int currentFuelUnits, int maxFuelUnits, int gx, int gy) //@@MP (Release 7-1)
        {
            int fuX = gx + 6;
            int fuY = gy + TILE_SIZE - 4;
            int barLength = (int)(20 * (float)currentFuelUnits / (float)maxFuelUnits);
            m_UI.UI_FillRect(Color.Black, new Rectangle(fuX, fuY, 20, 4)); //@@MP - the black bar demonstrating max fuel
            if (barLength > 0) //@@MP - this IF exists to handle when something dies and becomes a corpse
                m_UI.UI_FillRect(Color.Cyan, new Rectangle(fuX + 1, fuY + 1, barLength, 2)); //@@MP - the blue bar demonstrating current fuel as a proportion of max fuel (black bar)
        }

        public void DrawItemCookingBar(int currentCookingUnits, int maxCookingUnits, int gx, int gy, bool drawBlackBar) //@@MP (Release 7-6)
        {
            int fuX = gx + 6;
            int fuY = gy + TILE_SIZE - 4;
            int barLength = (int)(20 * (float)currentCookingUnits / (float)maxCookingUnits);
            if (barLength > 0)
            {
                if (drawBlackBar)
                    m_UI.UI_FillRect(Color.Black, new Rectangle(fuX, fuY, 20, 4)); //@@MP - the black bar demonstrating max before its cooked. only needed when in the map, not when in player's inv
                m_UI.UI_FillRect(Color.Violet, new Rectangle(fuX + 1, fuY + 1, barLength, 2)); //@@MP - the blue bar demonstrating current cooked % as a proportion of max turns to cook (black bar)
            }
        }

        public void DrawBar(int value, int previousValue, int maxValue, int refValue, int maxWidth, int height, int gx, int gy, 
            Color fillColor, Color lossFillColor, Color gainFillColor, Color emptyColor)
        {
            m_UI.UI_FillRect(emptyColor, new Rectangle(gx, gy, maxWidth, height));

            int prevBarLength = (int)(maxWidth * (float)previousValue / (float)maxValue);
            int barLength = (int)(maxWidth * (float)value / (float)maxValue);

            if (value > previousValue)
            {
                // gain
                if (barLength > 0)
                    m_UI.UI_FillRect(gainFillColor, new Rectangle(gx, gy, barLength, height));
                if (prevBarLength > 0)
                    m_UI.UI_FillRect(fillColor, new Rectangle(gx, gy, prevBarLength, height));
            }
            else if (value < previousValue)
            {
                // loss
                if (prevBarLength > 0)
                    m_UI.UI_FillRect(lossFillColor, new Rectangle(gx, gy, prevBarLength, height));
                if (barLength > 0)
                    m_UI.UI_FillRect(fillColor, new Rectangle(gx, gy, barLength, height));
            }
            else
            {
                // no change.
                if (barLength > 0)
                    m_UI.UI_FillRect(fillColor, new Rectangle(gx, gy, barLength, height));
            }

            // reference line.
            int refLength = (int)(maxWidth * (float)refValue / (float)maxValue);
            m_UI.UI_DrawLine(Color.White, gx + refLength, gy, gx + refLength, gy + height);
        }

        public void DrawMiniMap(Map map)
        {
            // clear minimap.
            if (s_Options.IsMinimapOn)
            {
                m_UI.UI_ClearMinimap(Color.Black);
            }

            // set visited tiles color.
#region
            if (s_Options.IsMinimapOn)
            {
                Point pt = new Point();
                for (int x = 0; x < map.Width; x++)
                {
                    pt.X = x;
                    for (int y = 0; y < map.Height; y++)
                    {
                        pt.Y = y;
                        Tile tile = map.GetTileAt(x, y);
                        if (tile.IsVisited)
                        {
                            // exits override tile color.
                            if (map.GetExitAt(pt) != null)
                                m_UI.UI_SetMinimapColor(x, y, Color.HotPink);
                            else
                                m_UI.UI_SetMinimapColor(x, y, tile.Model.MinimapColor);
                        }
                    }
                }
            }
#endregion

            // show minimap.
            if (s_Options.IsMinimapOn)
            {
                m_UI.UI_DrawMinimap(MINIMAP_X, MINIMAP_Y);
            }

            // show view rect.
            m_UI.UI_DrawRect(Color.White, new Rectangle(MINIMAP_X + m_MapViewRect.Left * MINITILE_SIZE, MINIMAP_Y + m_MapViewRect.Top * MINITILE_SIZE, m_MapViewRect.Width * MINITILE_SIZE, m_MapViewRect.Height * MINITILE_SIZE));

            // show player tags.
#region
            /*if (s_Options.ShowPlayerTagsOnMinimap) //@@MP (Release 5-7)
            {*/
                for (int x = 0; x < map.Width; x++)
                    for (int y = 0; y < map.Height; y++)
                    {
                        Tile tile = map.GetTileAt(x, y);
                        if (tile.IsVisited)
                        {
                            string minitag = null;
                            if (tile.HasDecoration(GameImages.DECO_PLAYER_TAG1))
                                minitag = GameImages.MINI_PLAYER_TAG1;
                            else if (tile.HasDecoration(GameImages.DECO_PLAYER_TAG2))
                                minitag = GameImages.MINI_PLAYER_TAG2;
                            else if (tile.HasDecoration(GameImages.DECO_PLAYER_TAG3))
                                minitag = GameImages.MINI_PLAYER_TAG3;
                            else if (tile.HasDecoration(GameImages.DECO_PLAYER_TAG4))
                                minitag = GameImages.MINI_PLAYER_TAG4;
                            if (minitag != null)
                            {
                                Point pos = new Point(MINIMAP_X + x * MINITILE_SIZE, MINIMAP_Y + y * MINITILE_SIZE);
                                m_UI.UI_DrawImage(minitag, pos.X - MINI_TRACKER_OFFSET, pos.Y - MINI_TRACKER_OFFSET);
                            }
                        }
                    }
            //}
#endregion

            // show player & tracked actors.
            // add tracked targets images out of player fov on the map.
#region
            if (m_Player != null)
            {
                // tracker items.
                if (!m_Player.IsSleeping)
                {
                    ItemTracker tracker = m_Player.GetEquippedItem(DollPart.LEFT_HAND) as ItemTracker;

                    // tracking...
                    if (tracker != null && tracker.Batteries > 0)
                    {
                        // ...followers?
#region
                        if (m_Player.CountFollowers > 0 && tracker.CanTrackFollowersOrLeader)
                        {
                            foreach (Actor fo in m_Player.Followers)
                            {
                                // only track in same map.
                                if (fo.Location.Map != m_Player.Location.Map)
                                    continue;

                                ItemTracker foTracker = fo.GetEquippedItem(DollPart.LEFT_HAND) as ItemTracker;
                                if (foTracker != null && foTracker.CanTrackFollowersOrLeader)
                                {
                                    // show follower position.
                                    Point foMiniPos = new Point(MINIMAP_X + fo.Location.Position.X * MINITILE_SIZE, MINIMAP_Y + fo.Location.Position.Y * MINITILE_SIZE);
                                    m_UI.UI_DrawImage(GameImages.MINI_FOLLOWER_POSITION, foMiniPos.X - MINI_TRACKER_OFFSET, foMiniPos.Y - MINI_TRACKER_OFFSET);

                                    // if out of FoV but in view,, draw on map.
                                    if (IsInViewRect(fo.Location.Position) && !IsVisibleToPlayer(fo))
                                    {
                                        Point screenPos = MapToScreen(fo.Location.Position);
                                        m_UI.UI_DrawImage(GameImages.TRACK_FOLLOWER_POSITION, screenPos.X, screenPos.Y);
                                    }
                                }
                            }
                        }
#endregion

                        // ...undeads?
#region
                        if (tracker.CanTrackUndeads)
                        {
                            foreach (Actor other in map.Actors)
                            {
                                if (other == m_Player)
                                    continue;
                                if (!other.Model.Abilities.IsUndead)
                                    continue;
                                // only track in same map.
                                if (other.Location.Map != m_Player.Location.Map)
                                    continue;
                                if (m_Rules.GridDistance(other.Location.Position, m_Player.Location.Position) > Rules.ZTRACKINGRADIUS)
                                    continue;

                                // close undead, show it.
                                Point undeadPos = new Point(MINIMAP_X + other.Location.Position.X * MINITILE_SIZE, MINIMAP_Y + other.Location.Position.Y * MINITILE_SIZE);
                                m_UI.UI_DrawImage(GameImages.MINI_UNDEAD_POSITION, undeadPos.X - MINI_TRACKER_OFFSET, undeadPos.Y - MINI_TRACKER_OFFSET);

                                // if out of FoV but in view,, draw on map.
                                if (IsInViewRect(other.Location.Position) && !IsVisibleToPlayer(other))
                                {
                                    Point screenPos = MapToScreen(other.Location.Position);
                                    m_UI.UI_DrawImage(GameImages.TRACK_UNDEAD_POSITION, screenPos.X, screenPos.Y);
                                }
                            }
                        }
#endregion

                        // ...BlackOps?
#region
                        if (tracker.CanTrackBlackOps && s_Options.BlackOpsRaidsEnabled == true) // if option disabled, don't bother.  //@@MP (Release 7-5)
                        {
                            foreach (Actor other in map.Actors)
                            {
                                if (other == m_Player)
                                    continue;
                                if (other.Faction != GameFactions.TheBlackOps)
                                    continue;
                                // only track in same map.
                                if (other.Location.Map != m_Player.Location.Map)
                                    continue;

                                // blackop, show it.
                                Point boPos = new Point(MINIMAP_X + other.Location.Position.X * MINITILE_SIZE, MINIMAP_Y + other.Location.Position.Y * MINITILE_SIZE);
                                m_UI.UI_DrawImage(GameImages.MINI_BLACKOPS_POSITION, boPos.X - MINI_TRACKER_OFFSET, boPos.Y - MINI_TRACKER_OFFSET);

                                // if out of FoV but in view,, draw on map.
                                if (IsInViewRect(other.Location.Position) && !IsVisibleToPlayer(other))
                                {
                                    Point screenPos = MapToScreen(other.Location.Position);
                                    m_UI.UI_DrawImage(GameImages.TRACK_BLACKOPS_POSITION, screenPos.X, screenPos.Y);
                                }
                            }
                        }
#endregion

                        // ...Police?
                        if (tracker.CanTrackPolice)
                        {
                            foreach (Actor other in map.Actors)
                            {
                                if (other == m_Player)
                                    continue;
                                if (other.Faction != GameFactions.ThePolice)
                                    continue;
                                // only track in same map.
                                if (other.Location.Map != m_Player.Location.Map)
                                    continue;

                                // policeman, show it.
                                Point boPos = new Point(MINIMAP_X + other.Location.Position.X * MINITILE_SIZE, MINIMAP_Y + other.Location.Position.Y * MINITILE_SIZE);
                                m_UI.UI_DrawImage(GameImages.MINI_POLICE_POSITION, boPos.X - MINI_TRACKER_OFFSET, boPos.Y - MINI_TRACKER_OFFSET);

                                // if out of FoV but in view,, draw on map.
                                if (IsInViewRect(other.Location.Position) && !IsVisibleToPlayer(other))
                                {
                                    Point screenPos = MapToScreen(other.Location.Position);
                                    m_UI.UI_DrawImage(GameImages.TRACK_POLICE_POSITION, screenPos.X, screenPos.Y);
                                }
                            }
                        }
                    }
                }

                // player.
                Point pos = new Point(MINIMAP_X + m_Player.Location.Position.X * MINITILE_SIZE, MINIMAP_Y + m_Player.Location.Position.Y * MINITILE_SIZE);
                m_UI.UI_DrawImage(GameImages.MINI_PLAYER_POSITION, pos.X - MINI_TRACKER_OFFSET, pos.Y - MINI_TRACKER_OFFSET);
            }
#endregion
        }

        public void DrawActorStatus(Actor actor, int gx, int gy)
        {
            // 1. Name & occupation
            m_UI.UI_DrawStringBold(Color.DeepSkyBlue, String.Format("{0}, {1}", actor.Name, actor.Faction.MemberName), gx, gy);

            // 2. Bars: Health, Stamina, Food, Sleep, Infection.
            gy += BOLD_LINE_SPACING;
            int maxHP = m_Rules.ActorMaxHPs(actor);
            m_UI.UI_DrawStringBold(Color.White, String.Format("HP  {0}", actor.HitPoints), gx, gy); //@@MP - current HP (to left of bar)
            DrawBar(actor.HitPoints, actor.PreviousHitPoints, maxHP, 0, 100, BOLD_LINE_SPACING, gx + BOLD_LINE_SPACING * 5, gy, Color.Red, Color.DarkRed, Color.OrangeRed, Color.Gray);
            m_UI.UI_DrawStringBold(Color.White, String.Format("{0}", maxHP), gx + BOLD_LINE_SPACING * 6 + 100, gy); //@@MP - max HP (to right of bar)
            m_UI.UI_DrawStringBold(actor.GetIntoxicationTextColor(), actor.GetIntoxicationDescription(), gx + BOLD_LINE_SPACING * 9 + 100, gy); //@@MP (Release 7-1)
            if (actor.IsFoodPoisoned) //@@MP (Release 7-6)
            {
                m_UI.UI_DrawStringBold(Color.White, "|", gx + BOLD_LINE_SPACING * 9 + 148, gy); //seperator between intoxication and food poisoning
                m_UI.UI_DrawStringBold(Color.Red, "unwell", gx + BOLD_LINE_SPACING * 9 + 156, gy);
            }

            gy += BOLD_LINE_SPACING;
            if (actor.Model.Abilities.CanTire)
            {
                int maxSTA = m_Rules.ActorMaxSTA(actor);
                m_UI.UI_DrawStringBold(Color.White, String.Format("STA {0}", actor.StaminaPoints), gx, gy);
                DrawBar(actor.StaminaPoints, actor.PreviousStaminaPoints, maxSTA, Rules.STAMINA_MIN_FOR_ACTIVITY, 100, BOLD_LINE_SPACING, gx + BOLD_LINE_SPACING * 5, gy, Color.Green, Color.DarkGreen, Color.LightGreen, Color.Gray);
                m_UI.UI_DrawStringBold(Color.White, String.Format("{0}", maxSTA), gx + BOLD_LINE_SPACING * 6 + 100, gy);
                if (actor.IsRunning)
                    m_UI.UI_DrawStringBold(Color.LightGreen, "RUNNING!", gx + BOLD_LINE_SPACING * 9 + 100, gy);
                else if (m_Rules.CanActorRun(actor))
                    m_UI.UI_DrawStringBold(Color.Green, "can run", gx + BOLD_LINE_SPACING * 9 + 100, gy);
                else if (m_Rules.IsActorTired(actor))
                    m_UI.UI_DrawStringBold(Color.Gray, "TIRED", gx + BOLD_LINE_SPACING * 9 + 100, gy);
            }

            gy += BOLD_LINE_SPACING;
            if (actor.Model.Abilities.HasToEat) //human
            {
                int maxFood = m_Rules.ActorMaxFood(actor);
                m_UI.UI_DrawStringBold(Color.White, String.Format("FOO {0}", actor.FoodPoints), gx, gy);
                DrawBar(actor.FoodPoints, actor.PreviousFoodPoints, maxFood, Rules.FOOD_HUNGRY_LEVEL, 100, BOLD_LINE_SPACING, gx + BOLD_LINE_SPACING * 5, gy, Color.Chocolate, Color.Brown, Color.Beige, Color.Gray);
                m_UI.UI_DrawStringBold(Color.White, String.Format("{0}", maxFood), gx + BOLD_LINE_SPACING * 6 + 100, gy);
                if (m_Rules.IsActorHungry(actor))
                {
                    if (m_Rules.IsActorStarving(actor))
                        m_UI.UI_DrawStringBold(Color.Red, "STARVING!", gx + BOLD_LINE_SPACING * 9 + 100, gy);
                    else if (m_Rules.IsActorReallyHungry(actor)) //@@MP (Release 7-1)
                        m_UI.UI_DrawStringBold(Color.Orange, "Famished", gx + BOLD_LINE_SPACING * 9 + 100, gy);
                    else
                        m_UI.UI_DrawStringBold(Color.Yellow, "Hungry", gx + BOLD_LINE_SPACING * 9 + 100, gy);
                }
                else
                    m_UI.UI_DrawStringBold(Color.White, String.Format("{0}h", FoodToHoursUntilHungry(actor.FoodPoints)), gx + BOLD_LINE_SPACING * 9 + 100, gy);
            }
            else if (actor.Model.Abilities.IsRotting) //undead
            {
                int maxFood = m_Rules.ActorMaxRot(actor);
                m_UI.UI_DrawStringBold(Color.White, String.Format("ROT {0}", actor.FoodPoints), gx, gy);
                DrawBar(actor.FoodPoints, actor.PreviousFoodPoints, maxFood, Rules.ROT_HUNGRY_LEVEL, 100, BOLD_LINE_SPACING, gx + BOLD_LINE_SPACING * 5, gy, Color.Chocolate, Color.Brown, Color.Beige, Color.Gray);
                m_UI.UI_DrawStringBold(Color.White, String.Format("{0}", maxFood), gx + BOLD_LINE_SPACING * 6 + 100, gy);
                if (m_Rules.IsRottingActorHungry(actor))
                {
                    if (m_Rules.IsRottingActorStarving(actor))
                        m_UI.UI_DrawStringBold(Color.Red, "STARVING!", gx + BOLD_LINE_SPACING * 9 + 100, gy);
                    else
                        m_UI.UI_DrawStringBold(Color.Yellow, "Hungry", gx + BOLD_LINE_SPACING * 9 + 100, gy);
                }
                else
                    m_UI.UI_DrawStringBold(Color.White, String.Format("{0}h", FoodToHoursUntilRotHungry(actor.FoodPoints)), gx + BOLD_LINE_SPACING * 9 + 100, gy);
            }

            gy += BOLD_LINE_SPACING;
            if (actor.Model.Abilities.HasToSleep)
            {
                int maxSleep = m_Rules.ActorMaxSleep(actor);
                m_UI.UI_DrawStringBold(Color.White, String.Format("SLP {0}", actor.SleepPoints), gx, gy);
                DrawBar(actor.SleepPoints, actor.PreviousSleepPoints, maxSleep, Rules.SLEEP_SLEEPY_LEVEL, 100, BOLD_LINE_SPACING, gx + BOLD_LINE_SPACING * 5, gy, Color.Blue, Color.DarkBlue, Color.LightBlue, Color.Gray);
                m_UI.UI_DrawStringBold(Color.White, String.Format("{0}", maxSleep), gx + BOLD_LINE_SPACING * 6 + 100, gy);
                if (m_Rules.IsActorSleepy(actor))
                {
                    if (m_Rules.IsActorExhausted(actor))
                        m_UI.UI_DrawStringBold(Color.Red, "EXHAUSTED!", gx + BOLD_LINE_SPACING * 9 + 100, gy);
                    else
                        m_UI.UI_DrawStringBold(Color.Yellow, "Sleepy", gx + BOLD_LINE_SPACING * 9 + 100, gy);
                }
                else
                    m_UI.UI_DrawStringBold(Color.White, String.Format("{0}h", m_Rules.SleepToHoursUntilSleepy(actor.SleepPoints, m_Session.WorldTime.IsNight)), gx + BOLD_LINE_SPACING * 9 + 100, gy);
            }

            if (s_Options.IsSanityEnabled)
            {
                gy += BOLD_LINE_SPACING;
                if (actor.Model.Abilities.HasSanity)
                {
                    int maxSan = m_Rules.ActorMaxSanity(actor);
                    m_UI.UI_DrawStringBold(Color.White, String.Format("SAN {0}", actor.Sanity), gx, gy);
                    DrawBar(actor.Sanity, actor.PreviousSanity, maxSan, m_Rules.ActorDisturbedLevel(actor), 100, BOLD_LINE_SPACING, gx + BOLD_LINE_SPACING * 5, gy, Color.Orange, Color.DarkOrange, Color.OrangeRed, Color.Gray);
                    m_UI.UI_DrawStringBold(Color.White, String.Format("{0}", maxSan), gx + BOLD_LINE_SPACING * 6 + 100, gy);
                    if (m_Rules.IsActorDisturbed(actor))
                    {
                        if (m_Rules.IsActorInsane(actor))
                            m_UI.UI_DrawStringBold(Color.Red, "INSANE!", gx + BOLD_LINE_SPACING * 9 + 100, gy);
                        else
                            m_UI.UI_DrawStringBold(Color.Yellow, "Disturbed", gx + BOLD_LINE_SPACING * 9 + 100, gy);
                    }
                else
                    m_UI.UI_DrawStringBold(Color.White, String.Format("{0}h", m_Rules.SanityToHoursUntilUnstable(actor)), gx + BOLD_LINE_SPACING * 9 + 100, gy);
                }
            }

            if (Rules.HasInfection(m_Session.GameMode) && !actor.Model.Abilities.IsUndead)
            {
                int maxInf = m_Rules.ActorInfectionHPs(actor);
                int refInf = (Rules.INFECTION_LEVEL_1_WEAK * maxInf) / 100;
                gy += BOLD_LINE_SPACING;
                m_UI.UI_DrawStringBold(Color.White, String.Format("INF {0}", actor.Infection), gx, gy);
                DrawBar(actor.Infection, actor.Infection, maxInf, refInf, 100, BOLD_LINE_SPACING, gx + BOLD_LINE_SPACING * 5, gy, Color.Purple, Color.Black, Color.Black, Color.Gray);
                m_UI.UI_DrawStringBold(Color.White, String.Format("{0}%", m_Rules.ActorInfectionPercent(actor)), gx + BOLD_LINE_SPACING * 6 + 100, gy);
            }

            // 3. Melee & Ranged Attacks.
            gy += BOLD_LINE_SPACING;
            Attack melee = m_Rules.ActorMeleeAttack(actor, actor.CurrentMeleeAttack, null);
            int dmgBonusVsUndead = m_Rules.ActorDamageBonusVsUndeads(actor);
            m_UI.UI_DrawStringBold(Color.White, String.Format("Melee  Atk {0:D2}  Dmg {1:D2}/{2:D2}", melee.HitValue, melee.DamageValue, melee.DamageValue+dmgBonusVsUndead), gx, gy);

            gy += BOLD_LINE_SPACING;
            Attack ranged = m_Rules.ActorRangedAttack(actor, actor.CurrentRangedAttack, actor.CurrentRangedAttack.EfficientRange, null);
            ItemRangedWeapon rangedWeapon = actor.GetEquippedWeapon() as ItemRangedWeapon;
            int ammo, maxAmmo;
            ammo = maxAmmo=0;
            if (rangedWeapon != null)
            {
                ammo = rangedWeapon.Ammo;
                maxAmmo = (rangedWeapon.Model as ItemRangedWeaponModel).MaxAmmo;
                m_UI.UI_DrawStringBold(Color.White, String.Format("Ranged Atk {0:D2}  Dmg {1:D2}/{2:D2} Rng {3}-{4} Amo {5}/{6}", 
                    ranged.HitValue, ranged.DamageValue, ranged.DamageValue+dmgBonusVsUndead, ranged.Range, ranged.EfficientRange, ammo, maxAmmo), gx, gy);
            }
            
            // 4. (living)Def, Pro, Spd, FoV & Nb of followers / (undead)Def, Spd, Fov, Sml, Kills
            gy += BOLD_LINE_SPACING;
            Defence defence = m_Rules.ActorDefence(actor, actor.CurrentDefence);

            if (actor.Model.Abilities.IsUndead)
            {
                m_UI.UI_DrawStringBold(Color.White, String.Format("Def {0:D2} Spd {1:F2} FoV {2} Sml {3:F2} Kills {4}",
                    defence.Value,
                    (float)m_Rules.ActorSpeed(actor) / (float)Rules.BASE_SPEED, 
                    m_Rules.ActorFOV(actor, m_Session.WorldTime, m_Session.World.Weather),
                    m_Rules.ActorSmell(actor),
                    actor.KillsCount),
                    gx, gy);
            }
            else
            {
                m_UI.UI_DrawStringBold(Color.White, String.Format("Def {0:D2} Arm {1:D1}/{2:D1} Spd {3:F2} FoV {4}/{5} Fol {6}/{7}", //alpha 10 modified
                    defence.Value, defence.Protection_Hit, defence.Protection_Shot,
                    (float)m_Rules.ActorSpeed(actor) / (float)Rules.BASE_SPEED,
                    m_Rules.ActorFOV(actor, m_Session.WorldTime, m_Session.World.Weather),
                    actor.Sheet.BaseViewRange,
                    actor.CountFollowers, m_Rules.ActorMaxFollowers(actor)),
                    gx, gy);
            }

            // 5. Odor suppressor // alpha10
            gy += BOLD_LINE_SPACING;
            if (actor.OdorSuppressorCounter > 0)
                m_UI.UI_DrawStringBold(Color.LightBlue, string.Format("              Odor suppressor : {0} -{1}", actor.OdorSuppressorCounter, m_Rules.OdorsDecay(actor.Location.Map, actor.Location.Position, m_Session.World.Weather)), gx, gy);
        }

        public void DrawInventory(Inventory inventory, string title, bool drawSlotsNumbers, int slotsPerLine, int maxSlots, int gx, int gy)
        {
            int x, y;
            int slot = 0;

            // Draw title.
            gy -= BOLD_LINE_SPACING;
            m_UI.UI_DrawStringBold(Color.White, title, gx, gy);
            gy += BOLD_LINE_SPACING;
            
            // Draw slots.
            x = gx; y = gy; slot = 0;
            for (int i = 0; i < maxSlots; i++)
            {
                m_UI.UI_DrawImage(GameImages.ITEM_SLOT, x, y);
                if (++slot >= slotsPerLine)
                {
                    slot = 0;
                    y += TILE_SIZE;
                    x = gx;
                }
                else
                    x += TILE_SIZE;
            }

            // Draw items.
            if (inventory == null)
                return;

            x = gx; y = gy; slot = 0;
            foreach (Item it in inventory.Items)
            {
                if (it is ItemFood)
                {
                    ItemFood food = it as ItemFood;
                    if (m_Rules.IsFoodExpired(food, m_Session.WorldTime.TurnCounter))
                        m_UI.UI_DrawImage(GameImages.ICON_EXPIRED_FOOD, x, y);
                    else if (m_Rules.IsFoodSpoiled(food, m_Session.WorldTime.TurnCounter))
                        m_UI.UI_DrawImage(GameImages.ICON_SPOILED_FOOD, x, y);
                }
                else if (it is ItemRangedWeapon)
                {
                    ItemRangedWeapon w = it as ItemRangedWeapon;
                    if (w.Ammo <= 0)
                        m_UI.UI_DrawImage(GameImages.ICON_OUT_OF_AMMO, x, y);
                    DrawBar(w.Ammo, w.Ammo, (w.Model as ItemRangedWeaponModel).MaxAmmo, 0, 28, 3, x + 2, y + 27, Color.Blue, Color.Blue, Color.Blue, Color.DarkGray);
                }
                else if (it is ItemEntertainment)
                {
                    if (m_Player != null && ((it as ItemEntertainment).IsBoringFor(m_Player))) // alpha10 boring items item-centric
                        m_UI.UI_DrawImage(GameImages.ICON_BORING_ITEM, x, y);
                }
                else if (it is ItemLight)
                {
                    ItemLight lt = it as ItemLight;
                    if (lt.MaxBatteries > 0) //@@MP - moved into this check so that binocs don't crash GDI+ with an overflow (Release 7-2)
                    {
                        if (lt.Batteries <= 0)
                            m_UI.UI_DrawImage(GameImages.ICON_OUT_OF_BATTERIES, x, y);
                        DrawBar(lt.Batteries, lt.Batteries, (lt.Model as ItemLightModel).MaxBatteries, 0, 28, 3, x + 2, y + 27, Color.Yellow, Color.Yellow, Color.Yellow, Color.DarkGray);
                    }
                }
                else if (it is ItemSprayScent)
                {
                    ItemSprayScent sp = it as ItemSprayScent;
                    DrawBar(sp.SprayQuantity, sp.SprayQuantity, (sp.Model as ItemSprayScentModel).MaxSprayQuantity, 0, 28, 3, x + 2, y + 27, Color.Cyan, Color.Cyan, Color.Cyan, Color.DarkGray);
                }
                else if (it is ItemTrap)
                {
                    ItemTrap trap = it as ItemTrap;
                    DrawTrapItem(trap, x, y);  // alpha10 factorized code
                }
                else if (it is ItemTracker)
                {
                    ItemTracker tr = it as ItemTracker;
                    if (tr.Batteries <= 0)
                        m_UI.UI_DrawImage(GameImages.ICON_OUT_OF_BATTERIES, x, y);
                    DrawBar(tr.Batteries, tr.Batteries, (tr.Model as ItemTrackerModel).MaxBatteries, 0, 28, 3, x + 2, y + 27, Color.Pink, Color.Pink, Color.Pink, Color.DarkGray);
                }
                else if (it is ItemSprayPaint)
                {
                    ItemSprayPaint sp = it as ItemSprayPaint;
                    DrawBar(sp.PaintQuantity, sp.PaintQuantity, (sp.Model as ItemSprayPaintModel).MaxPaintQuantity, 0, 28, 3, x + 2, y + 27, Color.Gold, Color.Gold, Color.Gold, Color.DarkGray);
                }

                if (it.IsEquipped) //@@MP - weapons, torches, armour, phones, trackers, sprays
                {
                    m_UI.UI_DrawImage(GameImages.ITEM_EQUIPPED, x, y);
                }

                DrawItem(it, x, y);

                if (++slot >= slotsPerLine)
                {
                    slot = 0;
                    y += TILE_SIZE;
                    x = gx;
                }
                else
                    x += TILE_SIZE;
            }

            // Draw slots numbers.
            if (drawSlotsNumbers)
            {
                x = gx + 4; y = gy + TILE_SIZE;
                for (int i = 0; i < inventory.MaxCapacity; i++)
                {
                    m_UI.UI_DrawString(Color.White, (i + 1).ToString(), x, y);
                    x += TILE_SIZE;
                }

            }
        }

        public void DrawBackpackInventory(Inventory inventory, string title, bool drawSlotsNumbers, int slotsPerLine, int maxSlots, int gx, int gy) //@@MP (Release 8-2)
        {
            int x, y;
            int slot = 0;

            // Draw title.
            gy -= BOLD_LINE_SPACING;
            m_UI.UI_DrawStringBold(Color.BurlyWood, title, gx, gy);
            gy += BOLD_LINE_SPACING;

            // Draw slots.
            x = gx; y = gy; slot = 0;
            for (int i = 0; i < maxSlots; i++)
            {
                m_UI.UI_DrawImage(GameImages.ITEM_BACKPACK_SLOT, x, y);
                if (++slot >= slotsPerLine)
                {
                    slot = 0;
                    y += TILE_SIZE;
                    x = gx;
                }
                else
                    x += TILE_SIZE;
            }

            // Draw items.
            if (inventory == null)
                return;

            x = gx; y = gy; slot = 0;
            foreach (Item it in inventory.Items)
            {
                if (it is ItemFood)
                {
                    ItemFood food = it as ItemFood;
                    if (m_Rules.IsFoodExpired(food, m_Session.WorldTime.TurnCounter))
                        m_UI.UI_DrawImage(GameImages.ICON_EXPIRED_FOOD, x, y);
                    else if (m_Rules.IsFoodSpoiled(food, m_Session.WorldTime.TurnCounter))
                        m_UI.UI_DrawImage(GameImages.ICON_SPOILED_FOOD, x, y);
                }
                else if (it is ItemRangedWeapon)
                {
                    ItemRangedWeapon w = it as ItemRangedWeapon;
                    if (w.Ammo <= 0)
                        m_UI.UI_DrawImage(GameImages.ICON_OUT_OF_AMMO, x, y);
                    DrawBar(w.Ammo, w.Ammo, (w.Model as ItemRangedWeaponModel).MaxAmmo, 0, 28, 3, x + 2, y + 27, Color.Blue, Color.Blue, Color.Blue, Color.DarkGray);
                }
                else if (it is ItemEntertainment)
                {
                    if (m_Player != null && ((it as ItemEntertainment).IsBoringFor(m_Player))) // alpha10 boring items item-centric
                        m_UI.UI_DrawImage(GameImages.ICON_BORING_ITEM, x, y);
                }
                else if (it is ItemLight)
                {
                    ItemLight lt = it as ItemLight;
                    if (lt.MaxBatteries > 0) //@@MP - moved into this check so that binocs don't crash GDI+ with an overflow (Release 7-2)
                    {
                        if (lt.Batteries <= 0)
                            m_UI.UI_DrawImage(GameImages.ICON_OUT_OF_BATTERIES, x, y);
                        DrawBar(lt.Batteries, lt.Batteries, (lt.Model as ItemLightModel).MaxBatteries, 0, 28, 3, x + 2, y + 27, Color.Yellow, Color.Yellow, Color.Yellow, Color.DarkGray);
                    }
                }
                else if (it is ItemSprayScent)
                {
                    ItemSprayScent sp = it as ItemSprayScent;
                    DrawBar(sp.SprayQuantity, sp.SprayQuantity, (sp.Model as ItemSprayScentModel).MaxSprayQuantity, 0, 28, 3, x + 2, y + 27, Color.Cyan, Color.Cyan, Color.Cyan, Color.DarkGray);
                }
                else if (it is ItemTrap)
                {
                    ItemTrap trap = it as ItemTrap;
                    DrawTrapItem(trap, x, y);  // alpha10 factorized code
                }
                else if (it is ItemTracker)
                {
                    ItemTracker tr = it as ItemTracker;
                    if (tr.Batteries <= 0)
                        m_UI.UI_DrawImage(GameImages.ICON_OUT_OF_BATTERIES, x, y);
                    DrawBar(tr.Batteries, tr.Batteries, (tr.Model as ItemTrackerModel).MaxBatteries, 0, 28, 3, x + 2, y + 27, Color.Pink, Color.Pink, Color.Pink, Color.DarkGray);
                }
                else if (it is ItemSprayPaint)
                {
                    ItemSprayPaint sp = it as ItemSprayPaint;
                    DrawBar(sp.PaintQuantity, sp.PaintQuantity, (sp.Model as ItemSprayPaintModel).MaxPaintQuantity, 0, 28, 3, x + 2, y + 27, Color.Gold, Color.Gold, Color.Gold, Color.DarkGray);
                }

                DrawItem(it, x, y);

                if (++slot >= slotsPerLine)
                {
                    slot = 0;
                    y += TILE_SIZE;
                    x = gx;
                }
                else
                    x += TILE_SIZE;
            }

            // Draw slots numbers.
            if (drawSlotsNumbers)
            {
                x = gx + 4; y = gy + TILE_SIZE;
                for (int i = 0; i < inventory.MaxCapacity; i++)
                {
                    m_UI.UI_DrawString(Color.White, (i + 1).ToString(), x, y);
                    x += TILE_SIZE;
                }

            }
        }

        public void DrawItem(Item it, int gx, int gy)
        {
            DrawItem(it, gx, gy, Color.White);
        }

        public void DrawItem(Item it, int gx, int gy, Color tint)
        {
            m_UI.UI_DrawImage(it.ImageID, gx, gy, tint);

            if (it.Model.IsStackable)
            {
                string q = string.Format("{0}", it.Quantity);
                int tx = gx + TILE_SIZE - 10;
                if (it.Quantity > 100)
                    tx -= 10;
                else if (it.Quantity > 10)
                    tx -= 4;
                m_UI.UI_DrawString(Color.DarkGray, q, tx + 1, gy + 1);
                m_UI.UI_DrawString(Color.White, q, tx, gy);
            }

            // special cases.
            ItemTrap trap = it as ItemTrap;
            if (trap != null)
            {
                DrawTrapItem(trap, gx, gy);  // alpha10 factorized code
                return; //no need to do anything further
            }

            ItemFood food = it as ItemFood;    //@@MP (Release 7-6)
            if (food != null && food.CanBeCooked && food.CookedDegree > 0)
            {
                bool drawBlackBar = !m_Player.Inventory.Contains(it); //don't draw the black bar when it's in our inv, as that overlaps the item slot border
                DrawItemCookingBar(food.CookedDegree, food.MaxCookedDegree, gx, gy, drawBlackBar);
            }
        }

        void DrawTrapItem(ItemTrap trap, int gx, int gy)  // alpha10 factorized code
        {
            if (trap.IsTriggered)
            {
                // alpha10
                if (trap.Owner == m_Player)
                    m_UI.UI_DrawImage(GameImages.ICON_TRAP_TRIGGERED_SAFE_PLAYER, gx, gy);
                else if (m_Rules.IsSafeFromTrap(trap, m_Player))
                    m_UI.UI_DrawImage(GameImages.ICON_TRAP_TRIGGERED_SAFE_GROUP, gx, gy);
                else
                    m_UI.UI_DrawImage(GameImages.ICON_TRAP_TRIGGERED, gx, gy);
            }
            else if (trap.IsActivated)
            {
                // alpha10
                if (trap.Owner == m_Player)
                    m_UI.UI_DrawImage(GameImages.ICON_TRAP_ACTIVATED_SAFE_PLAYER, gx, gy);
                else if (m_Rules.IsSafeFromTrap(trap, m_Player))
                    m_UI.UI_DrawImage(GameImages.ICON_TRAP_ACTIVATED_SAFE_GROUP, gx, gy);
                else
                    m_UI.UI_DrawImage(GameImages.ICON_TRAP_ACTIVATED, gx, gy);
            }
        }

        public void DrawActorSkillTable(Actor actor, int gx, int gy) //m_player, 680, 352
        {
            gy -= BOLD_LINE_SPACING; //338
            m_UI.UI_DrawStringBold(Color.White, "Skills", gx, gy); //680,338
            gy += BOLD_LINE_SPACING; //352

            IEnumerable<Skill> skills = actor.Sheet.SkillTable.Skills;
            if (skills == null)
                return;

            int x, y;
            int count = 0;
            x = gx; y = gy; //680,352
            foreach (Skill sk in skills)
            {
                Color skColor = Color.White;

                // alpha10 highlight if active skills are active or not
                switch (sk.ID)
                {
                    case (int)Skills.IDs.MARTIAL_ARTS:
                        skColor = (actor.GetEquippedWeapon() == null ? Color.LightGreen : Color.Red); break;
                    case (int)Skills.IDs.HARDY:
                        if (actor.IsSleeping) skColor = Color.LightGreen; break;
                    case (int)Skills.IDs.BOWS_EXPLOSIVES: //@@MP (Release 7-2)
                        Item rangedWeapon = actor.GetEquippedRangedWeapon();
                        if (rangedWeapon != null)
                        {
                            if ((rangedWeapon.Model as ItemRangedWeaponModel).IsBow)
                                skColor = Color.LightGreen;
                            else
                                skColor = Color.Red;
                        }
                        break;
                    case (int)Skills.IDs.FIREARMS: //@@MP (Release 7-2)
                        Item firearm = actor.GetEquippedRangedWeapon();
                        if (firearm != null)
                        {
                            if ((firearm.Model as ItemRangedWeaponModel).IsFireArm)
                                skColor = Color.LightGreen;
                            else
                                skColor = Color.Red;
                        }
                        break;
                }

                m_UI.UI_DrawString(skColor, String.Format("{0}-", sk.Level), x, y); //680,352. skill level-
                x += 16; //16 pixels to the right of kill level
                m_UI.UI_DrawString(skColor, Skills.Name(sk.ID), x, y); //696,352. skill name
                x -= 16; //680. back to the left

                if (++count >= SKILLTABLE_LINES) //@@MP - if there's more skills held by the player than will fit vertically, move to second column to the right
                {
                    count = 0;
                    y = gy; //352
                    x += 150; //830
                }
                else
                    y += LINE_SPACING; //366. go down a row
            }
        }
#endregion

#region -Overlays
        void AddOverlay(Overlay o)
        {
            lock (m_Overlays)  // alpha10
            {
                m_Overlays.Add(o);
            }
        }

        void ClearOverlays()
        {
            lock (m_Overlays)  // alpha10
            {
                m_Overlays.Clear();
            }
        }

        void RemoveOverlay(Overlay o)
        {
            lock (m_Overlays)  // alpha10
            {
                m_Overlays.Remove(o);
            }
        }

        bool HasOverlay(Overlay o) // alpha10 added
        {
            bool hasIt = false;
            lock (m_Overlays)
            {
                if (m_Overlays.Contains(o))
                    hasIt = true;
            }
            return hasIt;
        }
#endregion

#region -Coordinates conversion
        Point MapToScreen(Point mapPosition)
        {
            return MapToScreen(mapPosition.X, mapPosition.Y);
        }

        Point MapToScreen(int x, int y)
        {
            return new Point((x - m_MapViewRect.Left) * RogueGame.TILE_SIZE, (y - m_MapViewRect.Top) * RogueGame.TILE_SIZE);
        }

        Point ScreenToMap(Point screenPosition)
        {
            return ScreenToMap(screenPosition.X, screenPosition.Y);
        }

        Point ScreenToMap(int gx, int gy)
        {
            return new Point(m_MapViewRect.Left + gx / RogueGame.TILE_SIZE, m_MapViewRect.Top + gy / RogueGame.TILE_SIZE);
        }

        Point MouseToMap(Point mousePosition)
        {
            return MouseToMap(mousePosition.X, mousePosition.Y);
        }

        Point MouseToMap(int mouseX, int mouseY)
        {
            mouseX = (int)(mouseX / m_UI.UI_GetCanvasScaleX());
            mouseY = (int)(mouseY / m_UI.UI_GetCanvasScaleY());
            return ScreenToMap(mouseX, mouseY);
        }

        Point MouseToInventorySlot(int invX, int invY, int mouseX, int mouseY)
        {
            mouseX = (int)(mouseX / m_UI.UI_GetCanvasScaleX());
            mouseY = (int)(mouseY / m_UI.UI_GetCanvasScaleY());

            return new Point((mouseX - invX) / 32, (mouseY - invY) / 32);
            //@@MP - At first this code might look odd, because 712/32=22.25, but Point uses int. A trap for new C# players like me.
            //C# inherently drops any fractions in integer arithmetic, ie. "I see you're dividing two integers; I'll give you the result as an integer".
            //Using breakpoints to inspect the values during debug will confirm this, and explains how 'Item MouseToInventoryItem(Point, Inventory, Point)'
            //determines which inventory item (index) the mouse is hovering over.
        }

        static Point InventorySlotToScreen(int invX, int invY, int slotX, int slotY)
        {
            return new Point(invX + slotX * 32, invY + slotY * 32);
        }

        Point MouseToPreScaledCoords(int mouseX, int mouseY) //@@MP - translates scaled canvas coordinates to unscaled (ie those used in the constants) (Release 2)
        {
            mouseX = (int)(mouseX / m_UI.UI_GetCanvasScaleX());
            mouseY = (int)(mouseY / m_UI.UI_GetCanvasScaleY());
            return new Point(mouseX, mouseY);
        }

        /// <summary>For any given coordinates, are they in a given coord range. Use for confirming coordinates are on a line or within a rectangle</summary>
        /// <param name="coordX">The X coord you want to test.</param>
        /// <param name="coordY">The Y coord you want to test.</param>
        /// <param name="minX">The lower X coord in the range.</param>
        /// <param name="maxX">The upper X coord in the range.</param>
        /// <param name="minY">The lower X coord in the range.</param>
        /// <param name="maxY">The upper X coord in the range.</param>
        /// <returns>True if both X and Y within the range; false if either X or Y are outside.</returns>
        static bool IsInTheCoordinateRange(int coordX, int coordY, int minX, int maxX, int minY, int maxY) //@@MP - for any given coordinates, are they in a given coord range? (Release 2)
        {
            if (!((minX <= coordX) && (coordX <= maxX)))
                return false; //no need to check Y

            if (!((minY <= coordY) && (coordY <= maxY)))
                return false; //X was, but Y isn't

            return true; //yup it's in the range we're looking at
        }

#endregion

#region -Visibility/Smell & memory helpers
        public bool IsVisibleToPlayer(Location location) //@@MP - made public (Release 7-6)
        {
            return IsVisibleToPlayer(location.Map, location.Position);
        }

        bool IsVisibleToPlayer(Map map, Point position)
        {
            return m_Player != null
                && map == m_Player.Location.Map && map.IsInBounds(position.X, position.Y) 
                && map.GetTileAt(position.X, position.Y).IsInView;
        }

        /// <summary>
        /// Is player or location is visible to player
        /// </summary>
        bool IsVisibleToPlayer(Actor actor)
        {
            return actor == m_Player || IsVisibleToPlayer(actor.Location);
        }

        bool IsVisibleToPlayer(MapObject mapObj)
        {
            return IsVisibleToPlayer(mapObj.Location);
        }

        static bool IsKnownToPlayer(Map map, Point position)
        {
            return map.IsInBounds(position.X, position.Y) && map.GetTileAt(position.X, position.Y).IsVisited;
        }

        static bool IsKnownToPlayer(Location location) //@@MP - made static (Release 5-7)
        {
            return IsKnownToPlayer(location.Map, location.Position);
        }

        static bool IsKnownToPlayer(MapObject mapObj) //@@MP - made static (Release 5-7)
        {
            return IsKnownToPlayer(mapObj.Location);
        }

        bool IsPlayerSleeping()
        {
            return m_Player != null && m_Player.IsSleeping;
        }
#endregion
#endregion

#region EVENTS & SPAWNING
#region -SPECIAL MAP EVENTS
        void OnMapPowerGeneratorSwitch(Location location) //@@MP - unused parameter (Release 5-7)
        {
            Map map = location.Map;
            //////////////////////////////////////////////////////
            // Maps:
            // 1. CHAR Underground Facility.
            // 2. Subway
            // 3. Police Station Jails.
            // 4. Hospital Power.
            // 5. Army base
            /////////////////////////////////////////////////////

            // 1. CHAR Underground Facility
            // Darkness->Lit, TODO: Elevator off->on.
#region
            if (map == m_Session.UniqueMaps.CHARUndergroundFacility.TheMap)
            {
                lock (m_Session) // thread safe
                {
                    // check all power generators are on.
                    bool allAreOn = m_Rules.ComputeMapPowerRatio(map) >= 1.0f;

                    // change map lighting.
                    if (allAreOn)
                    {
                        if (map.Lighting != Lighting.LIT)
                        {
                            map.Lighting = Lighting.LIT;
                            WarnAboutNightVision(); //@@MP (Release 7-1)

                            // achievement? //@MP - moved within if so that only the player's presence triggers the achievement (Release 6-3)
                            if (!m_Session.Scoring.HasCompletedAchievement(Achievement.IDs.CHAR_POWER_UNDERGROUND_FACILITY))
                            {
                                // completed!
                                m_Session.Scoring.SetCompletedAchievement(Achievement.IDs.CHAR_POWER_UNDERGROUND_FACILITY);

                                // achievement!
                                ShowNewAchievement(Achievement.IDs.CHAR_POWER_UNDERGROUND_FACILITY);
                            }

                            // message.
                            if (m_Player.Location.Map == map)
                            {
                                ClearMessages();
                                AddMessage(new Message("The Facility lights turn on!", map.LocalTime.TurnCounter, Color.Green));
                                RedrawPlayScreen();
                            }
                        }
                    }
                    else // part off
                    {
                        if (map.Lighting != Lighting.DARKNESS)
                        {
                            map.Lighting = Lighting.DARKNESS;

                            // message.
                            if (m_Player.Location.Map == map)
                            {
                                ClearMessages();
                                AddMessage(new Message("The Facility lights turn off!", map.LocalTime.TurnCounter, Color.Red));
                                RedrawPlayScreen();
                            }
                        }
                    }
                }
            }
#endregion

            // 2. Subway
            // Darkness->Lit, Gates->open.
#region
            if (map == map.District.SubwayMap)
            {
                lock (m_Session) // thread safe
                {
                    // check all power generators are on.
                    bool allAreOn = m_Rules.ComputeMapPowerRatio(map) >= 1.0f;

                    // change map lighting, open/close fences.
                    if (allAreOn)
                    {
                        if (map.Lighting != Lighting.LIT)
                        {
                            // lit.
                            map.Lighting = Lighting.LIT;
                            WarnAboutNightVision(); //@@MP (Release 7-1)

                            // message.
                            if (m_Player.Location.Map == map)
                            {
                                ClearMessages();
                                AddMessage(new Message("The station power turns on!", map.LocalTime.TurnCounter, Color.Green));
                                AddMessage(new Message("You hear the gates opening.", map.LocalTime.TurnCounter, Color.Green));
                                RedrawPlayScreen();
                            }

                            // open iron gates.
                            DoOpenSubwayGates(map);
                        }
                    }
                    else // part off
                    {
                        if (map.Lighting != Lighting.DARKNESS)
                        {
                            // message.
                            if (m_Player.Location.Map == map)
                            {
                                ClearMessages();
                                AddMessage(new Message("The station power turns off!", map.LocalTime.TurnCounter, Color.Red));
                                AddMessage(new Message("You hear the gates closing.", map.LocalTime.TurnCounter, Color.Red));
                                RedrawPlayScreen();
                            }

                            // darkness.
                            map.Lighting = Lighting.DARKNESS;

                            // close iron gates.
                            DoCloseSubwayGates(map);

                        }
                    }
                }
            }
#endregion

            // 3. Police Station Jails.
#region
            if (map == m_Session.UniqueMaps.PoliceStation_JailsLevel.TheMap)
            {
                lock (m_Session) // thread safe
                {
                    // check all power generators are on.
                    bool allAreOn = m_Rules.ComputeMapPowerRatio(map) >= 1.0f;

                    // open/close cells.
                    if (allAreOn)
                    {
                        // message.
                        if (m_Player.Location.Map == map)
                        {
                            ClearMessages();
                            AddMessage(new Message("The cells are opening.", map.LocalTime.TurnCounter, Color.Green));
                            RedrawPlayScreen();
                        }

                        // open cells.
                        DoOpenPoliceJailCells(map);
                    }
                    else
                    {
                        // message.
                        if (m_Player.Location.Map == map)
                        {
                            ClearMessages();
                            AddMessage(new Message("The cells are closing.", map.LocalTime.TurnCounter, Color.Green));
                            RedrawPlayScreen();
                        }

                        // open cells.
                        DoClosePoliceJailCells(map);
                    }
                }
            }
#endregion

            // 4. Hospital Power.
#region
            if (map == m_Session.UniqueMaps.Hospital_Power.TheMap)
            {
                lock (m_Session) // thread safe
                {
                    // check all power generators are on.
                    bool allAreOn = m_Rules.ComputeMapPowerRatio(map) >= 1.0f;

                    // open/close cells.
                    if (allAreOn)
                    {
                        // message.
                        if (m_Player.Location.Map == map)
                        {
                            ClearMessages();
                            AddMessage(new Message("The lights turn on and you hear something opening upstairs.", map.LocalTime.TurnCounter, Color.Green));
                            RedrawPlayScreen();
                        }

                        // turn power on.
                        DoHospitalPowerOn();
                    }
                    else
                    {
                        if (map.Lighting != Lighting.DARKNESS)
                        {
                            // message.
                            if (m_Player.Location.Map == map)
                            {
                                ClearMessages();
                                AddMessage(new Message("The lights turn off and you hear something closing upstairs.", map.LocalTime.TurnCounter, Color.Green));
                                RedrawPlayScreen();
                            }

                            // turn power off.
                            DoHospitalPowerOff();
                        }
                    }
                }
            }
#endregion

            // 5. Army base     //@@MP (Release 6-3)
#region
            if (map == m_Session.UniqueMaps.ArmyBase.TheMap)
            {
                lock (m_Session) // thread safe
                {
                    // check all power generators are on.
                    bool allAreOn = m_Rules.ComputeMapPowerRatio(map) >= 1.0f;

                    // change map lighting.
                    if (allAreOn)
                    {
                        if (map.Lighting != Lighting.LIT)
                        {
                            map.Lighting = Lighting.LIT;
                            WarnAboutNightVision(); //@@MP (Release 7-1)

                            // message.
                            if (m_Player.Location.Map == map)
                            {
                                // achievement?
                                if (!m_Session.Scoring.HasCompletedAchievement(Achievement.IDs.ARMY_POWER_UNDERGROUND_BASE))
                                {
                                    // completed!
                                    m_Session.Scoring.SetCompletedAchievement(Achievement.IDs.ARMY_POWER_UNDERGROUND_BASE);

                                    // achievement!
                                    ShowNewAchievement(Achievement.IDs.ARMY_POWER_UNDERGROUND_BASE);
                                }

                                ClearMessages();
                                AddMessage(new Message("The base's lights turn on!", map.LocalTime.TurnCounter, Color.Green));
                                RedrawPlayScreen();

                                // helicopter evac details //@@MP (Release 6-3)
                                if (m_Session.PlayerKnows_HelicopterArrivalDetails == false)
                                {
                                    // Scoring event.
                                    m_Session.Scoring.AddEvent(m_Session.WorldTime.TurnCounter, "Learned the location of the army helicopter rescue.");
                                    m_Session.PlayerKnows_HelicopterArrivalDetails = true;

                                    // The power comes on, and radios loop the message about helicopter rescue
                                    string[] text;
                                    bool missedRescue = false;
                                    if ((m_Session.WorldTime.Day == m_Session.ArmyHelicopterRescue_Day) && (m_Session.WorldTime.Hour > 16)) //Player didn't make it before sunset on arrival day
                                        missedRescue = true;
                                    else if (m_Session.WorldTime.Day > m_Session.ArmyHelicopterRescue_Day)
                                        missedRescue = true;

                                    if (missedRescue == false)
                                    {
                                        text = new string[]
                                        {
                                        "You hear the comms radios spring to life, repeating a message...",
                                        "\"  This is Murdoch air force base.",
                                        "  We have a command post established for survivors.",
                                        String.Format("  We will send an evac helicopter to you on day {0}.", m_Session.ArmyHelicopterRescue_Day.ToString()),
                                        String.Format("  It will land at coordinates {0}:{1}.", m_Session.ArmyHelicopterRescue_DistrictRef, (m_Session.ArmyHelicopterRescue_Coordinates.X + "-" + m_Session.ArmyHelicopterRescue_Coordinates.Y)),
                                        "  It will arrive at sunrise, and make it's last trip by sunset.",
                                        "  Make sure you have your staff and civilians ready to go. \"",
                                        };
                                    }
                                    else
                                    {
                                        text = new string[]
                                        {
                                        "You hear the comms radios spring to life, repeating a message...",
                                        "\"  The helicopter we sent to you has not returned. We have to assume it's gone.",
                                        "  I'm sorry, but we don't have any more helicopters.",
                                        "  Rescue won't be possible. You're on your own.",
                                        "  Good luck. God bless. \"",
                                        };
                                    }

                                    ShowSpecialDialogue(m_Player, text);
                                }
                            }
                        }
                    }
                    else // part off
                    {
                        if (map.Lighting != Lighting.DARKNESS)
                        {
                            map.Lighting = Lighting.DARKNESS;

                            // message.
                            if (m_Player.Location.Map == map)
                            {
                                ClearMessages();
                                AddMessage(new Message("The base's lights turn off.", map.LocalTime.TurnCounter, Color.Red));
                                RedrawPlayScreen();
                            }
                        }
                    }
                }
            }
#endregion

            // 6. Shopping mall    //@@MP (Release 7-3)
#region
            if (map == m_Session.UniqueMaps.ShoppingMall_Parking.TheMap)
            {
                lock (m_Session) // thread safe
                {
                    // check all power generators are on.
                    bool allAreOn = m_Rules.ComputeMapPowerRatio(map) >= 1.0f;

                    // open/close cells.
                    if (allAreOn)
                    {
                        // message.
                        if (m_Player.Location.Map == map)
                        {
                            ClearMessages();
                            AddMessage(new Message("The lights turn on in parts of the mall.", map.LocalTime.TurnCounter, Color.Green));
                            RedrawPlayScreen();
                            WarnAboutNightVision();
                        }

                        // turn power on.
                        //m_Session.UniqueMaps.ShoppingMall_GroundFloor.TheMap.Lighting = Lighting.LIT;
                        m_Session.UniqueMaps.ShoppingMall_Parking.TheMap.Lighting = Lighting.LIT;
                        m_Session.UniqueMaps.ShoppingMall_UpperLevel.TheMap.Lighting = Lighting.LIT;
                    }
                    else
                    {
                        if (map.Lighting != Lighting.DARKNESS)
                        {
                            // message.
                            if (m_Player.Location.Map == map)
                            {
                                ClearMessages();
                                AddMessage(new Message("The lights turn off in parts of the mall.", map.LocalTime.TurnCounter, Color.Green));
                                RedrawPlayScreen();
                            }

                            // turn power off.
                            //m_Session.UniqueMaps.ShoppingMall_GroundFloor.TheMap.Lighting = Lighting.OUTSIDE;  //@@MP - doesn't work, makes the sky not visible even when outside for some reason...
                            m_Session.UniqueMaps.ShoppingMall_Parking.TheMap.Lighting = Lighting.DARKNESS;
                            m_Session.UniqueMaps.ShoppingMall_UpperLevel.TheMap.Lighting = Lighting.DARKNESS;
                        }
                    }
                }
            }
#endregion
        }

        static void DoOpenSubwayGates(Map map) //@@MP - made static (Release 5-7)
        {
            foreach (MapObject obj in map.MapObjects)
            {
                if (obj.ImageID == GameImages.OBJ_GATE_CLOSED)
                {
                    obj.IsWalkable = true;
                    obj.ImageID = GameImages.OBJ_GATE_OPEN;
                }
            }
        }

        void DoCloseSubwayGates(Map map)
        {
            foreach (MapObject obj in map.MapObjects)
            {
                if (obj.ImageID == GameImages.OBJ_GATE_OPEN)
                {
                    obj.IsWalkable = false;
                    obj.ImageID = GameImages.OBJ_GATE_CLOSED;
                    Actor crushedActor = map.GetActorAt(obj.Location.Position);
                    if (crushedActor != null && !crushedActor.IsInvincible)
                    {
                        KillActor(null, crushedActor, "crushed by a gate");
                        if (m_Player.Location.Map == map)
                        {
                            AddMessage(new Message("Someone got crushed between the closing gates!", map.LocalTime.TurnCounter, Color.Red));
                            RedrawPlayScreen();
                        }
                    }
                }
            }
        }

        static void DoOpenPoliceJailCells(Map map) //@@MP - made static (Release 5-7)
        {
            foreach (MapObject obj in map.MapObjects)
            {
                if (obj.ImageID == GameImages.OBJ_GATE_CLOSED)
                {
                    obj.IsWalkable = true;
                    obj.ImageID = GameImages.OBJ_GATE_OPEN;
                }
            }
        }

        void DoClosePoliceJailCells(Map map)
        {
            foreach (MapObject obj in map.MapObjects)
            {
                if (obj.ImageID == GameImages.OBJ_GATE_OPEN)
                {
                    obj.IsWalkable = false;
                    obj.ImageID = GameImages.OBJ_GATE_CLOSED;
                    Actor crushedActor = map.GetActorAt(obj.Location.Position);
                    if (crushedActor != null && !crushedActor.IsInvincible) // alpha10
                    {
                        KillActor(null, crushedActor, "crushed by a gate");
                        if (m_Player.Location.Map == map)
                        {
                            AddMessage(new Message("Someone got crushed between the closing cells!", map.LocalTime.TurnCounter, Color.Red));
                            RedrawPlayScreen();
                        }
                    }
                }
            }
        }

        void DoHospitalPowerOn()
        {
            // turn all hospital lights on.
            m_Session.UniqueMaps.Hospital_Admissions.TheMap.Lighting = Lighting.LIT;
            m_Session.UniqueMaps.Hospital_Offices.TheMap.Lighting = Lighting.LIT;
            m_Session.UniqueMaps.Hospital_Patients.TheMap.Lighting = Lighting.LIT;
            m_Session.UniqueMaps.Hospital_Power.TheMap.Lighting = Lighting.LIT;
            m_Session.UniqueMaps.Hospital_Storage.TheMap.Lighting = Lighting.LIT;

            WarnAboutNightVision(); //@@MP (Release 7-1)

            // open storage gates.
            foreach (MapObject obj in m_Session.UniqueMaps.Hospital_Storage.TheMap.MapObjects)
            {
                if (obj.ImageID == GameImages.OBJ_GATE_CLOSED)
                {
                    obj.IsWalkable = true;
                    obj.ImageID = GameImages.OBJ_GATE_OPEN;
                }
            }
        }

        void DoHospitalPowerOff()
        {
            // turn all hospital lights off.
            m_Session.UniqueMaps.Hospital_Admissions.TheMap.Lighting = Lighting.DARKNESS;
            m_Session.UniqueMaps.Hospital_Offices.TheMap.Lighting = Lighting.DARKNESS;
            m_Session.UniqueMaps.Hospital_Patients.TheMap.Lighting = Lighting.DARKNESS;
            m_Session.UniqueMaps.Hospital_Power.TheMap.Lighting = Lighting.DARKNESS;
            m_Session.UniqueMaps.Hospital_Storage.TheMap.Lighting = Lighting.DARKNESS;

            // close storage gate.
            Map map = m_Session.UniqueMaps.Hospital_Storage.TheMap;
            foreach (MapObject obj in map.MapObjects)
            {
                if (obj.ImageID == GameImages.OBJ_GATE_OPEN)
                {
                    obj.IsWalkable = false;
                    obj.ImageID = GameImages.OBJ_GATE_CLOSED;
                    Actor crushedActor = map.GetActorAt(obj.Location.Position);
                    if (crushedActor != null)
                    {
                        KillActor(null, crushedActor, "crushed by a gate");
                        if (m_Player.Location.Map == map)
                        {
                            AddMessage(new Message("Someone got crushed between the closing gate!", map.LocalTime.TurnCounter, Color.Red));
                            RedrawPlayScreen();
                        }
                    }
                }
            }
        }

        void DoTurnAllGeneratorsOn(Map map)
        {
            foreach (MapObject obj in map.MapObjects)
            {
                PowerGenerator powGen = obj as PowerGenerator;
                if (powGen == null)
                    continue;
                if (!powGen.IsOn)
                {
                    powGen.TogglePower();
                    OnMapPowerGeneratorSwitch(powGen.Location); //@@MP - unused parameter (Release 5-7)
                }
            }
        }
#endregion

#region -AI EVENTS
#region --Zombie Invasion
        static bool CheckForEvent_ZombieInvasion(Map map) //@@MP - made static (Release 5-7)
        {
            // when midnight strikes only.
            if (!map.LocalTime.IsStrikeOfMidnight)
                return false;

            // if not enough zombies only.
            int undeads = map.CountUndeads();
            if (undeads >= s_Options.MaxUndeads)
                return false;

            // clear.
            return true;
        }

        void FireEvent_ZombieInvasion(Map map)
        {
            // announce.
            if (map == m_Player.Location.Map && !m_Player.IsSleeping && !m_Player.Model.Abilities.IsUndead)
            {
                // message.
                AddMessage(new Message("The number of undead seems to be increasing!", m_Session.WorldTime.TurnCounter, Color.Crimson));
                RedrawPlayScreen();
            }

            // do it.
            int undeads = map.CountUndeads();
            float invasionRatio = Math.Min(1.0f, (map.LocalTime.Day * s_Options.ZombieInvasionDailyIncrease + s_Options.DayZeroUndeadsPercent) / 100.0f);
            int targetUndeadsCount = 1 + (int)(invasionRatio * s_Options.MaxUndeads);
            int undeadsToSpawn = targetUndeadsCount - undeads;
            for (int i = 0; i < undeadsToSpawn; i++)
                SpawnNewUndead(map, map.LocalTime.Day);

        }
#endregion

#region --Sewers Invasion
        bool CheckForEvent_SewersInvasion(Map map)
        {
            // check game mode.
            if (!Rules.HasZombiesInSewers(m_Session.GameMode))
                return false;

            // randomly.
            if (!m_Rules.RollChance(SEWERS_INVASION_CHANCE))
                return false;

            // if not enough zombies only.
            int undeads = map.CountUndeads();
            if (undeads >= s_Options.MaxUndeads * SEWERS_UNDEADS_FACTOR)
                return false;

            // clear.
            return true;
        }

        void FireEvent_SewersInvasion(Map map)
        {
            // do it silently.
            int undeads = map.CountUndeads();
            float invasionRatio = Math.Min(1.0f, (map.LocalTime.Day * s_Options.ZombieInvasionDailyIncrease + s_Options.DayZeroUndeadsPercent) / 100.0f);
            int targetUndeadsCount = 1 + (int)(invasionRatio * s_Options.MaxUndeads * SEWERS_UNDEADS_FACTOR);
            int undeadsToSpawn = targetUndeadsCount - undeads;
            for (int i = 0; i < undeadsToSpawn; i++)
                SpawnNewSewersUndead(map); //@@MP - unused parameter (Release 5-7)

        }
#endregion

#region --DISABLED Subway Invasion
#if false
        bool CheckForEvent_SubwayInvasion(Map map)
        {
            // randomly.
            if (!m_Rules.RollChance(SUBWAY_INVASION_CHANCE))
                return false;

            // if not enough zombies only.
            int undeads = CountUndeads(map);
            if (undeads >= s_Options.MaxUndeads * SUBWAY_UNDEADS_FACTOR)
                return false;

            // clear.
            return true;
        }

        void FireEvent_SubwayInvasion(Map map)
        {
            // do it silently.
            int undeads = CountUndeads(map);
            float invasionRatio = Math.Min(1.0f, (map.LocalTime.Day * s_Options.ZombieInvasionDailyIncrease + s_Options.DayZeroUndeadsPercent) / 100.0f);
            int targetUndeadsCount = 1 + (int)(invasionRatio * s_Options.MaxUndeads * SUBWAY_UNDEADS_FACTOR);
            int undeadsToSpawn = targetUndeadsCount - undeads;
            for (int i = 0; i < undeadsToSpawn; i++)
                SpawnNewSubwayUndead(map, map.LocalTime.Day);

        }
#endif
#endregion

#region --Refugees wave
        static bool CheckForEvent_RefugeesWave(Map map) //@@MP - made static (Release 5-7)
        {
            // when midday strikes only.
            if (!map.LocalTime.IsStrikeOfMidday)
                return false;

            // if not enough civs only.
#if false // TEST: disabled
            int civs = CountActors(map, (a) => a.Faction == GameFactions.TheCivilians || a.Faction == GameFactions.ThePolice);
            if (civs >= Options.MaxCivilians)
                return false;
#endif

            // clear.
            return true;
        }

        /// <summary>
        /// Double factor on city borders, half factor in city center, normal factor in all other districts.
        /// </summary> 
        /// <param name="d"></param>
        /// <returns></returns>
        float RefugeesEventDistrictFactor(District d)
        {
            int dx = d.WorldPosition.X;
            int dy = d.WorldPosition.Y;
            int border = m_Session.World.Size - 1;
            int center = border / 2;

            return (dx == 0 || dy == 0 || dx == border || dy == border ? 2f :
                dx == center && dy == center ? 0.5f :
                1f);
        }

        void FireEvent_RefugeesWave(District district)
        {
            // announce.
            if (district == m_Player.Location.Map.District && !m_Player.IsSleeping && !m_Player.Model.Abilities.IsUndead)
            {
                // message.
                AddMessage(new Message("A wave of refugees has arrived!", m_Session.WorldTime.TurnCounter, Color.Pink));
                RedrawPlayScreen();
            }

            // Spawn most on the surface and a small number in sewers and subway.
            int civilians = district.EntryMap.CountActorsBasedOn((a) => a.Faction == GameFactions.TheCivilians || a.Faction == GameFactions.ThePolice);
            int size = 1 + (int)(REFUGEES_WAVE_SIZE * RefugeesEventDistrictFactor(district) * s_Options.MaxCivilians);
            int civiliansToSpawn = Math.Min(size, s_Options.MaxCivilians - civilians);
            Map spawnMap = null;
            for (int i = 0; i < civiliansToSpawn; i++)
            {
                // map: surface or sewers/subway.
                if (m_Rules.RollChance(REFUGEE_SURFACE_SPAWN_CHANCE))
                    spawnMap = district.EntryMap;
                else
                {
                    // 50% sewers and 50% subway, but some districts have no subway.
                    if (district.HasSubway)
                        spawnMap = m_Rules.RollChance(50) ? district.SubwayMap : district.SewersMap;
                    else
                        spawnMap = district.SewersMap;
                }
                // do it.
                SpawnNewRefugee(spawnMap);
            }

            #region spawn animals    //@@MP (Release 7-6)
            int farmsCount = 0, parksCount = 0, pondsCount = 0;
            int foodAnimals = district.EntryMap.CountActorsBasedOn((a) => a.Faction == GameFactions.TheUnintelligentAnimals);
            int foodAnimalsToMaybeSpawn = s_Options.MaxAnimals - foodAnimals; //just top up to the max. will only apply if this is an appropriate district
            if (foodAnimalsToMaybeSpawn > 0)
            {
                //SpawnNewChicken(district.EntryMap); //SpawnNewRabbit(district.EntryMap);   - unused methods
                Map map = district.EntryMap;
                
                Zone farm = null, park = null;

                //work out what zones we're dealing with
                foreach (Zone zone in map.Zones)
                {
                    if (zone.Name.Contains("Farm"))
                    {
                        farm = zone;
                        ++farmsCount;
                    }
                    else if (zone.Name.Contains("Park"))
                    {
                        park = zone;
                        ++parksCount;
                    }
                    else if (zone.Name.Contains("Pond"))
                        ++pondsCount; //ponds provide fish, so this district doesn't need more animals for food
                }

                //now work out what type of animal to spawn based on those zones
                string selectedAnimalType = "";
                Rectangle rect = new Rectangle(1, 1, 1, 1); //placeholder. super lazy
                if (parksCount > 0 && pondsCount == 0 && farmsCount == 0) //if no farms but does have parks without ponds, spawn rabbits
                {
                    selectedAnimalType = "rabbit";
                    rect = park.Bounds;
                }
                else if (farmsCount > 0) //if a farm is present, spawn chickens
                {
                    selectedAnimalType = "chicken";
                    rect = farm.Bounds;
                }

                //now spawn that animal type if we're not already at the per district limit
                if (!String.IsNullOrEmpty(selectedAnimalType))
                {
                    int foodAnimalsToSpawn = foodAnimalsToMaybeSpawn;
                    for (int i = 0; i < foodAnimalsToSpawn; i++)
                    {
                        Actor newAnimal = null;
                        if (selectedAnimalType == "chicken")
                            newAnimal = m_TownGenerator.CreateNewChicken(district.EntryMap.LocalTime.TurnCounter);
                        else if (selectedAnimalType == "rabbit")
                            newAnimal = m_TownGenerator.CreateNewRabbit(district.EntryMap.LocalTime.TurnCounter);
                        else
                            throw new InvalidOperationException("no valid animal type supplied");

                        // select spot in zone. doesn't matter where, as they'll roam their zone
                        bool wasSpawned = m_TownGenerator.ActorPlace(m_Rules.DiceRoller, 25, map, newAnimal, rect.Left, rect.Top, rect.Width, rect.Height,
                        (pt) => map.IsWalkable(pt.X, pt.Y) && map.GetActorAt(pt) == null && (map.GetTileAt(pt).Model == GameTiles.FLOOR_GRASS || map.GetTileAt(pt).Model == GameTiles.FLOOR_PLANTED));

                        if (wasSpawned)
                        {
                            if (selectedAnimalType == "chicken")
                            {
                                Item egg = new ItemFood(GameItems.CHICKEN_EGG, map.LocalTime.TurnCounter + (WorldTime.TURNS_PER_DAY * GameItems.CHICKEN_EGG.BestBeforeDays), false, false);
                                egg.Quantity = 2;
                                map.DropItemAt(egg, newAnimal.Location.Position);
                            }
                        }
                    }
                }
            }
            if (farmsCount == 0 && parksCount == 0 && pondsCount == 0) //it's not a district suitable for food animals, so its for dogs instead
            {
                //spawn feral dogs    //@@MP (Release 7-3)
                int dogs = district.EntryMap.CountActorsBasedOn((a) => a.Faction == GameFactions.TheFerals);
                int dogsToSpawn = s_Options.MaxAnimals - dogs; //just top up to the max
                for (int i = 0; i < dogsToSpawn; i++)
                {
                    // dogs only spawn on the surface.
                    SpawnNewFeralDog(district.EntryMap);
                }
            }
            #endregion

            /*    //@@MP - unique NPCs removed (Release 8-1)
            // check for uniques, always in surface.
            if (m_Rules.RollChance(UNIQUE_REFUGEE_CHECK_CHANCE))
            {
                lock (m_Session) // thread safe
                {
                    UniqueActor[] array = m_Session.UniqueActors.ToArray();
                    UniqueActor[] mayArrive = Array.FindAll(array,
                        (UniqueActor a) =>
                        {
                            return a.IsWithRefugees && !a.IsSpawned && !a.TheActor.IsDead;
                        });
                    if (mayArrive != null && mayArrive.Length > 0)
                    {
                        int iArrive = m_Rules.Roll(0, mayArrive.Length);
                        FireEvent_UniqueActorArrive(district.EntryMap, mayArrive[iArrive]);
                    }
                }
            }
            */
        }

        void FireEvent_UniqueActorArrive(Map map, UniqueActor unique)
        {
            // try to find a spot.
            bool spawned = SpawnActorOnMapBorder(map, unique.TheActor, SPAWN_DISTANCE_TO_PLAYER, true);

            // if failed, cancel.
            if (!spawned)
                return;

            // mark as spawned.
            unique.IsSpawned = true;

            // announce.
            if (map == m_Player.Location.Map && !m_Player.IsSleeping && !m_Player.Model.Abilities.IsUndead)
            {
                // alpha 10 factorized to PlayUniqueActorMusicAndMessage
                /*// message and music.
                if (unique.EventMessage != null)
                {
                    if (unique.EventThemeMusic != null)
                    {
                        m_MusicManager.StopAll();
                        m_MusicManager.Play(unique.EventThemeMusic, AudioPriority.PRIORITY_EVENT);
                    }
                    // message.
                    ClearMessages();
                    AddMessage(new Message(unique.EventMessage, m_Session.WorldTime.TurnCounter, Color.Pink));
                    AddMessage(MakePlayerCentricMessage("Seems to come from", unique.TheActor.Location.Position));
                    AddMessagePressEnter();
                    ClearMessages();
                }*/
                PlayUniqueActorMusicAndMessage(unique, true); // alpha 10
                // scoring event.
                m_Session.Scoring.AddEvent(m_Session.WorldTime.TurnCounter, unique.TheActor.Name + " arrived.");
            }
        }

        void PlayUniqueActorMusicAndMessage(UniqueActor unique, bool hasArrived)  // alpha10
        {
            if (unique.EventMessage != null)
            {
                Overlay highlightOverlay = null;

                if (unique.EventThemeMusic != null)
                {
                    m_MusicManager.StopAll();
                    m_MusicManager.Play(unique.EventThemeMusic, AudioPriority.PRIORITY_EVENT);
                }

                ClearMessages();
                AddMessage(new Message(unique.EventMessage, m_Session.WorldTime.TurnCounter, Color.Pink));
                if (hasArrived)
                    AddMessage(MakePlayerCentricMessage("Seems to come from", unique.TheActor.Location.Position));
                else
                {
                    highlightOverlay = new OverlayRect(Color.Pink, new Rectangle(MapToScreen(unique.TheActor.Location.Position), new Size(TILE_SIZE, TILE_SIZE)));
                    AddOverlay(highlightOverlay);
                }
                if (!m_Player.IsBotPlayer) //alpha 10.1
                {
                    AddMessagePressEnter();
                    ClearMessages();
                }
                if (highlightOverlay != null)
                    RemoveOverlay(highlightOverlay);
            }
        }
#endregion

#region --Helicopter arrival actors wave
        //@@MP - to add a bunch of people attracted by the noise of the rescue helicopter (Release 7-3)

        void FireEvent_RescueWave(District district)
        {
            // announce.
            if (district == m_Player.Location.Map.District && !m_Player.IsSleeping && !m_Player.Model.Abilities.IsUndead)
            {
                // message.
                AddMessage(new Message("A surge of people are rushing about excitedly!", m_Session.WorldTime.TurnCounter, Color.Pink));
                AddMessage(new Message("The number of undead seems to be increasing!", m_Session.WorldTime.TurnCounter, Color.Crimson));
                RedrawPlayScreen();
            }

            // Spawn most on the surface and a small number in sewers and subway.
            int civilians = district.EntryMap.CountActorsBasedOn((a) => a.Faction == GameFactions.TheCivilians || a.Faction == GameFactions.ThePolice);
            int civiliansToSpawn = s_Options.MaxCivilians - civilians;
            for (int i = 0; i < civiliansToSpawn; i++)
            {
                // only on surface
                SpawnNewRefugee(district.EntryMap);
            }

            //spawn feral dogs
            int dogs = district.EntryMap.CountActorsBasedOn((a) => a.Faction == GameFactions.TheFerals);
            int dogsToSpawn = s_Options.MaxAnimals - dogs; //just top up to the max
            for (int i = 0; i < dogsToSpawn; i++)
            {
                // dogs only spawn on the surface.
                SpawnNewFeralDog(district.EntryMap);
            }

            // spawn undeads
            int undeads = district.EntryMap.CountUndeads();
            int undeadsToSpawn = s_Options.MaxUndeads - undeads;
            for (int i = 0; i < undeadsToSpawn; i++)
                SpawnNewUndead(district.EntryMap, district.EntryMap.LocalTime.Day);
        }
#endregion

#region --National guard
        bool CheckForEvent_NationalGuard(Map map)
        {
            // if option zeroed, don't bother.
            if (s_Options.NatGuardFactor == 0)
                return false;

            // during day only.
            if (map.LocalTime.IsNight)
                return false;

            // date.
            if (map.LocalTime.Day < NATGUARD_DAY)
                return false;
            if (map.LocalTime.Day >= Math.Max(NATGUARD_END_DAY, m_Session.ArmyHelicopterRescue_Day - 3)) //@@MP - accounted for longer expected surival times than vanilla (Release 7-3)
                return false;

            // check chance.
            if (!m_Rules.RollChance(NATGUARD_INTERVENTION_CHANCE))
                return false;

            // if zombies significantly outnumber livings only (army count as 2 livings).
            int livings = map.CountLivings() + map.CountFaction(GameFactions.TheArmy);
            int undeads = map.CountUndeads();
            float undeadsPerLiving = (float)undeads / (float)livings;
            if (undeadsPerLiving * (s_Options.NatGuardFactor / 100f) < NATGUARD_INTERVENTION_FACTOR)
                return false;

            // clear.
            return true;
        }

        void FireEvent_NationalGuard(Map map)
        {
            // do it.
            // spawn squad leader then troopers.
            Actor squadLeader = SpawnNewNatGuardLeader(map);
            if (squadLeader != null)
            {
                for (int i = 0; i < NATGUARD_SQUAD_SIZE - 1; i++)
                {
                    // spawn trooper.
                    Actor trooper = SpawnNewNatGuardTrooper(map, squadLeader.Location.Position);
                    // add to leader squad.
                    if (trooper != null)
                        squadLeader.AddFollower(trooper);
                }
            }
            if (squadLeader == null)
                return;

            // notify AI.
            NotifyOrderablesAI(map, RaidType.NATGUARD, squadLeader.Location.Position);

            // announce.
            if (map == m_Player.Location.Map && !m_Player.IsSleeping && !m_Player.Model.Abilities.IsUndead)
            {
                // music.
                m_MusicManager.StopAll();
                m_MusicManager.Play(GameMusics.ARMY, AudioPriority.PRIORITY_EVENT);

                // message.
                ClearMessages();
                AddMessage(new Message("A National Guard squad has arrived!", m_Session.WorldTime.TurnCounter, Color.LightGreen));
                AddMessage(MakePlayerCentricMessage("Soldiers seem to come from", squadLeader.Location.Position));
                if (!m_Player.IsBotPlayer) //alpha 10.1 check
                {
                    AddMessagePressEnter();
                    ClearMessages();
                }
            }

            // scoring event.
            if (map == m_Player.Location.Map)
            {
                m_Session.Scoring.AddEvent(m_Session.WorldTime.TurnCounter, "A National Guard squad arrived.");
            }

        }
#endregion

#region --Army drop supplies
        bool CheckForEvent_ArmySupplies(Map map)
        {
            // if option zeroed, don't bother.
            if (s_Options.SuppliesDropFactor == 0)
                return false;

            // during day only.
            if (map.LocalTime.IsNight)
                return false;

            // date.
            if (map.LocalTime.Day < ARMY_SUPPLIES_DAY)
                return false;

            // check chance.
            if (!m_Rules.RollChance(ARMY_SUPPLIES_CHANCE))
                return false;

            // count food items vs livings.
            int livingsNeedFood = 1 + map.CountActorsBasedOn((a) => !a.Model.Abilities.IsUndead && a.Model.Abilities.HasToEat && a.Faction == GameFactions.TheCivilians);
            int food = 1 + map.CountFoodItemsNutrition(this);
            float foodPerLiving = (float)food / (float)livingsNeedFood;
            if (foodPerLiving >= (s_Options.SuppliesDropFactor / 100f) * ARMY_SUPPLIES_FACTOR)
                return false;

            // clear.
            return true;
        }

        void FireEvent_ArmySupplies(Map map)
        {
            ////////////////////////////
            // Do it.
            // 1. Pick drop point.
            // 2. Drop scattered items.
            ////////////////////////////

            // 1. Pick drop point.
            Point dropPoint;
            bool dropped = FindDropSuppliesPoint(map, out dropPoint);
            if (!dropped)
                return;

            // 2. Drop scattered items.
            // only outside and free of actor and objects.
            int xmin = dropPoint.X - ARMY_SUPPLIES_SCATTER;
            int xmax = dropPoint.X + ARMY_SUPPLIES_SCATTER;
            int ymin = dropPoint.Y - ARMY_SUPPLIES_SCATTER;
            int ymax = dropPoint.Y + ARMY_SUPPLIES_SCATTER;
            map.TrimToBounds(ref xmin, ref ymin);
            map.TrimToBounds(ref xmax, ref ymax);
            for (int sx = xmin; sx <= xmax; sx++)
                for (int sy = ymin; sy <= ymax; sy++)
                {
                    if (!IsSuitableDropSuppliesPoint(map, sx, sy))
                        continue;

                    // drop stuff.
                    if (m_Rules.RollChance(80))
                        map.DropItemAt(m_TownGenerator.MakeItemArmyRation(), sx, sy);
                    if (m_Rules.RollChance(80))
                        map.DropItemAt(m_TownGenerator.MakeItemLargeMedikit(), sx, sy);
                    if (m_Rules.RollChance(80))  //@@MP (Release 7-6)
                        map.DropItemAt(m_TownGenerator.MakeItemRandomCommonAmmo(), sx, sy);
                    if (m_Rules.RollChance(10))  //@@MP (Release 7-6)
                        map.DropItemAt(m_TownGenerator.MakeItemMatches(), sx, sy);
                    if (Rules.HasAntiviralPills(m_Session.GameMode) && m_Rules.RollChance(GameOptions.ResourcesAvailabilityToInt(s_Options.ResourcesAvailability)))  //@@MP (Release 7-6)
                        map.DropItemAt(m_TownGenerator.MakeItemPillsAntiviral(), sx, sy);
                }

            // notify AI.
            NotifyOrderablesAI(map, RaidType.ARMY_SUPLLIES, dropPoint);

            // announce.
            if (map == m_Player.Location.Map && !m_Player.IsSleeping && !m_Player.Model.Abilities.IsUndead)
            {
                // music.
                m_AmbientSFXManager.Play(GameAmbients.HELICOPTER_FLYOVER, AudioPriority.PRIORITY_EVENT);

                // message.
                ClearMessages();
                AddMessage(new Message("An army chopper has dropped supplies!", m_Session.WorldTime.TurnCounter, Color.LightGreen));
                AddMessage(MakePlayerCentricMessage("The drop point seems to be", dropPoint));
                if (!m_Player.IsBotPlayer) //alpha 10.1 check
                {
                    AddMessagePressEnter();
                    ClearMessages();
                }
            }

            // scoring event.
            if (map == m_Player.Location.Map)
            {
                m_Session.Scoring.AddEvent(m_Session.WorldTime.TurnCounter, "An army chopper dropped supplies.");
            }
        }

        bool IsSuitableDropSuppliesPoint(Map map, int x, int y)
        {
            //////////////////////////////
            // Must be:
            // 1. In bounds.
            // 2. Outside & walkable.
            // 3. No actor nor object.
            // 4. Far enough from player.
            //////////////////////////////

            // 1. In bounds.
            if (!map.IsInBounds(x, y))
                return false;

            // 2. Outside & walkable.
            Tile tile = map.GetTileAt(x, y);
            if (tile.IsInside || !tile.Model.IsWalkable)
                return false;

            // 3. No actor nor object.
            if (map.GetActorAt(x, y) != null || map.GetMapObjectAt(x, y) != null)
                return false;

            // 4. Far enough from player.
            if (DistanceToPlayer(map, x, y) < SPAWN_DISTANCE_TO_PLAYER)
                return false;

            // all clear.
            return true;
        }

        bool FindDropSuppliesPoint(Map map, out Point dropPoint)
        {
            dropPoint = new Point();

            // try to find a suitable point.
            int maxAttempts = 4 * map.Width;
            for (int attempt = 0; attempt < maxAttempts; attempt++)
            {
                // roll.
                dropPoint.X = m_Rules.RollX(map);
                dropPoint.Y = m_Rules.RollY(map);

                // suitable?
                if (!IsSuitableDropSuppliesPoint(map, dropPoint.X, dropPoint.Y))
                    continue;

                // we're good.
                return true;
            }

            // failed
            return false;
        }
#endregion

#region --Timed raids
        bool HasRaidHappenedSince(RaidType raid, District district, WorldTime mapTime, int sinceNTurns)
        {
            return m_Session.HasRaidHappened(raid, district) && mapTime.TurnCounter - m_Session.LastRaidTime(raid, district) < sinceNTurns;
        }

#region --Bikers raid
        bool CheckForEvent_BikersRaid(Map map)
        {
            // date.
            if (map.LocalTime.Day < BIKERS_RAID_DAY)
                return false;
            if (map.LocalTime.Day >= BIKERS_END_DAY)
                return false;

            // last time : at least N day
            if (HasRaidHappenedSince(RaidType.BIKERS, map.District, map.LocalTime, BIKERS_RAID_DAYS_GAP * WorldTime.TURNS_PER_DAY))
                return false;

            // check chance.
            if (!m_Rules.RollChance(BIKERS_RAID_CHANCE_PER_TURN))
                return false;

            // if no bikers.
#if false
            disabled to take advantage of the new rival gang feature.
            if(HasActorOfModelID(map, GameActors.IDs.BIKER_MAN))
                return false;
#endif

            // clear.
            return true;
        }

        void FireEvent_BikersRaid(Map map)
        {
            // remember time.
            m_Session.SetLastRaidTime(RaidType.BIKERS, map.District, map.LocalTime.TurnCounter);

            // roll a random gang.
            GameGangs.IDs gangId = GameGangs.BIKERS[m_Rules.Roll(0, GameGangs.BIKERS.Length)];

            // do it.
            // spawn raid leader then squadies.
            Actor raidLeader = SpawnNewBikerLeader(map, gangId);
            if (raidLeader != null)
            {
                for (int i = 0; i < BIKERS_RAID_SIZE - 1; i++)
                {
                    // spawn squadie.
                    Actor squadie = SpawnNewBiker(map, gangId, raidLeader.Location.Position);
                    // add to leader squad.
                    if (squadie != null)
                        raidLeader.AddFollower(squadie);
                }
            }
            if (raidLeader == null)
                return;

            // notify AI.
            NotifyOrderablesAI(map, RaidType.BIKERS, raidLeader.Location.Position);

            // announce.
            if (map == m_Player.Location.Map && !m_Player.IsSleeping && !m_Player.Model.Abilities.IsUndead)
            {
                // music.
                m_MusicManager.StopAll();
                m_MusicManager.Play(GameMusics.BIKER, AudioPriority.PRIORITY_EVENT);

                // message.
                ClearMessages();
                AddMessage(new Message("You hear the sound of roaring engines!", m_Session.WorldTime.TurnCounter, Color.LightGreen));
                AddMessage(MakePlayerCentricMessage("Motorbikes seem to come from", raidLeader.Location.Position));
                if (!m_Player.IsBotPlayer) //alpha 10.1 check
                {
                    AddMessagePressEnter();
                    ClearMessages();
                }
            }

            // scoring event.
            if (map == m_Player.Location.Map)
            {
                m_Session.Scoring.AddEvent(m_Session.WorldTime.TurnCounter, "Bikers raided the district.");
            }
        }
#endregion

#region --Gangsta raid
        bool CheckForEvent_GangstasRaid(Map map)
        {
            // date.
            if (map.LocalTime.Day < GANGSTAS_RAID_DAY)
                return false;
            if (map.LocalTime.Day >= GANGSTAS_END_DAY)
                return false;

            // last time : at least N day
            if (HasRaidHappenedSince(RaidType.GANGSTA, map.District, map.LocalTime, GANGSTAS_RAID_DAYS_GAP * WorldTime.TURNS_PER_DAY))
                return false;

            // check chance.
            if (!m_Rules.RollChance(GANGSTAS_RAID_CHANCE_PER_TURN))
                return false;

            // if no gangsta.
#if false
            disabled to take advantage of the new rival gang feature.
            if (HasActorOfModelID(map, GameActors.IDs.GANGSTA_MAN))
                return false;
#endif

            // clear.
            return true;
        }

        void FireEvent_GangstasRaid(Map map)
        {
            // remember time.
            m_Session.SetLastRaidTime(RaidType.GANGSTA, map.District, map.LocalTime.TurnCounter);

            // roll a random gang.
            GameGangs.IDs gangId = GameGangs.GANGSTAS[m_Rules.Roll(0, GameGangs.GANGSTAS.Length)];

            // do it.
            // spawn raid leader then squadies.
            Actor raidLeader = SpawnNewGangstaLeader(map, gangId);
            if (raidLeader != null)
            {
                for (int i = 0; i < GANGSTAS_RAID_SIZE - 1; i++)
                {
                    // spawn squadie.
                    Actor squadie = SpawnNewGangsta(map, gangId, raidLeader.Location.Position);
                    // add to leader squad.
                    if (squadie != null)
                        raidLeader.AddFollower(squadie);
                }
            }
            if (raidLeader == null)
                return;

            // notify AI.
            NotifyOrderablesAI(map, RaidType.GANGSTA, raidLeader.Location.Position);

            // announce.
            if (map == m_Player.Location.Map && !m_Player.IsSleeping && !m_Player.Model.Abilities.IsUndead)
            {
                // music.
                m_MusicManager.StopAll();
                m_MusicManager.Play(GameMusics.GANGSTA, AudioPriority.PRIORITY_EVENT);

                // message.
                ClearMessages();
                AddMessage(new Message("You hear obnoxious loud music!", m_Session.WorldTime.TurnCounter, Color.LightGreen));
                AddMessage(MakePlayerCentricMessage("Cars seem to come from", raidLeader.Location.Position));
                if (!m_Player.IsBotPlayer) //alpha 10.1 check
                {
                    AddMessagePressEnter();
                    ClearMessages();
                }
            }

            // scoring event.
            if (map == m_Player.Location.Map)
            {
                m_Session.Scoring.AddEvent(m_Session.WorldTime.TurnCounter, "Gangstas raided the district.");
            }
        }
#endregion

#region --BlackOps raid
        bool CheckForEvent_BlackOpsRaid(Map map)
        {
            // if option disabled, don't bother.  //@@MP (Release 7-5)
            if (s_Options.BlackOpsRaidsEnabled == false)
                return false;

            // date.
            if (map.LocalTime.Day < BLACKOPS_RAID_DAY)
                return false;

            // last time : at least N day
            if (HasRaidHappenedSince(RaidType.BLACKOPS, map.District, map.LocalTime, BLACKOPS_RAID_DAY_GAP * WorldTime.TURNS_PER_DAY))
                return false;

            // check chance.
            if (!m_Rules.RollChance(BLACKOPS_RAID_CHANCE_PER_TURN))
                return false;

            // clear.
            return true;
        }

        void FireEvent_BlackOpsRaid(Map map)
        {
            // remember time.
            m_Session.SetLastRaidTime(RaidType.BLACKOPS, map.District, map.LocalTime.TurnCounter);

            // do it.
            // spawn raid leader then squadies.
            Actor raidLeader = SpawnNewBlackOpsLeader(map);
            if (raidLeader != null)
            {
                for (int i = 0; i < BLACKOPS_RAID_SIZE - 1; i++)
                {
                    // spawn squadie.
                    Actor squadie = SpawnNewBlackOpsTrooper(map, raidLeader.Location.Position);
                    // add to leader squad.
                    if (squadie != null)
                        raidLeader.AddFollower(squadie);
                }
            }
            if (raidLeader == null)
                return;

            // notify AI.
            NotifyOrderablesAI(map, RaidType.BLACKOPS, raidLeader.Location.Position);

            // announce.
            if (map == m_Player.Location.Map && !m_Player.IsSleeping && !m_Player.Model.Abilities.IsUndead)
            {
                // music.
                m_MusicManager.StopAll();
                m_MusicManager.Play(GameMusics.BLACK_OPS, AudioPriority.PRIORITY_EVENT); //@@MP changed music from Army to the new Black Ops (Release 6-1)

                // message.
                ClearMessages();
                AddMessage(new Message("A plane passes quickly over the city!", m_Session.WorldTime.TurnCounter, Color.LightGreen));
                AddMessage(MakePlayerCentricMessage("Parachutists have dropped", raidLeader.Location.Position));
                if (!m_Player.IsBotPlayer) //alpha 10.1 check
                {
                    AddMessagePressEnter();
                    ClearMessages();
                }
            }

            // scoring event.
            if (map == m_Player.Location.Map)
            {
                m_Session.Scoring.AddEvent(m_Session.WorldTime.TurnCounter, "BlackOps raided the district.");
            }
        }
#endregion

#region --Band of Survivors
        bool CheckForEvent_BandOfSurvivors(Map map)
        {
            // date.
            if (map.LocalTime.Day < SURVIVORS_BAND_DAY)
                return false;

            // last time : at least N day
            if (HasRaidHappenedSince(RaidType.SURVIVORS, map.District, map.LocalTime, SURVIVORS_BAND_DAY_GAP * WorldTime.TURNS_PER_DAY))
                return false;

            // check chance.
            if (!m_Rules.RollChance(SURVIVORS_BAND_CHANCE_PER_TURN))
                return false;

            // clear.
            return true;
        }

        void FireEvent_BandOfSurvivors(Map map)
        {
            // remember time.
            m_Session.SetLastRaidTime(RaidType.SURVIVORS, map.District, map.LocalTime.TurnCounter);

            // do it.
            // spawn dudes.
            Actor bandScout = SpawnNewSurvivor(map);
            if (bandScout != null)
            {
                for (int i = 0; i < SURVIVORS_BAND_SIZE - 1; i++)
                    SpawnNewSurvivor(map, bandScout.Location.Position);
            }
            if (bandScout == null)
                return;

            // notify AI.
            NotifyOrderablesAI(map, RaidType.SURVIVORS, bandScout.Location.Position);

            // announce.
            if (map == m_Player.Location.Map && !m_Player.IsSleeping && !m_Player.Model.Abilities.IsUndead)
            {
                // music.
                m_MusicManager.StopAll();
                m_MusicManager.Play(GameMusics.SURVIVORS, AudioPriority.PRIORITY_EVENT);

                // message.
                ClearMessages();
                AddMessage(new Message("You hear shooting and honking in the distance.", m_Session.WorldTime.TurnCounter, Color.LightGreen));
                AddMessage(MakePlayerCentricMessage("A vehicle has stopped", bandScout.Location.Position));
                if (!m_Player.IsBotPlayer) //alpha 10.1 check
                {
                    AddMessagePressEnter();
                    ClearMessages();
                }
            }

            // scoring event.
            if (map == m_Player.Location.Map)
            {
                m_Session.Scoring.AddEvent(m_Session.WorldTime.TurnCounter, "A band of survivors entered the district.");
            }
        }
        #endregion

#region --CHAR scientists
        //@@MP - added (Release 8-1)

        bool CheckForEvent_CHARScientists(Map map)
        {
            // date.
            if (map.LocalTime.Day < SCIENTISTS_TEAM_DAY)
                return false;

            // last time : at least N day
            if (HasRaidHappenedSince(RaidType.CHAR_SCIENTISTS, map.District, map.LocalTime, SCIENTISTS_TEAM_DAY_GAP * WorldTime.TURNS_PER_DAY))
                return false;

            // check chance.
            if (!m_Rules.RollChance(SCIENTISTS_TEAM_CHANCE_PER_TURN))
                return false;

            // clear.
            return true;
        }

        void FireEvent_CHARScientists(Map map)
        {
            // remember time.
            m_Session.SetLastRaidTime(RaidType.CHAR_SCIENTISTS, map.District, map.LocalTime.TurnCounter);

            // do it.
            // spawn team leader then colleagues.
            Actor teamLeader = SpawnNewCHARScientistLeader(map);
            if (teamLeader != null)
            {
                for (int i = 0; i < SCIENTISTS_TEAM_SCIENTISTS - 1; i++)
                {
                    // spawn colleague.
                    Actor colleague = SpawnNewCHARScientist(map, teamLeader.Location.Position);
                    // add to leader.
                    if (colleague != null)
                        teamLeader.AddFollower(colleague);
                }
                for (int i = 0; i < SCIENTISTS_TEAM_GUARDS - 1; i++)
                {
                    // spawn guard.
                    Actor guard = SpawnNewCHARGuard(map, teamLeader.Location.Position);
                    // add to leader.
                    if (guard != null)
                        teamLeader.AddFollower(guard);
                }
            }
            if (teamLeader == null)
                return;

            // notify AI.
            NotifyOrderablesAI(map, RaidType.CHAR_SCIENTISTS, teamLeader.Location.Position);

            // announce.
            if (map == m_Player.Location.Map && !m_Player.IsSleeping && !m_Player.Model.Abilities.IsUndead)
            {
                // music.
                m_MusicManager.StopAll();
                m_MusicManager.Play(GameMusics.CHAR_RESEARCHERS, AudioPriority.PRIORITY_EVENT);

                // message.
                ClearMessages();
                AddMessage(new Message("You hear a strange, electronic whirring in the distance.", m_Session.WorldTime.TurnCounter, Color.LightGreen));
                AddMessage(MakePlayerCentricMessage("A vehicle has stopped", teamLeader.Location.Position));
                if (!m_Player.IsBotPlayer) //alpha 10.1 check
                {
                    AddMessagePressEnter();
                    ClearMessages();
                }
            }

            // scoring event.
            if (map == m_Player.Location.Map)
            {
                m_Session.Scoring.AddEvent(m_Session.WorldTime.TurnCounter, "A CHAR research team entered the district.");
            }
        }
#endregion

        static void NotifyOrderablesAI(Map map, RaidType raid, Point position) //@@MP - made static (Release 5-7)
        {
            foreach (Actor a in map.Actors)
            {
                OrderableAI oAI = a.Controller as OrderableAI;
                if (oAI == null)
                    continue;
                oAI.OnRaid(raid, new Location(map, position), map.LocalTime.TurnCounter);
            }
        }
#endregion

#region --Army rescue helicopter
        //@@MP - methods supporting the end-goal helicopter rescue (Release 6-4)

        private void SpawnArmyHelicopterOnMap(Map map)
        {
            //the heli is a 3x1 tile, so clear its designated space of actors and objects
            Point heli1 = m_Session.ArmyHelicopterRescue_Coordinates;
            Point heli2 = new Point(heli1.X + 1, heli1.Y);
            Point heli3 = new Point(heli1.X + 2, heli1.Y);

            List<Point> heliPoints = new List<Point>() { heli1, heli2, heli3 };
            foreach (Point heliPoint in heliPoints)
            {
                //remove objects in the way
                if (map.GetMapObjectAt(heliPoint) != null)
                    map.RemoveMapObjectAt(heliPoint.X, heliPoint.Y);

                //remove items in the way
                map.RemoveAllItemsAt(heliPoint);

                //move actors in the way
                Actor actor = map.GetActorAt(heliPoint);
                if (actor != null)
                {
                    //kill AI actors
                    if (!actor.IsPlayer)
                    {
                        KillActor(actor, actor, "crushed by a helicopter"); //@@MP - previously they were just outright removed (Release 7-5)
                        map.RemoveAllItemsAt(heliPoint); //get rid of their stuff they dropped
                    }
                    else
                    {
                        //find a suitable location to move the player to
                        Point winningSpot = FindNonHelicopterSpotToMovePlayer(map, heliPoint, heliPoints);
                        //if we found absolutely no good spot, widen the search
                        if (winningSpot == Point.Empty)
                        {
                            bool foundASpot = false;
                            foreach (Direction d in Direction.COMPASS)
                            {
                                winningSpot = FindNonHelicopterSpotToMovePlayer(map, heliPoint + d, heliPoints);
                                if (winningSpot != Point.Empty)
                                {
                                    foundASpot = true;
                                    break;
                                }
                            }
                            if (foundASpot == false)
                                throw new InvalidOperationException("Could not find clear point to relocate player to (away from helicopter). Please reload your last save");
                        }

                        //now move them
                        map.RemoveActor(actor);
                        map.PlaceActorAt(actor, winningSpot);
                        OnActorEnterTile(actor);
                    }
                }
            }

            //now place the helicopter down
            map.PlaceMapObjectAt(m_TownGenerator.MakeObjHelicopter(GameImages.OBJ_HELICOPTER1), heli1);
            map.PlaceMapObjectAt(m_TownGenerator.MakeObjHelicopter(GameImages.OBJ_HELICOPTER2), heli2);
            map.PlaceMapObjectAt(m_TownGenerator.MakeObjHelicopter(GameImages.OBJ_HELICOPTER3), heli3);

            //audio
            CheckLandedHelicopterSFX(map); //play the ambient helicopter sound if required
            //if not already within earshot for the ambient sound, play a flyover to let the player know a heli is around
            if (!m_AmbientSFXManager.IsPlaying(GameAmbients.STATIONARY_HELICOPTER_FARTHEST) && !m_AmbientSFXManager.IsPlaying(GameAmbients.STATIONARY_HELICOPTER_FAR) && 
                !m_AmbientSFXManager.IsPlaying(GameAmbients.STATIONARY_HELICOPTER_NEAR) && !m_AmbientSFXManager.IsPlaying(GameAmbients.STATIONARY_HELICOPTER_VISIBLE))
            {
                m_AmbientSFXManager.PlayIfNotAlreadyPlaying(GameAmbients.HELICOPTER_FLYOVER, AudioPriority.PRIORITY_EVENT);
            }

            // notify AI.   //@@MP (Release 7-5)
            NotifyOrderablesAI(map, RaidType.HELICOPTER_RESCUE, m_Session.ArmyHelicopterRescue_Coordinates);

            //rescue helicopter attracts attention   //@@MP (Release 7-3)
            FireEvent_RescueWave(map.District);
        }

        private static Point FindNonHelicopterSpotToMovePlayer(Map map, Point source, List<Point> heliPoints)
        {
            Point winningPoint = Point.Empty;
            int winningScore = 0;
            foreach (Direction d in Direction.COMPASS)
            {
                Point pt = source + d;
                int thisPtScore = 0;

                //can't be out of bounds
                if (!map.IsInBounds(pt)) continue;

                //rule out any other points that are also heli spots
                bool itsAnotherHeliPoint = false;
                foreach (Point heliPt in heliPoints)
                {
                    if (pt == heliPt) itsAnotherHeliPoint = true;
                }
                if (itsAnotherHeliPoint) continue;

                //check if there is already an actor there
                if (map.GetActorAt(pt) != null) continue;

                MapObject mapObj = map.GetMapObjectAt(pt);
                if (mapObj == null)
                    thisPtScore += 50;
                else if (mapObj.IsJumpable)
                    thisPtScore += 25;
                else
                    continue;

                //if the spot is on fire it's possible but not ideal for humans, so score lower
                if (map.IsAnyTileFireThere(map, pt))
                    thisPtScore -= 30;
                else
                    thisPtScore += 100; //passed all the checks so it must be a good spot; score high

                if (thisPtScore > winningScore) winningPoint = pt;
            }
            return winningPoint;
        }

        private void DespawnArmyHelicopter(Map map)
        {
            //the heli is a 4x2 tile, so we need to clear it in pieces
            Point heli1 = m_Session.ArmyHelicopterRescue_Coordinates;
            Point heli2 = new Point(heli1.X + 1, heli1.Y);
            Point heli3 = new Point(heli1.X + 2, heli1.Y);

            List<Point> heliPoints = new List<Point>() { heli1, heli2, heli3 };
            foreach (Point heliPoint in heliPoints)
            {
                //remove objects in the way
                if (map.GetMapObjectAt(heliPoint) != null) map.RemoveMapObjectAt(heliPoint.X, heliPoint.Y);
            }
        }
#endregion
#endregion

#region -SPAWNING NEW ACTORS
        int DistanceToPlayer(Map map, int x, int y)
        {
            if (m_Player == null || m_Player.Location.Map != map)
                return int.MaxValue;
            return m_Rules.GridDistance(m_Player.Location.Position, x, y);
        }

        int DistanceToPlayer(Map map, Point pos)
        {
            return DistanceToPlayer(map, pos.X, pos.Y);
        }

        bool IsAdjacentToEnemy(Map map, Point pos, Actor actor)
        {
            int xmin = pos.X - 1;
            int xmax = pos.X + 1;
            int ymin = pos.Y - 1;
            int ymax = pos.Y + 1;
            map.TrimToBounds(ref xmin, ref ymin);
            map.TrimToBounds(ref xmax, ref ymax);

            for (int x = xmin; x <= xmax; x++)
                for (int y = ymin; y <= ymax; y++)
                {
                    if (x == pos.X && y == pos.Y)
                        continue;
                    Actor other = map.GetActorAt(x, y);
                    if (other == null)
                        continue;
                    if (m_Rules.AreEnemies(actor, other))
                        return true;
                }

            return false;
        }

        bool SpawnActorOnMapBorder(Map map, Actor actorToSpawn, int minDistToPlayer, bool mustBeOutside)
        {
            // find a good spot.
            int maxTries = 4 * (map.Width + map.Height);

            int i = 0;
            Point pos = new Point();
            do
            {
                ++i;

                // roll a position on the border.
                int x = (m_Rules.RollChance(50) ? 0 : map.Width - 1);
                int y = (m_Rules.RollChance(50) ? 0 : map.Height - 1);
                if (m_Rules.RollChance(50))
                    x = m_Rules.RollX(map);
                else
                    y = m_Rules.RollY(map);

                // must be free, (outside), far enough to player and not adjacent to an enemy.
                pos.X = x;
                pos.Y = y;
                if (mustBeOutside && map.GetTileAt(pos.X, pos.Y).IsInside)
                    continue;
                if (!m_Rules.IsWalkableFor(actorToSpawn, map, pos.X, pos.Y))
                    continue;
                if (DistanceToPlayer(map, pos) < minDistToPlayer)
                    continue;
                if (IsAdjacentToEnemy(map, pos, actorToSpawn))
                    continue;

                // success!                
                map.PlaceActorAt(actorToSpawn, pos);
                // trigger stuff
                OnActorEnterTile(actorToSpawn);
                return true;
            }
            while (i <= maxTries);

            // failed.
            return false;
        }

        bool SpawnActorNear(Map map, Actor actorToSpawn, int minDistToPlayer, Point nearPoint, int maxDistToPoint)
        {
            // find a good spot.
            int maxTries = 4 * (map.Width + map.Height);

            int i = 0;
            Point pos = new Point();
            do
            {
                ++i;

                // roll a position.
                int x = nearPoint.X + m_Rules.Roll(1, maxDistToPoint + 1) - m_Rules.Roll(1, maxDistToPoint + 1);
                int y = nearPoint.Y + m_Rules.Roll(1, maxDistToPoint + 1) - m_Rules.Roll(1, maxDistToPoint + 1);

                // trim to map.
                pos.X = x;
                pos.Y = y;
                map.TrimToBounds(ref pos);

                // must free, outside, far enough to player and not adjacent to an enemy.
                if (map.GetTileAt(pos.X, pos.Y).IsInside)
                    continue;
                if (!m_Rules.IsWalkableFor(actorToSpawn, map, pos.X, pos.Y))
                    continue;
                if (DistanceToPlayer(map, pos) < minDistToPlayer)
                    continue;
                if (IsAdjacentToEnemy(map, pos, actorToSpawn))
                    continue;

                // success!                
                map.PlaceActorAt(actorToSpawn, pos);
                return true;
            }
            while (i <= maxTries);

            // failed.
            return false;
        }

        void SpawnNewUndead(Map map, int day)
        {
            ////////////////
            // Create actor.
            ////////////////
            Actor newUndead = m_TownGenerator.CreateNewUndead(map.LocalTime.TurnCounter);

            ///////////////////
            // Spawn hi level?
            ///////////////////
            if (s_Options.AllowUndeadsEvolution && Rules.HasEvolution(m_Session.GameMode))
            {
                // chances.
                bool doLevelUp = false;
                GameActors.IDs levelupID = (GameActors.IDs)newUndead.Model.ID;
                int levelupChance = Math.Min(75, day * 2); // +2% per day, max 75%. //@@MP - restored to vanilla (Release 5-7)
                if (m_Rules.RollChance(levelupChance)) //@@MP - roll to check if they evolve to stage 2
                {
                    doLevelUp = true;
                    levelupID = NextUndeadEvolution((GameActors.IDs)newUndead.Model.ID);
                    if (m_Rules.RollChance(levelupChance)) //@@MP - roll again to check if they evolve to stage 3
                        levelupID = NextUndeadEvolution(levelupID);
                }

                // restrict some models. //@@MP - expanded to the new types now limited in their evolution timeframes (Release 5-6)
                if (levelupID == GameActors.IDs.UNDEAD_ZOMBIE_MASTER && day < UNDEAD_STAGE2_SLOW_EVOLUTION_MIN_DAY)
                    doLevelUp = false;
                else if (levelupID == GameActors.IDs.UNDEAD_ZOMBIE_LORD && day < UNDEAD_STAGE3_SLOW_EVOLUTION_MIN_DAY)
                    doLevelUp = false;
                else if (levelupID == GameActors.IDs.UNDEAD_MALE_ZOMBIFIED && day < UNDEAD_STAGE2_SLOW_EVOLUTION_MIN_DAY)
                    doLevelUp = false;
                else if (levelupID == GameActors.IDs.UNDEAD_FEMALE_ZOMBIFIED && day < UNDEAD_STAGE2_SLOW_EVOLUTION_MIN_DAY)
                    doLevelUp = false;
                else if (levelupID == GameActors.IDs.UNDEAD_MALE_NEOPHYTE && day < UNDEAD_STAGE3_SLOW_EVOLUTION_MIN_DAY)
                    doLevelUp = false;
                else if (levelupID == GameActors.IDs.UNDEAD_FEMALE_NEOPHYTE && day < UNDEAD_STAGE3_SLOW_EVOLUTION_MIN_DAY)
                    doLevelUp = false;

                // levelup?
                if (doLevelUp)
                {
                    newUndead.Model = GameActors[levelupID];
                }
            }

            ///////////////////
            // Try to spawn it.
            ///////////////////
            SpawnActorOnMapBorder(map, newUndead, SPAWN_DISTANCE_TO_PLAYER, true);
        }

        void SpawnNewSewersUndead(Map map) //@@MP - unused parameter (Release 5-7)
        {
            ////////////////
            // Create actor.
            ////////////////
            Actor newUndead = m_TownGenerator.CreateNewSewersUndead(map.LocalTime.TurnCounter);

            ///////////////////
            // Try to spawn it.
            ///////////////////
            SpawnActorOnMapBorder(map, newUndead, SPAWN_DISTANCE_TO_PLAYER, false);
        }

        void SpawnNewSubwayUndead(Map map) //@@MP - unused parameter (Release 5-7)
        {
            ////////////////
            // Create actor.
            ////////////////
            Actor newUndead = m_TownGenerator.CreateNewSubwayUndead(map.LocalTime.TurnCounter);

            ///////////////////
            // Try to spawn it.
            ///////////////////
            SpawnActorOnMapBorder(map, newUndead, SPAWN_DISTANCE_TO_PLAYER, false);
        }

        void SpawnNewRefugee(Map map)
        {
            ////////////////
            // Create actor.
            ////////////////
            Actor newCivilian = m_TownGenerator.CreateNewRefugee(map.LocalTime.TurnCounter, REFUGEES_WAVE_ITEMS);

            ///////////////////
            // Try to spawn it.
            ///////////////////
            SpawnActorOnMapBorder(map, newCivilian, SPAWN_DISTANCE_TO_PLAYER, true);
        }

        Actor SpawnNewSurvivor(Map map)
        {
            ////////////////
            // Create actor.
            ////////////////
            Actor newSurvivor = m_TownGenerator.CreateNewSurvivor(map.LocalTime.TurnCounter);

            ///////////////////
            // Try to spawn it.
            ///////////////////
            if (SpawnActorOnMapBorder(map, newSurvivor, SPAWN_DISTANCE_TO_PLAYER, true))
                return newSurvivor;
            else
                return null;
        }

        Actor SpawnNewSurvivor(Map map, Point bandPos)
        {
            ////////////////
            // Create actor.
            ////////////////
            Actor newSurvivor = m_TownGenerator.CreateNewSurvivor(map.LocalTime.TurnCounter);

            ///////////////////
            // Try to spawn it.
            ///////////////////
            if (SpawnActorNear(map, newSurvivor, SPAWN_DISTANCE_TO_PLAYER, bandPos, 3))
                return newSurvivor;
            else
                return null;
        }

        Actor SpawnNewNatGuardLeader(Map map)
        {
            ////////////////
            // Create actor.
            ////////////////
            Actor newNatLeader = m_TownGenerator.CreateNewArmyNationalGuard(map.LocalTime.TurnCounter, "Sgt");

            // skills.
            m_TownGenerator.GiveStartingSkillToActor(newNatLeader, Skills.IDs.LEADERSHIP);

            // additional items : z-tracker.
            if (map.LocalTime.Day > NATGUARD_ZTRACKER_DAY)
            {
                newNatLeader.Inventory.AddAll(m_TownGenerator.MakeItemZTracker());
            }

            ///////////////////
            // Try to spawn it.
            ///////////////////
            bool spawned = SpawnActorOnMapBorder(map, newNatLeader, SPAWN_DISTANCE_TO_PLAYER, true);

            // done.
            return spawned ? newNatLeader : null;
        }

        Actor SpawnNewNatGuardTrooper(Map map, Point leaderPos)
        {
            ////////////////
            // Create actor.
            ////////////////
            Actor newNatGuard = m_TownGenerator.CreateNewArmyNationalGuard(map.LocalTime.TurnCounter, "Pvt");

            // additional items : combat knife or grenades.
            if (m_Rules.RollChance(50))
                newNatGuard.Inventory.AddAll(m_TownGenerator.MakeItemCombatKnife());
            else
                newNatGuard.Inventory.AddAll(m_TownGenerator.MakeItemGrenade());

            ///////////////////
            // Try to spawn it.
            ///////////////////
            bool spawned = SpawnActorNear(map, newNatGuard, SPAWN_DISTANCE_TO_PLAYER, leaderPos, 3);

            // done.
            return spawned ? newNatGuard : null;
        }

        Actor SpawnNewBikerLeader(Map map, GameGangs.IDs gangId)
        {
            ////////////////
            // Create actor.
            ////////////////
            Actor newBikerLeader = m_TownGenerator.CreateNewBikerMan(map.LocalTime.TurnCounter, gangId);

            // skills.
            m_TownGenerator.GiveStartingSkillToActor(newBikerLeader, Skills.IDs.LEADERSHIP);
            m_TownGenerator.GiveStartingSkillToActor(newBikerLeader, Skills.IDs.TOUGH);
            m_TownGenerator.GiveStartingSkillToActor(newBikerLeader, Skills.IDs.TOUGH);
            m_TownGenerator.GiveStartingSkillToActor(newBikerLeader, Skills.IDs.TOUGH);
            m_TownGenerator.GiveStartingSkillToActor(newBikerLeader, Skills.IDs.STRONG);
            m_TownGenerator.GiveStartingSkillToActor(newBikerLeader, Skills.IDs.STRONG);
            m_TownGenerator.GiveStartingSkillToActor(newBikerLeader, Skills.IDs.STRONG);

            ///////////////////
            // Try to spawn it.
            ///////////////////
            bool spawned = SpawnActorOnMapBorder(map, newBikerLeader, SPAWN_DISTANCE_TO_PLAYER, true);

            // done.
            return spawned ? newBikerLeader : null;
        }

        Actor SpawnNewBiker(Map map, GameGangs.IDs gangId, Point leaderPos)
        {
            ////////////////
            // Create actor.
            ////////////////
            Actor newBiker = m_TownGenerator.CreateNewBikerMan(map.LocalTime.TurnCounter, gangId);

            // skils.
            m_TownGenerator.GiveStartingSkillToActor(newBiker, Skills.IDs.TOUGH);
            m_TownGenerator.GiveStartingSkillToActor(newBiker, Skills.IDs.STRONG);

            ///////////////////
            // Try to spawn it.
            ///////////////////
            bool spawned = SpawnActorNear(map, newBiker, SPAWN_DISTANCE_TO_PLAYER, leaderPos, 3);

            // done.
            return spawned ? newBiker : null;
        }

        Actor SpawnNewGangstaLeader(Map map, GameGangs.IDs gangId)
        {
            ////////////////
            // Create actor.
            ////////////////
            Actor newGangstaLeader = m_TownGenerator.CreateNewGangstaMan(map.LocalTime.TurnCounter, gangId);

            // skills.
            m_TownGenerator.GiveStartingSkillToActor(newGangstaLeader, Skills.IDs.LEADERSHIP);
            m_TownGenerator.GiveStartingSkillToActor(newGangstaLeader, Skills.IDs.AGILE);
            m_TownGenerator.GiveStartingSkillToActor(newGangstaLeader, Skills.IDs.AGILE);
            m_TownGenerator.GiveStartingSkillToActor(newGangstaLeader, Skills.IDs.AGILE);
            m_TownGenerator.GiveStartingSkillToActor(newGangstaLeader, Skills.IDs.FIREARMS);

            ///////////////////
            // Try to spawn it.
            ///////////////////
            bool spawned = SpawnActorOnMapBorder(map, newGangstaLeader, SPAWN_DISTANCE_TO_PLAYER, true);

            // done.
            return spawned ? newGangstaLeader : null;
        }

        Actor SpawnNewGangsta(Map map, GameGangs.IDs gangId, Point leaderPos)
        {
            ////////////////
            // Create actor.
            ////////////////
            Actor newGangsta = m_TownGenerator.CreateNewGangstaMan(map.LocalTime.TurnCounter, gangId);

            // skils.
            m_TownGenerator.GiveStartingSkillToActor(newGangsta, Skills.IDs.AGILE);

            ///////////////////
            // Try to spawn it.
            ///////////////////
            bool spawned = SpawnActorNear(map, newGangsta, SPAWN_DISTANCE_TO_PLAYER, leaderPos, 3);

            // done.
            return spawned ? newGangsta : null;
        }

        Actor SpawnNewBlackOpsLeader(Map map)
        {
            ////////////////
            // Create actor.
            ////////////////
            Actor newBOLeader = m_TownGenerator.CreateNewBlackOps(map.LocalTime.TurnCounter, "Officer");

            // skills.
            m_TownGenerator.GiveStartingSkillToActor(newBOLeader, Skills.IDs.LEADERSHIP);
            m_TownGenerator.GiveStartingSkillToActor(newBOLeader, Skills.IDs.AGILE);
            m_TownGenerator.GiveStartingSkillToActor(newBOLeader, Skills.IDs.AGILE);
            m_TownGenerator.GiveStartingSkillToActor(newBOLeader, Skills.IDs.AGILE);
            m_TownGenerator.GiveStartingSkillToActor(newBOLeader, Skills.IDs.FIREARMS);
            m_TownGenerator.GiveStartingSkillToActor(newBOLeader, Skills.IDs.FIREARMS);
            m_TownGenerator.GiveStartingSkillToActor(newBOLeader, Skills.IDs.FIREARMS);
            m_TownGenerator.GiveStartingSkillToActor(newBOLeader, Skills.IDs.TOUGH);
            m_TownGenerator.GiveStartingSkillToActor(newBOLeader, Skills.IDs.TOUGH);
            m_TownGenerator.GiveStartingSkillToActor(newBOLeader, Skills.IDs.TOUGH);

            ///////////////////
            // Try to spawn it.
            ///////////////////
            bool spawned = SpawnActorOnMapBorder(map, newBOLeader, SPAWN_DISTANCE_TO_PLAYER, true);

            // done.
            return spawned ? newBOLeader : null;
        }

        Actor SpawnNewBlackOpsTrooper(Map map, Point leaderPos)
        {
            ////////////////
            // Create actor.
            ////////////////
            Actor newBO = m_TownGenerator.CreateNewBlackOps(map.LocalTime.TurnCounter, "Agent");

            // skills.
            m_TownGenerator.GiveStartingSkillToActor(newBO, Skills.IDs.AGILE);
            m_TownGenerator.GiveStartingSkillToActor(newBO, Skills.IDs.FIREARMS);
            m_TownGenerator.GiveStartingSkillToActor(newBO, Skills.IDs.TOUGH);

            ///////////////////
            // Try to spawn it.
            ///////////////////
            bool spawned = SpawnActorNear(map, newBO, SPAWN_DISTANCE_TO_PLAYER, leaderPos, 3);

            // done.
            return spawned ? newBO : null;
        }

        Actor SpawnNewCHARScientistLeader(Map map) //@@MP (Release 8-1)
        {
            ////////////////
            // Create actor.
            ////////////////
            Actor newCHARScientistLeader = m_TownGenerator.CreateNewCHARScientist(map.LocalTime.TurnCounter);

            // skills.
            m_TownGenerator.GiveStartingSkillToActor(newCHARScientistLeader, Skills.IDs.LEADERSHIP);

            ///////////////////
            // Try to spawn it.
            ///////////////////
            bool spawned = SpawnActorOnMapBorder(map, newCHARScientistLeader, SPAWN_DISTANCE_TO_PLAYER, true);

            // done.
            return spawned ? newCHARScientistLeader : null;
        }

        Actor SpawnNewCHARScientist(Map map, Point leaderPos) //@@MP (Release 8-1)
        {
            ////////////////
            // Create actor.
            ////////////////
            Actor newCHARScientist = m_TownGenerator.CreateNewCHARScientist(map.LocalTime.TurnCounter);

            // skills.
            m_TownGenerator.GiveStartingSkillToActor(newCHARScientist, Skills.IDs.LEADERSHIP);

            ///////////////////
            // Try to spawn it.
            ///////////////////
            bool spawned = SpawnActorNear(map, newCHARScientist, SPAWN_DISTANCE_TO_PLAYER, leaderPos, 4);

            // done.
            return spawned ? newCHARScientist : null;
        }

        Actor SpawnNewCHARGuard(Map map, Point leaderPos) //@@MP (Release 8-1)
        {
            ////////////////
            // Create actor.
            ////////////////
            Actor newCHARGuard = m_TownGenerator.CreateNewCHARGuard(map.LocalTime.TurnCounter);

            // items.
            newCHARGuard.Inventory.AddAll(m_TownGenerator.MakeItemTacticalShotgun());
            newCHARGuard.Inventory.AddAll(m_TownGenerator.MakeItemShotgunAmmo());
            newCHARGuard.Inventory.AddAll(m_TownGenerator.MakeItemShotgunAmmo());
            newCHARGuard.Inventory.AddAll(m_TownGenerator.MakeItemShotgunAmmo());

            // skills.
            m_TownGenerator.GiveStartingSkillToActor(newCHARGuard, Skills.IDs.AGILE);
            m_TownGenerator.GiveStartingSkillToActor(newCHARGuard, Skills.IDs.FIREARMS);
            m_TownGenerator.GiveStartingSkillToActor(newCHARGuard, Skills.IDs.TOUGH);

            ///////////////////
            // Try to spawn it.
            ///////////////////
            bool spawned = SpawnActorNear(map, newCHARGuard, SPAWN_DISTANCE_TO_PLAYER, leaderPos, 4);

            // done.
            return spawned ? newCHARGuard : null;
        }

        Actor SpawnNewFeralDog(Map map) //@@MP (Release 7-3)
        {
            ////////////////
            // Create actor.
            ////////////////
            Actor newDog = m_TownGenerator.CreateNewFeralDog(map.LocalTime.TurnCounter);

            ///////////////////
            // Try to spawn it.
            ///////////////////
            if (SpawnActorOnMapBorder(map, newDog, SPAWN_DISTANCE_TO_PLAYER, true))
                return newDog;
            else
                return null;
        }

        /// <summary>
        /// Unused and untested
        /// </summary>
        /// <param name="map"></param>
        /// <returns></returns>
        Actor SpawnNewRabbit(Map map) //@@MP (Release 7-6)
        {
            ////////////////
            // Find a park to spawn at
            ////////////////
            Rectangle? parkRect = null;
            foreach (Zone zone in map.Zones)
            {
                if (zone.Name.Contains("Park"))
                {
                    parkRect = zone.Bounds;
                    break; //just get the first park. that'll do
                }
            }
            if (parkRect == null)
                return null; //no parks on this map
            else
            {
                ////////////////
                // Create actor.
                ////////////////
                Actor newRabbit = m_TownGenerator.CreateNewRabbit(map.LocalTime.TurnCounter);

                ///////////////////
                // Try to spawn it.
                ///////////////////

                //get park center point
                int farmHeightHalved = (int)(parkRect.Value.Height / 2);
                int farmWidthHalved = (int)(parkRect.Value.Width / 2);
                Point parkCenterPoint = new Point(parkRect.Value.Left + farmWidthHalved, parkRect.Value.Top + farmHeightHalved);

                if (SpawnActorNear(map, newRabbit, SPAWN_DISTANCE_TO_PLAYER, parkCenterPoint, SPAWN_DISTANCE_TO_PLAYER))
                    return newRabbit;
                else
                    return null;
            }
        }

        /// <summary>
        /// Unused and untested
        /// </summary>
        /// <param name="map"></param>
        /// <returns></returns>
        Actor SpawnNewChicken(Map map) //@@MP (Release 7-6)
        {
            ////////////////
            // Find a farm to spawn at
            ////////////////
            Rectangle? farmRect = null;
            foreach (Zone zone in map.Zones)
            {
                if (zone.Name.Contains("Farm"))
                {
                    farmRect = zone.Bounds;
                    break; //just get the first farm. that'll do
                }
            }
            if (farmRect == null)
                return null; //no farms on this map
            else
            {
                ////////////////
                // Create actor.
                ////////////////
                Actor newChicken = m_TownGenerator.CreateNewChicken(map.LocalTime.TurnCounter);

                ///////////////////
                // Try to spawn it.
                ///////////////////

                //get farm center point
                int farmHeightHalved = (int)(farmRect.Value.Height / 2);
                int farmWidthHalved = (int)(farmRect.Value.Width / 2);
                Point farmCenterPoint = new Point(farmRect.Value.Left + farmWidthHalved, farmRect.Value.Top + farmHeightHalved);

                if (SpawnActorNear(map, newChicken, SPAWN_DISTANCE_TO_PLAYER, farmCenterPoint, SPAWN_DISTANCE_TO_PLAYER))
                    return newChicken;
                else
                    return null;
            }
        }
#endregion
#endregion

#region MISC & OTHER
#region -INTERFACE INTERUPTIONS
#region --Advisor Hints
        void HandleAdvisor() //@@MP - unused parameter (Release 5-7)
        {
            ///////////////////////////////
            // If all hints given, say so.
            ///////////////////////////////
            if (s_Hints.HasAdvisorGivenAllHints())
            {
                ShowAdvisorMessage(
                    "YOU KNOW THE BASICS!",
                    new string[] {
                        "The Advisor has given you all the hints.",
                        "You can disable the advisor in the options.",
                        "Read the manual or discover the rest of the game by yourself.",
                        "Good luck and have fun!",
                        String.Format("To REDEFINE THE KEYS : <{0}>.", s_KeyBindings.GetFriendlyFormat(PlayerCommand.KEYBINDING_MODE).ToString()),
                        String.Format("To CHANGE OPTIONS    : <{0}>.", s_KeyBindings.GetFriendlyFormat(PlayerCommand.OPTIONS_MODE).ToString()),
                        String.Format("To READ THE MANUAL   : <{0}>.", s_KeyBindings.GetFriendlyFormat(PlayerCommand.HELP_MODE).ToString())
                    });
                return;
            }

            /////////////////////////////////
            // Show the first appliable hint.
            /////////////////////////////////
            for (int i = (int)AdvisorHint._FIRST; i < (int)AdvisorHint._COUNT; i++)
            {
                if (s_Hints.IsAdvisorHintGiven((AdvisorHint)i))
                    continue;
                if (IsAdvisorHintAppliable((AdvisorHint)i))
                {
                    AdvisorGiveHint((AdvisorHint)i);
                    return;
                }
            }

            // no hint.
            ShowAdvisorMessage("No hint available.",
                new string[] {
                    "The Advisor has no new hint for you in this situation.",
                    "You will see a popup when it has something to say.",
                    String.Format("To REDEFINE THE KEYS : <{0}>.", s_KeyBindings.GetFriendlyFormat(PlayerCommand.KEYBINDING_MODE).ToString()),
                    String.Format("To CHANGE OPTIONS    : <{0}>.", s_KeyBindings.GetFriendlyFormat(PlayerCommand.OPTIONS_MODE).ToString()),
                    String.Format("To READ THE MANUAL   : <{0}>.", s_KeyBindings.GetFriendlyFormat(PlayerCommand.HELP_MODE).ToString())
                });
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns>-1 if none</returns>
        int GetAdvisorFirstAvailableHint() // alpha10
        {
            for (int i = (int)AdvisorHint._FIRST; i < (int)AdvisorHint._COUNT; i++)
            {
                if (s_Hints.IsAdvisorHintGiven((AdvisorHint)i))
                    continue;
                if (IsAdvisorHintAppliable((AdvisorHint)i))
                    return i;
            }

            return -1;
        }

        void AdvisorGiveHint(AdvisorHint hint)
        {
            ///////////////////////////
            // Show hint to the player
            ///////////////////////////
            string title;
            string[] body;

            GetAdvisorHintText(hint, out title, out body);
            //Logger.WriteLine(Logger.Stage.RUN_MAIN, title); //for troubleshooting
            ShowAdvisorMessage(title, body);

            /////////////////
            // Mark as given
            /////////////////
            s_Hints.SetAdvisorHintAsGiven(hint);

            ////////////////
            // Save status.
            ////////////////
            SaveHints();
        }

        bool IsAdvisorHintAppliable(AdvisorHint hint)
        {
            Map map = m_Player.Location.Map;
            Point pos = m_Player.Location.Position;

            switch (hint)
            {
                case AdvisorHint.ABSOLUTE_DARKNESS: //@@MP (Release 6-2)
                    return (m_Rules.ActorFOV(m_Player, m_Player.Location.Map.LocalTime, m_Session.World.Weather) == 0);

                case AdvisorHint.ACTOR_MELEE:   // adjacent to an enemy.
                    return IsAdjacentToEnemy(map, pos, m_Player);

                case AdvisorHint.BANK_SAFE: //@@MP (Release 6-5)
                    {
                        foreach (Direction d in Direction.COMPASS)
                        {
                            Point pt = pos + d;
                            if (!map.IsInBounds(pt))
                                continue;

                            MapObject mapObj = map.GetMapObjectAt(pt);
                            if (mapObj != null && (mapObj.ImageID == GameImages.OBJ_BANK_SAFE_OPEN))
                                return !m_Player.Model.Abilities.IsUndead;
                        }
                        return false;
                    };

                case AdvisorHint.BARRICADE:  // barricading.
                    return map.HasAnyAdjacentInMap(pos, (pt) =>
                    {
                        DoorWindow door = map.GetMapObjectAt(pt) as DoorWindow;
                        if (door == null)
                            return false;
                        return m_Rules.CanActorBarricadeDoor(m_Player, door, m_Session.World.Weather); //@@MP - added weather parameter (Release 6-2)
                    });

                case AdvisorHint.BUILD_FORTIFICATION: // building fortifications.
                    return map.HasAnyAdjacentInMap(pos, (pt) =>
                    {
                        return m_Rules.CanActorBuildFortification(m_Player, pt, false, m_Session.World.Weather); //@@MP - added weather parameter (Release 6-2)
                    });

                case AdvisorHint.CELLPHONES:
                    return m_Player.Inventory.GetFirstByModel(GameItems.CELL_PHONE) != null;

                case AdvisorHint.CHANGE_CLOTHING: //@@MP (Release 7-6)
                    foreach (Direction d in Direction.COMPASS)
                    {
                        Point pt = pos + d;
                        if (!map.IsInBounds(pt))
                            continue;

                        MapObject obj = map.GetMapObjectAt(pt);
                        if (obj == null)
                            return false;
                        else if (obj.ImageID == GameImages.OBJ_CLOTHES_WALL1 || obj.ImageID == GameImages.OBJ_CLOTHES_WALL2 || obj.ImageID == GameImages.OBJ_SHOES_WALL)
                            return true;
                    }
                    return false;

                case AdvisorHint.CHANGE_HAIRSTYLE: //@@MP (Release 7-6)
                    foreach (Direction d in Direction.COMPASS)
                    {
                        Point pt = pos + d;
                        if (!map.IsInBounds(pt))
                            continue;

                        MapObject obj = map.GetMapObjectAt(pt);
                        if (obj == null)
                            return false;
                        else if (obj.ImageID == GameImages.OBJ_WIGS_DISPLAY1 || obj.ImageID == GameImages.OBJ_WIGS_DISPLAY2 || obj.ImageID == GameImages.OBJ_WIGS_DISPLAY3)
                            return true;
                    }
                    return false;

                case AdvisorHint.CITY_INFORMATION:  // once the player is by an exit, after that hint has fired first. or once 10pm hits
                    {
                        if (s_Hints.IsAdvisorHintGiven(AdvisorHint.EXIT_LEAVING_DISTRICT) || map.LocalTime.Hour >= 10)
                        {
                            foreach (Direction d in Direction.COMPASS)
                            {
                                Point pt = pos + d;
                                if (map.IsInBounds(pt))
                                    continue;
                                if (map.GetExitAt(pt) != null)
                                    return true;
                            }
                        }
                        return false;
                    }

                case AdvisorHint.CORPSE: // alpha10 merge corpse hints
                    return !m_Player.Model.Abilities.IsUndead && map.GetCorpsesAt(pos) != null;

                case AdvisorHint.CORPSE_EAT:
                    return m_Player.Model.Abilities.IsUndead && map.GetCorpsesAt(pos) != null;

                case AdvisorHint.DOORWINDOW_OPEN:   // can open an adj door/window.
                    return map.HasAnyAdjacentInMap(pos, (pt) =>
                    {
                        DoorWindow door = map.GetMapObjectAt(pt) as DoorWindow;
                        if (door == null)
                            return false;
                        return m_Rules.IsOpenableFor(m_Player, door);
                    });

                /*case AdvisorHint.DOORWINDOW_CLOSE:   // can close an open door/window.
                    return map.HasAnyAdjacentInMap(pos, (pt) =>
                    {
                        DoorWindow door = map.GetMapObjectAt(pt) as DoorWindow;
                        if (door == null)
                            return false;
                        return m_Rules.IsClosableFor(m_Player, door);
                    });
                    return false;*/

                case AdvisorHint.EXIT_STAIRS_LADDERS:  // using stairs, ladders.
                    return map.GetExitAt(pos) != null;

                case AdvisorHint.EXIT_LEAVING_DISTRICT: // leaving the district.
                    {
                        foreach (Direction d in Direction.COMPASS)
                        {
                            Point pt = pos + d;
                            if (map.IsInBounds(pt))
                                continue;
                            if (map.GetExitAt(pt) != null)
                                return true;
                        }
                        return false;
                    }

                case AdvisorHint.FISHING: //@@MP (Release 7-6)
                    {
                        Inventory inv = m_Player.Inventory;
                        if (inv == null || inv.IsEmpty)
                            return false;

                        foreach (Item it in inv.Items)
                        {
                            if (it.Model == GameItems.FISHING_ROD)
                                return true;
                        }

                        return false;
                    }

                case AdvisorHint.INCAPACITATION: //@@MP (Release 7-2)
                    {
                        Inventory inv = m_Player.Inventory;
                        if (inv == null || inv.IsEmpty)
                            return false;

                        foreach (Item it in inv.Items)
                        {
                            if (it.Model == GameItems.FLASHBANG || it.Model == GameItems.STUN_GUN)
                                return true;
                        }

                        return false;
                    }

                case AdvisorHint.FLASHLIGHT:
                    {
                        if (map.LocalTime.TurnCounter < 3)  // don't spam at turn 0.
                            return false;
                        return m_Player.Inventory.HasItemOfType(typeof(ItemLight));
                    }

                case AdvisorHint.FOOD_POISONING:  // player is unwell, what to do         //@@MP (Release 7-6)
                    return m_Player.IsFoodPoisoned;

                case AdvisorHint.RAW_MEAT:                //@@MP (Release 7-6)
                    {
                        Inventory inv = m_Player.Inventory;
                        if (inv == null || inv.IsEmpty)
                            return false;
                        foreach (Item it in inv.Items)
                        {
                            ItemFood food = it as ItemFood;
                            if (food != null && food.CanCauseFoodPoisoning)
                                return true;
                        }
                        return false;
                    }

                case AdvisorHint.GAME_SAVE_LOAD:    // saving/loading. wait a bit...
                    return map.LocalTime.Hour >= 9;

                case AdvisorHint.GRENADE:
                    {
                        Inventory inv = m_Player.Inventory;
                        if (inv == null || inv.IsEmpty)
                            return false;
                        return inv.HasItemOfType(typeof(ItemGrenade));
                    }

                case AdvisorHint.ITEM_GRAB_CONTAINER: // can take an item from an adjacent container.
                    return map.HasAnyAdjacentInMap(pos, (pt) => m_Rules.CanActorGetItemFromContainer(m_Player, pt));

                case AdvisorHint.ITEM_GRAB_FLOOR:   // can take an item from the floor.
                    {
                        Inventory invThere = map.GetItemsAt(pos);
                        if (invThere == null)
                            return false;
                        foreach (Item it in invThere.Items)
                            if (m_Rules.CanActorGetItem(m_Player, it))
                                return true;
                        return false;
                    }

                case AdvisorHint.ITEM_EQUIP:  // equip an item.
                    {
                        if (map.LocalTime.TurnCounter < 3)  // don't spam at turn 0.
                            return false;

                        Inventory inv = m_Player.Inventory;
                        if (inv == null || inv.IsEmpty)
                            return false;
                        bool canEquip = false;
                        foreach (Item it in inv.Items)
                        {
                            if (it.IsEquipped)
                            {
                                s_Hints.SetAdvisorHintAsGiven(AdvisorHint.EXIT_LEAVING_DISTRICT);
                                return false;
                            }
                            else if (m_Rules.CanActorEquipItem(m_Player, it))
                                canEquip = true;
                        }
                        if (canEquip)
                            return true;
                        else
                            return false;
                    }

                /*case AdvisorHint.ITEM_UNEQUIP:  // unequip an item.
                    {
                        Inventory inv = m_Player.Inventory;
                        if (inv == null || inv.IsEmpty)
                            return false;
                        foreach (Item it in inv.Items)
                            if (m_Rules.CanActorUnequipItem(m_Player, it))
                                return true;
                        return false;
                    }
                    return false;*/

                case AdvisorHint.ITEM_DROP: // dropping an item.
                    {
                        if (map.LocalTime.TurnCounter < 6)
                            return false;

                        Inventory inv = m_Player.Inventory;
                        if (inv == null || inv.IsEmpty)
                            return false;
                        foreach (Item it in inv.Items)
                            if (m_Rules.CanActorDropItem(m_Player, it))
                                return true;
                        return false;
                    }

                case AdvisorHint.ITEM_TYPE_BARRICADING: // barricading material.
                    {
                        Inventory inv = m_Player.Inventory;
                        if (inv == null || inv.IsEmpty)
                            return false;
                        return inv.HasItemOfType(typeof(ItemBarricadeMaterial));
                    }

                case AdvisorHint.ITEM_USE: // using an item.
                    {
                        if (map.LocalTime.TurnCounter < 25)
                            return false;

                        Inventory inv = m_Player.Inventory;
                        if (inv == null || inv.IsEmpty)
                            return false;
                        foreach (Item it in inv.Items)
                            if (m_Rules.CanActorUseItem(m_Player, it))
                                return true;
                        return false;
                    }

                case AdvisorHint.KEYS_OPTIONS:  // redefining keys & options.
                    return map.LocalTime.TurnCounter >= 20;

                case AdvisorHint.LEADING_CAN_RECRUIT:   // can recruit follower.
                    return map.HasAnyAdjacentInMap(pos, (pt) =>
                    {
                        Actor other = map.GetActorAt(pt);
                        if (other == null)
                            return false;
                        return m_Rules.CanActorTakeLead(m_Player, other);
                    });

                case AdvisorHint.LEADING_GIVE_ORDERS:   // give orders to followers.
                    return m_Player.CountFollowers > 0;

                case AdvisorHint.LEADING_NEED_SKILL:    // could recruit...
                    {
                        if (map.LocalTime.Hour >= 9)
                            return false;

                        return map.HasAnyAdjacentInMap(pos, (pt) =>
                        {
                            Actor other = map.GetActorAt(pt);
                            if (other == null)
                                return false;
                            return !m_Rules.AreEnemies(m_Player, other);
                        });
                    }

                /*case AdvisorHint.LEADING_SWITCH_PLACE:  // switch place.
                    return map.HasAnyAdjacentInMap(pos, (pt) =>
                    {
                        Actor other = map.GetActorAt(pt);
                        if (other == null)
                            return false;
                        return m_Rules.CanActorSwitchPlaceWith(m_Player, other);
                    });
                    return false;*/

                case AdvisorHint.MAKE_FIRE_FOR_COOKING:     //@@MP (Release 7-6)
                    {
                        Inventory inv = m_Player.Inventory;
                        if (inv == null || inv.IsEmpty)
                            return false;

                        foreach (Item it in inv.Items)
                        {
                            if (it.Model == GameItems.MATCHES)
                                return true;
                        }

                        return false;
                    }

                case AdvisorHint.MAKE_MOLOTOV: //@@MP - when a bottle of liquor is picked up (Release 4)
                    {
                        Inventory inv = m_Player.Inventory;
                        if (inv == null || inv.IsEmpty)
                            return false;
                        if (inv.HasItemMatching((it) => it.Model == GameItems.LIQUOR_AMBER))
                            return true; //@MP (Release 5-5)
                        else if (inv.HasItemMatching((it) => it.Model == GameItems.LIQUOR_CLEAR))
                            return true; //@MP (Release 5-5)
                        else
                            return false;
                    }

                case AdvisorHint.MINIGUN: //@@MP (Release 7-6)
                    {
                        Inventory inv = m_Player.Inventory;
                        if (inv == null || inv.IsEmpty)
                            return false;

                        foreach (Item it in inv.Items)
                        {
                            if (it.Model == GameItems.MINIGUN)
                                return true;
                        }

                        return false;
                    }

                case AdvisorHint.MOUSE_LOOK:    // always!
                    return true;

                case AdvisorHint.MOVE_BASIC:    // always!
                    return true;

                case AdvisorHint.MOVE_JUMP:  // can jump.
                    {
                        if (map.LocalTime.TurnCounter < 3)
                            return false;

                        return !m_Rules.IsActorTired(m_Player) &&
                            map.HasAnyAdjacentInMap(pos, (pt) =>
                            {
                                MapObject obj = map.GetMapObjectAt(pt);
                                if (obj == null)
                                    return false;
                                return obj.IsJumpable;
                            });
                    }

                /*case AdvisorHint.MOVE_RUN:   // running.
                    return map.LocalTime.TurnCounter >= 5 && m_Rules.CanActorRun(m_Player);  // don't spam at turn 0.*/

                case AdvisorHint.MOVE_RESTING: // resting.
                    return m_Rules.IsActorTired(m_Player);

                case AdvisorHint.NIGHT: // night effects, wait a bit.
                    return map.LocalTime.TurnCounter >= 1 * WorldTime.TURNS_PER_HOUR;

                case AdvisorHint.NPC_TRADE: // trading.
                    {
                        if (map.LocalTime.Hour >= 8)
                            return false;

                        return map.HasAnyAdjacentInMap(pos, (pt) =>
                        {
                            Actor other = map.GetActorAt(pt);
                            if (other == null)
                                return false;
                            return m_Rules.CanActorInitiateTradeWith(m_Player, other);
                        });
                    }

                case AdvisorHint.NPC_GIVING_ITEM: // giving items.
                    {
                        return m_Player.CountFollowers > 0; //@@MP (Release 7-6)

                        /*Inventory inv = m_Player.Inventory;
                        if (inv == null || inv.IsEmpty)
                            return false;
                        return map.HasAnyAdjacentInMap(pos, (pt) =>
                        {
                            Actor other = map.GetActorAt(pt);
                            if (other == null)
                                return false;
                            return !m_Rules.AreEnemies(m_Player, other);
                        });*/
                    }

                case AdvisorHint.NPC_SHOUTING:  // shouting.
                    return map.HasAnyAdjacentInMap(pos, (pt) =>
                    {
                        Actor other = map.GetActorAt(pt);
                        if (other == null)
                            return false;
                        return other.IsSleeping && !m_Rules.AreEnemies(m_Player, other);
                    });

                case AdvisorHint.OBJECT_BREAK: // breaking around.
                    return map.HasAnyAdjacentInMap(pos, (pt) =>
                    {
                        MapObject obj = map.GetMapObjectAt(pt);
                        if (obj == null)
                            return false;
                        return m_Rules.IsBreakableFor(m_Player, obj);
                    });

                case AdvisorHint.OBJECT_PUSH:   // pushable around.
                    return map.HasAnyAdjacentInMap(pos, (pt) =>
                    {
                        MapObject obj = map.GetMapObjectAt(pt);
                        if (obj == null)
                            return false;
                        return m_Rules.CanActorPush(m_Player, obj);
                    });

                case AdvisorHint.ON_FIRE:  // player is on fire, how to extinguish         //@@MP (Release 7-6)
                    return m_Player.IsOnFire;

                case AdvisorHint.PLANT_SEEDS: //@@MP - when seeds, shovel or pickaxe is picked up (Release 5-5)
                    {
                        Inventory inv = m_Player.Inventory;
                        if (inv == null || inv.IsEmpty)
                            return false;

                        foreach (Item it in inv.Items)
                        {
                            if (it.Model == GameItems.VEGETABLE_SEEDS || it.Model == GameItems.SHORT_SHOVEL || it.Model == GameItems.SHOVEL || it.Model == GameItems.PICKAXE)
                                return true;
                        }

                        return false;
                    }

                case AdvisorHint.RAIN:  // rainy weather, wait a bit.
                    return m_Rules.IsWeatherRain(m_Session.World.Weather) && map.LocalTime.TurnCounter >= 45;

                case AdvisorHint.SIPHON_FUEL: //@@MP (Release 7-1)
                    {
                        Inventory inv = m_Player.Inventory;
                        if (inv == null || inv.IsEmpty)
                            return false;

                        foreach (Item it in inv.Items)
                        {
                            if (it.Model == GameItems.SIPHON_KIT || it.Model == GameItems.CHAINSAW || it.Model == GameItems.AMMO_FUEL || it.Model == GameItems.FLAMETHROWER)
                                return true;
                        }

                        return false;
                    }

                case AdvisorHint.SMG: //@@MP (Release 7-6)
                    {
                        Inventory inv = m_Player.Inventory;
                        if (inv == null || inv.IsEmpty)
                            return false;

                        foreach (Item it in inv.Items)
                        {
                            if (it.Model == GameItems.SMG)
                                return true;
                        }

                        return false;
                    }

                case AdvisorHint.SMOKE_GRENADE: //@@MP (Release 7-2)
                    {
                        Inventory inv = m_Player.Inventory;
                        if (inv == null || inv.IsEmpty)
                            return false;

                        foreach (Item it in inv.Items)
                        {
                            if (it.Model == GameItems.SMOKE_GRENADE)
                                return true;
                        }

                        return false;
                    }

                case AdvisorHint.SPRAYS_PAINT:    // using spraypaint.
                    return m_Player.Inventory.HasItemOfType(typeof(ItemSprayPaint));

                case AdvisorHint.SPRAYS_SCENT:    // using scent sprays.
                    return m_Player.Inventory.HasItemOfType(typeof(ItemSprayScent));

                case AdvisorHint.STATE_HUNGRY:
                    return m_Rules.IsActorHungry(m_Player);

                case AdvisorHint.STATE_SLEEPY:
                    return m_Rules.IsActorSleepy(m_Player);

                case AdvisorHint.WEAPON_FIRE: // can fire a weapon.
                    {
                        ItemRangedWeapon rw = m_Player.GetEquippedWeapon() as ItemRangedWeapon;
                        if (rw == null)
                            return false;
                        return rw.Ammo >= 0;
                    }

                case AdvisorHint.WEAPON_RELOAD: // reloading a weapon.
                    {
                        ItemRangedWeapon rw = m_Player.GetEquippedWeapon() as ItemRangedWeapon;
                        if (rw == null)
                            return false;
                        Inventory inv = m_Player.Inventory;
                        if (inv == null || inv.IsEmpty)
                            return false;
                        foreach (Item it in inv.Items)
                            if (it is ItemAmmo && m_Rules.CanActorUseItem(m_Player, it))
                                return true;
                        return false;
                    }

                case AdvisorHint.SANITY:  // alpha10
                    return m_Player.Sanity < 0.80f * m_Rules.ActorMaxSanity(m_Player);

                case AdvisorHint.INFECTION: // alpha10
                    return m_Player.Infection > 0;

                case AdvisorHint.TRAPS: // alpha10
                    return m_Player.Inventory.HasItemOfType(typeof(ItemTrap));

                default:
                    throw new ArgumentOutOfRangeException("hint", "unhandled hint trigger");
                    //return false;
            }
        }

        static void GetAdvisorHintText(AdvisorHint hint, out string title, out string[] body) //@@MP - made static (Release 5-7)
        {
            switch (hint)
            {
                case AdvisorHint.ABSOLUTE_DARKNESS: //@@MP (Release 6-2)
                    title = "ABSOLUTE DARKNESS";
                    body = new string[] {
                        "You are currently in absolute darkness, and cannot see around you.",
                        "Anything may be lurking nearby, and you won't see it coming.",
                        "You cannot barricade doors, build fortifications, or read books without light.",
                        "You should try to find a source of light, such as a flashlight."
                    };
                    break;

                case AdvisorHint.ACTOR_MELEE:
                    title = "ATTACK AN ENEMY IN MELEE";
                    body = new string[] {
                            "You are next to an enemy.",
                            "To ATTACK him, try to MOVE on him."};
                    break;

                case AdvisorHint.BANK_SAFE: //@@MP (Release 6-5)
                    title = "STORE ITEMS IN BANK SAFE";
                    body = new string[] {
                            "You are next to an open bank safe.",
                            "To securely store items, move onto the safe and drop them.",
                            "An icon will then highlight that safe, indicating that you own it.",
                            "No one else will be able to take your items from the safe once you own it."};
                    break;

                case AdvisorHint.BARRICADE:
                    title = "BARRICADING A DOOR/WINDOW";
                    body = new string[] {
                            "You can barricade an adjacent door or window.",
                            "Barricading uses material such as planks.",
                            String.Format("To BARRICADE : <{0}>.", s_KeyBindings.GetFriendlyFormat(PlayerCommand.BUILD_MODE).ToString())
                        };
                    break;

                case AdvisorHint.BUILD_FORTIFICATION:
                    title = "BUILDING FORTIFICATIONS";
                    body = new string[] {
                            "You can now build fortifications thanks to the Carpentry skill.",
                            "You will need enough barricading materials.",
                            String.Format("To BUILD FORTIFICATIONS : <{0}>.", s_KeyBindings.GetFriendlyFormat(PlayerCommand.BUILD_MODE).ToString()),
                        };
                    break;

                case AdvisorHint.CELLPHONES:
                    title = "CELLPHONES";
                    body = new string[] {
                            "You have found a cellphone.",
                            "Cellphones are useful to keep in contact with your follower(s).",
                            "You and your follower(s) must have a cellphone equipped.",
                            "You can recharge cellphones at power generators."
                        };
                    break;

                case AdvisorHint.CHANGE_CLOTHING:
                    title = "CHANGE CLOTHING";
                    body = new string[] {
                            "You are next to racks of clothes and shoes.",
                            "Bump into them to get them option to change outfit if you wish."
                        };
                    break;

                case AdvisorHint.CHANGE_HAIRSTYLE:
                    title = "CHANGE HAIRSTYLE";
                    body = new string[] {
                            "You are next to a display table.",
                            "Bump into it to get them option to change hairstyle if you wish."
                        };
                    break;

                case AdvisorHint.CITY_INFORMATION:
                    title = "CITY INFORMATION";
                    body = new string[] {
                            "You know the layout of your town.",
                            "You aso know the most notable locations.",
                            "Spraying tags will add points to your city info screen.",
                            String.Format("To VIEW THE CITY INFORMATION : <{0}>.", s_KeyBindings.GetFriendlyFormat(PlayerCommand.CITY_INFO).ToString())
                        };
                    break;

                case AdvisorHint.CORPSE: //living      // alpha10 merged corpses hints
                    title = "CORPSES";
                    body = new string[] {
                            "You are standing on a CORPSE. You can DRAG corpses to move them.",
                            "Corpses will slowly rot away but may resurrect as zombies (varies on game mode).",
                            "You can BUTCHER a corpse as a way to prevent that, and also to gather raw meat.",
                            "If you are desperate and starving you can resort to cannibalism by EATING corpses.",
                            String.Format("Warning: erad section 9 of Help <{0}> to understand what cannibalism entails.", s_KeyBindings.GetFriendlyFormat(PlayerCommand.HELP_MODE).ToString()),
                            "You can also try to REVIVE corpses if you have the medic skill and a medikit.",
                            String.Format("TO REVIVE the CORPSE : <{0}>", s_KeyBindings.GetFriendlyFormat(PlayerCommand.REVIVE_CORPSE).ToString()),
                            String.Format("TO EAT the CORPSE : <{0}>", s_KeyBindings.GetFriendlyFormat(PlayerCommand.EAT_CORPSE).ToString()),
                            String.Format("TO BUTCHER a CORPSE : RIGHT CLICK on it in the corpse list."),
                            String.Format("TO DRAG a CORPSE : LEFT CLICK on it in the corpse list."),
                            String.Format("TO STOP DRAGGING the CORPSE : LEFT CLICK on it in the corpse list."),
                            String.Format("TO BURY a CORPSE : <{0}>", s_KeyBindings.GetFriendlyFormat(PlayerCommand.BURY_CORPSE).ToString())
                    };
                    break;

                case AdvisorHint.CORPSE_EAT: //undead
                    title = "EATING CORPSES";
                    body = new string[] {
                            "You can eat that delicious corpse you're standing on to regain health.",
                            String.Format("TO EAT A CORPSE : RIGHT CLICK on it in the corpse list.")
                    };
                    break;

                case AdvisorHint.DOORWINDOW_OPEN:
                    title = "OPENING/CLOSING A DOOR/WINDOW";
                    body = new string[] {
                            "You are next to a closed door or window.",
                            "To OPEN it, try to MOVE on it.",
                            String.Format("To CLOSE : <{0}>.", s_KeyBindings.GetFriendlyFormat(PlayerCommand.CLOSE_DOOR).ToString())
                        };
                    break;

                /*case AdvisorHint.DOORWINDOW_CLOSE: //commented out, merged with DOORWINDOW_OPEN
                    title = "CLOSING A DOOR/WINDOW";
                    body = new string[] {
                            "You are next to an open door or window.",
                            String.Format("To CLOSE : <{0}>.", s_KeyBindings.GetFriendlyFormat(PlayerCommand.CLOSE_DOOR).ToString())
                        };
                    break;*/

                case AdvisorHint.EXIT_STAIRS_LADDERS:
                    title = "USING STAIRS & LADDERS";
                    body = new string[] {
                            "You are standing on stairs or a ladder.",
                            "You can use this exit to go on another map.",
                            String.Format("To USE THE EXIT : <{0}>.", s_KeyBindings.GetFriendlyFormat(PlayerCommand.USE_EXIT).ToString())
                        };
                    break;

                case AdvisorHint.FISHING:
                    title = "FISHING";
                    body = new string[] {
                            "You can use a fishing rod when next to a pond in order to catch fish.",
                            "Equip the rod when next to the water and then Wait for a fish to bite.",
                            String.Format("You can long-wait <{0}> or Wait manually <{1}>.", s_KeyBindings.GetFriendlyFormat(PlayerCommand.WAIT_LONG).ToString(), s_KeyBindings.GetFriendlyFormat(PlayerCommand.WAIT_OR_SELF).ToString()),
                            "If you long-wait it will be stopped the moment you hook a fish or are interrupted.",
                            "The Resources Availability difficulty option affects the chance of a fish biting.",
                            "Raw fish may give you food poisoning. It's always best to cook your fish first."
                        };
                    break;

                case AdvisorHint.INCAPACITATION: //@@MP (Release 7-2)
                    title = "FLASHBANGS";
                    body = new string[] {
                            "Flashbangs and stun guns will incapacitate livings for a number of turns.",
                            "Undead aren't affected."
                        };
                    break;

                case AdvisorHint.FLASHLIGHT:
                    title = "LIGHTING";
                    body = new string[] {
                            "You have found a lighting item, such as a flashlight.",
                            "Equip the item to increase your view distance (FoV).",
                            "Standing next to someone with a light on has the same effect.",
                            "You can recharge flashlights, phones, trackers and night vision at power generators."
                        };
                    break;

                case AdvisorHint.FOOD_POISONING: //@@MP (Release 7-6)
                    title = "FOOD POISONING";
                    body = new string[] {
                            "You ate raw meat and contracted food poisoning.",
                            "You will recover with time, however you can cure it immediately with antiviral pills.",
                            "Whilst unwell, you may vomit occasionally, and need breaks to rest."
                        };
                    break;

                case AdvisorHint.RAW_MEAT: //@@MP (Release 7-6)
                    title = "RAW MEAT";
                    body = new string[] {
                            "Raw meat is edible and will ease your hunger, however it can cause food poisoning.",
                            "Whilst unwell, you may vomit occasionally, and need breaks to rest.",
                            "You will recover with time, however you can cure it immediately with antiviral pills.",
                            "Thus, eating raw meat should only be a last resort. Instead, cook the meat at fires.",
                            "Use burning cars, or light receptacles / make campfires if you have wood and matches.",
                            String.Format("See section 9 of Help <{0}> for more information.", s_KeyBindings.GetFriendlyFormat(PlayerCommand.HELP_MODE).ToString())
                        };
                    break;

                case AdvisorHint.GAME_SAVE_LOAD:
                    title = "SAVING AND LOADING GAME";
                    body = new string[] {
                            "Now could be a good time to save your game.",
                            "You have only one save slot, but it's backed up (see the main menu).",
                            "By default autosaves occur every 540 turns (18 in-game hours).",
                            String.Format("You can disable autosaves in the Option menu <{0}>.", s_KeyBindings.GetFriendlyFormat(PlayerCommand.OPTIONS_MODE).ToString()),
                            String.Format("To SAVE THE GAME : <{0}>.", s_KeyBindings.GetFriendlyFormat(PlayerCommand.SAVE_GAME).ToString()),
                            String.Format("To LOAD THE GAME : <{0}>.", s_KeyBindings.GetFriendlyFormat(PlayerCommand.LOAD_GAME).ToString()),
                        };
                    break;

                case AdvisorHint.EXIT_LEAVING_DISTRICT:
                    title = "LEAVING THE DISTRICT";
                    body = new string[] {
                            "You are next to a district EXIT.",
                            "You can leave this district by MOVING into the exit."
                        };
                    break;

                case AdvisorHint.GRENADE:
                    title = "GRENADES";
                    body = new string[] {
                            "You have found an explosive (grenande, molotov or dynamte).",
                            "Be careful not to be caught in the blast radius.",
                            "Especially dynamite - place that and run until it blows!",
                            "To THROW/PLACE an EXPLOSIVE, EQUIP it and FIRE it.",
                            String.Format("To FIRE : <{0}>.", s_KeyBindings.GetFriendlyFormat(PlayerCommand.FIRE_MODE).ToString())
                        };
                    break;

                case AdvisorHint.ITEM_GRAB_CONTAINER:
                    title = "TAKING AN ITEM FROM A CONTAINER";
                    body = new string[] {
                            "You are next to a container, such as a wardrobe or a shelf.",
                            "You can TAKE the item there by MOVING into the object."
                        };
                    break;

                case AdvisorHint.ITEM_GRAB_FLOOR:
                    title = "TAKING AN ITEM FROM THE FLOOR";
                    body = new string[] {
                            "You are standing on a stack of items.",
                            "The items are listed on the right panel in the ground inventory.",
                            "To TAKE an item, move your mouse over the item on the ground inventory and LEFT CLICK.",
                            "Hotkey : <Ctrl-item slot number>." // alpha 10
                        };
                    break;

                case AdvisorHint.ITEM_DROP:
                    title = "DROPPING AN ITEM";
                    body = new string[] {
                            "You can drop items from your inventory.",
                            "To DROP an item, RIGHT CLICK on it.",
                            "Eqipped items must be unequiped before they can be dropped.",
                            String.Format("To delete an item from the world permanently: <{0}>.", s_KeyBindings.GetFriendlyFormat(PlayerCommand.DESTROY_ITEM).ToString())
                        };
                    break;

                case AdvisorHint.ITEM_EQUIP:
                    title = "EQUIPPING AN ITEM";
                    body = new string[] {
                            "You have an equippable item in your inventory.",
                            //"Typical equipable items are weapons, lights and phones.",
                            "To EQUIP the item, LEFT CLICK on it in your inventory.",
                            "Equipped items are given a green background.",
                            "To UNEQUIP the item, LEFT CLICK on it in your inventory.",
                            "Hotkey : <Ctrl + item slot number>" // alpha 10
                        };
                    break;

                case AdvisorHint.ITEM_TYPE_BARRICADING:
                    title = "ITEM - BARRICADING MATERIAL";
                    body = new string[] {
                            "You have some barricading materials, such as planks.",
                            "Barricading material is used when you barricade doors/windows or build fortifications.",
                            "To build fortifications you need the CARPENTRY skill."
                        };
                    break;

                /*case AdvisorHint.ITEM_UNEQUIP: //commented out
                    title = "UNEQUIPPING AN ITEM";
                    body = new string[] {
                            "You have equipped an item.",
                            "The item is displayed with a green background.",
                            "To UNEQUIP the item, LEFT CLICK on it in your inventory.",
                            "Hotkey : <Ctrl-item slot number>" // alpha 10
                        };
                    break;*/

                case AdvisorHint.ITEM_USE:
                    title = "USING AN ITEM";
                    body = new string[] {
                            "You can use one of your items.",
                            "Typical usable items are food, medicine and ammunition (reloads).",
                            "To USE the item, LEFT CLICK on it in your inventory.",
                            "Hotkey : <Ctrl-item slot number>" // alpha 10
                        };
                    break;

                case AdvisorHint.KEYS_OPTIONS:
                    title = "KEYS & OPTIONS";
                    body = new string[] {
                            String.Format("You can view and redefine the KEYS by pressing <{0}>.", s_KeyBindings.GetFriendlyFormat(PlayerCommand.KEYBINDING_MODE).ToString()),
                            String.Format("You can change OPTIONS by pressing <{0}>.", s_KeyBindings.GetFriendlyFormat(PlayerCommand.OPTIONS_MODE).ToString()),
                            "Some option changes will only take effect when starting a new game.",
                            "Keys and Options are saved."
                        };
                    break;

                case AdvisorHint.LEADING_CAN_RECRUIT:
                    title = "LEADING - RECRUITING";
                    body = new string[] {
                            "You can recruit a follower next to you!",
                            String.Format("To RECRUIT : <{0}>.", s_KeyBindings.GetFriendlyFormat(PlayerCommand.LEAD_MODE).ToString())
                        };
                    break;

                case AdvisorHint.LEADING_GIVE_ORDERS:
                    title = "LEADING - GIVING ORDERS";
                    body = new string[] {
                            "You can give orders to and fire your follower.",
                            "You can also switch place with followers next to you.",
                            String.Format("To GIVE ORDERS : <{0}>.", s_KeyBindings.GetFriendlyFormat(PlayerCommand.ORDER_MODE).ToString()),
                            String.Format("To FIRE YOUR FOLLOWER : <{0}>.", s_KeyBindings.GetFriendlyFormat(PlayerCommand.LEAD_MODE).ToString()),
                            String.Format("To SWITCH PLACE : <{0}>.", s_KeyBindings.GetFriendlyFormat(PlayerCommand.SWITCH_PLACE).ToString())
                        };
                    break;

                case AdvisorHint.LEADING_NEED_SKILL:
                    title = "LEADING - LEADERSHIP SKILL";
                    body = new string[] {
                            "You can try to recruit a follower if you have the LEADERSHIP skill.",
                            "The higher the skill, the more followers you can recruit."
                        };
                    break;

                /*case AdvisorHint.LEADING_SWITCH_PLACE: //commented out as merged with GIVE_ORDERS
                    title = "LEADING - SWITCHING PLACE";
                    body = new string[] {
                            "You can switch place with followers next to you.",
                            String.Format("To SWITCH PLACE : <{0}>.", s_KeyBindings.GetFriendlyFormat(PlayerCommand.SWITCH_PLACE).ToString())
                        };
                    break;*/

                case AdvisorHint.MAKE_FIRE_FOR_COOKING:   //@@MP (Release 7-6)
                    title = "MAKING FIRES FOR COOKING";
                    body = new string[] {
                            "Matches can be used to make campfires and ignite fires in receptacles.",
                            "You need also need wood for these.",
                            "Lighting a match will prompt for the direction of the receptacle or campfire placement.",
                            String.Format("To use : equip the matches and press <{0}>.", s_KeyBindings.GetFriendlyFormat(PlayerCommand.MAKE_COOKING_FIRE).ToString())
                        };
                    break;

                case AdvisorHint.MAKE_MOLOTOV: //@@MP (Release 4)
                    title = "MAKING A MOLOTOV";
                    body = new string[] {
                            "You've picked up some hard liquor, which can be used to make a molotov."
                        };
                    break;

                case AdvisorHint.MINIGUN: //@@MP (Release 7-6)
                    title = "MINIGUN FIRE MODE";
                    body = new string[] {
                            "Some weapons offer rapid-fire burst mode.",
                            "The minigun is NOT capable of firing in single-shot mode.",
                            "The minigun can only be used in rapid-fire mode."
                        };
                    break;

                case AdvisorHint.MOUSE_LOOK:
                    title = "LOOKING WITH THE MOUSE";
                    body = new string[] {
                            "Move the MOUSE over something interesting.",
                            "You will get a detailed description of the actor or object.",
                            "You can also use the keyboard with INSPECTION MODE.",
                            String.Format("To USE INSPECTION MODE : <{0}>.", s_KeyBindings.GetFriendlyFormat(PlayerCommand.INSPECTION_MODE).ToString()),
                        };
                    break;

                case AdvisorHint.MOVE_BASIC:
                    title = "MOVEMENT - DIRECTIONS";
                    body = new string[] {
                            "MOVE your character around with the movement keys.",
                            "The default keys are your NUMPAD numbers. Remember to keep NumLock on!",
                            "",
                            "7 8 9",
                            "4 - 6",
                            "1 2 3",
                            "",
                            "When asked for a DIRECTION, press a MOVE key.",
                            "You can also RUN to move faster.",
                            "Running is tiring and spend stamina.",
                            String.Format("To TOGGLE RUNNING : <{0}>.", s_KeyBindings.GetFriendlyFormat(PlayerCommand.RUN_TOGGLE).ToString())
                        };
                    break;

                case AdvisorHint.MOVE_JUMP:
                    title = "MOVEMENT - JUMPING";
                    body = new string[] {
                            //"You can JUMP on or over an obstacle next to you.",
                            "You can JUMP on/over cars, fences and furniture.",
                            "Jumpable objects are described as 'Can be jumped on'.",
                            "Some enemies can't jump and won't be able to follow you.",
                            "Jumping is tiring and spends stamina.",
                            "To jump, just MOVE on the obstacle."
                        };
                    break;

                /*case AdvisorHint.MOVE_RUN: //commented out as merged with MOVE_BASIC
                    title = "MOVEMENT - RUNNING";
                    body = new string[] {
                            "You can RUN to move faster.",
                            "Running is tiring and spend stamina.",
                            String.Format("To TOGGLE RUNNING : <{0}>.", s_KeyBindings.GetFriendlyFormat(PlayerCommand.RUN_TOGGLE).ToString())
                        };
                    break;*/

                case AdvisorHint.MOVE_RESTING:
                    title = "MOVEMENT - RESTING";
                    body = new string[] {
                            "You are TIRED because you lost too much STAMINA.",
                            "Being tired is bad for you! You move slowly.",
                            "You can't do tiring activities such as running, fighting and jumping.",
                            "You always recover a bit of stamina each turn.",
                            "But you can REST to recover stamina faster.",
                            String.Format("To REST/WAIT : <{0}>.", s_KeyBindings.GetFriendlyFormat(PlayerCommand.WAIT_OR_SELF).ToString())
                        };
                    break;

                case AdvisorHint.NIGHT:
                    title = "NIGHT TIME";
                    body = new string[] {
                            "It is night. Night time is penalizing for livings.",
                            "They tire faster (stamina and sleep) and don't see very far.",
                            "Undeads are not penalized by night at all."
                        };
                    break;

                case AdvisorHint.NPC_GIVING_ITEM:
                    title = "GIVING ITEMS";
                    body = new string[] {
                            "You can GIVE ITEMS to friendly NPCs, whether they're a follower or not.",
                            String.Format("To GIVE AN ITEM : move the mouse over your item and press <{0}>.", s_KeyBindings.GetFriendlyFormat(PlayerCommand.GIVE_ITEM).ToString())
                        };
                    break;

                case AdvisorHint.NPC_SHOUTING:
                    title = "SHOUTING";
                    body = new string[] {
                            "Someone is sleeping near you.",
                            "You can SHOUT to try to wake him or her up.",
                            "Other actors can also shout to wake their friends up when they see danger.",
                            String.Format("To SHOUT : <{0}>.", s_KeyBindings.GetFriendlyFormat(PlayerCommand.SHOUT).ToString())
                        };
                    break;

                case AdvisorHint.NPC_TRADE:
                    title = "TRADING";
                    body = new string[] {
                            "You can TRADE with an actor next to you.",
                            "Actors that can trade with you have a $ icon on the map.",
                            "To ask for a TRADE offer, just try to MOVE into the actor.",
                            String.Format("To TRADE : press <{0}> and select an NPC with the direction keys.", s_KeyBindings.GetFriendlyFormat(PlayerCommand.NEGOTIATE_TRADE).ToString())
                        };
                    break;

                case AdvisorHint.OBJECT_BREAK:
                    title = "BREAKING OBJECTS";
                    body = new string[] {
                            "You can try to BREAK an object around you.",
                            "Typical breakable objects are furnitures, doors and windows.",
                            String.Format("To BREAK : <{0}>.", s_KeyBindings.GetFriendlyFormat(PlayerCommand.BREAK_MODE).ToString())
                        };
                    break;

                case AdvisorHint.OBJECT_PUSH: // alpha10 also pulling and mention shoving actors
                    title = "PUSHING/PULLING OBJECTS";
                    body = new string[] {
                            "You can PUSH/PULL objects and actors around you.",
                            "Only MOVABLE stuff can be pushed (described as 'Can be moved').",
                            String.Format("To PUSH : <{0}>.", s_KeyBindings.GetFriendlyFormat(PlayerCommand.PUSH_MODE).ToString()),
                            String.Format("To PULL : <{0}>.", s_KeyBindings.GetFriendlyFormat(PlayerCommand.PULL_MODE).ToString())
                        };
                    break;

                case AdvisorHint.ON_FIRE: //@@MP (Release 7-6)
                    title = "ON FIRE";
                    body = new string[] {
                            "You are literally on fire!",
                            "You probably stepped on an alight square, or were blasted by a flame weapon.",
                            "To extinguish yourself, you can either walk around in the rain,",
                            "find a nearby pond and go for a dip, or press the Wait key to try a stop-drop-and-roll.",
                            String.Format("To WAIT : <{0}>.", s_KeyBindings.GetFriendlyFormat(PlayerCommand.WAIT_OR_SELF).ToString())
                        };
                    break;

                case AdvisorHint.PLANT_SEEDS: //@@MP (Release 5-5)
                    title = "PLANTING SEEDS";
                    body = new string[] {
                            "You can find vegie seeds in hardware stores.",
                            "Seeds can be planted using a shovel or pick axe.",
                            "On the next morning they will grow into harvestable vegies."
                        };
                    break;

                case AdvisorHint.RAIN:
                    title = "RAIN";
                    body = new string[] {
                            "It's raining. Rain has various effects.",
                            "Livings vision is reduced.",
                            "Firearms have more chance to jam.",
                            "Scents evaporate faster."
                        };
                    break;

                case AdvisorHint.SIPHON_FUEL: //@@MP (Release 7-1)
                    title = "SIPHON FUEL";
                    body = new string[] {
                            "Siphon kits can be used to take fuel from cars.",
                            "Certain items, like flamethrowers and chainsaws require fuel.",
                            "You can also use fuel to make flaming crossbow bolts (a fire mode)",
                            "To siphon fuel, move next to a car and use the siphon kit.",
                        };
                    break;

                case AdvisorHint.SMG: //@@MP (Release 7-6)
                    title = "SMG FIRE MODE";
                    body = new string[] {
                            "Some weapons offer rapid-fire burst mode.",
                            "Typically this means more damage potential but less accuracy.",
                            "The SMG is one weapon that is always better in rapid-fire mode where possible."
                        };
                    break;

                case AdvisorHint.SMOKE_GRENADE: //@@MP (Release 7-2)
                    title = "SMOKE GRENADE";
                    body = new string[] {
                            "Smoke grenades will block FOV.",
                            "Smoke overpowers scents, throwing off zombies who track by smell.",
                            "It will also suffocate ground fires."
                        };
                    break;

                case AdvisorHint.SPRAYS_PAINT:
                    title = "SPRAYS - SPRAY PAINT";
                    body = new string[] {
                            "You have found a can of spraypaint.",
                            "You can tag a symbol on walls and floors.",
                            "Tagged locations appear on your minimap.",
                            String.Format("To SPRAY : equip the spray and press <{0}>.", s_KeyBindings.GetFriendlyFormat(PlayerCommand.USE_SPRAY).ToString())
                        };
                    break;

                case AdvisorHint.SPRAYS_SCENT:
                    title = "SPRAYS - SCENT SPRAY";
                    body = new string[] {
                            "You have found a scent spray.",
                            "You can spray some perfume on yourself or another adjacent actor.",
                            "This is useful to confuse the undeads that hunt using smell.",
                            String.Format("To SPRAY : equip the spray and press <{0}>.", s_KeyBindings.GetFriendlyFormat(PlayerCommand.USE_SPRAY).ToString())
                        };
                    break;

                case AdvisorHint.STATE_HUNGRY:
                    title = "STATE - HUNGRY";
                    body = new string[] {
                            "You are HUNGRY. You should EAT soon.",
                            "If you become starved you can die!",
                            "To eat, just USE a food item, such as groceries.",
                            "Read the manual for more explanations on hunger."
                        };
                    break;

                case AdvisorHint.STATE_SLEEPY:
                    title = "STATE - SLEEPY";
                    body = new string[] {
                            "You are SLEEPY.",
                            "There are penalties if you don't find a place to sleep.",
                            "Beds and couches will boost SLP and slowly heal you.",
                            "Sleeping bags will boost SLP but won't heal you.", //@@MP (Release 7-3)
                            String.Format("To SLEEP : <{0}>.", s_KeyBindings.GetFriendlyFormat(PlayerCommand.SLEEP).ToString()),
                            "Read the manual for more explanations on sleep."
                        };
                    break;

                case AdvisorHint.WEAPON_FIRE:
                    title = "FIRING A WEAPON";
                    body = new string[] {
                            "You can fire your equipped ranged weapon at valid targets within range.",
                            "To fire on a target you need ammo and a clear line of fine.",
                            "The closer the target is, the easier it is to hit and it does slightly more damage.",
                            String.Format("To FIRE : <{0}>.", s_KeyBindings.GetFriendlyFormat(PlayerCommand.FIRE_MODE).ToString()),
                            "When firing you can switch to Rapid Fire mode : you will shoot twice but at reduced accuracy.",
                            "Read the manual for more explanation about firing and ranged weapons."
                        };
                    break;

                case AdvisorHint.WEAPON_RELOAD:
                    title = "RELOADING A WEAPON";
                    body = new string[] {
                            "You can reload your equiped ranged weapon.",
                            "To RELOAD, just USE a compatible ammo item.",
                        };
                    break;

                // alpha10 new hints from here down
                case AdvisorHint.SANITY:  // sanity
                    title = "SANITY";
                    body = new string[] {
                        "If your SANITY gets too low you can go insane. That's not good.",
                        "Living in this horrible world and seing horrible things will lower your sanity.",
                        "You can recover sanity by :",
                        "- Talking to people.",
                        "- Having followers you trust.",
                        "- Killing undeads.",
                        "- Using entertainment items (eg books).",
                        "- Taking pills.",
                        "- Burying corpses." //@@MP (Release 7-6)
                    };
                    break;

                case AdvisorHint.INFECTION:
                    title = "INFECTION";
                    body = new string[] {
                        "You are INFECTED!",
                        "Most undeads bites are infectious.",
                        "Infection worsens when you are bitten.",
                        "A low infection value will make you sick, a full infection value is death.",
                        "Cure the infection with appropriate meds."
                    };
                    break;

                case AdvisorHint.TRAPS:
                    title = "TRAPS";
                    body = new string[] {
                        "You are carrying TRAPS.",
                        "Drop activated traps on tiles.",
                        "Some traps are activated by dropping them.",
                        "Other traps need to be activated before being dropped.",
                        "You are always safe from your own traps.",
                        "Traps layed by your followers are also safe."
                    };
                    break;

                default:
                    throw new ArgumentOutOfRangeException("hint", "unhandled hint text");
            }
        }

        void ShowAdvisorMessage(string title, string[] lines)
        {
            // clear.
            ClearOverlays();

            // tell.
            string[] text = new string[lines.Length + 2];
            text[0] = "HINT : " + title;
            Array.Copy(lines, 0, text, 1, lines.Length);
            text[lines.Length + 1] = String.Format("(hint {0}/{1})", s_Hints.CountAdvisorHintsGiven(), (int)AdvisorHint._COUNT);
            AddOverlay(new OverlayPopup(text, Color.White, Color.White, Color.Black, new Point(0, 0)));

            // wait.
            ClearMessages();
            AddMessage(new Message("You can disable the advisor in the options screen.", m_Session.WorldTime.TurnCounter, Color.White));
            AddMessage(new Message(String.Format("To show the options screen : <{0}>.", s_KeyBindings.GetFriendlyFormat(PlayerCommand.OPTIONS_MODE).ToString()), m_Session.WorldTime.TurnCounter, Color.White));
            AddMessagePressEnter();

            // clear.
            ClearMessages();
            ClearOverlays();
            RedrawPlayScreen();
        }
#endregion

        /// <summary>
        /// Achievement banner
        /// </summary>
        void ShowNewAchievement(Achievement.IDs id)
        {
            // one more achievement.
            ++m_Session.Scoring.CompletedAchievementsCount;

            // get data.
            Achievement ach = m_Session.Scoring.GetAchievement(id);
            string SFXToPlay = ach.SFXID;
            string title = ach.Name;
            string[] text = ach.Text;

            // add event.
            m_Session.Scoring.AddEvent(m_Session.WorldTime.TurnCounter, String.Format("** Achievement : {0} for {1} points. **", title, ach.ScoreValue));

            // sound effect.
            m_SFXManager.Play(SFXToPlay, AudioPriority.PRIORITY_EVENT); //@@MP - switched from Music to SFX (Release 6-4)

            // prepare banner.
            int longestLine = FindLongestLine(text);
            string starsLine = new string('*', Math.Max(longestLine, 50));
            List<string> lines = new List<string>(text.Length + 3 + 2);
            lines.Add(starsLine);
            lines.Add(String.Format("ACHIEVEMENT : {0}", title));
            lines.Add("CONGRATULATIONS!");
            for (int i = 0; i < text.Length; i++)
                lines.Add(text[i]);
            lines.Add(String.Format("Achievements : {0}/{1}.", m_Session.Scoring.CompletedAchievementsCount, Scoring.MAX_ACHIEVEMENTS));
            lines.Add(starsLine);

            // banner.
            Point pos = new Point(0, 0);
            AddOverlay(new OverlayPopup(lines.ToArray(), Color.Gold, Color.Gold, Color.DimGray, pos));
            ClearMessages();
            if (!m_Player.IsBotPlayer) //alpha 10.1
                AddMessagePressEnter();
            ClearOverlays();
        }

#region --Special player events
        void ShowSpecialDialogue(Actor speaker, string[] text)
        {
            // music.
            m_MusicManager.StopAll();
            m_MusicManager.Play(GameMusics.INTERLUDE, AudioPriority.PRIORITY_EVENT);

            // overlays.
            AddOverlay(new OverlayPopup(text, Color.Gold, Color.Gold, Color.DimGray, new Point(0, 0)));
            AddOverlay(new OverlayRect(Color.Yellow, new Rectangle(MapToScreen(speaker.Location.Position), new Size(TILE_SIZE, TILE_SIZE))));

            // message & wait enter.
            ClearMessages();
            if (!m_Player.IsBotPlayer) //alpha10.1
                AddMessagePressEnter();
            ClearOverlays();  // alpha10 fix
            m_MusicManager.StopAll();
        }

        void CheckSpecialPlayerEventsAfterAction(Actor player)
        {
            //////////////////////////////////////////////////////////
            //
            // Special events - limited to some factions/actors
            // 1. Breaking into CHAR office for the 1st time: !undead !char
            // 2. Visiting CHAR Underground facility for the 1st time.
            // 3. Sighting The Sewers Thing : !thesewersthing
            // 4. Police Station script.
            // 5. Sighting Jason Myers : !jasonmyers
            // 6. Breaking into the army office for the 1st time //@@MP (Release 6-3)
            // 7. Visiting the army base for the first time //@@MP (Release 6-3)
            //
            // Generic 1st Time flags :
            // 1. Visiting a new map.
            // 2. Sighting an actor : actor model, unique NPCs.
            // 
            // Item interactions :
            // 1. Subway Worker Badge in Subway maps.
            //////////////////////////////////////////////////////////


#region Special events
            // 1. Breaking into a CHAR office for the 1st time: !undead !char
#region
            if (!player.Model.Abilities.IsUndead && player.Faction != GameFactions.TheCHARCorporation)
            {
                if (!m_Session.Scoring.HasCompletedAchievement(Achievement.IDs.CHAR_BROKE_INTO_OFFICE))
                {
                    if (IsInCHAROffice(player.Location))
                    {
                        // completed.
                        m_Session.Scoring.SetCompletedAchievement(Achievement.IDs.CHAR_BROKE_INTO_OFFICE);

                        // achievement!
                        ShowNewAchievement(Achievement.IDs.CHAR_BROKE_INTO_OFFICE);
                    }
                }
            }
#endregion

            // 2. Visiting CHAR Underground facility for the 1st time.
#region
            if (!m_Session.Scoring.HasCompletedAchievement(Achievement.IDs.CHAR_FOUND_UNDERGROUND_FACILITY))
            {
                if (player.Location.Map == m_Session.UniqueMaps.CHARUndergroundFacility.TheMap && player.Faction != GameFactions.TheCHARCorporation) //@@MP - added faction check (Release 6-3)
                {
                    lock (m_Session) // thread safe
                    {
                        // completed.
                        m_Session.Scoring.SetCompletedAchievement(Achievement.IDs.CHAR_FOUND_UNDERGROUND_FACILITY);

                        // achievement!
                        ShowNewAchievement(Achievement.IDs.CHAR_FOUND_UNDERGROUND_FACILITY);

                        // make sure the player knows about it now and it is activated.
                        m_Session.PlayerKnows_CHARUndergroundFacilityLocation = true;
                        m_Session.CHARUndergroundFacility_Activated = true;
                        m_Session.UniqueMaps.CHARUndergroundFacility.TheMap.IsSecret = false;

                        // open the exit to and from surface for AIs.
                        Map surfaceMap = m_Session.UniqueMaps.CHARUndergroundFacility.TheMap.District.EntryMap;
                        Point? surfaceEntry = surfaceMap.FindFirstInMap(
                            (pt) =>
                            {
                                Exit e = surfaceMap.GetExitAt(pt);
                                if (e == null)
                                    return false;
                                return e.ToMap == m_Session.UniqueMaps.CHARUndergroundFacility.TheMap;
                            });
                        if (surfaceEntry == null)
                            throw new InvalidOperationException("could not find exit to CUF in surface map");
                        Exit toCUF = surfaceMap.GetExitAt(surfaceEntry.Value);
                        toCUF.IsAnAIExit = true;

                        Point? cufExit = m_Session.UniqueMaps.CHARUndergroundFacility.TheMap.FindFirstInMap(
                            (pt) =>
                            {
                                Exit e = m_Session.UniqueMaps.CHARUndergroundFacility.TheMap.GetExitAt(pt);
                                if (e == null)
                                    return false;
                                return e.ToMap == surfaceMap;
                            });
                        if (cufExit == null)
                            throw new InvalidOperationException("could not find exit to surface in CUF map");
                        Exit fromCUF = m_Session.UniqueMaps.CHARUndergroundFacility.TheMap.GetExitAt(cufExit.Value);
                        fromCUF.IsAnAIExit = true;
                    }
                }
            }
#endregion

            // 3. Sighting The Sewers Thing : !thesewersthing
#region
            if (player != m_Session.UniqueActors.TheSewersThing.TheActor)
            {
                if (!m_Session.PlayerKnows_TheSewersThingLocation &&
                    player.Location.Map == m_Session.UniqueActors.TheSewersThing.TheActor.Location.Map &&
                    !m_Session.UniqueActors.TheSewersThing.TheActor.IsDead)
                {
                    if (IsVisibleToPlayer(m_Session.UniqueActors.TheSewersThing.TheActor))
                    {
                        lock (m_Session) // thread safe
                        {
                            m_Session.PlayerKnows_TheSewersThingLocation = true;

                            // message + music, so the player notices it.
                            m_MusicManager.StopAll();
                            m_MusicManager.Play(GameMusics.FIGHT, AudioPriority.PRIORITY_EVENT);
                            ClearMessages();
                            AddMessage(new Message("What the hell is that thing!?", m_Session.WorldTime.TurnCounter, Color.Yellow));
                            if (!m_Player.IsBotPlayer) //alpha 10.1
                                AddMessagePressEnter();
                        }
                    }
                }
            }
#endregion

            // 4. Police Station script.
#region
            if (player.Location.Map == m_Session.UniqueMaps.PoliceStation_JailsLevel.TheMap && !m_Session.UniqueActors.PoliceStationPrisonner.TheActor.IsDead)
            {
                Actor prisoner = m_Session.UniqueActors.PoliceStationPrisonner.TheActor;
                Map map = player.Location.Map;
                switch (m_Session.ScriptStage_PoliceStationPrisonner)
                {
                    case ScriptStage.STAGE_0:   // nothing happened yet, waiting to offer deal.
                        /////////////////////////////////////////////
                        // Player is next to generator : offer deal.
                        /////////////////////////////////////////////
                        if (map.HasAnyAdjacentInMap(player.Location.Position, (pt) => map.GetMapObjectAt(pt) is PowerGenerator) && map.IsClosestIronGateClosed(prisoner.Location.Position)) //@@MP - fixed with iron gate check (Release 5-6), removed unecessary visibility check [IsVisibleToPLayer(prisoner)] (Release 7-6)
                        {
                            lock (m_Session) // thread safe
                            {
                                if (prisoner.IsSleeping) //@@MP - moved from the if check (Release 6-1)
                                    DoWakeUp(prisoner);

                                // Offer deal.
                                string[] text = new string[]
                                {
                                "\"  Psssst! Hey! You there!  \"",
                                String.Format("{0} is discretely calling you from {1} cell...", prisoner.Name, HisOrHer(prisoner)),
                                "\"  Look, I know what's happening! I worked down there, at the CHAR facility!",
                                "  They warned me not to leave, but I did! Like I'm stupid enough to stay down there, huh?",
                                "  Stupid cops won't listen to me. I shouldn't be here!",
                                "  You look clever, let's make a deal. You just have to flick that lever to open my cell.",
                                "  The cops are too busy to care about a small fish like me!",
                                "  Then I'll tell you where the underground CHAR and army facilities are.",
                                "  I don't give a fuck about CHAR anymore, I just want to get the hell out of here!",
                                "  Do it, PLEASE! I REALLY shoudn't be here! \"",
                                String.Format("Sounds like {0} wants you to turn on the generator to open the cells...", HeOrShe(prisoner))
                                };
                                ShowSpecialDialogue(prisoner, text);

                                // Scoring event.
                                m_Session.Scoring.AddEvent(m_Session.WorldTime.TurnCounter, String.Format("{0} offered a deal.", prisoner.Name));

                                // Next stage.
                                m_Session.ScriptStage_PoliceStationPrisonner = ScriptStage.STAGE_1;
                            }
                        }
                        break;

                    case ScriptStage.STAGE_1:  // offered deal, waiting for opened cell.
                        ///////////////////////////////////////////////
                        // Wait to get out of cell and next to player.
                        ///////////////////////////////////////////////
                        if (IsVisibleToPlayer(prisoner) && (prisoner.Model == m_GameActors.MaleCivilian || prisoner.Model == m_GameActors.FemaleCivilian))
                        {
                            //@@MP - swapped the check from being adjacent in the cells zone, to being visible whilst not yet transformed (Release 7-6)
                            //Note: the assumes the level is Map.Lighting.LIT, but would also work if the player has an active light source. WON'T work if completely dark

                            lock (m_Session) // thread safe
                            {
                                if (prisoner.IsSleeping) //@@MP - moved from the if check (Release 6-1)
                                    DoWakeUp(prisoner);

                                // Thank you and give info.
                                string[] text = new string[] {
                                    "\"  Thank you for releasing me! Thank you so much!",
                                    "  I'll tell you the where the secret locations are.",
                                    String.Format("  The CHAR Underground Facility is in district {0}.", World.CoordToString(m_Session.UniqueMaps.CHARUndergroundFacility.TheMap.District.WorldPosition.X,  m_Session.UniqueMaps.CHARUndergroundFacility.TheMap.District.WorldPosition.Y)),
                                    String.Format("  The underground Army base is in district {0}.", World.CoordToString(m_Session.UniqueMaps.ArmyBase.TheMap.District.WorldPosition.X,  m_Session.UniqueMaps.ArmyBase.TheMap.District.WorldPosition.Y)), //@@MP (Release 6-3)
                                    "  The CHAR Office has evidence on what's going on. They have a lot of equipment too.",
                                    "  The army base is probably your best chance of rescue, if they're still alive...", //@@MP (Release 6-3)
                                    "  CHAR had captured a soldier. He probably had an access card to the army base.", //@@MP (Release 6-3)
                                    "  Now I must hurry! Thanks a lot for saving me!",
                                    "  I don't want them to- UGGH...",
                                    "  What's happening? NO!",
                                    "  NO NOT ME! AAAGGGGGGGRRR! NOT NOW! AAAGGGGGGGRRR \""
                                };
                                ShowSpecialDialogue(prisoner, text);

                                // Scoring event.
                                m_Session.Scoring.AddEvent(m_Session.WorldTime.TurnCounter, String.Format("Freed {0}.", prisoner.Name));

                                // reveal location.
                                m_Session.PlayerKnows_CHARUndergroundFacilityLocation = true;
                                m_Session.PlayerKnows_ArmyBaseLocation = true; //@@MP (Release 6-3)

                                // Scoring event.
                                m_Session.Scoring.AddEvent(m_Session.WorldTime.TurnCounter, "Learned the location of the CHAR Underground Facility.");
                                m_Session.Scoring.AddEvent(m_Session.WorldTime.TurnCounter, "Learned the location of the underground Army base."); //@@MP (Release 6-3)

                                // transformation.
                                // - zombify.
                                KillActor(null, prisoner, "transformation", false, false);  // alpha10 don't drop corpse!
                                Actor monster = Zombify(null, prisoner, prisoner.Location.Map, prisoner.Location.Position, false);
                                // - turn into a ZP.
                                monster.Model = m_GameActors.ZombiePrince;
                                // - zero AP so player don't get hit asap.
                                monster.ActionPoints = 0;

                                // Scoring event.
                                m_Session.Scoring.AddEvent(m_Session.WorldTime.TurnCounter, String.Format("{0} turned into a {1}!", prisoner.Name, monster.Model.Name));

                                // fight music!
                                m_MusicManager.Play(GameMusics.FIGHT, AudioPriority.PRIORITY_EVENT);

                                // Next stage.
                                m_Session.ScriptStage_PoliceStationPrisonner = ScriptStage.STAGE_2;
                            }
                        }
                        break;

                    case ScriptStage.STAGE_2: // monsterized!
                        // nothing to do...
                        break;

                    default:
                        throw new ArgumentOutOfRangeException("unhandled script stage " + m_Session.ScriptStage_PoliceStationPrisonner);
                }
            }
#endregion

            // 5. Sighting the deranged patient : !jasonmyers
#region
            if (player != m_Session.UniqueActors.DerangedPatient.TheActor)
            {
                if (!m_Session.UniqueActors.DerangedPatient.TheActor.IsDead)
                {
                    if (IsVisibleToPlayer(m_Session.UniqueActors.DerangedPatient.TheActor))
                    {
                        lock (m_Session) // thread safe
                        {
                            // music.
                            if (!m_MusicManager.IsPlaying(GameMusics.INSANE))
                            {
                                m_MusicManager.StopAll();
                                m_MusicManager.Play(GameMusics.INSANE, AudioPriority.PRIORITY_EVENT);
                            }

                            // message if 1st time.
                            if (!m_Session.Scoring.HasSighted(m_Session.UniqueActors.DerangedPatient.TheActor.Model.ID))
                            {
                                ClearMessages();
                                AddMessage(new Message("Who the hell are you!?", m_Session.WorldTime.TurnCounter, Color.Yellow));
                                if (!m_Player.IsBotPlayer) //alpha 10.1
                                    AddMessagePressEnter();
                            }
                        }
                    }
                }
            }
#endregion

            // 6. Breaking into the army office for the 1st time //@@MP (Release 6-3)
#region
            if (!player.Model.Abilities.IsUndead && player.Faction != GameFactions.TheCHARCorporation)
            {
                if (!m_Session.Scoring.HasCompletedAchievement(Achievement.IDs.ARMY_BROKE_INTO_OFFICE))
                {
                    if (IsInArmyOffice(player.Location))
                    {
                        // completed.
                        m_Session.Scoring.SetCompletedAchievement(Achievement.IDs.ARMY_BROKE_INTO_OFFICE);

                        // achievement!
                        ShowNewAchievement(Achievement.IDs.ARMY_BROKE_INTO_OFFICE);
                    }
                }
            }
#endregion

            // 7. Visiting the army base for the first time //@@MP (Release 6-3)
#region
            if (!m_Session.Scoring.HasCompletedAchievement(Achievement.IDs.ARMY_FOUND_UNDERGROUND_BASE))
            {
                if (player.Location.Map == m_Session.UniqueMaps.ArmyBase.TheMap && player.Faction != GameFactions.TheCHARCorporation)
                {
                    lock (m_Session) // thread safe
                    {
                        // completed.
                        m_Session.Scoring.SetCompletedAchievement(Achievement.IDs.ARMY_FOUND_UNDERGROUND_BASE);

                        // achievement!
                        ShowNewAchievement(Achievement.IDs.ARMY_FOUND_UNDERGROUND_BASE);

                        // make sure the player knows about it now and it is activated.
                        m_Session.PlayerKnows_ArmyBaseLocation = true;
                        m_Session.ArmyBaseUnderground_Activated = true;
                        m_Session.UniqueMaps.ArmyBase.TheMap.IsSecret = false;

                        // open the exit to and from surface for AIs.
                        Map surfaceMap = m_Session.UniqueMaps.ArmyBase.TheMap.District.EntryMap;
                        Point? surfaceEntry = surfaceMap.FindFirstInMap(
                            (pt) =>
                            {
                                Exit e = surfaceMap.GetExitAt(pt);
                                if (e == null)
                                    return false;
                                return e.ToMap == m_Session.UniqueMaps.ArmyBase.TheMap;
                            });
                        if (surfaceEntry == null)
                            throw new InvalidOperationException("could not find exit to army base in surface map");
                        Exit toArmyBase = surfaceMap.GetExitAt(surfaceEntry.Value);
                        toArmyBase.IsAnAIExit = true;

                        Point? armyBaseExit = m_Session.UniqueMaps.ArmyBase.TheMap.FindFirstInMap(
                            (pt) =>
                            {
                                Exit e = m_Session.UniqueMaps.ArmyBase.TheMap.GetExitAt(pt);
                                if (e == null)
                                    return false;
                                return e.ToMap == surfaceMap;
                            });
                        if (armyBaseExit == null)
                            throw new InvalidOperationException("could not find exit to surface in army base map");
                        Exit fromArmyBase = m_Session.UniqueMaps.ArmyBase.TheMap.GetExitAt(armyBaseExit.Value);
                        fromArmyBase.IsAnAIExit = true;
                    }
                }
            }
#endregion

#endregion

#region Item interactions
            // 1. Subway Worker Badge in Subway maps.
            //    conditions: In Subway, Must be Equipped, Next to closed gates.
            //    effects: Turn all generators on.
            if (m_Session.UniqueItems.TheSubwayWorkerBadge.TheItem.IsEquipped &&
                player.Location.Map == player.Location.Map.District.SubwayMap &&
                player.Inventory.Contains(m_Session.UniqueItems.TheSubwayWorkerBadge.TheItem))
            {
                // must be adjacent to closed gates.
                Map map = player.Location.Map;
                if (map.HasAnyAdjacentInMap(player.Location.Position, (pt) =>
                {
                    MapObject obj = map.GetMapObjectAt(pt);
                    if (obj == null)
                        return false;
                    return obj.ImageID == GameImages.OBJ_GATE_CLOSED;
                }))
                {
                    // turn all power on!
                    DoTurnAllGeneratorsOn(map);

                    // message.
                    AddMessage(new Message("The gate system scanned your badge and turned the power on!", m_Session.WorldTime.TurnCounter, Color.Green));
                }
            }
#endregion

#region Generic 1st time flags
            // 1. Visiting a new map.
            if (!m_Session.Scoring.HasVisited(player.Location.Map))
            {
                // visit.
                m_Session.Scoring.AddVisit(player.Location.Map); //@@MP - unused parameter (Release 5-7)
                m_Session.Scoring.AddEvent(m_Session.WorldTime.TurnCounter, String.Format("Visited {0}.", player.Location.Map.Name));
            }

            // 2. Sighting an actor model.
            foreach (Point p in m_PlayerFOV)
            {
                Actor a = player.Location.Map.GetActorAt(p);
                if (a == null)
                    continue;
                m_Session.Scoring.AddSighting(a.Model.ID, m_Session.WorldTime.TurnCounter);
                // alpha10 unique npcs lose their invincibility when sighted and highlight them.
                if (a.IsUnique)
                {
                    if (a.IsInvincible)  // 1st sighting
                    {
                        PlayUniqueActorMusicAndMessage(m_Session.ActorToUniqueActor(a), false);
                        a.IsInvincible = false;
                    }
                }
            }
#endregion
        }
#endregion
#endregion

#region -DESCRIBING GAME ELEMENTS
        string[] DescribeStuffAt(Map map, Point mapPos)
        {
            // Actor?
            Actor actor = map.GetActorAt(mapPos);
            if (actor != null)
            {
                return DescribeActor(actor);
            }

            // Object/Items?
            MapObject obj = map.GetMapObjectAt(mapPos);
            if (obj != null)
            {
                return DescribeMapObject(obj, map, mapPos);
            }

            // Items?
            Inventory inv = map.GetItemsAt(mapPos);
            if (inv != null && !inv.IsEmpty)
            {
                return DescribeInventory(inv);
            }

            // Corpses?
            List<Corpse> corpses = map.GetCorpsesAt(mapPos);
            if (corpses != null)
            {
                return DescribeCorpses(corpses);
            }

            // Nothing to describe!
            return null;
        }

        string[] DescribeActor(Actor actor)
        {
            List<string> lines = new List<string>(10);

            // 1. Name-Faction(Gang), Model, SpawnTime, Order & Leader(trust if player), (Murder counter if player law enforcer);
            //    Enemy & Self-Defence.
            if (actor.Faction != null)
            {
                if (actor.IsInAGang)
                    lines.Add(String.Format("{0}, {1}-{2}.", Capitalize(actor.Name), actor.Faction.MemberName, GameGangs.NAMES[actor.GangID]));
                else
                    lines.Add(String.Format("{0}, {1}.", Capitalize(actor.Name), actor.Faction.MemberName));
            }
            else
                lines.Add(String.Format("{0}.", Capitalize(actor.Name)));

            //@@MP - also describe their courage (Release 6-6)
            if (!actor.IsPlayer)
            {
                ActorDirective directives = (actor.Controller as AIController).Directives;
                if (directives != null)
                {
                    string courage = directives.Courage.ToString();
                    string display = "unpredicatable";
                    switch (courage)
                    {
                        case "COWARD": display = "cowardly"; break;
                        case "CAUTIOUS": display = "cautious"; break;
                        case "COURAGEOUS": display = "courageous"; break;
                        default: break;
                    }
                    lines.Add(String.Format("{0} ({1}).", Capitalize(actor.Model.Name), display));
                }
                else
                    lines.Add(String.Format("{0}.", Capitalize(actor.Model.Name)));
            }

            lines.Add(String.Format("{0} since {1}.", actor.Model.Abilities.IsUndead ? "Undead" : "Still alive", new WorldTime(actor.SpawnTime).ToString()));
            AIController ai = actor.Controller as AIController;
            if (ai != null && ai.Order != null)
            {
                lines.Add(String.Format("Order : {0}.", ai.Order.ToString()));
            }
            if (actor.HasLeader)
            {
                if (actor.Leader.IsPlayer)
                {
                    if (actor.TrustInLeader >= Rules.TRUST_BOND_THRESHOLD)
                        lines.Add(String.Format("Trust : BOND."));
                    else if (actor.TrustInLeader >= Rules.TRUST_MAX)
                        lines.Add("Trust : MAX.");
                    else
                        lines.Add(String.Format("Trust : {0}/T:{1}-B:{2}.", actor.TrustInLeader, Rules.TRUST_TRUSTING_THRESHOLD, Rules.TRUST_BOND_THRESHOLD));
                    OrderableAI orderAI = ai as OrderableAI;
                    if (orderAI != null)
                    {
                        if (orderAI.DontFollowLeader)
                            lines.Add("Ordered to not follow you.");
                    }
                    // gauges.
                    lines.Add(String.Format("Foo : {0} {1}h", actor.FoodPoints, FoodToHoursUntilHungry(actor.FoodPoints)));
                    lines.Add(String.Format("Slp : {0} {1}h", actor.SleepPoints, m_Rules.SleepToHoursUntilSleepy(actor.SleepPoints, actor.Location.Map.LocalTime.IsNight)));
                    if (s_Options.IsSanityEnabled) lines.Add(String.Format("San : {0} {1}h", actor.Sanity, m_Rules.SanityToHoursUntilUnstable(actor)));
                    if (Rules.HasInfection(m_Session.GameMode)) lines.Add(String.Format("Inf : {0} {1}%", actor.Infection, m_Rules.ActorInfectionPercent(actor)));
                }
                else
                    lines.Add(String.Format("Leader : {0}.", Capitalize(actor.Leader.Name)));
            }

            // show murder counter if trusting follower or player is a law enforcer.
            if (actor.MurdersCounter > 0 && m_Player.Model.Abilities.IsLawEnforcer)
            {
                lines.Add("WANTED FOR MURDER!");
                lines.Add(String.Format("{0} murder{1}!", actor.MurdersCounter, actor.MurdersCounter > 1 ? "s" : ""));
            }
            else if (actor.HasLeader && actor.Leader.IsPlayer && m_Rules.IsActorTrustingLeader(actor))
            {
                if (actor.MurdersCounter > 0)
                    lines.Add(String.Format("* Confess {0} murder{1}! *", actor.MurdersCounter, actor.MurdersCounter > 1 ? "s" : ""));
                else
                    lines.Add("Has committed no murders.");
            }
            if (actor.IsAggressorOf(m_Player))
                lines.Add("Aggressed you.");
            if (m_Player.IsSelfDefenceFrom(actor))
                lines.Add(String.Format("You can kill {0} in self-defence.", HimOrHer(actor)));
            if (m_Player.IsAggressorOf(actor))
                lines.Add(String.Format("You aggressed {0}.", HimOrHer(actor)));
            if (actor.IsSelfDefenceFrom(m_Player))
                lines.Add("Killing you would be self-defence.");
            if (!m_Player.Faction.IsEnemyOf(actor.Faction) && m_Rules.AreGroupEnemies(m_Player, actor)) // alpha10 modified: indirect enemies, eg enemy of leader with group means his followers are indirect enemies too
                lines.Add("You are enemies through groups.");

            lines.Add("");

            // 2. Activity & Hunger/Sleep/Sanity
            string activityLine = DescribeActorActivity(actor);
            if (activityLine != null)
                lines.Add(activityLine);
            else
                lines.Add(" ");  // blank activity line
            if (actor.Model.Abilities.HasToSleep)
            {
                if (actor.IsIncapacitated) //@@MP (Release7-2)
                    lines.Add("Stunned!");
                else if (m_Rules.IsActorExhausted(actor))
                    lines.Add("Exhausted.");
                else if (m_Rules.IsActorSleepy(actor))
                    lines.Add("Sleepy.");
            }
            if (actor.Model.Abilities.HasToEat) //@@MP - added intoxication (Release 7-2)
            {
                if (m_Rules.IsActorStarving(actor))
                    lines.Add("Starving! " + actor.GetIntoxicationDescription());
                else if (m_Rules.IsActorReallyHungry(actor)) //@@MP (Release 7-1)
                    lines.Add("Famished. " + actor.GetIntoxicationDescription());
                else if (m_Rules.IsActorHungry(actor))
                    lines.Add("Hungry. " + actor.GetIntoxicationDescription());
                if (actor.IsFoodPoisoned && (actor.Leader == m_Player || actor.IsPlayer)) //@@MP (Release 7-6)
                    lines.Add("Unwell: food poisoning.");
            }
            else if (actor.Model.Abilities.IsRotting)
            {
                if (m_Rules.IsRottingActorStarving(actor))
                    lines.Add("Starving!");
                else if (m_Rules.IsRottingActorHungry(actor))
                    lines.Add("Hungry.");
            }
            if (actor.Model.Abilities.HasSanity)
            {
                if (m_Rules.IsActorInsane(actor))
                    lines.Add("Insane!");
                else if (m_Rules.IsActorDisturbed(actor))
                    lines.Add("Disturbed.");
            }

            // 3. Speed
            lines.Add(String.Format("Spd : {0:F2}", (float)m_Rules.ActorSpeed(actor) / (float)Rules.BASE_SPEED));

            // 4. HP & STA.
            StringBuilder sb = new StringBuilder();
            int maxHP = m_Rules.ActorMaxHPs(actor);
            if (actor.HitPoints != maxHP)
                sb.Append(String.Format("HP  : {0:D2}/{1:D2}", actor.HitPoints, maxHP));
            else
                sb.Append(String.Format("HP  : {0:D2} MAX", actor.HitPoints));
            if (actor.Model.Abilities.CanTire)
            {
                int maxSTA = m_Rules.ActorMaxSTA(actor);
                if (actor.StaminaPoints != maxSTA)
                    sb.Append(String.Format("   STA : {0}/{1}", actor.StaminaPoints, maxSTA));
                else
                    sb.Append(string.Format("   STA : {0} MAX", actor.StaminaPoints));
            }
            lines.Add(sb.ToString());

            // 5. Attack, Dmg, Defence.
            Attack attack = m_Rules.ActorMeleeAttack(actor, actor.CurrentMeleeAttack, null);
            lines.Add(String.Format("Atk : {0:D2} Dmg : {1:D2}", attack.HitValue, attack.DamageValue));
            Defence defence = m_Rules.ActorDefence(actor, actor.CurrentDefence);
            lines.Add(String.Format("Def : {0:D2}", defence.Value));
            lines.Add(String.Format("Arm : {0}/{1}", defence.Protection_Hit, defence.Protection_Shot));
            lines.Add(" ");

            // 6. Flavor
            lines.Add(actor.Model.FlavorDescription);
            lines.Add(" ");

            // 7. Skills
            if (actor.Sheet.SkillTable != null && actor.Sheet.SkillTable.CountSkills > 0)
            {
                foreach (Skill sk in actor.Sheet.SkillTable.Skills)
                    lines.Add(String.Format("{0}-{1}", sk.Level, Skills.Name(sk.ID)));
                lines.Add(" ");
            }

            // alpha10
            // 8. Unusual abilities
            // unusual abilities for undeads
            if (actor.Model.Abilities.IsUndead)
            {
                // fov
                lines.Add(string.Format("- FOV : {0}.", actor.Model.StartingSheet.BaseViewRange));

                // smell rating
                int smell = (int)(100 * m_Rules.ActorSmell(actor));  // appliyes z-tracker skill
                lines.Add(
                    smell == 0 ? "- Has no sense of smell." :
                    smell < 50 ? "- Has poor sense of smell." :
                    smell < 100 ? "- Has good sense of smell." :
                    "- Has excellent sense of smell.");

                // grab?
                if (actor.Sheet.SkillTable.GetSkillLevel((int)Skills.IDs.Z_GRAB) > 0)
                    lines.Add("- Z-Grab : this undead can grab its victims.");

                if (actor.Model.Abilities.IsUndeadMaster) lines.Add("- Other undeads will follow this one.");
                else if (smell > 0) lines.Add("- This undead will follow Zombie Masters.");
                if (actor.Model.Abilities.IsIntelligent) lines.Add("- This undead is intelligent.");
                if (actor.Model.Abilities.CanDisarm) lines.Add("- This undead can disarm.");
                if (actor.Model.Abilities.CanJump)
                {
                    if (actor.Model.Abilities.CanJumpStumble) lines.Add("- This undead can jump but may stumble.");
                    else lines.Add("- This undead can jump.");
                }
                if (m_Rules.HasActorPushAbility(actor)) lines.Add("- This undead can push.");
                if (actor.Model.Abilities.ZombieAI_Explore) lines.Add("- This undead will hunt.");

                // things some of them cannot do
                if (!actor.Model.Abilities.IsRotting) lines.Add("- This undead will not rot.");
                if (!actor.Model.Abilities.CanBashDoors) lines.Add("- This undead cannot bash doors.");
                if (!actor.Model.Abilities.CanBreakObjects) lines.Add("- This undead cannot break objects.");
                if (!actor.Model.Abilities.CanZombifyKilled) lines.Add("- This undead cannot infect livings.");
                if (!actor.Model.Abilities.AI_CanUseAIExits) lines.Add("- This undead live in this map.");
            }
            // misc unusual abilities
            if (actor.Model.Abilities.IsLawEnforcer) lines.Add("- Is a law enforcer.");
            if (actor.Model.Abilities.IsSmall) lines.Add("- Is small and can sneak through things.");

            // 9. Inventory.
            if (actor.Inventory != null && !actor.Inventory.IsEmpty)
            {
                lines.Add(String.Format("Items {0}/{1} : ", actor.Inventory.CountItems, m_Rules.ActorMaxInv(actor)));
                lines.AddRange(DescribeInventory(actor.Inventory));
            }

            // done.
            return lines.ToArray();
        }

        static string DescribeActorActivity(Actor actor) //@@MP - made static (Release 5-7)
        {
            if (actor.IsPlayer)
                return null;

            switch (actor.Activity)
            {
                case Activity.IDLE:
                    return null;

                case Activity.CHASING:
                    if (actor.TargetActor == null)
                        return "Chasing!";
                    else
                        return String.Format("Chasing {0}!", actor.TargetActor.Name);

                case Activity.FIGHTING:
                    if (actor.TargetActor == null)
                        return "Fighting!";
                    else
                        return String.Format("Fighting {0}!", actor.TargetActor.Name);

                case Activity.TRACKING:
                    return "Tracking!";

                case Activity.FLEEING:
                    return "Fleeing!";

                case Activity.FLEEING_FROM_EXPLOSIVE:
                    return "Fleeing from explosives!";

                case Activity.FOLLOWING:
                    if (actor.TargetActor == null)
                        return "Following.";
                    else
                    {
                        // alpha10
                        if (actor.Leader == actor.TargetActor)
                            return string.Format("Following {0} leader.", HisOrHer(actor));
                        return string.Format("Following {0}.", actor.TargetActor.Name);
                    }

                case Activity.FOLLOWING_ORDER:
                    return "Following orders.";

                case Activity.SLEEPING:
                    return "Sleeping.";

                case Activity.FISHING:  //@@MP (Release 7-6)
                    return "Fishing.";

                case Activity.COOKING:  //@@MP (Release 7-6)
                    return "Cooking.";

                case Activity.HUNTING:  //@@MP (Release 7-6)
                    return "Hunting animals.";

                case Activity.EATING:  //@@MP (Release 6-6)
                    return "Eating.";

                case Activity.EXPLORING:
                    return "Exploring.";

                case Activity.WANDERING:
                    return "Wandering.";

                case Activity.FINDING_EXIT:
                    return "Leaving.";

                case Activity.HEALING:
                    return "Treating wounds.";

                case Activity.WAITING:
                    return "Waiting.";

                case Activity.PATROLLING:
                    return "Patrolling.";

                case Activity.CHATTING:
                    return "Chatting.";

                case Activity.REVIVING:
                    return "Reviving.";

                case Activity.BUILDING:
                    return "Constructing.";

                case Activity.MANAGING_INVENTORY:
                    return "Managing inventory.";

                case Activity.TRADING:
                    return "Trading.";

                case Activity.SEARCHING:
                    return "Searching for food.";

                case Activity.SHOUTING:
                    return "Shouting.";

                case Activity.DESTROYING:
                    return "Destroying something.";

                case Activity.RESTING:
                    return "Resting.";

                default:
                    throw new ArgumentException("unhandled activity " + actor.Activity);
            }
        }

        static string DescribePlayerFollowerStatus(Actor follower) //@@MP - made static (Release 5-7)
        {
            string desc;

            BaseAI foAI = follower.Controller as BaseAI;
            if (foAI.Order == null)
                desc = "(no orders)";
            else
                desc = foAI.Order.ToString();
            desc += String.Format("(trust:{0})", follower.TrustInLeader);

            return desc;
        }

        string[] DescribeMapObject(MapObject obj, Map map, Point mapPos)
        {
            List<string> lines = new List<string>(4);

            // 1. Name and description (if any)
            lines.Add(String.Format("{0}.", obj.AName));
            if (!(String.IsNullOrEmpty(obj.HoverDescription)))  //@@MP (Release 7-6)
                lines.Add(String.Format("{0}", obj.HoverDescription));

            // 2. Special flags.
            if (obj.IsJumpable)
                lines.Add("Can be jumped on.");
            if (obj.IsCouch)
                lines.Add("Is a couch.");
            if (obj.GivesWood)
                lines.Add("Can be dismantled for wood.");
            if (obj.IsMovable)
                lines.Add("Can be moved.");
            if (obj.StandOnFovBonus)
                lines.Add("Increases view range.");

            // 3. Common Status: Break, Fire.
            //    Concrete MapObjects status.
            StringBuilder sb = new StringBuilder();
            if (obj.BreakState == MapObject.Break.BROKEN)
                sb.Append("Broken! ");
            if (obj.FireState == MapObject.Fire.ONFIRE)
                sb.Append("On fire! ");
            else if (obj.FireState == MapObject.Fire.ASHES)
                sb.Append("Burnt to ashes! ");
            lines.Add(sb.ToString());
            if (obj is PowerGenerator)
            {
                PowerGenerator powGen = obj as PowerGenerator;
                if (powGen.IsOn)
                    lines.Add("Currently ON.");
                else
                    lines.Add("Currently OFF.");
                float powerRatio = m_Rules.ComputeMapPowerRatio(obj.Location.Map);
                lines.Add(String.Format("The power gauge reads {0}%.", (int)(100 * powerRatio)));
            }
            else if (obj is Board)
            {
                lines.Add("The text reads : ");
                lines.AddRange((obj as Board).Text);
            }
            else if (obj is Car) //@@MP (Release 7-1)
            {
                Car car = obj as Car;
                lines.Add(String.Format("Fuel      : {0}/{1}", car.FuelUnits.ToString(), car.MaxFuelUnits.ToString()));
            }
            else if (obj is Barrel) //@@MP (Release 7-6)
            {
                Barrel barrel = obj as Barrel;
                lines.Add(String.Format("Wood      : {0}/{1}", barrel.FuelUnits.ToString(), barrel.MaxFuelUnits.ToString()));
            }
            else if (obj is Campfire) //@@MP (Release 7-6)
            {
                Campfire campfire = obj as Campfire;
                lines.Add(String.Format("Wood      : {0}/{1}", campfire.FuelUnits.ToString(), campfire.MaxFuelUnits.ToString()));
            }

            // 4. HitPoints & Barricade
            if (obj.MaxHitPoints > 0)
            {
                if (obj.HitPoints < obj.MaxHitPoints)
                    lines.Add(String.Format("HP        : {0}/{1}", obj.HitPoints, obj.MaxHitPoints));
                else
                    lines.Add(String.Format("HP        : {0} [MAX]", obj.HitPoints));

                DoorWindow door = obj as DoorWindow;
                if (door != null)
                {
                    if (door.BarricadePoints < Rules.BARRICADING_MAX)
                        lines.Add(String.Format("Barricades: {0}/{1}", door.BarricadePoints, Rules.BARRICADING_MAX));
                    else
                        lines.Add(String.Format("Barricades: {0} [MAX]", door.BarricadePoints));
                }
            }

            // 5. Weight?
            if (obj.Weight > 0)
            {
                lines.Add(String.Format("Weight    : {0}", obj.Weight));
            }

            // 6. Items there
            Inventory inv = map.GetItemsAt(mapPos);
            if (inv != null && !inv.IsEmpty)
            {
                lines.AddRange(DescribeInventory(inv));
            }

            return lines.ToArray();
        }

        string[] DescribeInventory(Inventory inv)
        {
            List<string> lines = new List<string>(inv.CountItems);

            foreach (Item it in inv.Items)
            {
                if (it.IsEquipped)
                    lines.Add(String.Format("- {0} (equipped)", DescribeItemShort(it)));
                else
                    lines.Add(String.Format("- {0}", DescribeItemShort(it)));
            }

            return lines.ToArray();
        }

        static string[] DescribeCorpses(List<Corpse> corpses) //@@MP - made static (Release 5-7)
        {
            List<string> lines = new List<string>(corpses.Count + 2);

            if (corpses.Count > 1)
                lines.Add("There are corpses there...");
            else
                lines.Add("There is a corpse here.");
            lines.Add(" ");

            foreach (Corpse c in corpses)
            {
                lines.Add(String.Format("- Corpse of {0}.", c.DeadGuy.Name));
            }
            return lines.ToArray();
        }

        string[] DescribeCorpseLong(Corpse c, bool isInPlayerTile)
        {
            List<string> lines = new List<string>(10);

            // 1. Corpse of XXX
            lines.Add(String.Format("Corpse of {0}.", c.DeadGuy.Name));
            lines.Add(" ");

            // 2. Necrology infos.
            int necrology = m_Player.Sheet.SkillTable.GetSkillLevel((int)Skills.IDs.NECROLOGY);

            string deadSince = "<need Necrology 1>";
            if (necrology > 0) deadSince = WorldTime.MakeTimeDurationMessage(m_Session.WorldTime.TurnCounter - c.Turn);
            lines.Add(String.Format("Death  : {0}", deadSince));
            lines.Add(String.Format("Cause  : {0}", c.DeadGuy.CauseOfDeath));

            if (Rules.HasInfection(m_Session.GameMode)) //@MP - because I gave the option to enable corpses in STD mode (Release 1)
            {
                string infectionEst = String.Format("<need Necrology {0}>", Rules.SKILL_NECROLOGY_LEVEL_FOR_INFECTION);
                if (necrology >= Rules.SKILL_NECROLOGY_LEVEL_FOR_INFECTION)
                {
                    int infectionP = m_Rules.ActorInfectionPercent(c.DeadGuy);
                    if (infectionP == 0) infectionEst = "0/7 - none";
                    else if (infectionP < 5) infectionEst = "1/7 - traces";
                    else if (infectionP < 15) infectionEst = "2/7 - minor";
                    else if (infectionP < 30) infectionEst = "3/7 - low";
                    else if (infectionP < 55) infectionEst = "4/7 - average";
                    else if (infectionP < 70) infectionEst = "5/7 - important";
                    else if (infectionP < 99) infectionEst = "6/7 - great";
                    else infectionEst = "7/7 - total";
                }
                lines.Add(String.Format("Infection : {0}", infectionEst));

                string riseEst = String.Format("<need Necrology> {0}>", Rules.SKILL_NECROLOGY_LEVEL_FOR_RISE);
                if (necrology >= Rules.SKILL_NECROLOGY_LEVEL_FOR_RISE)
                {
                    int riseP = 2 * m_Rules.CorpseZombifyChance(c, c.DeadGuy.Location.Map.LocalTime, false);
                    if (riseP < 5) riseEst = "0/6 - extremely unlikely";
                    else if (riseP < 20) riseEst = "1/6 - unlikely";
                    else if (riseP < 40) riseEst = "2/6 - possible";
                    else if (riseP < 60) riseEst = "3/6 - likely";
                    else if (riseP < 80) riseEst = "4/6 - very likely";
                    else if (riseP < 99) riseEst = "5/6 - most likely";
                    else riseEst = "6/6 - certain";
                }
                lines.Add(String.Format("Rise   : {0}", riseEst));
                lines.Add(" ");
            }

            // 3. Decay
            int rotLevel = Rules.CorpseRotLevel(c);
            switch (rotLevel)
            {
                case 5: lines.Add("The corpse is about to crumble to dust."); break;
                case 4: lines.Add("The corpse is almost entirely rotten."); break;
                case 3: lines.Add("The corpse is badly damaged."); break;
                case 2: lines.Add("The corpse is damaged."); break;
                case 1: lines.Add("The corpse is bruised and smells."); break;
                case 0: lines.Add("The corpse looks fresh."); break;
                default: throw new ArgumentException("unhandled rot level", "c");
            }

            // 4. Medic info.
            string reviveEst = String.Format("<need Medic {0}>", Rules.SKILL_MEDIC_LEVEL_FOR_REVIVE_EST);
            int medic = m_Player.Sheet.SkillTable.GetSkillLevel((int)Skills.IDs.MEDIC);
            if (medic >= Rules.SKILL_MEDIC_LEVEL_FOR_REVIVE_EST)
            {
                int reviveP = m_Rules.CorpseReviveChance(m_Player, c);
                if (reviveP == 0) reviveEst = "impossible";
                else if (reviveP < 5) reviveEst = "0/6 - extremely unlikely";
                else if (reviveP < 20) reviveEst = "1/6 - unlikely";
                else if (reviveP < 40) reviveEst = "2/6 - possible";
                else if (reviveP < 60) reviveEst = "3/6 - likely";
                else if (reviveP < 80) reviveEst = "4/6 - very likely";
                else if (reviveP < 99) reviveEst = "5/6 - most likely";
                else reviveEst = "6/6 - certain";
            }
            lines.Add(String.Format("Revive : {0}.", reviveEst));

            // 5. Special keys.
            if (isInPlayerTile)
            {
                lines.Add(" ");
                lines.Add("----");
                lines.Add("LMB to start/stop dragging.");
                lines.Add(String.Format("RMB to {0}.", m_Player.Model.Abilities.IsUndead ? "eat" : "butcher"));
                if (!m_Player.Model.Abilities.IsUndead)
                {
                    lines.Add(String.Format("to eat: <{0}>", s_KeyBindings.GetFriendlyFormat(PlayerCommand.EAT_CORPSE).ToString()));
                    lines.Add(String.Format("to revive : <{0}>", s_KeyBindings.GetFriendlyFormat(PlayerCommand.REVIVE_CORPSE).ToString()));
                    lines.Add(String.Format("to bury : <{0}>", s_KeyBindings.GetFriendlyFormat(PlayerCommand.BURY_CORPSE).ToString()));
                }
            }

            return lines.ToArray();
        }

#region --Items
        string DescribeItemShort(Item it)
        {
            string name = it.Quantity > 1 ? it.Model.PluralName : it.AName;

            if (it is ItemFood)
            {
                ItemFood food = it as ItemFood;
                if (m_Rules.IsFoodSpoiled(food, m_Session.WorldTime.TurnCounter))
                    name += " (spoiled)";
                else if (m_Rules.IsFoodExpired(food, m_Session.WorldTime.TurnCounter))
                    name += " (expired)";
            }
            else if (it is ItemRangedWeapon)
            {
                ItemRangedWeapon rw = it as ItemRangedWeapon;
                name += String.Format(" ({0}/{1})", rw.Ammo, (rw.Model as ItemRangedWeaponModel).MaxAmmo);
            }
            else if (it is ItemTrap)
            {
                ItemTrap trap = it as ItemTrap;
                if (trap.IsActivated) name += "(activated)";
                if (trap.IsTriggered) name += "(triggered)";
                if (trap.Owner == m_Player) name += "(yours)";  // alpha10
            }

            if (it.Quantity > 1)
                return String.Format("{0} {1}", it.Quantity, name);
            else
                return name;
        }

        string[] DescribeItemLong(Item it, bool isPlayerInventory, int iSlot, bool isBackpackInventory = false) // alpha 10 added iSlot      //@@MP - added isBackpackInventory (Release 8-2)
        {
            List<string> lines = new List<string>();
            bool isDefaultUse = true; // alpha10

            // 1. Name & stacking.
            if (it.Model.IsStackable)
            {
                lines.Add(String.Format("{0} {1}/{2}", DescribeItemShort(it), it.Quantity, it.Model.StackingLimit));
            }
            else
                lines.Add(DescribeItemShort(it));

            // for backpack inventory cut the description short             //@@MP - added (Release 8-2)
            if (isBackpackInventory)
            {
                lines.Add(" ");
                lines.Add("----");
                lines.Add(String.Format("to destroy : <{0}>", s_KeyBindings.GetFriendlyFormat(PlayerCommand.DESTROY_ITEM).ToString()));
                lines.Add(String.Format("to move to inventory : <{0}>", s_KeyBindings.GetFriendlyFormat(PlayerCommand.SWAP_INVENTORY).ToString()));

                // done.
                return lines.ToArray();
            }

            // 2. Special flags.
            // unbreakable?
            if (it.Model.IsUnbreakable)
            {
                lines.Add("Unbreakable.");
            }
            if (it is ItemRangedWeapon) //@@MP - added extra info, to make it clear why their DMG stat is so low (Release 7-6)
            {
                if ((it as ItemRangedWeapon).Model.IsFlameWeapon)
                    lines.Add("Sets enemies on fire.");
                if ((it as ItemRangedWeapon).Model.CausesTileFires) //@@MP (Release 7-6)
                    lines.Add("Sets tiles on fire.");
            }
            else if (it is ItemExplosive)
            {
                if ((it as ItemExplosive).Model.IsFlameWeapon)
                    lines.Add("Sets enemies on fire.");
                if ((it as ItemExplosive).Model.CausesTileFires) //@@MP (Release 7-6)
                    lines.Add("Sets tiles on fire.");
            }
            if (it.IsForbiddenToAI)  //@@MP (Release 7-6)
            {
                lines.Add("NPCs aren't interested in this item.");
            }

            // 3. Item specific stuff...
            string inInvAdditionalDesc = null;
            if (it is ItemWeapon)
            {
                lines.AddRange(DescribeItemWeapon(it as ItemWeapon));
                ItemRangedWeapon rwp = it as ItemRangedWeapon; //@@MP - removed unecessary cast (Release 6-1)
                if (rwp != null)
                {
                    isDefaultUse = false;
                    inInvAdditionalDesc = String.Format("to fire : <{0}>", s_KeyBindings.GetFriendlyFormat(PlayerCommand.FIRE_MODE).ToString());
                    //if (rwp.IsEquipped) //@@MP (Release 7-6)
                        inInvAdditionalDesc = String.Format("to unload ammo : <{0}>", s_KeyBindings.GetFriendlyFormat(PlayerCommand.UNLOAD_AMMO).ToString());
                }
            }
            else if (it is ItemFood)
            {
                lines.AddRange(DescribeItemFood(it as ItemFood));
                if ((it as ItemFood).CanBeCooked)
                    inInvAdditionalDesc = String.Format("to cook : <{0}>", s_KeyBindings.GetFriendlyFormat(PlayerCommand.COOK_FOOD).ToString());
            }
            else if (it is ItemMedicine)
            {
                lines.AddRange(DescribeItemMedicine(it as ItemMedicine));
            }
            else if (it is ItemBarricadeMaterial)
            {
                lines.AddRange(DescribeItemBarricadeMaterial(it as ItemBarricadeMaterial));
                isDefaultUse = false;
                inInvAdditionalDesc = String.Format("to build : <{0}>",
                    s_KeyBindings.GetFriendlyFormat(PlayerCommand.BUILD_MODE).ToString());
            }
            else if (it is ItemBodyArmor)
            {
                lines.AddRange(DescribeItemBodyArmor(it as ItemBodyArmor));
            }
            else if (it is ItemSprayPaint)
            {
                lines.AddRange(DescribeItemSprayPaint(it as ItemSprayPaint));
                isDefaultUse = false;
                inInvAdditionalDesc = String.Format("to spray : <{0}>", s_KeyBindings.GetFriendlyFormat(PlayerCommand.USE_SPRAY).ToString());
            }
            else if (it is ItemSprayScent)
            {
                lines.AddRange(DescribeItemSprayScent(it as ItemSprayScent));
                isDefaultUse = false;
                inInvAdditionalDesc = String.Format("to spray : <{0}>", s_KeyBindings.GetFriendlyFormat(PlayerCommand.USE_SPRAY).ToString());
            }
            else if (it is ItemLight)
            {
                lines.AddRange(DescribeItemLight(it as ItemLight));
            }
            else if (it is ItemTracker)
            {
                lines.AddRange(DescribeItemTracker(it as ItemTracker));
            }
            else if (it is ItemAmmo)
            {
                lines.AddRange(DescribeItemAmmo(it as ItemAmmo));
                isDefaultUse = false;
                inInvAdditionalDesc = string.Format("to reload : <LMB> or <Ctrl-{0}>", iSlot + 1);
            }
            else if (it is ItemExplosive)
            {
                lines.AddRange(DescribeItemExplosive(it as ItemExplosive));
                inInvAdditionalDesc = String.Format("to throw : <{0}>", s_KeyBindings.GetFriendlyFormat(PlayerCommand.FIRE_MODE).ToString());
            }
            else if (it is ItemTrap)
            {
                lines.AddRange(DescribeItemTrap(it as ItemTrap));
                // alpha10
                if ((it as ItemTrap).TrapModel.ActivatesWhenDropped)
                    inInvAdditionalDesc = "to activate trap : drop it";
                else
                    inInvAdditionalDesc = "to activate trap : use it";
            }
            else if (it is ItemEntertainment)
            {
                lines.AddRange(DescribeItemEntertainment(it as ItemEntertainment));
            }
            else if (m_Rules.IsItemLiquorForMolotov(it)) //@@MP (Release 7-1)
            {
                inInvAdditionalDesc = "to make molotov : Use it";
            }
            else if (isPlayerInventory && it.Model.EquipmentPart == DollPart.LEFT_ARM) //@@MP - assume LeftArm == shield (Release 7-2)
            {
                it.Model.FlavorDescription = String.Format("{0}% total chance to block (including skill)", m_Rules.ActorShieldChanceToBlock(m_Player).ToString());
            }
            else if (isPlayerInventory && it.Model == GameItems.FISHING_ROD) //@@MP (Release 7-6)
            {
                inInvAdditionalDesc = String.Format("to fish : <{0}> or <{1}>", s_KeyBindings.GetFriendlyFormat(PlayerCommand.WAIT_LONG).ToString(), s_KeyBindings.GetFriendlyFormat(PlayerCommand.WAIT_OR_SELF).ToString());
            }
            else if (isPlayerInventory && it.Model == GameItems.MATCHES) //@@MP (Release 7-6)
            {
                inInvAdditionalDesc = String.Format("to start a fire : <{0}>", s_KeyBindings.GetFriendlyFormat(PlayerCommand.MAKE_COOKING_FIRE).ToString());
            }

            // 3. Flavor description
            lines.Add(" ");
            lines.Add(it.Model.FlavorDescription);

            // 4. Special keys.
            // alpha10 added more special keys very few players know about!
            if (isPlayerInventory)
            {
                lines.Add(" ");
                lines.Add("----");
                if (it.Model.IsEquipable)
                    lines.Add(string.Format("to {0} : <LMB> or <Ctrl-{1}>", it.IsEquipped ? "unequip" : "equip", iSlot + 1));
                else if (isDefaultUse)
                    lines.Add(string.Format("to use : <LMB> or <Ctrl-{0}>", iSlot + 1));
                if (!it.IsEquipped || it.Model.IsThrowable) //@@MP (Release 7-1)
                    lines.Add("to drop : <RMB>");
                lines.Add(String.Format("to give : <{0}>", s_KeyBindings.GetFriendlyFormat(PlayerCommand.GIVE_ITEM).ToString()));
                lines.Add(String.Format("to destroy : <{0}>", s_KeyBindings.GetFriendlyFormat(PlayerCommand.DESTROY_ITEM).ToString())); //@@MP (Release 7-6)
                if (it.Model.CanGoInBackpacks && m_Player.Inventory.HasItemOfType(typeof(ItemBackpack))) //@@MP (Release 8-2)
                    lines.Add(String.Format("to move to backpack : <{0}>", s_KeyBindings.GetFriendlyFormat(PlayerCommand.SWAP_INVENTORY).ToString()));
                if (inInvAdditionalDesc != null)
                    lines.Add(inInvAdditionalDesc);
            }
            else
            {
                lines.Add(" ");
                lines.Add("----");
                lines.Add(string.Format("to take : <LMB> or <Shift-{0}>", iSlot + 1));
            }

            // done.
            return lines.ToArray();
        }

        string[] DescribeItemExplosive(ItemExplosive ex)
        {
            List<string> lines = new List<string>();

            ItemExplosiveModel m = ex.Model as ItemExplosiveModel;
            ItemPrimedExplosive primed = ex as ItemPrimedExplosive;

            lines.Add("> explosive");

            // 1. Explosive attack.
            if (m.BlastAttack.CanDamageObjects)
                lines.Add("Can damage objects.");
            if (m.BlastAttack.CanDestroyWalls)
                lines.Add("Can destroy walls.");

            if (primed != null)
                lines.Add(String.Format("Fuse          : {0} turn(s) left!", primed.FuseTimeLeft));
            else
                lines.Add(String.Format("Fuse          : {0} turn(s)", m.FuseDelay));
            lines.Add(String.Format("Blast radius  : {0}", m.BlastAttack.Radius));

            // 2. Damage for each distance.
            StringBuilder sb = new StringBuilder();
            for (int blastRadius = 0; blastRadius <= m.BlastAttack.Radius; blastRadius++)
            {
                sb.Append(String.Format("{0};", m_Rules.BlastDamage(blastRadius, m.BlastAttack)));
            }
            lines.Add(String.Format("Blast damages : {0} (by ranges)", sb.ToString()));

            // 3. Specialized explosives.
            // grenade?
            ItemGrenade grenade = ex as ItemGrenade;
            if (grenade != null)
            {
                lines.Add("> grenade");

                ItemGrenadeModel greModel = grenade.Model as ItemGrenadeModel;
                int rng = m_Rules.ActorMaxThrowRange(m_Player, greModel.MaxThrowDistance);
                if (rng != greModel.MaxThrowDistance)
                    lines.Add(String.Format("Throwing rng  : {0} ({1})", rng, greModel.MaxThrowDistance));
                else
                    lines.Add(String.Format("Throwing rng  : {0}", rng));
            }

            // 4. Primed?
            if (primed != null)
            {
                lines.Add("PRIMED AND READY TO EXPLODE!");
            }

            return lines.ToArray();
        }

        static string[] DescribeItemWeapon(ItemWeapon w) //@@MP - made static (Release 5-7)
        {
            List<string> lines = new List<string>();

            ItemWeaponModel m = w.Model as ItemWeaponModel;

            lines.Add("> weapon");

            // 1. Attack
            lines.Add(String.Format("Atk : +{0}", m.Attack.HitValue));
            lines.Add(String.Format("Dmg : +{0}", m.Attack.DamageValue));
            // alpha10
            if (m.Attack.StaminaPenalty != 0)
                lines.Add(String.Format("Sta : -{0}", m.Attack.StaminaPenalty));
            if (m.Attack.DisarmChance != 0)
                lines.Add(String.Format("Disarm : +{0}%", m.Attack.DisarmChance));

            // 2. Melee vs Ranged items
            ItemMeleeWeapon mw = w as ItemMeleeWeapon;
            if (mw != null)
            {
                lines.Add(string.Format("Weight  : -{0:F2} SPD", 0.01f * mw.Weight)); //@@MP - added (Release 7-6)
                if (mw.IsFragile)
                    lines.Add("Breaks easily.");
                // alpha10, tools
                if (mw.IsTool)
                {
                    lines.Add("Is a tool.");
                    int toolBashDmg = mw.ToolBashDamageBonus;
                    if (toolBashDmg != 0)
                        lines.Add(string.Format("Tool Dmg   : +{0} = +{1}", toolBashDmg, toolBashDmg + m.Attack.DamageValue));
                    float toolBuild = mw.ToolBuildBonus;
                    if (toolBuild != 0)
                        lines.Add(string.Format("Tool Build : +{0}%", (int)(100 * toolBuild)));
                }
            }
            else
            {
                ItemRangedWeapon rw = w as ItemRangedWeapon;
                if (rw != null)
                {
                    ItemRangedWeaponModel rm = w.Model as ItemRangedWeaponModel;
                    lines.Add(string.Format("Weight  : -{0:F2} SPD", 0.01f * rm.Weight)); //@@MP - added (Release 7-6)
                    if (rm.IsFireArm)
                        lines.Add("> firearm");
                    else if (rm.IsBow)
                        lines.Add("> bow");
                    else
                        lines.Add("> ranged weapon");

                    if (rm.IsSingleShot) //@@MP - some weapons are not single-shot = can't rapid fire (Release 6-6)
                        lines.Add(string.Format("{0} cannot rapid fire", rm.SingleName));
                    else
                        lines.Add(string.Format("Rapid Fire Atk: {0} {1}", rm.RapidFireHit1Value, rm.RapidFireHit2Value)); // alpha10

                    lines.Add(string.Format("Range : {0}-{1} (efficient-max)", rm.Attack.EfficientRange, rm.Attack.Range)); //@@MP - reversed args to make more sense (release 6-6)
                    if (rw.Ammo < rm.MaxAmmo)
                        lines.Add(string.Format("Ammo : {0}/{1}", rw.Ammo, rm.MaxAmmo));
                    else
                        lines.Add(string.Format("Ammo : {0} MAX", rw.Ammo));
                    lines.Add(string.Format("Type : {0}", DescribeAmmoType(rm.AmmoType)));
                }
            }

            // done.
            return lines.ToArray();
        }

        static string DescribeAmmoType(AmmoType at) //@@MP - made static (Release 5-7)
        {
            switch (at)
            {
                case AmmoType.BOLT: return "crossbow bolts";
                case AmmoType.HEAVY_PISTOL: return "heavy pistol bullets";
                case AmmoType.HEAVY_RIFLE: return "heavy rifle bullets";
                case AmmoType.LIGHT_PISTOL: return "light pistol bullets";
                case AmmoType.LIGHT_RIFLE: return "light rifle bullets";
                case AmmoType.SHOTGUN: return "shotgun shells";
                case AmmoType.NAIL: return "nails"; //@MP (Release 5-1-1)
                case AmmoType.PRECISION_RIFLE: return "precision rifle rounds"; //@@MP (Release 6-6)
                case AmmoType.FUEL: return "fuel"; //@@MP (Release 7-1)
                case AmmoType.CHARGE: return "charges"; //@@MP (Release 7-2)
                case AmmoType.MINIGUN: return "minigun rounds"; //@@MP (Release 7-6)
                case AmmoType.GRENADES: return "launcher grenades"; //@@MP (Release 7-6)
                case AmmoType.PLASMA: return "plasma packs"; //@@MP (Release 7-6)
                default:
                    throw new ArgumentOutOfRangeException("at", "unhandled ammo type");
            }
        }

        static string[] DescribeItemAmmo(ItemAmmo am) //@@MP - made static (Release 5-7)
        {
            List<string> lines = new List<string>();

            lines.Add("> ammo");

            // 1. Ammo type
            lines.Add(string.Format("Type : {0}", DescribeAmmoType(am.AmmoType)));

            return lines.ToArray();
        }

        string[] DescribeItemFood(ItemFood f)
        {
            List<string> lines = new List<string>();

            ItemFoodModel m = f.Model as ItemFoodModel;

            lines.Add("> food");

            // 1. Fresh/Expired, Best-Before
            if (f.IsPerishable)
            {
                if (m_Rules.IsFoodStillFresh(f, m_Session.WorldTime.TurnCounter))
                    lines.Add("Fresh.");
                else if (m_Rules.IsFoodExpired(f, m_Session.WorldTime.TurnCounter))
                    lines.Add("*Expired*");
                else if (m_Rules.IsFoodSpoiled(f, m_Session.WorldTime.TurnCounter))
                    lines.Add("**SPOILED**");
                lines.Add(String.Format("Best-Before : {0}", f.BestBefore.ToString()));
            }
            else
                lines.Add("Always fresh.");


            // 2. Nutrition
            int nutrition = m_Rules.FoodItemNutrition(f, m_Session.WorldTime.TurnCounter);
            int nutritionForPlayer = (m_Player == null ? nutrition : m_Rules.ActorItemNutritionValue(m_Player, nutrition));
            if (nutritionForPlayer == m.Nutrition)
                lines.Add(String.Format("Nutrition   : +{0}", nutrition));
            else
                lines.Add(String.Format("Nutrition   : +{0} (+{1})", nutritionForPlayer, nutrition));

            // 3. Cooking progress                 //@@MP - added (Release 7-6)
            if (f.CanBeCooked)
            {
                double cookingProgress = (double)f.CookedDegree / f.MaxCookedDegree * 100;
                lines.Add(String.Format("Cooked   : {0}%", cookingProgress.ToString()));
            }

            return lines.ToArray();
        }

        string[] DescribeItemMedicine(ItemMedicine med)
        {
            List<string> lines = new List<string>();

            ItemMedicineModel m = med.Model as ItemMedicineModel;

            lines.Add("> medicine");

            // 1. Healing, STA, SLP
            // alpha10 dont add lines for zero values
            if (m.Healing != 0)
            {
                int healingForPlayer = (m_Player == null ? m.Healing : m_Rules.ActorMedicineEffect(m_Player, m.Healing));
                if (healingForPlayer == m.Healing)
                    lines.Add(String.Format("Healing : +{0}", m.Healing));
                else
                    lines.Add(String.Format("Healing : +{0} (+{1})", healingForPlayer, m.Healing));
            }

            if (m.StaminaBoost != 0)
            {
                int staminaForPlayer = (m_Player == null ? m.StaminaBoost : m_Rules.ActorMedicineEffect(m_Player, m.StaminaBoost));
                if (staminaForPlayer == m.StaminaBoost)
                    lines.Add(String.Format("Stamina : +{0}", m.StaminaBoost));
                else
                    lines.Add(String.Format("Stamina : +{0} (+{1})", staminaForPlayer, m.StaminaBoost));
            }

            if (m.SleepBoost != 0)
            {
                int sleepForPlayer = (m_Player == null ? m.SleepBoost : m_Rules.ActorMedicineEffect(m_Player, m.SleepBoost));
                if (sleepForPlayer == m.SleepBoost)
                    lines.Add(String.Format("Sleep   : +{0}", m.SleepBoost));
                else
                    lines.Add(String.Format("Sleep   : +{0} (+{1})", sleepForPlayer, m.SleepBoost));
            }

            if (m.SanityCure != 0)
            {
                int sanForPlayer = (m_Player == null ? m.SanityCure : m_Rules.ActorMedicineEffect(m_Player, m.SanityCure));
                if (sanForPlayer == m.SanityCure)
                    lines.Add(String.Format("Sanity  : +{0}", m.SanityCure));
                else
                    lines.Add(String.Format("Sanity  : +{0} (+{1})", sanForPlayer, m.SanityCure));
            }

            if (Rules.HasInfection(m_Session.GameMode))
            {
                if (m.InfectionCure != 0)
                {
                    int cureForPlayer = (m_Player == null ? m.InfectionCure : m_Rules.ActorMedicineEffect(m_Player, m.InfectionCure));
                    if (cureForPlayer == m.InfectionCure)
                        lines.Add(String.Format("Cure    : +{0}", m.InfectionCure));
                    else
                        lines.Add(String.Format("Cure    : +{0} (+{1})", cureForPlayer, m.InfectionCure));
                }
            }

            return lines.ToArray();
        }

        string[] DescribeItemBarricadeMaterial(ItemBarricadeMaterial bm)
        {
            List<string> lines = new List<string>();

            ItemBarricadeMaterialModel m = bm.Model as ItemBarricadeMaterialModel;

            lines.Add("> barricade material");

            // 1. Barricading value.
            int barForPlayer = (m_Player == null ? m.BarricadingValue : m_Rules.ActorBarricadingPoints(m_Player, m.BarricadingValue));
            if (barForPlayer == m.BarricadingValue)
                lines.Add(String.Format("Barricading : +{0}", m.BarricadingValue));
            else
                lines.Add(String.Format("Barricading : +{0} (+{1})", barForPlayer, m.BarricadingValue));

            return lines.ToArray();
        }

        string[] DescribeItemBodyArmor(ItemBodyArmor b)
        {
            List<string> lines = new List<string>();

            lines.Add("> body armor");

            // 1. Protection value.
            lines.Add(string.Format("Protection vs Hits  : +{0}", b.Protection_Hit));
            lines.Add(string.Format("Protection vs Shots : +{0}", b.Protection_Shot));
            lines.Add(string.Format("Encumbrance         : -{0} DEF", b.Encumbrance));
            lines.Add(string.Format("Weight              : -{0:F2} SPD", 0.01f * b.Weight));
            lines.Add(string.Format("Fire resistance     : +{0}%", b.Fire_Resistance));
            if (Rules.HasInfection(m_Session.GameMode))
                lines.Add(string.Format("INF resistance      : +{0}%", b.Infection_Resistance));

            // 2. Unsuspicious effects.
            List<string> unsuspicious = new List<string>();
            List<string> suspicious = new List<string>();
            if (b.IsFriendlyForCops()) unsuspicious.Add("Cops");
            if (b.IsHostileForCops()) suspicious.Add("Cops");
            foreach (GameGangs.IDs gang in GameGangs.BIKERS)
            {
                if (b.IsHostileForBiker(gang)) suspicious.Add(GameGangs.NAMES[(int)gang]);
                if (b.IsFriendlyForBiker(gang)) unsuspicious.Add(GameGangs.NAMES[(int)gang]);
            }
            // alpha10 fixed rule & desc mismatch
            //foreach (GameGangs.IDs gang in GameGangs.GANGSTAS)
            //{
            //    if (b.IsHostileForBiker(gang)) suspicious.Add(GameGangs.NAMES[(int)gang]);
            //    if (b.IsFriendlyForBiker(gang)) unsuspicious.Add(GameGangs.NAMES[(int)gang]);
            //}
            if (unsuspicious.Count > 0)
            {
                lines.Add("Unsuspicious to:");
                foreach (string s in unsuspicious)
                    lines.Add("- " + s);
            }
            if (suspicious.Count > 0)
            {
                lines.Add("Suspicious to:");
                foreach (string s in suspicious)
                    lines.Add("- " + s);
            }

            return lines.ToArray();
        }

        static string[] DescribeItemSprayPaint(ItemSprayPaint sp) //@@MP - made static (Release 5-7)
        {
            List<string> lines = new List<string>();

            ItemSprayPaintModel m = sp.Model as ItemSprayPaintModel;

            lines.Add("> spray");

            // 1. Paint
            if (sp.PaintQuantity < m.MaxPaintQuantity)
                lines.Add(String.Format("Quantity : {0}/{1}", sp.PaintQuantity, m.MaxPaintQuantity));
            else
                lines.Add(String.Format("Quantity : {0} (MAX)", sp.PaintQuantity));

            return lines.ToArray();
        }

        static string[] DescribeItemSprayScent(ItemSprayScent sp) //@@MP - made static (Release 5-7)
        {
            List<string> lines = new List<string>();

            ItemSprayScentModel m = sp.Model as ItemSprayScentModel;

            lines.Add("> spray scent");

            // 1. Spray.
            if(sp.SprayQuantity < m.MaxSprayQuantity)
                lines.Add(String.Format("Spray    : {0}/{1}", sp.SprayQuantity, m.MaxSprayQuantity));
            else
                lines.Add(String.Format("Spray    : {0} (MAX)", sp.SprayQuantity));

            // alpha10
            // 2. Odor & Strength
            lines.Add(string.Format("Odor     : {0}", Capitalize(sp.Odor.ToString().ToLower())));
            lines.Add(string.Format("Strength : {0}h", sp.Strength / WorldTime.TURNS_PER_HOUR));

            return lines.ToArray();
        }

        static string[] DescribeItemLight(ItemLight lt) //@@MP - made static (Release 5-7)
        {
            List<string> lines = new List<string>();

            ItemLightModel m = lt.Model as ItemLightModel;

            lines.Add("> light");

            // 1. Batteries
            if (m.IsBatteryPowered) //@@MP - filter added for new non-powered lights like flares (Release 7-1)
                lines.Add(DescribeBatteries(lt.Batteries, m.MaxBatteries));

            // 2. FoV
            lines.Add(String.Format("FOV       : +{0}", lt.FovBonus));

            return lines.ToArray();
        }

        string[] DescribeItemTracker(ItemTracker tr)
        {
            List<string> lines = new List<string>();

            ItemTrackerModel m = tr.Model as ItemTrackerModel;

            lines.Add("> tracker");

            // 1. Batteries
            lines.Add(DescribeBatteries(tr.Batteries, m.MaxBatteries));
            // alpha 10, range if applicable
            // TODO -- should be an tracker item property, hardcoding is baaaad -_-
            if (tr.CanTrackUndeads)
                lines.Add(string.Format("Range: {0}", Rules.ZTRACKINGRADIUS));
            else
                lines.Add("Range: whole map");

            // 2. Clock   // alpha10
            if (tr.HasClock)
            {
                lines.Add(" ");
                if (tr.Batteries == 0)
                    lines.Add("Out of batteries, can't give the time.");
                else if (!tr.IsEquipped)
                    lines.Add("Equip the item to read the time.");
                else
                    lines.Add(string.Format("The clock reads: {0}h, {1}", m_Session.WorldTime.Hour, DescribeDayPhase(m_Session.WorldTime.Phase)));
            }

            return lines.ToArray();
        } //@@MP - can't be static

        string[] DescribeItemTrap(ItemTrap tr) //@@MP - can't be static
        {
            List<string> lines = new List<string>();

            ItemTrapModel m = tr.Model as ItemTrapModel;

            lines.Add("> trap");

            // 1. Status
            if (tr.IsActivated)
            {
                lines.Add("** Activated! **");
                // alpha10
                if (m_Rules.IsSafeFromTrap(tr, m_Player))
                {
                    lines.Add("* You will safely avoid this trap.");
                    if (tr.Owner != null)
                        lines.Add(string.Format("Trap set by {0}.", tr.Owner.Name));
                }
            }
            else if (tr.IsTriggered)
            {
                // alpha10
                lines.Add("** Triggered! **");
                if (m_Rules.IsSafeFromTrap(tr, m_Player))
                {
                    lines.Add("* You will safely avoid this trap.");
                    if (tr.Owner != null)
                        lines.Add(string.Format("Trap set by {0}.", tr.Owner.Name));
                }
            }
            // alpha10
            lines.Add(string.Format("Trigger chance for you : {0}%.", m_Rules.GetTrapTriggerChance(tr, m_Player)));

            // 2. Flags
            if (m.IsOneTimeUse) lines.Add("Deactives when triggered.");
            if (m.IsNoisy) lines.Add(String.Format("Makes {0} noise.", m.NoiseName));
            if (m.UseToActivate) lines.Add("Use to activate.");
            // if (m.IsFlammable) lines.Add("Can be put on fire.");

            // 3. Stats
            lines.Add(String.Format("Damage  : {0} x{1} = {2}", m.Damage, tr.Quantity, tr.Quantity * m.Damage));  // alpha10
            lines.Add(String.Format("Trigger : {0}% x{1} = {2}%", m.TriggerChance, tr.Quantity, tr.Quantity * m.TriggerChance));  // alpha10
            lines.Add(String.Format("Break   : {0}%", m.BreakChance));
            if (m.BlockChance > 0) lines.Add(String.Format("Block   : {0}%", m.BlockChance));
            if (m.BreakChanceWhenEscape > 0) lines.Add(String.Format("{0}% to break on escape", m.BreakChanceWhenEscape));

            return lines.ToArray();
        }

        string[] DescribeItemEntertainment(ItemEntertainment ent)
        {
            List<String> lines = new List<string>();

            ItemEntertainmentModel entModel = ent.EntertainmentModel;

            lines.Add("> entertainment");

            // player bored?
            if (m_Player != null && ent.IsBoringFor(m_Player)) // alpha10 made boring items item-centric
                lines.Add("* BORED OF IT! *");

            // San & Bore chance.
            int sanForPlayer = (m_Player == null ? entModel.Value : m_Rules.ActorSanRegenValue(m_Player, entModel.Value));
            if (sanForPlayer != entModel.Value)
                lines.Add(String.Format("Sanity : +{0} (+{1})", sanForPlayer, entModel.Value));
            else
                lines.Add(String.Format("Sanity : +{0}", entModel.Value));
            lines.Add(String.Format("Boring : {0}%", entModel.BoreChance));

            return lines.ToArray();
        }

        static string DescribeBatteries(int batteries, int maxBatteries) //@@MP - made static (Release 5-7)
        {
            int hours = BatteriesToHours(batteries);
            if (batteries < maxBatteries)
                return String.Format("Charge : {0}/{1} ({2}h)", batteries, maxBatteries, hours);
            else
                return String.Format("Charge : {0} MAXED ({1}h)", batteries, hours);
        }
#endregion

        static string DescribeSkillShort(Skills.IDs id) //@@MP - made static (Release 5-7)
        {
            switch (id)
            {
                case Skills.IDs.AGILE:
                    return String.Format("+{0} melee ATK, +{1} DEF", Rules.SKILL_AGILE_ATK_BONUS, Rules.SKILL_AGILE_DEF_BONUS);
                case Skills.IDs.AWAKE:
                    return String.Format("+{0}% max SLP, +{1}% SLP regen ", (int)(100 * Rules.SKILL_AWAKE_SLEEP_BONUS), (int)(100 * Rules.SKILL_AWAKE_SLEEP_REGEN_BONUS));
                case Skills.IDs.BOWS_EXPLOSIVES: //@@MP - expanded to includes explosives (Release 6-6)
                    return String.Format("bows +{0} ATK, +{1} DMG. explosives +{2}. flaming shot fire mode", Rules.SKILL_BOWS_ATK_BONUS, Rules.SKILL_BOWS_DMG_BONUS, Rules.SKILL_EXPLOSIVES_DMG_BONUS);
                case Skills.IDs.CARPENTRY:
                    return String.Format("build, -{0} mat. at lvl 3, +{1}% barricading", Rules.SKILL_CARPENTRY_LEVEL3_BUILD_BONUS, (int)(100 * Rules.SKILL_CARPENTRY_BARRICADING_BONUS));
                case Skills.IDs.CHARISMATIC:
                    return String.Format("+{0} trust per turn, +{1}% trade offers. dogs like you", Rules.SKILL_CHARISMATIC_TRUST_BONUS, Rules.SKILL_CHARISMATIC_TRADE_BONUS);
                case Skills.IDs.FIREARMS:
                    return String.Format("firearms +{0} ATK, +{1} DMG", Rules.SKILL_FIREARMS_ATK_BONUS, Rules.SKILL_FIREARMS_DMG_BONUS);
                case Skills.IDs.HARDY:
                    return String.Format("sleeping anywhere heals, +{0}% chance to heal when sleeping,\n        +{1}% chance to recover faster from food poisoning", Rules.SKILL_HARDY_HEAL_CHANCE_BONUS, Rules.SKILL_HARDY_FOOD_POISONING_RECOVERY_CHANCE_BONUS); //@@MP - added food poisoning (Release 7-6)
                case Skills.IDs.HAULER:
                    return String.Format("+{0} inventory slots", Rules.SKILL_HAULER_INV_BONUS);
                case Skills.IDs.HIGH_STAMINA:
                    return String.Format("+{0} STA", Rules.SKILL_HIGH_STAMINA_STA_BONUS);
                case Skills.IDs.LEADERSHIP:
                    return String.Format("+{0} max Followers", Rules.SKILL_LEADERSHIP_FOLLOWER_BONUS);
                case Skills.IDs.LIGHT_EATER:
                    return String.Format("+{0}% max FOO, +{1}% item food points", (int)(100 * Rules.SKILL_LIGHT_EATER_MAXFOOD_BONUS), (int)(100 * Rules.SKILL_LIGHT_EATER_FOOD_BONUS));
                case Skills.IDs.LIGHT_FEET:
                    return String.Format("+{0}% to avoid and escape traps", Rules.SKILL_LIGHT_FEET_TRAP_BONUS);
                case Skills.IDs.LIGHT_SLEEPER:
                    return String.Format("+{0}% noise wake up chance", Rules.SKILL_LIGHT_SLEEPER_WAKEUP_CHANCE_BONUS);
                case Skills.IDs.MARTIAL_ARTS:
                    return String.Format("unarmed only +{0} ATK, +{1} DMG, +{2}% disarm", Rules.SKILL_MARTIAL_ARTS_ATK_BONUS, Rules.SKILL_MARTIAL_ARTS_DMG_BONUS, Rules.SKILL_MARTIAL_ARTS_DISARM_BONUS);
                case Skills.IDs.MEDIC:
                    return String.Format("+{0}% medicine item effects, +{1}% revive ", (int)(100 * Rules.SKILL_MEDIC_BONUS), Rules.SKILL_MEDIC_REVIVE_BONUS);
                case Skills.IDs.NECROLOGY:
                    return String.Format("+{0}/+{1} DMG vs undeads, info on corpses", Rules.SKILL_NECROLOGY_UNDEAD_BONUS, Rules.SKILL_NECROLOGY_CORPSE_BONUS);
                case Skills.IDs.STRONG:
                    return String.Format("+{0} melee DMG, +{1}% resist disarming, +{2} throw range", Rules.SKILL_STRONG_DMG_BONUS, Rules.SKILL_STRONG_RESIST_DISARM_BONUS, Rules.SKILL_STRONG_THROW_BONUS);
                case Skills.IDs.STRONG_PSYCHE:
                    return String.Format("+{0}% SAN threshold, +{1}% regen", (int)(100 * Rules.SKILL_STRONG_PSYCHE_LEVEL_BONUS), (int)(100 * Rules.SKILL_STRONG_PSYCHE_ENT_BONUS));
                case Skills.IDs.TOUGH:
                    return String.Format("+{0} HP", Rules.SKILL_TOUGH_HP_BONUS);
                case Skills.IDs.UNSUSPICIOUS:
                    return String.Format("+{0}% unnoticed by cops and gangs, +{1}% catch fish chance", Rules.SKILL_UNSUSPICIOUS_BONUS, Rules.SKILL_UNSUSPICIOUS_FISHING_BONUS); //@@MP - added fishing bonus (Release 7-6)

                case Skills.IDs.Z_AGILE:
                    return String.Format("+{0} melee ATK, +{1} DEF, can jump", Rules.SKILL_ZAGILE_ATK_BONUS, Rules.SKILL_ZAGILE_DEF_BONUS);
                case Skills.IDs.Z_EATER:
                    return String.Format("+{0}% eating HP regen", (int)(100 * Rules.SKILL_ZEATER_REGEN_BONUS));
                case Skills.IDs.Z_GRAB:
                    return String.Format("can grab enemies, +{0}% per level", Rules.SKILL_ZGRAB_CHANCE);
                case Skills.IDs.Z_INFECTOR:
                    return String.Format("+{0}% infection damage", (int)(100 * Rules.SKILL_ZINFECTOR_BONUS));
                case Skills.IDs.Z_LIGHT_EATER:
                    return String.Format("+{0}% max ROT, +{1}% from eating", (int)(100 * Rules.SKILL_ZLIGHT_EATER_MAXFOOD_BONUS), (int)(100 * Rules.SKILL_ZLIGHT_EATER_FOOD_BONUS));
                case Skills.IDs.Z_LIGHT_FEET:
                    return String.Format("+{0}% to avoid traps", Rules.SKILL_ZLIGHT_FEET_TRAP_BONUS);
                case Skills.IDs.Z_STRONG:
                    return String.Format("+{0} melee DMG, can push", Rules.SKILL_ZSTRONG_DMG_BONUS);
                case Skills.IDs.Z_TOUGH:
                    return String.Format("+{0} HP", Rules.SKILL_ZTOUGH_HP_BONUS);
                case Skills.IDs.Z_TRACKER:
                    return String.Format("+{0}% smell", (int)(100 * Rules.SKILL_ZTRACKER_SMELL_BONUS));

                default:
                    throw new ArgumentOutOfRangeException("id", "unhandled skill id");
            }
        }

        static string DescribeDayPhase(DayPhase phase) //@@MP - made static (Release 5-7)
        {
            switch (phase)
            {
                case DayPhase.AFTERNOON: return "Afternoon";
                case DayPhase.DEEP_NIGHT: return "Deep Night";
                case DayPhase.EVENING: return "Evening";
                case DayPhase.MIDDAY: return "Midday";
                case DayPhase.MIDNIGHT: return "Midnight";
                case DayPhase.MORNING: return "Morning";
                case DayPhase.SUNRISE: return "Sunrise";
                case DayPhase.SUNSET: return "Sunset";

                default: throw new ArgumentOutOfRangeException("phase", "unhandled dayphase");
            }
        }

        static string DescribeWeather(Weather weather) //@@MP - made static (Release 5-7)
        {
            switch (weather)
            {
                case Weather.CLOUDY: return "Cloudy";
                case Weather.HEAVY_RAIN: return "Heavy rain";
                case Weather.RAIN: return "Rain";
                case Weather.CLEAR: return "Clear";

                default:
                    throw new ArgumentOutOfRangeException("weather", "unhandled weather");
            }
        }

        static Color WeatherColor(Weather weather) //@@MP - made static (Release 5-7)
        {
            switch (weather)
            {
                case Weather.CLOUDY: return Color.Gray;
                case Weather.HEAVY_RAIN: return Color.Blue;
                case Weather.RAIN: return Color.LightBlue;
                case Weather.CLEAR: return Color.Yellow;

                default:
                    throw new ArgumentOutOfRangeException("weather", "unhandled weather");
            }
        }

        static int BatteriesToHours(int batteries) //@@MP - made static (Release 5-7)
        {
            return batteries / WorldTime.TURNS_PER_HOUR;
        }

        static int FoodToHoursUntilHungry(int food) //@@MP - made static (Release 5-7)
        {
            int left = food - Rules.FOOD_HUNGRY_LEVEL;
            if (left <= 0)
                return 0;
            return left / WorldTime.TURNS_PER_HOUR;
        }

        static int FoodToHoursUntilRotHungry(int food) //@@MP - made static (Release 5-7)
        {
            int left = food - Rules.ROT_HUNGRY_LEVEL;
            if (left <= 0)
                return 0;
            return left / WorldTime.TURNS_PER_HOUR;
        }

        public bool IsAlmostHungry(Actor actor) //@@MP - can't make static
        {
            if (!actor.Model.Abilities.HasToEat)
                return false;
            return FoodToHoursUntilHungry(actor.FoodPoints) <= 3;
        }

        public static bool IsAlmostRotHungry(Actor actor) //@@MP - made static (Release 5-7)
        {
            if (!actor.Model.Abilities.IsRotting)
                return false;
            return FoodToHoursUntilRotHungry(actor.FoodPoints) <= 3;
        }
#endregion

#region Background music
        void UpdateBgMusic() //@@MP - somewhat modified music handling from how alpha 10 implemented it (Release 6-1)
        {
            if (!s_Options.PlayMusic)
                return;
            if (m_Player == null)
                return;

            // don't interrupt music that has higher priority than background music
            if ((m_MusicManager.Track != null) && (m_MusicManager.Priority > AudioPriority.PRIORITY_BGM))
                return;

            // check for current map music and play if not already playing something
            string mapMusic = m_Session.CurrentMap.BgMusic; //some maps, such as CHAR basement, have specific bg music. The surface doesn't though for eg
            if (string.IsNullOrEmpty(mapMusic)) //this is a level that doesn't have bgm
            {
                List<string> bgMusics = new List<string>() { GameMusics.CHAR_UNDERGROUND_FACILITY, GameMusics.HOSPITAL, GameMusics.SHOPPING_MALL, GameMusics.SEWERS, GameMusics.SUBWAY, GameMusics.SURFACE }; //@@MP - stop any bgm that isn't relevant for this map (Release 7-4)
                foreach (string music in bgMusics)
                    m_MusicManager.Stop(music);
                //m_MusicManager.PlayRandom(m_bgMusicPlaylist, AudioPriority.PRIORITY_BGM); //pick a random bgm to play   //@@MP - disabled in preference for ambient sound effects (Release 6-6)
                return;
            }
            else if (m_MusicManager.Track == mapMusic && m_MusicManager.IsPlaying(mapMusic))
                return; //no need to do anything, it's already playing the appropriate bgm for this map
            else
            {
                m_MusicManager.StopAll(); //stops any low priority music
                m_MusicManager.Play(mapMusic, AudioPriority.PRIORITY_BGM);
            }
        }
#endregion

#region -Various predicates
        public static bool IsInCHAROffice(Location location)
        {
            List<Zone> zones = location.Map.GetZonesAt(location.Position.X, location.Position.Y);
            if (zones == null)
                return false;
            foreach (Zone z in zones)
            {
                if (z.HasGameAttribute(ZoneAttributes.IS_CHAR_OFFICE))
                    return true;
            }
            return false;
        }

        public bool IsInCHARProperty(Location location)
        {
            return location.Map == Session.UniqueMaps.CHARUndergroundFacility.TheMap ||
                IsInCHAROffice(location);
        }

        public static bool IsInArmyOffice(Location location)
        {
            List<Zone> zones = location.Map.GetZonesAt(location.Position.X, location.Position.Y);
            if (zones == null)
                return false;
            foreach (Zone z in zones)
            {
                if (z.HasGameAttribute(ZoneAttributes.IS_ARMY_OFFICE))
                    return true;
            }
            return false;
        }
#endregion

#region -Experimental Bot Mode
        // alpha10.1 Bot Mode - DEBUG build only
#if DEBUG
        bool m_isBotMode = false;
        BaseAI m_botControl = null;
        const int BOT_DELAY = DELAY_SHORT;
        readonly Object m_botLock = new Object(); // necessary because dev keys presses from RogueForm can happen at any time

        public void BotToggleControl()
        {
            lock (m_botLock)
            {
                if (m_isBotMode)
                    BotReleaseControl();
                else
                    BotTakeControl();
            }
        }

        void BotTakeControl()
        {
            // bot restrictions check
            if (m_Player == null || m_Player.IsDead)
            {
                AddMessage(MakeErrorMessage("Bot cannot take control of null/dead player"));
                return;
            }

            if (m_botControl != null)
                m_botControl.LeaveControl();

            try
            {
                Type aiClass = m_Player.Model.DefaultController;
                if (aiClass == null)
                    throw new InvalidOperationException("actor model has null defaultcontroller");
                ActorController aiController = aiClass.GetConstructor(Type.EmptyTypes).Invoke(null) as ActorController;
                if (!(aiController is BaseAI))
                    throw new InvalidOperationException("actor model defaultcontroller is not BaseAI");

                m_botControl = aiController as BaseAI;
                m_botControl.TakeControl(m_Player);
                m_Player.IsBotPlayer = true;
                m_isBotMode = true;
                AddMessage(MakeMessage(m_Player, "is now bot controlled by " + m_botControl.GetType() + ".", Color.LightGreen));
            }
            catch (Exception e)
            {
                ClearMessages();
                AddMessage(MakeErrorMessage("error while creating bot ai:"));
                AddMessage(MakeErrorMessage(e.Message));
                AddMessagePressEnter();
            }
        }

        void BotReleaseControl()
        {
            if (m_botControl == null)
                return;
            if (m_Player != null)
                m_Player.IsBotPlayer = false;
            m_botControl.LeaveControl();
            m_botControl = null;
            m_isBotMode = false;
            if (m_Player != null)
                AddMessage(MakeMessage(m_Player, "is now human controlled.", Color.LightGreen));
        }
#endif
#endregion

#region -Dev Stuff
#if DEBUG
        public void DEV_ToggleShowActorsStats() //@@MP - can't be made static
        {
            s_Options.DEV_ShowActorsStats = !s_Options.DEV_ShowActorsStats;
        }

        static void AddDevCheatItems() //@@MP - made static (Release 5-7)
        {
            /*Inventory inv = m_Player.Inventory;
            Item it = new ItemBarricadeMaterial(m_GameItems.WOODENPLANK) { Quantity = 4 };
            inv.AddAll(it);
            it = new ItemBarricadeMaterial(m_GameItems.WOODENPLANK) { Quantity = 3 };
            inv.AddAll(it);
            it = new ItemBarricadeMaterial(m_GameItems.WOODENPLANK) { Quantity = 2 };
            inv.AddAll(it);

            Map map = m_Player.Location.Map;
            Point pos = m_Player.Location.Position;
            it = new ItemBarricadeMaterial(m_GameItems.WOODENPLANK) { Quantity = 3 };
            map.DropItemAt(it, pos);
            it = new ItemBarricadeMaterial(m_GameItems.WOODENPLANK) { Quantity = 3 };
            map.DropItemAt(it, pos);
            Item it2 = new ItemBarricadeMaterial(m_GameItems.WOODENPLANK) { Quantity = 3 };
            map.DropItemAt(it2, pos);
            it.Quantity--;
            */
        }

        void AddDevCheatSkills()
        {
            // all the living skills.
            /*
            for (int id = (int)Skills.IDs._FIRST_LIVING; id < (int)Skills.IDs._FIRST_UNDEAD; id++)
                for (int l = 0; l < 5; l++)
                    m_Player.Sheet.SkillTable.AddOrIncreaseSkill(id);
             */
        }

        public void DEV_TogglePlayerInvincibility() // alpha10
        {
            if (m_Session == null || m_Player == null)
                return;

            m_Player.IsInvincible = !m_Player.IsInvincible;
            AddMessage(new Message("DEAR DEV, YOU ARE NOW " + (m_Player.IsInvincible ? "INVINCIBLE" : "NOT INVINCIBLE"), m_Session.WorldTime.TurnCounter, Color.LightGreen));

        }

        public void DEV_KillAllActorsInMap() //@@MP (Release 6-3)
        {
            foreach (Actor actor in m_Player.Location.Map.Actors.ToList()) //tolist allows modifying the set within the loop
            {
                if (!actor.IsPlayer)
                    KillActor(actor, actor, "testing", true, true);
            }
        }

        void AddDevMiscStuff()
        {
            // insane right of the bat.
            /*            
            m_Player.Sanity = 0;
            */

            // join cops.
            //m_Player.Faction = GameFactions.ThePolice;
        }

        public void DEV_MaxTrust() // alpha10.1
        {
            if (m_Session == null || m_Player == null)
                return;
            if (m_Player.Followers == null)  // alpha10.1 fix
                return;

            foreach (Actor f in m_Player.Followers)
                f.TrustInLeader = Rules.TRUST_MAX;
            AddMessage(new Message("DEAR DEV, FOLLOWERS TRUST MAXED.", m_Session.WorldTime.TurnCounter, Color.LightGreen));
        }
#endif

#region Debug AI Looping
        // alpha10
        // Looping ai detection code: 
        // detect cases where an ai is proably performing an infinite sequence of AP-free actions.
        Actor m_DEBUG_prevAiActor;
        int m_DEBUG_sameAiActorCount;
        const int DEBUG_AI_ACTOR_LOOP_COUNT_WARNING = 10;
        //@@MP - recommend this always be at least 1 greater than Rules.AI_REPETITIVE_NOAPCOST_ACTION_LIMIT
        //@@MP - 5 or less will trigger a lot on turns 1 & 2 when the cops equip all their stuff
#endregion
#endregion
#endregion

#region TO BE REFACTORED OR RELOCATED?
        void WarnAboutNightVision() //@@MP (Release 7-1)
        {
            ItemLight eyesLight = m_Player.GetEquippedItem(DollPart.EYES) as ItemLight;
            if (eyesLight != null && m_Rules.IsItemNightVision(eyesLight))
            {
                bool canSeeSky = m_Rules.CanActorSeeSky(m_Player);
                bool isNight = m_Session.WorldTime.IsNight;
                bool outsideDuringDay = (canSeeSky && !isNight);
                if (m_Session.CurrentMap.Lighting == Lighting.LIT || outsideDuringDay)
                {
                    // first check if we're next to a power generator. we don't want to spam messages when the player is recharging the NVGs
                    if (!m_Player.Location.Map.HasAnyAdjacentInMap(m_Player.Location.Position, (pt) => m_Player.Location.Map.GetMapObjectAt(pt) is PowerGenerator))
                    {
                        //don't forcibly unequip it, as otherwise the player couldn't recharge them in Lit or outdoor daytime areas
                        //just let the player know that it's unecessary
                        AddMessage(new Message(String.Format("It's light enough now that I don't need the night vision goggles."), 0, Color.Yellow));
                    }
                }
            }
        }

        bool IsMainThread() //@@MP (Release 7-1)
        {
            if (Thread.CurrentThread == MainThread)
                return true;
            else
                return false;
        }

        static bool IsActorStandingInLight(Actor actor) //@@MP (Release 7-5), tidied up the logic (Release 8-2)
        {
            // check if next to any non-equipped light sources (assumes that ambient lights from items/decorations are always only 3x3 tiles)
            Map map = actor.Location.Map;
            Point spot = actor.Location.Position;  //start by checking the actor's location, then adjacent
            foreach (Direction d in Direction.COMPASS)
            {
                if (!map.IsInBounds(spot))
                    continue;

                // on fire objects
                MapObject mapObj = map.GetMapObjectAt(spot);
                if (mapObj != null && mapObj.IsOnFire)
                    return true;

                // tile-based light sources
                if (map.IsAnyTileFireThere(map, spot))
                    return true;
                if (map.GetTileAt(spot).HasDecoration(Gameplay.GameImages.DECO_LIT_CANDLE))
                    return true;

                // actors carrying lights
                Actor act = map.GetActorAt(spot);
                if (act != null)
                {
                    ItemLight heldLight = (act.GetEquippedItem(DollPart.LEFT_HAND) as ItemLight);
                    if (heldLight != null && heldLight.Batteries > 0)
                        return true;
                }

                // dropped lights
                Inventory inv = map.GetItemsAt(spot);
                if (inv != null)
                {
                    foreach (Item item in inv.Items)
                    {
                        ItemLight light = item as ItemLight;
                        if (light != null)
                            return true;
                    }
                }

                spot = actor.Location.Position + d;
            }

            return false;
        }

        /// <summary>
        /// Certain things prevent the player from performing their desired action
        /// </summary>
        /// <param name="checkBinos">This action can't be done when binoculars are equiped</param>
        /// <param name="checkBackpack">This action can't be done when their backpack is open</param>
        /// <param name="reason"></param>
        /// <returns></returns>
        bool BlockAction(out string reason, bool checkBinos, bool checkBackpack, Direction dir = null) //@@MP (Release 8-2)
        {
            reason = "";

            // are binoculars equipped?
            if (checkBinos) //@@MP (Release 7-1)
            {
                // we have to check within the loop because the player could unequip them, which costs no AP
                // and therefore the player will do something else on this same turn but with the light now unequipped
                ItemLight loopEyesLight = m_Player.GetEquippedItem(DollPart.EYES) as ItemLight;
                if (loopEyesLight != null && m_Rules.IsItemBinoculars(loopEyesLight) && loopEyesLight.IsEquipped)
                {
                    reason = BINOCULARS_DENIED_MESSAGE;
                    return true;
                }
            }

            // is backpack open?
            if (checkBackpack) //@@MP (Release 8-2)
            {
                ItemBackpack backPack = m_Player.Inventory.GetFirstByType(typeof(ItemBackpack)) as ItemBackpack;
                if (backPack != null && !backPack.IsEquipped)
                {
                    //backpack is open.
                    if (dir != null) //check if dir will result in a move or a bump
                    {
                        //bump, such as taking an item from a container, or meleeing an enemy, is allowed with an open backpack. moving is not
                        if (!m_Rules.IsWalkableFor(m_Player, m_Player.Location + dir))
                            return false;
                    }

                    //opted to auto-equip the backpack rather than stop the player with a "no go" message
                    DoEquipItem(m_Player, backPack, false);
                    return false;
                    /*reason = BACKPACK_DENIED_MESSAGE;
                    return true;*/
                }
            }

            //nothing preventing the go-ahead of the player's chosen action
            return false;
        }
        #endregion
    }
}
